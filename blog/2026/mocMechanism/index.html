<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> （四）Qt 那些事儿：Qt的核心机制-MOC 机制 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A blog for documenting my own study notes. "> <meta name="keywords" content="blog, cpp, programmer"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/toc-custom.css"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2026/mocMechanism/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-8"> <div class="post"> <header class="post-header"> <h1 class="post-title">（四）Qt 那些事儿：Qt的核心机制-MOC 机制</h1> <p class="post-meta"> Created on January 04, 2026 </p> <p class="post-tags"> <a href="/blog/2026"> <i class="fa-solid fa-calendar fa-sm"></i> 2026 </a>   ·   <a href="/blog/tag/qt"> <i class="fa-solid fa-hashtag fa-sm"></i> Qt</a>   ·   <a href="/blog/category/c"> <i class="fa-solid fa-tag fa-sm"></i> C++</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="四qt-那些事儿qt-的核心机制-moc-机制">（四）Qt 那些事儿：Qt 的核心机制-MOC 机制</h2> <p><strong>MOC（Meta-Object Compiler，元对象编译器）</strong> 是 Qt 自带的预处理工具，扫描包含特定宏（如<code class="language-plaintext highlighter-rouge">Q_OBJECT</code>、<code class="language-plaintext highlighter-rouge">signals</code>、<code class="language-plaintext highlighter-rouge">slots</code>等）的头文件，自动生成额外的 C++源码文件（通常命名为<code class="language-plaintext highlighter-rouge">moc_xxx.cpp</code>）。这些生成文件与用户代码一同被标准 C++编译器编译，构建 Qt 的<strong>元对象系统（Meta-Object System）</strong>。</p> <p>MOC 本质上是 Qt 对标准 C++的<strong>语言级扩展机制</strong>，通过自动生成补充代码，弥补 C++在反射、运行时类型信息、动态通信等方面的不足。</p> <p><strong>主要功能</strong>：</p> <table> <thead> <tr> <th>功能</th> <th>描述</th> <th>实现方式</th> </tr> </thead> <tbody> <tr> <td>信号与槽机制</td> <td>实现对象间松耦合通信</td> <td>生成信号实现代码和连接管理</td> </tr> <tr> <td>元对象信息</td> <td>提供运行时类型信息</td> <td>生成类名、方法、属性的元数据表</td> </tr> <tr> <td>动态属性</td> <td>支持运行时属性读写</td> <td>解析<code class="language-plaintext highlighter-rouge">Q_PROPERTY</code>宏生成访问接口</td> </tr> <tr> <td>运行时方法调用</td> <td>通过字符串名调用方法</td> <td>处理<code class="language-plaintext highlighter-rouge">Q_INVOKABLE</code>和槽函数</td> </tr> <tr> <td>国际化支持</td> <td>处理翻译相关接口</td> <td>生成<code class="language-plaintext highlighter-rouge">tr()</code>等国际化代码结构</td> </tr> </tbody> </table> <p><strong>工作流程</strong>：</p> <ol> <li> <strong>扫描代码</strong>：查找包含<code class="language-plaintext highlighter-rouge">Q_OBJECT</code>宏的类，分析信号、槽、属性等元素</li> <li> <strong>生成元对象代码</strong>：为每个符合条件的类生成对应的<code class="language-plaintext highlighter-rouge">moc_xxx.cpp</code>文件</li> <li> <strong>编译与链接</strong>：生成的代码（<code class="language-plaintext highlighter-rouge">moc_xxx.cpp</code>）与用户源码一起编译到最终可执行文件</li> </ol> <p><strong>使用条件</strong>：</p> <ul> <li>类中定义了信号（<code class="language-plaintext highlighter-rouge">signals</code>）</li> <li>类中定义了槽（<code class="language-plaintext highlighter-rouge">slots</code>）</li> <li>类中使用<code class="language-plaintext highlighter-rouge">Q_PROPERTY</code>定义了属性</li> <li>类中使用<code class="language-plaintext highlighter-rouge">Q_INVOKABLE</code>暴露方法给元对象系统</li> </ul> <h3 id="0-moc-基本使用">0 moc 基本使用</h3> <p><strong>原始类定义</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;QObject&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QString&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MyObject</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QObject</span> <span class="p">{</span>
    <span class="n">Q_OBJECT</span>
    <span class="n">Q_PROPERTY</span><span class="p">(</span><span class="n">QString</span> <span class="n">name</span> <span class="n">READ</span> <span class="n">name</span> <span class="n">WRITE</span> <span class="n">setName</span> <span class="n">NOTIFY</span> <span class="n">nameChanged</span><span class="p">)</span>

<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">MyObject</span><span class="p">(</span><span class="n">QObject</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="o">:</span> <span class="n">QObject</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{}</span>

    <span class="n">QString</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_name</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">setName</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m_name</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">m_name</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
            <span class="n">emit</span> <span class="n">nameChanged</span><span class="p">(</span><span class="n">m_name</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="n">signals</span><span class="o">:</span>
    <span class="kt">void</span> <span class="nf">nameChanged</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span> <span class="o">&amp;</span><span class="n">newName</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">mySignal</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>

<span class="k">public</span> <span class="n">slots</span><span class="o">:</span>
    <span class="kt">void</span> <span class="nf">mySlot</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">QString</span> <span class="n">m_name</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p><strong>MOC 生成的核心代码结构</strong>：</p> <ol> <li> <strong>字符串表</strong>：存储类名、方法名、参数名等</li> <li> <strong>元数据表</strong>：描述方法数量、属性数量、参数类型等</li> <li> <strong>静态调用分派函数</strong>：处理信号发射和方法调用</li> <li> <strong>静态元对象</strong>：包含所有元信息</li> <li> <strong>元对象接口实现</strong>：提供运行时访问接口</li> <li> <strong>信号函数实现</strong>：自动生成的信号发射代码</li> </ol> <h3 id="1-信号槽">1 信号槽</h3> <ul> <li> <strong>信号槽是什么</strong> Qt 的信号与槽机制是一种高效、灵活的事件处理系统，用于对象之间的通信。它允许一个对象在特定事件发生时<strong>主动通知</strong>其他对象，而接收方可以<strong>自由决定</strong>如何处理，从而实现模块之间的低耦合交互。这种机制极大提升了代码的可维护性与复用性。信号与槽机制依托 MOC（元对象编译器）生成的代码来实现，包括信号与槽的绑定关系、事件传递，以及跨线程通信中的消息封装与分发。</li> </ul> <p><strong>核心特性</strong>：</p> <ul> <li> <strong>类型安全</strong>：编译期检查参数类型匹配</li> <li> <strong>运行时动态连接</strong>：可在运行时建立或断开连接</li> <li> <strong>跨线程通信</strong>：自动处理线程间安全调用</li> <li> <p><strong>多对多连接</strong>：一个信号可连接多个槽，多个信号可连接同一槽</p> </li> <li> <strong>信号函数体</strong>不是你写的，moc 生成：内部只干一件事——<code class="language-plaintext highlighter-rouge">QMetaObject::activate</code>。</li> <li> <strong>activate</strong>：同线程直接调，跨线程<strong>打包成事件</strong>投到对方线程。</li> <li> <strong>qt_metacall / qt_static_metacall</strong>：把“方法索引 + 参数指针数组”映射到<strong>真正的 C++ 函数调用</strong>。</li> <li> <strong>staticMetaObject</strong>：元信息总表，反射、连接、invokeMethod 都靠它。</li> </ul> <h4 id="11-怎么用--信号与槽的声明及连接">1.1 怎么用 – 信号与槽的声明及连接</h4> <p><strong>信号声明</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Button</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QObject</span> <span class="p">{</span>
    <span class="n">Q_OBJECT</span>
<span class="nl">signals:</span>
    <span class="kt">void</span> <span class="n">clicked</span><span class="p">();</span>                    <span class="c1">// 无参信号</span>
    <span class="kt">void</span> <span class="n">valueChanged</span><span class="p">(</span><span class="kt">int</span> <span class="n">newValue</span><span class="p">);</span>   <span class="c1">// 带参信号</span>
<span class="p">};</span>
</code></pre></div></div> <p><strong>槽声明</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Application</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QObject</span> <span class="p">{</span>
    <span class="n">Q_OBJECT</span>
<span class="k">public</span> <span class="n">slots</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">onClicked</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Button clicked!"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">onValueChanged</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Value:"</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p><strong>连接方式对比</strong>：</p> <table> <thead> <tr> <th>连接方式</th> <th>语法示例</th> <th>优缺点</th> </tr> </thead> <tbody> <tr> <td>函数指针语法（推荐）</td> <td><code class="language-plaintext highlighter-rouge">QObject::connect(&amp;button, &amp;Button::clicked, &amp;app, &amp;Application::onClicked);</code></td> <td>✅ 编译期类型检查</td> </tr> <tr> <td>宏语法（旧版）</td> <td><code class="language-plaintext highlighter-rouge">QObject::connect(sender, SIGNAL(clicked()), receiver, SLOT(onClicked()));</code></td> <td>❌ 运行时才发现错误</td> </tr> <tr> <td>Lambda 表达式</td> <td><code class="language-plaintext highlighter-rouge">QObject::connect(&amp;button, &amp;Button::clicked, [](){...});</code></td> <td>✅ 简洁，适合简单逻辑</td> </tr> </tbody> </table> <h4 id="12-moc--信号槽背后的实现">1.2 moc – 信号槽背后的实现</h4> <p><strong>连接阶段</strong>：</p> <ol> <li> <code class="language-plaintext highlighter-rouge">QObject::connect()</code>记录信号与槽的绑定关系</li> <li>根据<code class="language-plaintext highlighter-rouge">Qt::ConnectionType</code>决定调用方式</li> <li>将连接信息存储在发送者的连接表中</li> </ol> <p><strong>发射阶段</strong>：</p> <ol> <li> <code class="language-plaintext highlighter-rouge">emit mySignal(value)</code>调用 MOC 生成的信号实现</li> <li>信号实现调用<code class="language-plaintext highlighter-rouge">QMetaObject::activate()</code> </li> <li>查找所有连接，根据线程情况选择调用方式： <ul> <li> <strong>同线程</strong>：直接函数调用</li> <li> <strong>跨线程</strong>：封装为事件投递到目标线程队列</li> </ul> </li> </ol> <p><strong>跨线程处理流程</strong>：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>发送线程: emit signal()
    ↓
QMetaObject::activate() 序列化参数
    ↓
投递QMetaCallEvent到目标线程事件队列
    ↓
目标线程: 事件循环处理QMetaCallEvent
    ↓
调用qt_metacall() → 槽函数执行
</code></pre></div></div> <p>假设有如下一个简单的 Qt 类：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;QObject&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MyObject</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QObject</span> <span class="p">{</span>
    <span class="n">Q_OBJECT</span>  <span class="c1">// 必须添加此宏，否则 MOC 不会处理</span>

<span class="nl">signals:</span>
    <span class="kt">void</span> <span class="n">mySignal</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>  <span class="c1">// 信号</span>

<span class="k">public</span>
<span class="nl">slots:</span>
    <span class="kt">void</span> <span class="n">mySlot</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>    <span class="c1">// 槽函数</span>
<span class="p">};</span>
</code></pre></div></div> <p>在编译流程中，MOC 会扫描该类的头文件，发现 <code class="language-plaintext highlighter-rouge">Q_OBJECT</code> 宏后解析信号与槽的声明，并生成一个名为 <code class="language-plaintext highlighter-rouge">moc_MyObject.cpp</code> 的文件，其中包含：</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">mySignal</code> 的具体实现，用于触发元对象系统的连接和事件分发逻辑；</p> <div class="language-c++ highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">MyObject</span><span class="o">::</span><span class="n">mySignal</span><span class="p">(</span><span class="kt">int</span> <span class="n">_t1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">_a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_t1</span><span class="p">))</span> <span class="p">};</span>
    <span class="c1">// 这个过程其实是向发送事件到对应的QObject，需要的信息都会记录在元对象表里面。</span>
    <span class="n">QMetaObject</span><span class="o">::</span><span class="n">activate</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">staticMetaObject</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li>用于描述 <code class="language-plaintext highlighter-rouge">mySignal</code> 和 <code class="language-plaintext highlighter-rouge">mySlot</code> 的元对象信息表；</li> <li>支持运行时动态调用信号和槽的 <code class="language-plaintext highlighter-rouge">qt_metacall()</code> 函数及相关辅助函数。 <div class="language-c++ highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">qt_static_metacall</span><span class="p">(</span><span class="n">QObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="n">QMetaObject</span><span class="o">::</span><span class="n">Call</span> <span class="n">call</span><span class="p">,</span> <span class="kt">int</span> <span class="n">methodId</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">call</span> <span class="o">==</span> <span class="n">QMetaObject</span><span class="o">::</span><span class="n">InvokeMetaMethod</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">auto</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">MyObject</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
          <span class="k">switch</span> <span class="p">(</span><span class="n">methodId</span><span class="p">)</span> <span class="p">{</span>
          <span class="p">...</span>
          <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span> <span class="c1">// mySignal(int)</span>
              <span class="kt">int</span> <span class="n">arg</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
              <span class="n">self</span><span class="o">-&gt;</span><span class="n">mySignal</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
              <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="p">...</span>
          <span class="p">}</span>
      <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> </div> </li> </ul> <p>Qt 通过 MOC 对 C++ 进行扩展，专门处理标记有 <code class="language-plaintext highlighter-rouge">Q_OBJECT</code> 宏的类声明，生成与之配套的源文件，这些额外的代码实现了信号与槽机制及元对象系统的其他能力。</p> <p>信号与槽的运行原理依赖 Qt 元对象系统：</p> <ol> <li> <p><strong>连接阶段</strong> 当调用 <code class="language-plaintext highlighter-rouge">QObject::connect()</code> 时，Qt 会将信号与槽的绑定关系记录到元对象系统的连接表中，并根据 <code class="language-plaintext highlighter-rouge">Qt::ConnectionType</code> 决定调用方式（直接调用、事件队列等）。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">connect(sender, &amp;MyObject::mySignal, receiver, &amp;ReceiverType::someSlot, type)</code> 时：</li> </ul> <ol> <li>利用 <strong>元对象</strong>信息（方法表）拿到信号/槽的<strong>索引</strong>与<strong>参数类型</strong>；</li> <li>把连接关系挂到 <code class="language-plaintext highlighter-rouge">sender</code> 的私有连接表里；</li> <li>记录 <code class="language-plaintext highlighter-rouge">ConnectionType</code>（<code class="language-plaintext highlighter-rouge">Auto/Direct/Queued/BlockingQueued/Unique</code> 等）。</li> </ol> <ul> <li>运行时根据 <strong>发送线程 == 接收线程</strong> 与 <code class="language-plaintext highlighter-rouge">ConnectionType</code> 决定<strong>直接调用</strong>还是<strong>排队事件</strong>。</li> </ul> </li> <li> <p><strong>发射阶段</strong> 当调用 <code class="language-plaintext highlighter-rouge">emit mySignal(value)</code> 时，底层会调用 MOC 生成的 <code class="language-plaintext highlighter-rouge">mySignal</code> 实现，查找所有已连接的槽函数，并依次调用它们。</p> <ol> <li>运行<code class="language-plaintext highlighter-rouge">emit mySignal(42);</code>的时候</li> <li>实际调用的是 moc 生成的 <code class="language-plaintext highlighter-rouge">MyObject::mySignal(int)</code> 函数（上面第 8 点）。</li> <li>它调用 <code class="language-plaintext highlighter-rouge">QMetaObject::activate(...)</code>：</li> </ol> <ul> <li>查到所有连接（<code class="language-plaintext highlighter-rouge">QObjectPrivate::Connection</code> 列表）；</li> <li> <strong>同线程</strong> → 直接函数调用；</li> <li> <strong>跨线程</strong>（Queued/BlockingQueued）→ 打包参数（<code class="language-plaintext highlighter-rouge">QMetaType</code> 序列化），投递 <code class="language-plaintext highlighter-rouge">QMetaCallEvent</code> 到<strong>目标线程</strong>事件队列。</li> </ul> <ol> <li>目标对象线程的事件循环收到 <code class="language-plaintext highlighter-rouge">QMetaCallEvent</code>，进入 <code class="language-plaintext highlighter-rouge">QObject::event</code>，再进入 <code class="language-plaintext highlighter-rouge">qt_metacall</code> → <code class="language-plaintext highlighter-rouge">qt_static_metacall</code> → <code class="language-plaintext highlighter-rouge">mySlot(value)</code>。</li> </ol> <p>这也解释了：</p> <ul> <li> <strong>跨线程</strong>连接为何安全：数据被复制并排队到对方线程；</li> <li> <strong>为什么能靠“事件队列”实现异步</strong>：本质就是 <code class="language-plaintext highlighter-rouge">postEvent</code> 一样的队列投递。</li> </ul> </li> <li> <p><strong>跨线程处理</strong> 若信号与槽不在同一线程，Qt 会将调用封装为事件投递到目标线程的事件队列中，由事件循环在合适的时机调用槽函数，保证线程安全。</p> </li> </ol> <h4 id="13-信号槽与普通回调函数的对比">1.3 信号槽与普通回调函数的对比</h4> <p>在 Qt 应用开发中，经常会遇到<strong>一个事件需要多个模块同时响应</strong>的场景。比如用户点击按钮后，需要：</p> <ul> <li>清空标签内容；</li> <li>记录日志；</li> <li>通知后端业务模块；</li> <li>启动界面动画。</li> </ul> <p>这些操作分属不同模块，但都依赖同一个“按钮点击”事件。</p> <p><strong>信号槽方案</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 一个信号连接多个槽</span>
<span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">button</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Button</span><span class="o">::</span><span class="n">clicked</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QLabel</span><span class="o">::</span><span class="n">clear</span><span class="p">);</span>
<span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">button</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Button</span><span class="o">::</span><span class="n">clicked</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Logger</span><span class="o">::</span><span class="n">writeLog</span><span class="p">);</span>
<span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">button</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Button</span><span class="o">::</span><span class="n">clicked</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Backend</span><span class="o">::</span><span class="n">notify</span><span class="p">);</span>
<span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="n">button</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Button</span><span class="o">::</span><span class="n">clicked</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MainWindow</span><span class="o">::</span><span class="n">startAnimation</span><span class="p">);</span>
</code></pre></div></div> <p><strong>传统回调方案</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 需要手动组合所有操作</span>
<span class="n">button</span><span class="o">-&gt;</span><span class="n">setCallback</span><span class="p">([</span><span class="o">=</span><span class="p">]()</span> <span class="p">{</span>
    <span class="n">label</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">logger</span><span class="o">-&gt;</span><span class="n">writeLog</span><span class="p">();</span>
    <span class="n">backend</span><span class="o">-&gt;</span><span class="n">notify</span><span class="p">();</span>
    <span class="n">startAnimation</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></div></div> <p><strong>对比总结</strong>：</p> <table> <thead> <tr> <th>特性</th> <th>回调函数</th> <th>信号槽</th> </tr> </thead> <tbody> <tr> <td>多响应支持</td> <td>❌ 需手动组合</td> <td>✅ 天然支持</td> </tr> <tr> <td>模块解耦</td> <td>❌ 强耦合</td> <td>✅ 完全解耦</td> </tr> <tr> <td>扩展性</td> <td>❌ 需修改原逻辑</td> <td>✅ 添加连接即可</td> </tr> <tr> <td>跨线程安全</td> <td>❌ 手动处理</td> <td>✅ 自动处理</td> </tr> </tbody> </table> <h3 id="2-动态属性">2 动态属性</h3> <h4 id="21-怎么用--动态属性的声明和使用">2.1 怎么用 – 动态属性的声明和使用</h4> <ol> <li> <strong>QMetaObject</strong> <code class="language-plaintext highlighter-rouge">QMetaObject</code> 提供了获取类的<strong>元信息</strong>（Meta Information）的能力，包括类名、属性、信号与槽、方法等。</li> </ol> <ul> <li> <p><strong>类名</strong> 通过 <code class="language-plaintext highlighter-rouge">QMetaObject</code> 可在运行时获取类的名称。例如，对于一个 <code class="language-plaintext highlighter-rouge">QObject</code> 对象 <code class="language-plaintext highlighter-rouge">obj</code>，可以这样获取类名：</p> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">QObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QObject</span><span class="p">();</span>
<span class="k">const</span> <span class="n">QMetaObject</span> <span class="o">*</span><span class="n">metaObj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">metaObject</span><span class="p">();</span>
<span class="n">QString</span> <span class="n">className</span> <span class="o">=</span> <span class="n">metaObj</span><span class="o">-&gt;</span><span class="n">className</span><span class="p">();</span>  <span class="c1">// 返回 "QObject"</span>
</code></pre></div> </div> </li> <li> <strong>属性信息</strong> 能够列出类声明的所有属性，包括通过 <code class="language-plaintext highlighter-rouge">Q_PROPERTY</code> 定义的属性及动态属性（Dynamic Property）。</li> <li> <strong>信号与槽信息</strong> 可以查询类中有哪些信号与槽函数，并在运行时进行动态连接。</li> <li> <strong>方法信息</strong> 包含类中所有方法的名称、参数列表、返回类型等，这为运行时动态调用方法提供了基础。</li> </ul> <hr> <ol> <li> <strong>QMetaMethod</strong> <code class="language-plaintext highlighter-rouge">QMetaMethod</code> 用于处理与类的方法相关的元信息操作，常见功能包括：</li> </ol> <ul> <li> <strong>方法名称获取</strong> 方便运行时确定具体的方法标识。</li> <li> <strong>参数类型获取</strong> 用于在运行时调用前进行参数匹配检查。</li> <li> <strong>动态调用方法</strong> 借助 <code class="language-plaintext highlighter-rouge">QMetaMethod::invoke()</code> 可以在运行时直接调用对象的方法，这在脚本绑定、插件系统等需要动态扩展的场景非常有用。</li> </ul> <hr> <ol> <li> <strong>对象名称和类型</strong> <code class="language-plaintext highlighter-rouge">QObject</code> 提供了 <code class="language-plaintext highlighter-rouge">objectName</code> 属性，用于唯一标识一个对象。</li> </ol> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">QObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QObject</span><span class="p">();</span>
<span class="n">obj</span><span class="o">-&gt;</span><span class="n">setObjectName</span><span class="p">(</span><span class="s">"myObject"</span><span class="p">);</span>      <span class="c1">// 设置名称</span>
<span class="n">QString</span> <span class="n">name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">objectName</span><span class="p">();</span>    <span class="c1">// 获取名称</span>
</code></pre></div></div> <p>配合 <code class="language-plaintext highlighter-rouge">QMetaObject::className()</code>，可以快速识别对象的<strong>逻辑标识</strong>（名称）和<strong>类型信息</strong>（类名），在调试、查找对象、自动化测试中都非常方便。</p> <hr> <ol> <li> <strong>动态属性</strong> <code class="language-plaintext highlighter-rouge">QObject</code> 允许在运行时添加、修改、删除属性，这就是<strong>动态属性</strong>（Dynamic Property）功能：</li> </ol> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">QObject</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QObject</span><span class="p">();</span>
<span class="c1">// 添加动态属性</span>
<span class="n">obj</span><span class="o">-&gt;</span><span class="n">setProperty</span><span class="p">(</span><span class="s">"dynamicProperty"</span><span class="p">,</span> <span class="mi">123</span><span class="p">);</span>
<span class="c1">// 获取动态属性值</span>
<span class="n">QVariant</span> <span class="n">value</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">property</span><span class="p">(</span><span class="s">"dynamicProperty"</span><span class="p">);</span>
<span class="c1">// 删除动态属性（设置为无效 QVariant）</span>
<span class="n">obj</span><span class="o">-&gt;</span><span class="n">setProperty</span><span class="p">(</span><span class="s">"dynamicProperty"</span><span class="p">,</span> <span class="n">QVariant</span><span class="p">());</span>
<span class="c1">// 获取对象的所有动态属性名</span>
<span class="n">QList</span><span class="o">&lt;</span><span class="n">QByteArray</span><span class="o">&gt;</span> <span class="n">props</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">dynamicPropertyNames</span><span class="p">();</span>
</code></pre></div></div> <p>动态属性的好处：</p> <ul> <li> <strong>灵活性</strong>：可以在不修改类定义的情况下，为对象添加额外信息。</li> <li> <strong>元对象系统支持</strong>：通过 <code class="language-plaintext highlighter-rouge">Q_PROPERTY</code> 定义的属性和动态属性都可以在运行时查询、修改，便于反射和脚本绑定。</li> <li> <strong>工具支持</strong>：<code class="language-plaintext highlighter-rouge">Q_PROPERTY</code> 定义的属性可被 Qt Designer、QML 等工具识别并编辑，而直接在类中暴露 <code class="language-plaintext highlighter-rouge">public</code> 成员变量则无法享受这种支持。</li> </ul> <hr> <h4 id="22-moc--动态属性背后的实现">2.2 moc – 动态属性背后的实现</h4> <p>Qt 的动态属性功能依赖于 <strong>元对象系统</strong>（Meta-Object System），而元对象系统的核心是 <strong>moc</strong>（Meta-Object Compiler，元对象编译器）。</p> <p><code class="language-plaintext highlighter-rouge">moc</code> 的工作原理简述：</p> <ol> <li> <strong>扫描源码</strong> <code class="language-plaintext highlighter-rouge">moc</code> 会在编译前扫描 <code class="language-plaintext highlighter-rouge">.h</code> 文件中的 <code class="language-plaintext highlighter-rouge">Q_OBJECT</code> 宏、<code class="language-plaintext highlighter-rouge">Q_PROPERTY</code> 宏、<code class="language-plaintext highlighter-rouge">signals</code> / <code class="language-plaintext highlighter-rouge">slots</code> 关键字。</li> <li> <p><strong>生成元对象代码</strong> <code class="language-plaintext highlighter-rouge">moc</code> 会生成一个额外的 <code class="language-plaintext highlighter-rouge">.moc</code> 文件，其中包含：</p> <ul> <li>一个静态的 <code class="language-plaintext highlighter-rouge">QMetaObject</code> 实例（保存类的元信息，包括属性、信号槽、方法等）</li> <li>信号槽调用所需的内部函数</li> <li>属性的元信息表（名称、类型、可读写标志等）</li> </ul> </li> <li> <strong>运行时访问</strong> 当你调用 <code class="language-plaintext highlighter-rouge">setProperty()</code>、<code class="language-plaintext highlighter-rouge">property()</code>、<code class="language-plaintext highlighter-rouge">dynamicPropertyNames()</code> 等函数时，Qt 首先会查找 <code class="language-plaintext highlighter-rouge">QMetaObject</code> 中声明的静态属性，如果没有找到，再去动态属性表中查找。</li> <li> <strong>动态属性存储</strong> 动态属性不会出现在 <code class="language-plaintext highlighter-rouge">moc</code> 生成的静态元信息表中，而是保存在 <code class="language-plaintext highlighter-rouge">QObjectPrivate</code> 的一个 <code class="language-plaintext highlighter-rouge">QMap&lt;QByteArray, QVariant&gt;</code> 里（称为 <strong>动态属性表</strong>）。</li> </ol> <p>动态属性访问流程：</p> <ul> <li> <strong>写入</strong>：<code class="language-plaintext highlighter-rouge">QObject::setProperty()</code> 会先判断属性是否存在于静态属性表（由 <code class="language-plaintext highlighter-rouge">moc</code> 生成）；如果不存在，则直接将其添加到动态属性表中。</li> <li> <strong>读取</strong>：<code class="language-plaintext highlighter-rouge">QObject::property()</code> 会先查找静态属性表，再查找动态属性表。</li> <li> <strong>枚举</strong>：<code class="language-plaintext highlighter-rouge">dynamicPropertyNames()</code> 会直接返回动态属性表的所有键名。</li> </ul> <p><strong>特点</strong>：</p> <ul> <li>动态属性完全在运行时生效，不需要重新编译类。</li> <li>静态属性由 <code class="language-plaintext highlighter-rouge">moc</code> 生成的元对象描述；动态属性则由运行时的属性表维护。</li> <li>QML、Qt Designer、序列化系统都可以利用这套机制进行对象的属性管理。</li> </ul> <h3 id="3-反射">3 反射</h3> <h4 id="31-怎么用--反射">3.1 怎么用 – 反射</h4> <ul> <li> <p><strong>使用元对象系统进行反射</strong> 反射是指在运行时检查和调用对象的属性和方法的能力。Qt 的元对象系统为 C++ 提供了类似动态语言的反射机制，使得程序在运行时能够获取类的类型信息、枚举属性、动态调用方法等。</p> <p>常见用途包括：</p> <ol> <li> <strong>获取类名</strong>：使用 <code class="language-plaintext highlighter-rouge">className()</code> 方法获取运行时类名。</li> <li> <strong>获取和设置属性</strong>：使用 <code class="language-plaintext highlighter-rouge">property()</code>、<code class="language-plaintext highlighter-rouge">setProperty()</code> 或通过 <code class="language-plaintext highlighter-rouge">QMetaProperty</code> 访问属性。</li> <li> <strong>调用方法</strong>：使用 <code class="language-plaintext highlighter-rouge">QMetaObject::invokeMethod()</code> 动态调用对象的方法。</li> <li> <strong>枚举元数据</strong>：遍历类的属性列表、信号槽列表、枚举类型等。</li> </ol> <p><strong>示例</strong>：</p> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;QObject&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QDebug&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QMetaProperty&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QMetaObject&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MyObject</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QObject</span> <span class="p">{</span>
    <span class="n">Q_OBJECT</span>
    <span class="n">Q_PROPERTY</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span> <span class="n">READ</span> <span class="n">value</span> <span class="n">WRITE</span> <span class="n">setValue</span><span class="p">)</span>
<span class="nl">public:</span>
    <span class="n">MyObject</span><span class="p">(</span><span class="n">QObject</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="o">:</span> <span class="n">QObject</span><span class="p">(</span><span class="n">parent</span><span class="p">),</span> <span class="n">m_value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">int</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_value</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">setValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">m_value</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyObject</span> <span class="n">obj</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">QMetaObject</span> <span class="o">*</span><span class="n">metaObj</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">metaObject</span><span class="p">();</span>

    <span class="c1">// 获取类名</span>
    <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Class name:"</span> <span class="o">&lt;&lt;</span> <span class="n">metaObj</span><span class="o">-&gt;</span><span class="n">className</span><span class="p">();</span>

    <span class="c1">// 获取属性</span>
    <span class="kt">int</span> <span class="n">propIndex</span> <span class="o">=</span> <span class="n">metaObj</span><span class="o">-&gt;</span><span class="n">indexOfProperty</span><span class="p">(</span><span class="s">"value"</span><span class="p">);</span>
    <span class="n">QMetaProperty</span> <span class="n">prop</span> <span class="o">=</span> <span class="n">metaObj</span><span class="o">-&gt;</span><span class="n">property</span><span class="p">(</span><span class="n">propIndex</span><span class="p">);</span>
    <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Property name:"</span> <span class="o">&lt;&lt;</span> <span class="n">prop</span><span class="p">.</span><span class="n">name</span><span class="p">();</span>
    <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Property value:"</span> <span class="o">&lt;&lt;</span> <span class="n">prop</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">).</span><span class="n">toInt</span><span class="p">();</span>

    <span class="c1">// 修改属性</span>
    <span class="n">prop</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
    <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"New property value:"</span> <span class="o">&lt;&lt;</span> <span class="n">prop</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">).</span><span class="n">toInt</span><span class="p">();</span>

    <span class="c1">// 动态调用方法（示例：假设存在某个槽函数）</span>
    <span class="c1">// QMetaObject::invokeMethod(&amp;obj, "someSlot", Q_ARG(int, 123));</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p>上述代码展示了：</p> <ul> <li>如何通过 <code class="language-plaintext highlighter-rouge">metaObject()</code> 获取运行时元信息；</li> <li>如何用 <code class="language-plaintext highlighter-rouge">QMetaProperty</code> 读取、修改属性；</li> <li>如何为后续动态方法调用做准备。</li> </ul> </li> </ul> <h4 id="32-moc--反射背后的实现">3.2 moc – 反射背后的实现</h4> <p>Qt 的反射机制并不是由 C++ 原生支持的，而是依赖 <strong>Meta-Object Compiler（moc）</strong> 在编译阶段生成额外的 C++ 代码实现的。</p> <ol> <li> <p><strong>moc 的工作时机</strong></p> <ul> <li>当一个类使用了 <code class="language-plaintext highlighter-rouge">Q_OBJECT</code> 宏时，Qt 的构建系统（qmake 或 CMake）会在编译前调用 <code class="language-plaintext highlighter-rouge">moc</code> 工具；</li> <li> <code class="language-plaintext highlighter-rouge">moc</code> 会解析头文件，找到包含 <code class="language-plaintext highlighter-rouge">Q_OBJECT</code> 宏的类，并扫描 <code class="language-plaintext highlighter-rouge">Q_PROPERTY</code>、<code class="language-plaintext highlighter-rouge">signals</code>、<code class="language-plaintext highlighter-rouge">slots</code>、<code class="language-plaintext highlighter-rouge">Q_ENUM</code> 等声明；</li> <li>根据解析结果生成一个 <code class="language-plaintext highlighter-rouge">.moc</code> 文件（通常命名为 <code class="language-plaintext highlighter-rouge">moc_ClassName.cpp</code>）。</li> </ul> </li> <li> <p><strong>moc 生成的内容</strong> <code class="language-plaintext highlighter-rouge">moc</code> 生成的代码会为类添加一个静态的 <strong><code class="language-plaintext highlighter-rouge">QMetaObject</code></strong> 实例，并实现以下功能：</p> <ul> <li> <strong>类的元信息表</strong>：包括类名、父类名、属性列表、方法（信号与槽）列表、枚举列表等；</li> <li> <strong>静态访问函数</strong>：如 <code class="language-plaintext highlighter-rouge">staticMetaObject</code>、<code class="language-plaintext highlighter-rouge">qt_static_metacall</code> 等，用于 Qt 元对象系统调用；</li> <li> <strong>信号槽连接支持</strong>：生成信号的唯一 ID、槽函数索引等，使运行时可以通过字符串名进行连接；</li> <li> <strong>属性读写函数指针</strong>：<code class="language-plaintext highlighter-rouge">QMetaProperty</code> 调用时会通过这些指针访问真实的 getter/setter。</li> </ul> </li> <li> <p><strong>QMetaObject 的作用</strong> 每个 <code class="language-plaintext highlighter-rouge">QObject</code> 派生类在运行时都会携带一个 <code class="language-plaintext highlighter-rouge">QMetaObject</code>，它是 Qt 反射的核心数据结构，提供：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">className()</code>：类名；</li> <li> <code class="language-plaintext highlighter-rouge">superClass()</code>：父类的元对象；</li> <li> <code class="language-plaintext highlighter-rouge">propertyCount()</code> / <code class="language-plaintext highlighter-rouge">property(i)</code>：属性的元数据；</li> <li> <code class="language-plaintext highlighter-rouge">methodCount()</code> / <code class="language-plaintext highlighter-rouge">method(i)</code>：方法的元数据；</li> <li> <code class="language-plaintext highlighter-rouge">invokeMethod()</code>：动态调用方法。</li> </ul> </li> <li> <p><strong>运行时反射过程示例</strong> 当你调用：</p> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">obj</span><span class="o">-&gt;</span><span class="n">metaObject</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">property</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">read</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</code></pre></div> </div> <p>实际流程是：</p> <ul> <li>通过 <code class="language-plaintext highlighter-rouge">metaObject()</code> 找到类的 <code class="language-plaintext highlighter-rouge">QMetaObject</code>；</li> <li>在 <code class="language-plaintext highlighter-rouge">QMetaObject</code> 的属性表中查找对应 <code class="language-plaintext highlighter-rouge">QMetaProperty</code>；</li> <li>调用 <code class="language-plaintext highlighter-rouge">QMetaProperty::read()</code>，它内部会调用 moc 生成的 getter 函数指针来获取值。</li> </ul> </li> <li> <p><strong>为什么 C++ 需要 moc 才能反射</strong></p> <ul> <li>标准 C++ 并没有运行时类型枚举、属性反射等功能（<code class="language-plaintext highlighter-rouge">typeid</code> 只能返回类名等非常有限的信息）；</li> <li>moc 通过 <strong>在编译前生成额外的 C++ 代码</strong>，弥补了这一缺陷，实现了近似动态语言的反射能力；</li> <li>因为一切都是在编译时生成的代码，所以运行时几乎没有额外开销。</li> </ul> </li> </ol> <p><strong>总结</strong>： Qt 的反射是由 moc 在编译期生成元信息表和调用分发代码来实现的，运行时只需查表调用，因此性能较高；相比 Java、C# 这种纯运行时反射机制，Qt 反射更偏向静态生成 + 运行时查表的混合模式。</p> <h3 id="99-quiz">99. quiz</h3> <h4 id="信号和槽跨线程">信号和槽跨线程</h4> <ul> <li> <strong>信号和槽跨线程</strong>：当信号和槽跨线程连接时，Qt 借助事件队列机制确保槽函数在正确线程被调用。</li> </ul> <p>Qt 的事件循环与信号槽机制共同构建了强大的事件处理和对象间通信框架，支持同步与异步操作以及跨线程通信。</p> <p>当不同线程触发信号时，若信号和槽跨越线程（即信号发出者与槽函数接收者位于不同线程），Qt 使用消息队列传递事件：</p> <ul> <li>信号触发时，相关事件（即信号激活的动作）被放入事件队列。</li> <li>事件循环按顺序处理队列中的事件。当处理到信号相关事件时，依据 <code class="language-plaintext highlighter-rouge">QObject::connect()</code> 建立的连接，找到并调用对应的槽函数。</li> <li>若信号和槽在同一线程，槽函数通常直接（同步）调用。若在不同线程，Qt 会将槽函数的调用封装为一个事件，发送到接收者所在线程的事件队列，由该线程的事件循环异步处理。</li> </ul> <h4 id="信号槽与-event-函数对比">信号槽与 event() 函数对比</h4> <ol> <li> <strong>信号槽（Signal - Slot）</strong>：Qt 特有的事件处理机制，主要用于对象间通信。特定事件发生时信号发射，可连接一个或多个槽函数，信号发射时，所有连接的槽函数均会被调用。该机制是异步的，实现了事件发送者和接收者的松耦合，双方无需知晓对方的具体实现。</li> <li> <strong>event() 函数</strong>：主要用于处理各种事件（如鼠标点击、键盘按键等）。当事件发送到对象时，对象的 <code class="language-plaintext highlighter-rouge">event()</code> 函数会被调用。开发者可通过重写此函数实现自定义事件处理逻辑，该函数是同步的，直接处理事件，并决定是否继续传递事件。</li> </ol> <ul> <li> <strong>QAction 解析</strong> <code class="language-plaintext highlighter-rouge">QAction</code> 可看作是对信号槽机制的高级封装，它不仅具备信号槽函数的功能，还增加了快捷键、图标、状态提示等功能，帮助开发者更便捷地实现丰富的交互效果。</li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/signal/">（三）内核那些事儿：CPU中断和信号</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/program/">（二）内核那些事儿：程序启动到运行的完整过程</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/os/">（一）内核那些事儿：从硬件抽象到系统服务的完整框架</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/internet/">（七）内核那些事儿：操作系统对网络包的处理</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/interaction/">（五）内核那些事儿：系统和程序的交互</a> </li> </div> </div> <div class="col-sm-4"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <script src="/assets/js/toc-depth.js"></script> </body> </html>