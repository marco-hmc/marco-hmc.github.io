<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> （四）C++对象内存模型详解：数据内存布局 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A blog for documenting my own study notes. "> <meta name="keywords" content="blog, cpp, programmer"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/toc-custom.css"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2026/cppData/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-8"> <div class="post"> <header class="post-header"> <h1 class="post-title">（四）C++对象内存模型详解：数据内存布局</h1> <p class="post-meta"> Created on January 04, 2026 </p> <p class="post-tags"> <a href="/blog/2026"> <i class="fa-solid fa-calendar fa-sm"></i> 2026 </a>   ·   <a href="/blog/tag/class"> <i class="fa-solid fa-hashtag fa-sm"></i> Class</a>   ·   <a href="/blog/category/c"> <i class="fa-solid fa-tag fa-sm"></i> C++</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="c对象内存模型详解数据内存布局">C++对象内存模型详解：数据内存布局</h2> <h3 id="1-程序内存布局概述">1. 程序内存布局概述</h3> <h4 id="11-内存区域划分">1.1 内存区域划分</h4> <p>程序运行时的内存空间被划分为以下几个主要区域：</p> <ol> <li> <p><strong>代码段（Text Segment）</strong></p> <ul> <li>存储编译后的机器指令，设置为只读</li> <li>包含<strong>常量存储区</strong>：存放字符串字面量和编译时常量</li> </ul> </li> <li> <p><strong>数据段（Data Segment）</strong></p> <ul> <li> <strong>初始化数据段</strong>：已初始化的全局变量和静态变量</li> <li> <strong>BSS 段</strong>：未初始化的全局变量和静态变量（自动初始化为 0）</li> </ul> </li> <li> <p><strong>堆区（Heap）</strong></p> <ul> <li>动态内存分配区域（<code class="language-plaintext highlighter-rouge">malloc</code>、<code class="language-plaintext highlighter-rouge">new</code>等）</li> <li>需要程序员手动管理，容易发生内存泄漏</li> </ul> </li> <li> <p><strong>栈区（Stack）</strong></p> <ul> <li>存储局部变量、函数参数、返回地址</li> <li>编译器自动管理内存分配和释放</li> </ul> </li> <li> <p><strong>其他区域</strong></p> <ul> <li> <strong>动态库加载区域</strong>：共享库代码和数据</li> <li> <strong>内存映射区域</strong>：文件映射、共享内存</li> <li> <strong>寄存器</strong>：CPU 内部高速存储单元</li> </ul> </li> </ol> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>高地址 ┌─────────────────┐
      │    内核空间      │
      ├─────────────────┤
      │    栈区(Stack)   │ ↓ 向下增长
      ├─────────────────┤
      │   内存映射区域    │
      ├─────────────────┤
      │    堆区(Heap)    │ ↑ 向上增长
      ├─────────────────┤
      │   BSS段(未初始化) │
      ├─────────────────┤
      │  数据段(已初始化)  │
      ├─────────────────┤
低地址 │   代码段(只读)    │
      └─────────────────┘
</code></pre></div></div> <h3 id="2-全局变量与静态变量">2. 全局变量与静态变量</h3> <h4 id="21-全局对象的存储位置与地址分配">2.1 全局对象的存储位置与地址分配</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">数据段存储</code>：全局变量和全局对象存储于数据段。数据段作为程序的一部分，用于存放静态分配的变量，包括全局变量与静态变量。</li> <li> <code class="language-plaintext highlighter-rouge">内存默认清零</code>：若未给全局对象设置初始值，编译器会默认将全局对象所在内存清零，即其所有成员变量初始化为零值。</li> <li> <code class="language-plaintext highlighter-rouge">编译期确定地址与分配内存</code>：全局变量在编译阶段便完成空间分配，其地址在编译期间确定，且该内存空间在程序运行时始终存在，地址固定不变。</li> <li> <code class="language-plaintext highlighter-rouge">构造时机</code>：全局对象的构造在 <code class="language-plaintext highlighter-rouge">main()</code> 函数执行前进行。全局对象存储于数据段且默认值为零，编译器会在程序启动前调用其构造函数，以确保正确初始化。</li> <li> <code class="language-plaintext highlighter-rouge">析构时机</code>：全局对象的析构在 <code class="language-plaintext highlighter-rouge">main()</code> 函数执行完毕后进行。编译器会在程序结束时调用其析构函数，保证资源的正确清理。</li> </ul> <h4 id="22-全局对象的构造和析构步骤">2.2 全局对象的构造和析构步骤</h4> <ol> <li> <code class="language-plaintext highlighter-rouge">地址与内存分配</code>：全局对象 <code class="language-plaintext highlighter-rouge">g_aobj</code> 的地址及内存空间均在编译时确定并分配，在程序运行期间其地址保持固定。</li> <li> <code class="language-plaintext highlighter-rouge">静态初始化</code>：程序启动前，编译器对全局对象 <code class="language-plaintext highlighter-rouge">g_aobj</code> 执行静态初始化，将其内存内容清零，使所有成员变量初始化为零值。</li> <li> <code class="language-plaintext highlighter-rouge">构造函数调用</code>：在 <code class="language-plaintext highlighter-rouge">main()</code> 函数执行前，编译器调用全局对象 <code class="language-plaintext highlighter-rouge">g_aobj</code> 所属类 <code class="language-plaintext highlighter-rouge">A</code> 的构造函数，确保 <code class="language-plaintext highlighter-rouge">g_aobj</code> 在 <code class="language-plaintext highlighter-rouge">main()</code> 函数执行前正确初始化。</li> <li>``main()<code class="language-plaintext highlighter-rouge"> 函数执行</code>：程序开始执行 <code class="language-plaintext highlighter-rouge">main()</code>函数，此时已初始化的全局对象<code class="language-plaintext highlighter-rouge">g_aobj</code> 可供使用。</li> <li> <code class="language-plaintext highlighter-rouge">析构函数调用</code>：<code class="language-plaintext highlighter-rouge">main()</code> 函数执行完毕后，编译器调用全局对象 <code class="language-plaintext highlighter-rouge">g_aobj</code> 所属类 <code class="language-plaintext highlighter-rouge">A</code> 的析构函数，确保程序结束时 <code class="language-plaintext highlighter-rouge">g_aobj</code> 被正确清理，释放相关资源。</li> </ol> <p><strong>全局对象的生命周期管理：</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GlobalTest</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">GlobalTest</span><span class="p">()</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Global object constructed"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">GlobalTest</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Global object destructed"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">GlobalTest</span> <span class="n">g_obj</span><span class="p">;</span>  <span class="c1">// 全局对象</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"main() starts"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// g_obj已经构造完成，可以使用</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"main() ends"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 程序输出：</span>
<span class="c1">// Global object constructed</span>
<span class="c1">// main() starts</span>
<span class="c1">// main() ends</span>
<span class="c1">// Global object destructed</span>
</code></pre></div></div> <p><strong>关键特性：</strong></p> <ul> <li> <strong>存储位置</strong>：数据段</li> <li> <strong>地址确定</strong>：编译期确定，运行期固定不变</li> <li> <strong>初始化</strong>：未显式初始化时默认清零</li> <li> <strong>构造时机</strong>：<code class="language-plaintext highlighter-rouge">main()</code>函数执行前</li> <li> <strong>析构时机</strong>：<code class="language-plaintext highlighter-rouge">main()</code>函数执行后</li> </ul> <h4 id="23-局部静态对象的构造和析构">2.3 局部静态对象的构造和析构</h4> <ul> <li> <code class="language-plaintext highlighter-rouge">构造时机</code>：局部静态对象的构造函数仅在首次调用包含该对象定义的函数时执行一次。此后，即便多次调用该函数，该对象也不会再次构造。</li> <li> <code class="language-plaintext highlighter-rouge">地址特性</code>：局部静态对象的内存地址在编译阶段即已确定，每次调用函数时，该对象的地址始终保持不变。</li> <li> <code class="language-plaintext highlighter-rouge">初始化过程</code>：若未对局部静态对象进行显式初始化，程序启动时它会被默认初始化为零值。直到首次调用包含它的函数时，才会触发其构造函数进行正式初始化。</li> <li> <code class="language-plaintext highlighter-rouge">析构时机</code>：局部静态对象的析构函数会在 <code class="language-plaintext highlighter-rouge">main()</code> 函数执行完毕后被调用，以此确保在程序结束时，该对象所占用的资源能够被正确释放。</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Counter</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">Counter</span><span class="p">()</span> <span class="p">{</span> <span class="o">++</span><span class="n">count</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">count</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">Counter</span><span class="o">::</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 静态成员定义</span>

<span class="kt">void</span> <span class="nf">createObject</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">Counter</span> <span class="n">localStatic</span><span class="p">;</span>  <span class="c1">// 局部静态对象</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Function called, count: "</span> <span class="o">&lt;&lt;</span> <span class="n">Counter</span><span class="o">::</span><span class="n">getCount</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">createObject</span><span class="p">();</span>  <span class="c1">// 第一次调用，构造localStatic</span>
    <span class="n">createObject</span><span class="p">();</span>  <span class="c1">// 第二次调用，不再构造</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>局部静态对象特点：</strong></p> <ul> <li>首次调用函数时构造，只构造一次</li> <li>地址编译期确定，每次调用保持不变</li> <li>程序结束时析构</li> </ul> <h3 id="3-类数据成员内存布局">3. 类数据成员内存布局</h3> <ol> <li> <p><code class="language-plaintext highlighter-rouge">声明顺序与排列</code>：非静态数据成员在对象中的排列顺序遵循其在类定义中的声明顺序。也就是说，编译器会按照声明先后为数据成员分配内存。在同一个访问控制段（如 <code class="language-plaintext highlighter-rouge">private</code>、<code class="language-plaintext highlighter-rouge">protected</code>、<code class="language-plaintext highlighter-rouge">public</code>）内，后声明的数据成员会被分配到相对较高的内存地址。从内存地址增长方向来看，数据成员从低地址向高地址依次分配存储。这里需要提及大小端存储的概念，它描述了数据在内存中的存储方式。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">大端存储</code>：数据的低位保存在内存中的高地址中，数据的高位保存在内存中的低地址中。</li> <li> <code class="language-plaintext highlighter-rouge">小端存储</code>：数据的低位保存在内存中的低地址中，数据的高位保存在内存中的高地址中。大小端存储方式虽然与数据成员的声明顺序和排列没有直接关联，但在理解数据在内存中的实际存储形式时是重要的基础知识。</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">内存对齐</code>：为优化数据访问速度，数据成员会按照其自身的自然对齐边界进行对齐。例如，一个四字节的整型通常会被对齐到四字节边界。这种对齐机制可能导致在数据成员之间插入额外的填充字节，以满足对齐要求。通过特定的编译指令可以调整对齐方式，例如：</p> </li> </ol> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma pack(1) // 对齐方式设置为1字节对齐（不对齐）
</span>
<span class="cp">#pragma pack() // 取消指定对齐，恢复缺省对齐；
</span></code></pre></div></div> <ol> <li> <p><code class="language-plaintext highlighter-rouge">静态数据成员</code>：静态数据成员并不在对象实例中存储，而是在程序的全局数据区域或静态区进行分配。这使得所有类实例共享相同的静态数据成员实例。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">虚函数表</code>：若类中包含虚函数，编译器会为该类生成一个虚函数表（vtable），它本质上是一个函数指针数组，存储了类中所有虚函数的地址。每个含有虚函数的类实例会包含一个指向这个 vtable 的指针（称为 vptr），一般情况下，该指针位于对象的起始位置，但具体位置依赖于编译器实现。虚函数表则在代码区。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">多重继承</code>：在多重继承场景下，派生类可能会拥有多个虚函数表指针，每个指针分别指向其不同基类的虚函数表，以此来支持正确的动态调度。此外，为保证基类子对象布局的正确性，可能还需要进行额外的偏移量调整。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">空对象</code>：即便一个类没有数据成员，编译器通常也会为其分配一个字节的空间。这是为了确保每个对象实例都具有唯一的地址，从而能够有效识别空对象。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">访问控制</code>：不同的访问控制段（<code class="language-plaintext highlighter-rouge">public</code>、<code class="language-plaintext highlighter-rouge">protected</code>、<code class="language-plaintext highlighter-rouge">private</code>）虽然不会对数据成员在内存中的物理布局产生影响，但它们严格限定了成员的访问权限。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">位域成员</code>：当类定义中包含位域时，这些成员会根据位域的定义紧密打包存储，这可能导致内存布局不符合直观预期。</p> </li> </ol> <h4 id="31-基本布局规则">3.1 基本布局规则</h4> <ol> <li> <code class="language-plaintext highlighter-rouge">基类子对象</code>：在多重继承中，每个基类的子对象都会嵌入到派生类对象内，保持各自基类的布局。基类子对象的排列顺序依编译器实现而异，部分编译器倾向于按继承列表中基类出现的顺序安排。每个基类子对象包含自身的非静态数据成员，若基类有虚函数，还包含一个指向该基类虚函数表的指针（vptr）。</li> <li> <code class="language-plaintext highlighter-rouge">内存对齐</code>：每个基类子对象的起始位置需满足其内部数据成员的对齐要求。同时，派生类起始部分及各基类子对象间的布局也会考虑对齐，以实现最佳访问性能。</li> <li> <code class="language-plaintext highlighter-rouge">虚函数表指针（vptr）</code>：多重继承时，可能存在多个虚函数表指针。若基类中有虚函数，派生类对象通常需包含一个或多个指向虚函数表的指针。对于有相同虚函数的基类，编译器可能采用虚基类机制或优化策略（如共享虚函数表指针）以避免重复。</li> <li> <code class="language-plaintext highlighter-rouge">虚基类</code>：若基类本身是多重继承的结果且被继承为虚基类，派生类对象中仅包含一个虚基类的实例，而非每个继承路径上各有一个。虚基类表指针（vbptr）可能用于定位这个共享的虚基类实例，确保对虚基类数据成员的正确访问。</li> <li> <code class="language-plaintext highlighter-rouge">派生类特有的数据成员</code>：在所有基类子对象之后，是派生类自定义的非静态数据成员，它们按声明顺序排列并满足对齐要求。</li> <li> <code class="language-plaintext highlighter-rouge">内存填充</code>：为确保对齐，编译器可能在基类子对象之间、基类子对象与派生类数据成员之间插入填充字节。</li> <li> <code class="language-plaintext highlighter-rouge">菱形继承问题</code>：菱形继承是多重继承中典型的问题，即一个类直接继承自两个或更多个类，而这些类又共同继承自同一个基类。C++引入虚基类来解决此问题，确保基类的子对象只被继承一次，避免数据重复。</li> </ol> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MemoryLayout</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>       <span class="c1">// 1字节</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>        <span class="c1">// 4字节，可能有3字节填充</span>
    <span class="kt">double</span> <span class="n">c</span><span class="p">;</span>     <span class="c1">// 8字节</span>
    <span class="kt">char</span> <span class="n">d</span><span class="p">;</span>       <span class="c1">// 1字节，可能有7字节填充</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Size of MemoryLayout: "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MemoryLayout</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Address of a: "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Address of b: "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Address of c: "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Address of d: "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="32-虚函数表布局">3.2 虚函数表布局</h4> <p>虚函数表（vtable）是编译器为支持动态多态生成的只读函数指针表；每个多态子对象在实例中保留一个 vptr（指向 vtable）的指针字段。不同继承模型会影响 vptr 的数量、位置与查找过程（单继承通常 1 个 vptr，多重/虚继承可能有多个 vptr 或额外的 vbptr），并且构造/析构阶段 vptr 的值会变化以保证语义正确。</p> <p>示意布局（简化、按字节块表示）</p> <ul> <li>单继承（Base 有虚函数） [ vptr (-&gt; vtable_Base) ][ Base::data ][ Derived::data ]</li> <li>多重继承（A,B 都有虚） [ A.vptr ][ A::data ][ B.vptr ][ B::data ][ C::data ]</li> <li>虚继承（B、C virtual A） [ B 子对象 (vbptr_B, B.vptr, B::data) ] [ C 子对象 (vbptr_C, C.vptr, C::data) ] [ 共享虚基 A 子对象 (A::data) ] [ C::own data… ]</li> </ul> <p>伪结构表示（概念）</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// vtable: 只读</span>
<span class="k">using</span> <span class="n">Fn</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="k">struct</span> <span class="nc">VTable</span> <span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">typeinfo</span><span class="p">;</span>    <span class="c1">// RTTI（可选/ABI相关）</span>
    <span class="n">Fn</span>   <span class="n">func1</span><span class="p">;</span>
    <span class="n">Fn</span>   <span class="n">func2</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="c1">// 对象内代表（单继承）</span>
<span class="k">struct</span> <span class="nc">Base_Object</span> <span class="p">{</span>
    <span class="n">VTable</span><span class="o">*</span> <span class="n">vptr</span><span class="p">;</span>   <span class="c1">// 指向 Base 的 vtable</span>
    <span class="kt">int</span> <span class="n">baseData</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>构造与虚调用（伪代码）</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 构造时（编译器插入）</span>
<span class="kt">void</span> <span class="nf">Derived_ctor</span><span class="p">(</span><span class="n">Derived</span><span class="o">*</span> <span class="k">this</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 先设置为 Base vtable（基类构造阶段）</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">vptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vtable_Base</span><span class="p">;</span>
    <span class="n">Base_ctor</span><span class="p">((</span><span class="n">Base</span><span class="o">*</span><span class="p">)</span><span class="k">this</span><span class="p">);</span>
    <span class="c1">// 然后设置为 Derived vtable（最派生类构造完成）</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">vptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vtable_Derived</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 虚调用 site（obj-&gt;f(); 编译器生成）</span>
<span class="kt">void</span> <span class="nf">call_f</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span><span class="o">**</span> <span class="n">vptr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="n">obj</span><span class="p">;</span>          <span class="c1">// 取 vptr，编译期无法确定实际是哪个类型，因此需要间接寻址</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="n">Base</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">Base</span><span class="o">*</span><span class="p">))</span><span class="n">vptr</span><span class="p">[</span><span class="n">f_index</span><span class="p">];</span> <span class="c1">// f_index是编译期确定的偏移</span>
    <span class="n">fn</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>                             <span class="c1">// 间接跳转（可能要先调整 this）</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="33-虚继承内存布局">3.3 虚继承内存布局</h4> <p>虚继承会把共享的虚基子对象只放一份，派生对象内除了各个基类子对象的 vptr 外还会有用于定位虚基的 vbptr/vbtable 信息；最派生类负责初始化虚基，调用时需通过子对象地址 + vptr（或 thunks）或通过 vbptr 表查找虚基偏移。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 类定义（菱形）：
  - class A { virtual ...; int a; };
  - class B : virtual A { ...; int b; };
  - class C : virtual A { ...; int c; };
  - class D : B, C { ...; int d; };

- D 对象内存布局（示意）
  [ B 子对象: (vbptr_B?, B.vptr, B::data) ]
  [ C 子对象: (vbptr_C?, C.vptr, C::data) ]
  [ 共享虚基 A 子对象: (A.vptr?, A::data) ]    &lt;- 只存一次
  [ D::own data... ]

- vbtable/vbptr（示意）
  - vbtable（只读）存储从该子对象到每个虚基的偏移（offset-to-top / offset-to-vbase）。
  - vbptr（对象内）指向对应的 vbtable，用于 runtime 计算虚基地址： vbase_addr = (char*)subobj + vbtable[i]
</code></pre></div></div> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 示例：虚继承的内存与 vptr/vbptr 观察</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fa</span><span class="p">()</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">virtual</span> <span class="n">A</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fb</span><span class="p">()</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">virtual</span> <span class="n">A</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fc</span><span class="p">()</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">D</span> <span class="o">:</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fd</span><span class="p">()</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">D</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"&amp;obj="</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">obj</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// 观察 B 子对象处的 vptr/vbptr（粗略读取）</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">bp</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">B</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">));</span>
    <span class="kt">void</span><span class="o">**</span> <span class="n">maybe_vptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">**&gt;</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"B subobj addr="</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">bp</span>
              <span class="o">&lt;&lt;</span> <span class="s">", *maybe_vptr="</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">maybe_vptr</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// 观察 C 子对象处</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">cp</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">C</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">));</span>
    <span class="kt">void</span><span class="o">**</span> <span class="n">maybe_vptr_c</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">**&gt;</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"C subobj addr="</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">cp</span>
              <span class="o">&lt;&lt;</span> <span class="s">", *maybe_vptr_c="</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">maybe_vptr_c</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// 观察 A （虚基）子对象地址</span>
    <span class="n">A</span><span class="o">*</span> <span class="n">ap</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">A</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A (virtual base) addr="</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">ap</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// 调用以看动态分派行为</span>
    <span class="n">B</span><span class="o">*</span> <span class="n">bp2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">;</span>
    <span class="n">C</span><span class="o">*</span> <span class="n">cp2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">;</span>
    <span class="n">A</span><span class="o">*</span> <span class="n">ap2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">;</span>
    <span class="n">bp2</span><span class="o">-&gt;</span><span class="n">fb</span><span class="p">();</span>
    <span class="n">cp2</span><span class="o">-&gt;</span><span class="n">fc</span><span class="p">();</span>
    <span class="n">ap2</span><span class="o">-&gt;</span><span class="n">fa</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*
&amp;obj=0x7ffd2cc6a160
B subobj addr=0x7ffd2cc6a160, *maybe_vptr=0x55d7ec05abd8
C subobj addr=0x7ffd2cc6a170, *maybe_vptr_c=0x55d7ec05ac00
A (virtual base) addr=0x7ffd2cc6a180
*/</span>
</code></pre></div></div> <h3 id="4-动态内存管理">4. 动态内存管理</h3> <h4 id="41-new-和-delete-的区别详解">4.1 new 和 delete 的区别详解</h4> <p><strong>基本数据类型：</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">demonstrateNewBehavior</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 基本类型 - 不加括号</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>        <span class="c1">// 未初始化，值随机</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*p1 = "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 随机值</span>

    <span class="c1">// 基本类型 - 加括号</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">();</span>      <span class="c1">// 初始化为0</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*p2 = "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 0</span>

    <span class="c1">// 基本类型 - 指定初值</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">p3</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>   <span class="c1">// 初始化为100</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*p3 = "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p3</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// 100</span>

    <span class="c1">// 数组</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">arr1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>     <span class="c1">// 未初始化</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">arr2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">10</span><span class="p">]();</span>   <span class="c1">// 初始化为0</span>

    <span class="k">delete</span> <span class="n">p1</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">p2</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">p3</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">arr1</span><span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">arr2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>类对象：</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TestClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TestClass</span><span class="p">()</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="mi">99</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Constructor called, value = "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">TestClass</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Destructor called"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">demonstrateClassNew</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">TestClass</span><span class="o">*</span> <span class="n">obj1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestClass</span><span class="p">;</span>    <span class="c1">// 调用构造函数</span>
    <span class="n">TestClass</span><span class="o">*</span> <span class="n">obj2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestClass</span><span class="p">();</span>  <span class="c1">// 调用构造函数</span>
    <span class="c1">// 对于有构造函数的类，两种写法效果相同</span>

    <span class="k">delete</span> <span class="n">obj1</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">obj2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="42-newdelete-的底层实现">4.2 new/delete 的底层实现</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// new的操作步骤等价于：</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span><span class="o">*</span> <span class="nf">myNew</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 1. 调用operator new分配内存</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">memory</span> <span class="o">=</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>

    <span class="c1">// 2. 调用构造函数</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span> <span class="n">T</span><span class="p">();</span>  <span class="c1">// placement new</span>

    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// delete的操作步骤等价于：</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">myDelete</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1. 调用析构函数</span>
    <span class="n">obj</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span>

    <span class="c1">// 2. 调用operator delete释放内存</span>
    <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="43-placement-new-的应用">4.3 placement new 的应用</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;new&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MemoryPool</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">pool</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">used</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">MemoryPool</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">poolSize</span><span class="p">)</span> <span class="o">:</span> <span class="n">size</span><span class="p">(</span><span class="n">poolSize</span><span class="p">),</span> <span class="n">used</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">MemoryPool</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">pool</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="n">T</span><span class="o">*</span> <span class="nf">allocate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">T</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">pool</span> <span class="o">+</span> <span class="n">used</span><span class="p">)</span> <span class="n">T</span><span class="p">();</span>  <span class="c1">// placement new</span>
        <span class="n">used</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">obj</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span>  <span class="c1">// 只调用析构函数，不释放内存</span>
        <span class="c1">// 内存池统一管理内存释放</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">useMemoryPool</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MemoryPool</span> <span class="n">pool</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>

    <span class="n">TestClass</span><span class="o">*</span> <span class="n">obj1</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">allocate</span><span class="o">&lt;</span><span class="n">TestClass</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">TestClass</span><span class="o">*</span> <span class="n">obj2</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">allocate</span><span class="o">&lt;</span><span class="n">TestClass</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">pool</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">obj1</span><span class="p">);</span>
    <span class="n">pool</span><span class="p">.</span><span class="n">deallocate</span><span class="p">(</span><span class="n">obj2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="5-内存管理深入探讨">5. 内存管理深入探讨</h3> <h4 id="51-delete-时的长度信息">5.1 delete 时的长度信息</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">memoryLengthDemo</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 单个对象 - 编译器知道类型大小</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">singleInt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="k">delete</span> <span class="n">singleInt</span><span class="p">;</span>  <span class="c1">// 编译器知道删除4字节</span>

    <span class="c1">// 数组 - 需要存储长度信息</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">arrayInt</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">arrayInt</span><span class="p">;</span>  <span class="c1">// 运行时系统知道数组长度</span>
    <span class="cm">/*
        - 若元素是非平凡析构，库通常在 user 指针之前写入一个 cookie（元素个数或字节数），delete[] 读取 cookie 用于逐个析构并计算应传给底层释放器的原始指针。
        - 若元素是平凡析构（例如 int），运行时常可省略存 cookie：因为不需要逐元素析构，delete[] 只需把指针交给底层释放器（malloc/free 的内部 metadata 已记录块大小，或 operator delete 会处理），无需额外长度信息。
        - 现代实现/ABI 还可能使用 sized deallocation（编译器把大小传给 operator delete(void*, size_t)），编译器可据此省去 cookie。
        - 标准并不规定 cookie 放哪儿或必须存在（implementation‑defined），所以不要依赖或读取实现细节（那通常是未定义行为或非可移植的）。
    */</span>

    <span class="c1">// 多态删除 - 需要虚析构函数</span>
    <span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>  <span class="c1">// 虚析构函数很重要</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
    <span class="nl">public:</span>
        <span class="n">Derived</span><span class="p">()</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">100</span><span class="p">])</span> <span class="p">{}</span>
        <span class="o">~</span><span class="n">Derived</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">Base</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Derived</span><span class="p">();</span>
    <span class="k">delete</span> <span class="n">obj</span><span class="p">;</span>  <span class="c1">// 正确调用Derived的析构函数</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="52-operator-new-vs-new-operator">5.2 operator new vs new operator</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CustomAlloc</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// 重载operator new</span>
    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Custom operator new called, size: "</span> <span class="o">&lt;&lt;</span> <span class="n">size</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 重载operator delete</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Custom operator delete called"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">CustomAlloc</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Constructor called"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">CustomAlloc</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Destructor called"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">demonstrateOperatorOverload</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 使用new operator（会调用重载的operator new和构造函数）</span>
    <span class="n">CustomAlloc</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CustomAlloc</span><span class="p">();</span>
    <span class="k">delete</span> <span class="n">obj</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"---"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 直接使用operator new（只分配内存，不调用构造函数）</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">rawMemory</span> <span class="o">=</span> <span class="n">CustomAlloc</span><span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">CustomAlloc</span><span class="p">));</span>
    <span class="n">CustomAlloc</span><span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">rawMemory</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-常量段为什么单独存放">1: 常量段为什么单独存放？</h4> <p>常量段独立于数据段的原因：</p> <ul> <li> <strong>安全性</strong>：只读保护防止意外修改</li> <li> <strong>优化</strong>：编译器可进行常量折叠等优化</li> <li> <strong>共享</strong>：多个进程可共享相同的常量段</li> </ul> <h4 id="2-malloc-的系统调用机制">2: malloc 的系统调用机制</h4> <ul> <li> <strong>小内存分配（&lt;128KB）</strong>：使用<code class="language-plaintext highlighter-rouge">brk</code>系统调用扩展堆</li> <li> <strong>大内存分配（≥128KB）</strong>：使用<code class="language-plaintext highlighter-rouge">mmap</code>映射虚拟内存</li> <li> <strong>缺页中断</strong>：访问虚拟地址时分配物理内存</li> </ul> <h4 id="3-内存对齐优化">3. 内存对齐优化</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 不优化的布局</span>
<span class="k">class</span> <span class="nc">BadLayout</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>      <span class="c1">// 1字节</span>
    <span class="kt">double</span> <span class="n">b</span><span class="p">;</span>    <span class="c1">// 8字节，前面有7字节填充</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>      <span class="c1">// 1字节</span>
    <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>       <span class="c1">// 4字节，前面有3字节填充</span>
<span class="p">};</span>
<span class="c1">// sizeof(BadLayout) = 24</span>

<span class="c1">// 优化后的布局</span>
<span class="k">class</span> <span class="nc">GoodLayout</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">b</span><span class="p">;</span>    <span class="c1">// 8字节</span>
    <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>       <span class="c1">// 4字节</span>
    <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>      <span class="c1">// 1字节</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>      <span class="c1">// 1字节，后面有2字节填充</span>
<span class="p">};</span>
<span class="c1">// sizeof(GoodLayout) = 16</span>
</code></pre></div></div> <h3 id="8-总结">8. 总结</h3> <p>理解 C++对象内存模型对于编写高效、安全的程序至关重要：</p> <ol> <li> <strong>内存布局</strong>：掌握各内存区域的作用和特点</li> <li> <strong>对象生命周期</strong>：理解构造和析构的时机</li> <li> <strong>内存对齐</strong>：优化数据结构布局</li> <li> <strong>动态内存</strong>：正确使用 new/delete 和智能指针</li> <li> <strong>多线程安全</strong>：保护共享数据的访问</li> </ol> <p>通过深入理解这些概念，可以写出更加健壮和高效的 C++程序。</p> <ol> <li> <code class="language-plaintext highlighter-rouge">基类子对象</code>：在多重继承中，每个基类的子对象都会嵌入到派生类对象内，保持各自基类的布局。基类子对象的排列顺序依编译器实现而异，部分编译器倾向于按继承列表中基类出现的顺序安排。每个基类子对象包含自身的非静态数据成员，若基类有虚函数，还包含一个指向该基类虚函数表的指针（vptr）。</li> <li> <code class="language-plaintext highlighter-rouge">内存对齐</code>：每个基类子对象的起始位置需满足其内部数据成员的对齐要求。同时，派生类起始部分及各基类子对象间的布局也会考虑对齐，以实现最佳访问性能。</li> <li> <code class="language-plaintext highlighter-rouge">虚函数表指针（vptr）</code>：多重继承时，可能存在多个虚函数表指针。若基类中有虚函数，派生类对象通常需包含一个或多个指向虚函数表的指针。对于有相同虚函数的基类，编译器可能采用虚基类机制或优化策略（如共享虚函数表指针）以避免重复。</li> <li> <code class="language-plaintext highlighter-rouge">虚基类</code>：若基类本身是多重继承的结果且被继承为虚基类，派生类对象中仅包含一个虚基类的实例，而非每个继承路径上各有一个。虚基类表指针（vbptr）可能用于定位这个共享的虚基类实例，确保对虚基类数据成员的正确访问。</li> <li> <code class="language-plaintext highlighter-rouge">派生类特有的数据成员</code>：在所有基类子对象之后，是派生类自定义的非静态数据成员，它们按声明顺序排列并满足对齐要求。</li> <li> <code class="language-plaintext highlighter-rouge">内存填充</code>：为确保对齐，编译器可能在基类子对象之间、基类子 对象与派生类数据成员之间插入填充字节。</li> <li> <code class="language-plaintext highlighter-rouge">菱形继承问题</code>：菱形继承是多重继承中典型的问题，即一个类直接继承自两个或更多个类，而这些类又共同继承自同一个基类。C++引入虚基类来解决此问题，确保基类的子对象只被继承一次，避免数据重复。</li> </ol> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/signal/">（三）内核那些事儿：CPU中断和信号</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/program/">（二）内核那些事儿：程序启动到运行的完整过程</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/os/">（一）内核那些事儿：从硬件抽象到系统服务的完整框架</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/internet/">（七）内核那些事儿：操作系统对网络包的处理</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2026/interaction/">（五）内核那些事儿：系统和程序的交互</a> </li> </div> </div> <div class="col-sm-4"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <script src="/assets/js/toc-depth.js"></script> </body> </html>