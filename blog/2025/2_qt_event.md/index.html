<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> （二）Qt 那些事儿：事件循环机制 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/toc-custom.css"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/2_qt_event.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-8"> <div class="post"> <header class="post-header"> <h1 class="post-title">（二）Qt 那些事儿：事件循环机制</h1> <p class="post-meta"> Created on September 15, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/qt"> <i class="fa-solid fa-hashtag fa-sm"></i> Qt</a>   ·   <a href="/blog/category/c"> <i class="fa-solid fa-tag fa-sm"></i> C++</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="二qt-那些事儿事件循环机制">（二）Qt 那些事儿：事件循环机制</h2> <h3 id="1-concepts">1. concepts</h3> <h4 id="11-什么是事件循环">1.1 什么是事件循环？</h4> <p>Qt 事件循环（Event Loop）是整个框架的核心，它基于<strong>生产者-消费者</strong>模式运作：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>操作系统 → 事件队列 → Qt事件循环 → 控件处理
   ↑          ↑          ↑         ↑
生产事件    缓存事件    消费事件   响应事件
</code></pre></div></div> <p><strong>核心机制：</strong></p> <ul> <li> <strong>事件生产</strong>：操作系统捕获用户操作（鼠标、键盘等）</li> <li> <strong>事件缓存</strong>：事件被放入队列等待处理</li> <li> <strong>事件消费</strong>：Qt 从队列取出事件并分发</li> <li> <strong>事件响应</strong>：目标控件处理事件</li> </ul> <p>在 Qt 框架中，事件循环（Event Loop）处于核心地位，负责管理和处理应用程序中各类事件。无论是用户在界面上的点击、输入等操作，还是系统产生的定时器事件、状态变化通知等，都需由程序捕捉并做出响应。</p> <p>操作系统会捕获这些事件，发送到程序和 os 之间的一个缓存区，也叫事件队列。程序会不定期从这个事件队列取出事件消费，所谓的程序未响应其实就是这个事件队列已满，无法继续添加事件，因此当前出于无法响应的状态。而 Qt 作为一个框架，在这个过程中屏蔽了不同平台产生的事件类型，不同平台的事件获取方式，并给出了统一的事件消费、事件分发机制。</p> <p>又因为事件的处理（分发、消费）和事件的生成不是同一个主体，前者是程序自身，而后者是 os 的事情，因此即使事件在处理的过程中，事件也可以不停生产并添加到事件队列中。</p> <p>事件循环基于队列机制循环处理事件。当事件队列中有等待处理的事件时，事件循环被激活并处理这些事件；若队列为空，事件循环则进入阻塞状态，等待新事件发生。</p> <p>借助事件循环，Qt 应用能够以非阻塞方式响应用户交互，使界面保持响应状态，同时处理其他异步事件。这种模型让程序在等待事件发生时保持低功耗，仅在必要时唤醒执行相关操作，高效利用系统资源。</p> <h4 id="12-qt-程序对事件的具体处理机制">1.2 Qt 程序对事件的具体处理机制</h4> <p>程序接收操作系统分发的事件（如鼠标点击、键盘输入、窗口大小变化等）后，借助事件循环处理并传递给相应控件。以 Qt 为例，详细过程如下：</p> <ol> <li> <p><strong>事件的消费和加工</strong></p> <p>操作系统将事件消息发送至前台窗口。以Windows为例，Qt内部使用<code class="language-plaintext highlighter-rouge">QWindowsEventDispatcher</code>接收<code class="language-plaintext highlighter-rouge">WM_MOUSEMOVE</code>、<code class="language-plaintext highlighter-rouge">WM_LBUTTONDOWN</code>等消息，随后封装为Qt自己的事件对象（如<code class="language-plaintext highlighter-rouge">QMouseEvent</code>）。</p> <p>Qt将平台事件统一加工成Qt事件，屏蔽平台差异：</p> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// Windows: WM_MOUSEMOVE, WM_LBUTTONDOWN</span>
<span class="c1">// Linux: X11 events</span>
<span class="c1">// macOS: Cocoa events</span>
<span class="c1">// ↓ Qt内部转换</span>
<span class="c1">// QMouseEvent, QKeyEvent, QPaintEvent</span>
</code></pre></div> </div> <p>Qt程序启动时执行<code class="language-plaintext highlighter-rouge">QApplication::exec()</code>，这是一个持续运行的循环函数，不断从事件队列消费事件：</p> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="n">MainWindow</span> <span class="n">w</span><span class="p">;</span>
    <span class="n">w</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>  <span class="c1">// 启动事件循环</span>
<span class="p">}</span>
</code></pre></div> </div> <p>事件循环基于操作系统消息机制，封装在<code class="language-plaintext highlighter-rouge">QEventLoop</code>类中。Qt将平台消息转换为<code class="language-plaintext highlighter-rouge">QEvent</code>对象并放入事件队列（由<code class="language-plaintext highlighter-rouge">QCoreApplication</code>管理）。执行<code class="language-plaintext highlighter-rouge">app.exec()</code>时启动事件循环机制，通过<code class="language-plaintext highlighter-rouge">QEventLoop::exec()</code>进行while循环，不断取出并处理事件。</p> </li> <li> <p><strong>Qt 对事件的分发</strong></p> <p>取出事件后，通过<code class="language-plaintext highlighter-rouge">QCoreApplication::notify(QObject *receiver, QEvent *event)</code>确定接收事件的控件并分发。该函数负责将事件分发给接收者，并调用<code class="language-plaintext highlighter-rouge">receiver-&gt;event(event)</code>函数。</p> <p>不同事件的分发方式：</p> <ul> <li> <strong>鼠标事件</strong>：通过坐标映射确定对应控件接收</li> <li> <strong>键盘事件</strong>：由获得焦点的控件接收</li> <li> <strong>定时器事件</strong>：由设置了<code class="language-plaintext highlighter-rouge">QTimer</code>的控件或对象接收</li> <li> <strong>自定义事件</strong>：手动投递或发送</li> </ul> <p>以鼠标事件为例：</p> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// 在 QApplication::notify 中</span>
<span class="c1">// Qt直接定位目标控件，不逐层传递</span>
<span class="n">QWidget</span> <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="n">QWidget</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">widgetAt</span><span class="p">(</span><span class="n">mousePos</span><span class="p">));</span>
<span class="n">QMouseEvent</span> <span class="nf">event</span><span class="p">(...);</span>
<span class="n">QCoreApplication</span><span class="o">::</span><span class="n">sendEvent</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>
</code></pre></div> </div> <p>Qt的事件分发是直接传入目标控件，而非父对象逐层传递。当鼠标点击发生时，Qt精准定位最终目标控件（如<code class="language-plaintext highlighter-rouge">QPushButton</code>），直接发送事件给它。这种定位在<code class="language-plaintext highlighter-rouge">QApplication::notify()</code>中完成，借助<code class="language-plaintext highlighter-rouge">QWidget::find()</code>等机制确定接收事件的具体控件。</p> <p>假设控件结构如下：</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>MainWindow
└── QWidget (parent)
    └── QPushButton (child, 坐标区域覆盖鼠标)
</code></pre></div> </div> <p>事件分发流程：</p> <ol> <li>Qt获取鼠标坐标（相对于屏幕或主窗口）</li> <li>调用<code class="language-plaintext highlighter-rouge">QWidget::childAt()</code>找到该坐标下最深层的控件（<code class="language-plaintext highlighter-rouge">QPushButton</code>）</li> <li>直接将事件发送给<code class="language-plaintext highlighter-rouge">QPushButton</code> </li> <li> <code class="language-plaintext highlighter-rouge">QPushButton</code>接收事件后调用自身的<code class="language-plaintext highlighter-rouge">event()</code>函数，进而分发给<code class="language-plaintext highlighter-rouge">mousePressEvent()</code>处理</li> </ol> <p>不同类型事件的分发方式：</p> <table> <thead> <tr> <th>类型</th> <th>分发方式</th> </tr> </thead> <tbody> <tr> <td>鼠标/键盘/触摸事件</td> <td>🚀 直接分发给目标控件</td> </tr> <tr> <td>绘制事件 PaintEvent</td> <td>🧱 由外层控件递归向子控件调用</td> </tr> <tr> <td>自定义事件</td> <td>🚀 使用<code class="language-plaintext highlighter-rouge">postEvent</code>/<code class="language-plaintext highlighter-rouge">sendEvent</code>手动指定目标</td> </tr> <tr> <td>拦截机制</td> <td>🛑 <code class="language-plaintext highlighter-rouge">installEventFilter()</code>先于正常分发</td> </tr> </tbody> </table> <p><strong>注意</strong>：普通输入事件直接发送至目标控件，但绘制事件（<code class="language-plaintext highlighter-rouge">QPaintEvent</code>）不同。绘制事件由框架自动产生，分发顺序按控件层级从外到内调用，如<code class="language-plaintext highlighter-rouge">MainWindow::paintEvent() → QWidget::paintEvent() → QPushButton::paintEvent()</code>。</p> </li> <li> <p><strong>控件对事件的消费</strong></p> <p>事件到达控件（QObject派生类）后，先调用<code class="language-plaintext highlighter-rouge">event()</code>函数，再分发给具体处理函数：</p> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">QWidget</span><span class="o">::</span><span class="n">event</span><span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">QEvent</span><span class="o">::</span><span class="n">MouseButtonPress</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mousePressEvent</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">QMouseEvent</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
        <span class="k">case</span> <span class="n">QEvent</span><span class="o">::</span><span class="n">KeyPress</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">keyPressEvent</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">QKeyEvent</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <p><code class="language-plaintext highlighter-rouge">event()</code>是控件处理所有事件的统一入口，Qt根据事件类型调用专门的函数。开发者可重写这些处理函数实现自定义行为。</p> <p><strong>事件处理返回值的意义：</strong></p> <ul> <li> <strong>返回<code class="language-plaintext highlighter-rouge">true</code></strong>：事件已处理完毕，Qt事件系统认为不需要再传递给其他对象（包括父控件）</li> <li> <strong>返回<code class="language-plaintext highlighter-rouge">false</code></strong>：当前控件未处理该事件，Qt事件系统将继续分发给其他对象</li> </ul> <p>返回值决定事件是否”终止传播”：<code class="language-plaintext highlighter-rouge">true</code>终止传播，<code class="language-plaintext highlighter-rouge">false</code>允许事件继续传递。</p> </li> </ol> <h4 id="13-如何介入事件处理流程的时机与方式">1.3 如何介入事件处理流程的时机与方式</h4> <p>使用事件过滤器（事件拦截机制）可在事件到达目标控件<strong>之前</strong>进行拦截处理：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 事件过滤器类 MyFilter</span>
<span class="kt">bool</span> <span class="n">MyFilter</span><span class="o">::</span><span class="n">eventFilter</span><span class="p">(</span><span class="n">QObject</span> <span class="o">*</span><span class="n">watched</span><span class="p">,</span> <span class="n">QEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">QEvent</span><span class="o">::</span><span class="n">KeyPress</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"Key pressed!"</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 返回 true 表示拦截该事件</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 返回 false 表示不处理，将事件交给目标对象</span>
<span class="p">}</span>

<span class="c1">// 在主代码中安装事件过滤器</span>
<span class="n">targetWidget</span><span class="o">-&gt;</span><span class="n">installEventFilter</span><span class="p">(</span><span class="n">myFilter</span><span class="p">);</span>
<span class="c1">// 注意：此行为不会对子对象生效，如需对子对象安装eventFilter，需要找到子对象调用此方法</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">eventFilter()</code>是<code class="language-plaintext highlighter-rouge">QObject</code>类的成员函数，通常在<code class="language-plaintext highlighter-rouge">QObject</code>或其子类中重写，用于过滤其他对象的事件。安装事件过滤器后，当目标对象接收事件时，<code class="language-plaintext highlighter-rouge">eventFilter()</code>函数优先被调用，可以决定是否拦截事件或进行特殊处理。</p> <h4 id="14-挂起事件的提前消费---processevents">1.4 挂起事件的提前消费 - <code class="language-plaintext highlighter-rouge">processEvents</code> </h4> <p><code class="language-plaintext highlighter-rouge">processEvents()</code>是在阻塞代码中促使Qt对已排队事件进行”抢先处理”，维持界面响应性的关键手段：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">MainWindow</span><span class="o">::</span><span class="n">onLoadClicked</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// UI显示"正在加载"</span>
    <span class="n">ui</span><span class="o">-&gt;</span><span class="n">label</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="s">"Loading..."</span><span class="p">);</span>

    <span class="c1">// 这里不调用 processEvents，UI 可能不会立即刷新</span>
    <span class="c1">// 开始加载一个大文件（阻塞主线程）</span>
    <span class="n">loadBigFile</span><span class="p">();</span>

    <span class="c1">// 加载完再刷新 UI</span>
    <span class="n">ui</span><span class="o">-&gt;</span><span class="n">label</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="s">"Load done"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>在此实现中，由于设置<code class="language-plaintext highlighter-rouge">label</code>文本后未调用<code class="language-plaintext highlighter-rouge">processEvents()</code>，执行<code class="language-plaintext highlighter-rouge">loadBigFile()</code>这一阻塞操作时，UI可能无法及时刷新显示”Loading…“。</p> <p>改进后的实现：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">MainWindow</span><span class="o">::</span><span class="n">onLoadClicked</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ui</span><span class="o">-&gt;</span><span class="n">label</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="s">"Loading..."</span><span class="p">);</span>
    <span class="n">qApp</span><span class="o">-&gt;</span><span class="n">processEvents</span><span class="p">();</span>  <span class="c1">// 立即处理事件，刷新界面</span>

    <span class="n">loadBigFile</span><span class="p">();</span> <span class="c1">// 阻塞操作</span>

    <span class="n">ui</span><span class="o">-&gt;</span><span class="n">label</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="s">"Load done"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">processEvents()</code>方法处理事件队列中的所有挂起事件，包括用户输入、窗口更新、定时器事件等。通过调用<code class="language-plaintext highlighter-rouge">qApp-&gt;processEvents()</code>，在设置文本后立即处理事件，确保UI及时刷新。</p> <p><strong>使用注意事项：</strong></p> <ol> <li> <strong>性能问题</strong>：频繁调用可能引发性能下降，每次调用都会处理所有挂起事件</li> <li> <strong>避免递归事件</strong>：在事件处理过程中再次调用可能导致递归，使逻辑复杂</li> <li> <strong>替代方案</strong>：优先采用异步操作（如<code class="language-plaintext highlighter-rouge">QThread</code>或<code class="language-plaintext highlighter-rouge">QtConcurrent</code>）防止阻塞事件循环</li> </ol> <h4 id="15-主动生成事件">1.5 主动生成事件</h4> <p>在Qt中，事件（<code class="language-plaintext highlighter-rouge">QEvent</code>）是对象间传递信息的机制。除了外部事件（鼠标、键盘、窗口重绘等），还有系统内部事件（定时器消息、进程间消息等）。</p> <p>事件的构造函数不是私有的，我们可以直接构造事件。对于新构造的事件，有两种消费方式：</p> <p><strong>(1) <code class="language-plaintext highlighter-rouge">sendEvent(QObject *receiver, QEvent *event)</code></strong></p> <ul> <li> <strong>同步调用</strong>：事件立即发送到目标对象，调用链立刻进入<code class="language-plaintext highlighter-rouge">receiver-&gt;event()</code> </li> <li>事件处理完成后才返回调用者</li> <li>不进入Qt事件队列，不等待事件循环</li> <li>适合<strong>需要立即执行的场景</strong> </li> <li>因为立即执行，若在非UI线程调用，会违反线程亲和性，可能导致崩溃</li> <li>会阻塞当前线程直到事件处理完成</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">QMouseEvent</span> <span class="nf">event</span><span class="p">(</span><span class="n">QEvent</span><span class="o">::</span><span class="n">MouseButtonPress</span><span class="p">,</span> <span class="n">QPointF</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">Qt</span><span class="o">::</span><span class="n">LeftButton</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">LeftButton</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">NoModifier</span><span class="p">);</span>
<span class="n">QCoreApplication</span><span class="o">::</span><span class="n">sendEvent</span><span class="p">(</span><span class="n">widget</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>  <span class="c1">// 立即调用 widget-&gt;event(&amp;event)</span>
</code></pre></div></div> <p><strong>(2) <code class="language-plaintext highlighter-rouge">postEvent(QObject *receiver, QEvent *event)</code></strong></p> <ul> <li> <strong>异步调用</strong>：将事件放入Qt事件队列，等到事件循环处理时才调用<code class="language-plaintext highlighter-rouge">receiver-&gt;event()</code> </li> <li>不会立即处理，返回时事件还未处理</li> <li>适合跨线程通信、延迟处理、避免阻塞</li> <li> <code class="language-plaintext highlighter-rouge">postEvent</code>会自动接管<code class="language-plaintext highlighter-rouge">event</code>的内存（Qt事件队列负责delete）</li> <li>目标对象销毁时，未处理的事件会被自动丢弃并释放</li> <li>更安全地跨线程发送事件，Qt会把事件派发到目标对象所在线程的事件循环</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">QMouseEvent</span> <span class="o">*</span><span class="n">event</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">QMouseEvent</span><span class="p">(</span><span class="n">QEvent</span><span class="o">::</span><span class="n">MouseButtonPress</span><span class="p">,</span> <span class="n">QPointF</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">Qt</span><span class="o">::</span><span class="n">LeftButton</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">LeftButton</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">NoModifier</span><span class="p">);</span>
<span class="n">QCoreApplication</span><span class="o">::</span><span class="n">postEvent</span><span class="p">(</span><span class="n">widget</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>  <span class="c1">// 放入事件队列，稍后执行</span>
</code></pre></div></div> <h3 id="2-子事件循环">2. 子事件循环</h3> <h4 id="21-什么是子事件循环">2.1 什么是子事件循环</h4> <p>子事件循环是一种临时构建的事件处理机制。除了由<code class="language-plaintext highlighter-rouge">QApplication::exec()</code>启动的主事件循环外，开发者可以在函数中临时创建<code class="language-plaintext highlighter-rouge">QEventLoop</code>对象，通过执行<code class="language-plaintext highlighter-rouge">loop.exec()</code>来处理事件。</p> <p>主要功能：</p> <ol> <li> <p><strong>暂停当前函数执行以显示模态对话框</strong>：如<code class="language-plaintext highlighter-rouge">QDialog::exec()</code>利用子事件循环暂停当前操作流程，等待用户输入</p> </li> <li> <p><strong>等待异步事件完成</strong>：</p> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">QEventLoop</span> <span class="n">loop</span><span class="p">;</span>
<span class="n">connect</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">AsyncTask</span><span class="o">::</span><span class="n">done</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QEventLoop</span><span class="o">::</span><span class="n">quit</span><span class="p">);</span>
<span class="n">loop</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>  <span class="c1">// 等待异步信号触发</span>
</code></pre></div> </div> </li> <li> <p><strong>在不中断主事件循环的前提下维持UI响应性</strong>：</p> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">QEventLoop</span> <span class="n">loop</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">operationFinished</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">doOneStepOfLongTask</span><span class="p">();</span>
    <span class="n">loop</span><span class="p">.</span><span class="n">processEvents</span><span class="p">();</span>  <span class="c1">// 处理用户输入和界面刷新</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shouldCancelOperation</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> </ol> <p><code class="language-plaintext highlighter-rouge">QEventLoop</code>主要接口：</p> <table> <thead> <tr> <th>接口名</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">exec(QEventLoop::ProcessEventsFlags flags = AllEvents)</code></td> <td>启动事件循环</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">exit(int returnCode = 0)</code></td> <td>停止事件循环，并返回状态码</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">quit()</code></td> <td>信号：用于退出事件循环</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">isRunning()</code></td> <td>判断事件循环是否正在运行</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">processEvents(QEventLoop::ProcessEventsFlags flags = AllEvents)</code></td> <td>立即处理所有待处理事件</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">wakeUp()</code></td> <td>唤醒处于阻塞状态的事件循环，常用于线程间通信</td> </tr> </tbody> </table> <ul> <li> <strong><code class="language-plaintext highlighter-rouge">wakeUp()</code></strong>：主要用于唤醒因事件队列无事件而阻塞的事件循环，通常在多线程场景下用于线程间通信</li> <li> <strong><code class="language-plaintext highlighter-rouge">isRunning()</code></strong>：判断当前是否正在运行事件循环，避免重复调用<code class="language-plaintext highlighter-rouge">exec()</code>防止嵌套过深或死锁</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">QEventLoop</span> <span class="n">loop</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loop</span><span class="p">.</span><span class="n">isRunning</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">loop</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="22-多个-qeventloop-同时存在的情况">2.2 多个 QEventLoop 同时存在的情况</h4> <p>Qt应用程序拥有一个由<code class="language-plaintext highlighter-rouge">QApplication::exec()</code>启动的主事件循环。当启动子事件循环时，主事件循环暂时暂停，子事件循环成为当前活动的事件循环。</p> <p><strong>事件处理特点：</strong></p> <ul> <li>子事件循环活动时负责处理事件队列中的事件</li> <li>父事件循环（主事件循环）暂停，无法主动消费事件</li> <li>新事件仍可添加到事件队列中</li> <li>新事件会在当前活动的子循环中处理（若适用），或等待子循环退出后由父循环处理</li> </ul> <p>子事件循环退出后，父事件循环恢复运行继续处理剩余事件。任一时刻仅有一个事件循环处于活动状态，但事件队列是共享的。</p> <p><strong>嵌套事件循环示例：</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;QCoreApplication&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QEventLoop&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QTimer&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QDebug&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QCoreApplication</span> <span class="n">a</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="c1">// 外层事件循环</span>
    <span class="n">QEventLoop</span> <span class="n">outerLoop</span><span class="p">;</span>
    <span class="c1">// 内层事件循环</span>
    <span class="n">QEventLoop</span> <span class="n">innerLoop</span><span class="p">;</span>

    <span class="c1">// 定时器，用于退出内层事件循环</span>
    <span class="n">QTimer</span> <span class="n">innerTimer</span><span class="p">;</span>
    <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">innerTimer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QTimer</span><span class="o">::</span><span class="n">timeout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">innerLoop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QEventLoop</span><span class="o">::</span><span class="n">quit</span><span class="p">);</span>
    <span class="n">innerTimer</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span> <span class="c1">// 1秒后超时</span>

    <span class="c1">// 定时器，用于退出外层事件循环</span>
    <span class="n">QTimer</span> <span class="n">outerTimer</span><span class="p">;</span>
    <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">outerTimer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QTimer</span><span class="o">::</span><span class="n">timeout</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">outerLoop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QEventLoop</span><span class="o">::</span><span class="n">quit</span><span class="p">);</span>
    <span class="n">outerTimer</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span> <span class="c1">// 3秒后超时</span>

    <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"进入外层事件循环"</span><span class="p">;</span>
    <span class="n">outerLoop</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
    <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"外层事件循环结束"</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>注意</strong>：过多的嵌套事件循环会使代码逻辑复杂，可能引发死锁等问题。在嵌套事件循环中，所有事件依旧在主事件循环中处理，嵌套事件循环仅暂停当前代码执行，不影响事件分发和处理。</p> <h3 id="3-同步方式实现的-ui-交互">3. 同步方式实现的 UI 交互</h3> <p>在UI交互中，常见一种”顺序式”的逻辑：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">StartLineCommand</span><span class="p">();</span>
<span class="n">GetPoint</span><span class="p">(</span><span class="s">"请选择起点"</span><span class="p">);</span>  <span class="c1">// 等待用户点击</span>
<span class="n">GetPoint</span><span class="p">(</span><span class="s">"请选择终点"</span><span class="p">);</span>  <span class="c1">// 再等待用户点击</span>
</code></pre></div></div> <p>这种同步执行流程直观清晰：一行一行执行，<code class="language-plaintext highlighter-rouge">GetPoint()</code>会”停下来等待”用户点击，用户点击后函数返回再继续执行下一行。这种写法就像控制台程序或脚本那样，自然清晰，也便于维护。</p> <p>但这在Qt中行不通，因为Qt是<strong>事件驱动的GUI框架</strong>：</p> <ol> <li>程序启动后，Qt启动一个<strong>事件循环（event loop）</strong> </li> <li>鼠标点击、键盘输入、窗口重绘等都会生成”事件”</li> <li>Qt把事件投递给响应的对象（按钮、窗口等）</li> <li>我们通过信号槽、事件处理函数来响应这些事件</li> </ol> <p><strong>关键区别</strong>：事件不是你代码调用触发的，而是用户操作后Qt调用你的回调函数。所以无法写出像<code class="language-plaintext highlighter-rouge">GetPoint()</code>这样的阻塞函数，除非<strong>人为构造一个”同步等待”的机制</strong>。</p> <h4 id="31-qt-原生方式--异步状态机">3.1 Qt 原生方式 —— 异步+状态机</h4> <p>在 Qt 中，推荐的写法是通过事件驱动的回调进行处理。例如监听点击事件，通过状态记录当前是第几次点击：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 假设 currentState 是一个成员变量，记录当前状态（0=等待起点，1=等待终点）</span>
<span class="kt">void</span> <span class="nf">onUserClicked</span><span class="p">(</span><span class="n">QPoint</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">currentState</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">startPoint</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">currentState</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">showHint</span><span class="p">(</span><span class="s">"请选择终点"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">currentState</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">endPoint</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">finishLine</span><span class="p">(</span><span class="n">startPoint</span><span class="p">,</span> <span class="n">endPoint</span><span class="p">);</span>
        <span class="n">currentState</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">showHint</span><span class="p">(</span><span class="s">"请选择起点"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>这是标准的事件驱动写法，但它有两个问题：（1）写起来不像“流程代码”，而是拆成多个回调；（2）无法清晰表达“阻塞等待用户输入”的语义。</p> <h4 id="32-为什么不能用-while-等待用户点击">3.2 为什么不能用 <code class="language-plaintext highlighter-rouge">while()</code> 等待用户点击？</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">QPoint</span> <span class="n">p</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">gotUserClick</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 等待点击</span>
<span class="p">}</span>
</code></pre></div></div> <p>很多人第一反应也还是上面这种写法，这种写法会让程序直接“卡死”，因为你阻塞了主线程，Qt 无法处理 UI 事件 —— 鼠标、键盘、重绘等全部停摆，界面无响应，整个程序陷入死锁状态。</p> <h4 id="33-使用-qeventloop-启动子事件循环">3.3 使用 QEventLoop 启动“子事件循环”</h4> <p>Qt 提供一个非常有用的类 <code class="language-plaintext highlighter-rouge">QEventLoop</code>，它可以临时开启一个新的事件循环，让 UI 不会卡死，同时主流程“停下来等结果”，模拟同步行为。</p> <p>示意代码如下：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">QEventLoop</span> <span class="n">loop</span><span class="p">;</span>

<span class="n">connect</span><span class="p">(</span><span class="n">viewport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MyCanvas</span><span class="o">::</span><span class="n">clicked</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">loop</span><span class="p">](</span><span class="n">QPoint</span> <span class="n">pt</span><span class="p">){</span>
    <span class="n">point</span> <span class="o">=</span> <span class="n">pt</span><span class="p">;</span>
    <span class="n">loop</span><span class="p">.</span><span class="n">quit</span><span class="p">();</span>  <span class="c1">// 退出子事件循环</span>
<span class="p">});</span>

<span class="n">showHint</span><span class="p">(</span><span class="s">"请选择一个点"</span><span class="p">);</span>
<span class="n">loop</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>       <span class="c1">// 启动子事件循环，等待 quit 被调用</span>
</code></pre></div></div> <p>你可以理解为：主流程暂时“挂起”，进入一个新的事件处理阶段；用户点击后触发回调，退出循环，主流程恢复继续执行。这就实现了看起来是同步的等待，但实际上 Qt 仍然在正常处理事件，不会卡 UI。</p> <p>底层由事件驱动 + 子事件循环机制支撑，表面上是“同步流程”，实际上是异步事件响应。</p> <p>但是一个实际的系统，可能还会面临如下需求：</p> <ul> <li>模态交互（如点选对象、选择区域）；</li> <li>取消机制（按 Esc 或右键取消当前命令）；</li> <li>多重嵌套（主命令中调用子命令或对话框）；</li> <li>跨模块的统一交互逻辑调度。</li> </ul> <p>所以一般都需要再对<code class="language-plaintext highlighter-rouge">loop</code>去封装一下</p> <table> <thead> <tr> <th>目标</th> <th>是否达成</th> </tr> </thead> <tbody> <tr> <td>看起来是同步的交互等待</td> <td>✅ 使用 <code class="language-plaintext highlighter-rouge">exec()</code> + <code class="language-plaintext highlighter-rouge">quit()</code> 实现</td> </tr> <tr> <td>UI 保持响应性</td> <td>✅ 子事件循环不阻塞 UI</td> </tr> <tr> <td>支持多级嵌套和弹窗调用</td> <td>✅ 用 <code class="language-plaintext highlighter-rouge">_loops</code> 栈统一管理</td> </tr> <tr> <td>支持中断退出、状态恢复</td> <td>✅ <code class="language-plaintext highlighter-rouge">earlyExit</code> / <code class="language-plaintext highlighter-rouge">interrupt()</code> 控制</td> </tr> <tr> <td>提供统一指令交互调度框架</td> <td>✅ 所有命令逻辑都走统一事件循环封装</td> </tr> </tbody> </table> <p><strong>总结</strong>：Qt是异步事件驱动模型，无法像控制台程序那样”等输入”。如果想在界面程序中”等用户点一下”，要么写异步状态机逻辑，要么用<code class="language-plaintext highlighter-rouge">QEventLoop</code>开个子事件循环，模拟同步流程而不阻塞UI。</p> <p>这种做法在Qt的机制上构建了一套统一的指令调度和交互系统，既保留异步驱动的优势，又提供可控、清晰的”同步式”交互体验。</p> <h4 id="34-协程方式实现同步的-ui-交互">3.4 协程方式实现同步的 ui 交互</h4> <p>随着C++20引入协程支持，我们可以使用更现代的方式来实现看似同步的UI交互，避免复杂的状态机逻辑和事件循环嵌套。</p> <h5 id="341-协程的基本概念与优势">3.4.1 协程的基本概念与优势</h5> <p>协程（Coroutine）是一种可以被暂停和恢复的函数，它允许我们在函数执行过程中”让出控制权”，稍后再从暂停的地方继续执行。这非常适合实现异步等待用户输入的场景。</p> <p><strong>核心优势对比：</strong></p> <table> <thead> <tr> <th>方式</th> <th>代码结构</th> <th>异常处理</th> <th>维护性</th> <th>嵌套支持</th> </tr> </thead> <tbody> <tr> <td>状态机方式</td> <td>🔴 分散的回调</td> <td>🔴 复杂</td> <td>🔴 难维护</td> <td>🔴 困难</td> </tr> <tr> <td>QEventLoop方式</td> <td>🟡 较清晰</td> <td>🟡 一般</td> <td>🟡 中等</td> <td>🟡 需要管理</td> </tr> <tr> <td>协程方式</td> <td>🟢 线性同步式</td> <td>🟢 自然</td> <td>🟢 易维护</td> <td>🟢 天然支持</td> </tr> </tbody> </table> <h5 id="342-qt协程ui交互框架实现">3.4.2 Qt协程UI交互框架实现</h5> <p>首先，我们需要定义一个协程框架来处理UI交互：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;coroutine&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;optional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QEventLoop&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QTimer&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QMouseEvent&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QWidget&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QApplication&gt;</span><span class="cp">
</span>
<span class="c1">// 协程任务类型</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Task</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">promise_type</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">value</span><span class="p">{};</span>
        <span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span> <span class="n">exception</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

        <span class="n">Task</span> <span class="nf">get_return_object</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">Task</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;::</span><span class="n">from_promise</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)};</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">suspend_never</span> <span class="n">initial_suspend</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{};</span> <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">suspend_never</span> <span class="n">final_suspend</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{};</span> <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">return_value</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="p">}</span>

        <span class="kt">void</span> <span class="nf">unhandled_exception</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">exception</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">coro</span><span class="p">;</span>

    <span class="n">Task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">promise_type</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="o">:</span> <span class="n">coro</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="p">{}</span>

    <span class="o">~</span><span class="n">Task</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">coro</span><span class="p">)</span> <span class="n">coro</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// 移动语义</span>
    <span class="n">Task</span><span class="p">(</span><span class="n">Task</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">coro</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">coro</span><span class="p">,</span> <span class="p">{}))</span> <span class="p">{}</span>
    <span class="n">Task</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Task</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">coro</span><span class="p">)</span> <span class="n">coro</span><span class="p">.</span><span class="n">destroy</span><span class="p">();</span>
            <span class="n">coro</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">coro</span><span class="p">,</span> <span class="p">{});</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 禁止拷贝</span>
    <span class="n">Task</span><span class="p">(</span><span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">Task</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="n">T</span> <span class="nf">get_result</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">coro</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">rethrow_exception</span><span class="p">(</span><span class="n">coro</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">exception</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">coro</span><span class="p">.</span><span class="n">promise</span><span class="p">().</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 等待用户点击的 awaiter</span>
<span class="k">class</span> <span class="nc">PointAwaiter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QObject</span> <span class="p">{</span>
    <span class="n">Q_OBJECT</span>

<span class="nl">public:</span>
    <span class="n">PointAwaiter</span><span class="p">(</span><span class="n">QWidget</span><span class="o">*</span> <span class="n">widget</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span><span class="o">&amp;</span> <span class="n">hint</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">widget_</span><span class="p">(</span><span class="n">widget</span><span class="p">),</span> <span class="n">hint_</span><span class="p">(</span><span class="n">hint</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">handle_</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
        <span class="n">showHint</span><span class="p">(</span><span class="n">hint_</span><span class="p">);</span>
        <span class="n">installEventFilter</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">QPoint</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">removeEventFilter</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">result_point_</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span> <span class="n">slots</span><span class="o">:</span>
    <span class="kt">void</span> <span class="nf">onTimeout</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">removeEventFilter</span><span class="p">();</span>
        <span class="n">cancelled_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">handle_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">handle_</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">QWidget</span><span class="o">*</span> <span class="n">widget_</span><span class="p">;</span>
    <span class="n">QString</span> <span class="n">hint_</span><span class="p">;</span>
    <span class="n">QPoint</span> <span class="n">result_point_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">handle_</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">cancelled_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">QTimer</span><span class="o">*</span> <span class="n">timeout_timer_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">showHint</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span><span class="o">&amp;</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">widget_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">widget_</span><span class="o">-&gt;</span><span class="n">setToolTip</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
            <span class="n">widget_</span><span class="o">-&gt;</span><span class="n">setStatusTip</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">installEventFilter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">widget_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">widget_</span><span class="o">-&gt;</span><span class="n">installEventFilter</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

            <span class="c1">// 设置超时机制</span>
            <span class="n">timeout_timer_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QTimer</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
            <span class="n">timeout_timer_</span><span class="o">-&gt;</span><span class="n">setSingleShot</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
            <span class="n">connect</span><span class="p">(</span><span class="n">timeout_timer_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QTimer</span><span class="o">::</span><span class="n">timeout</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">PointAwaiter</span><span class="o">::</span><span class="n">onTimeout</span><span class="p">);</span>
            <span class="n">timeout_timer_</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">(</span><span class="mi">30000</span><span class="p">);</span> <span class="c1">// 30秒超时</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">removeEventFilter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">widget_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">widget_</span><span class="o">-&gt;</span><span class="n">removeEventFilter</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">timeout_timer_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">timeout_timer_</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">();</span>
            <span class="n">timeout_timer_</span><span class="o">-&gt;</span><span class="n">deleteLater</span><span class="p">();</span>
            <span class="n">timeout_timer_</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">eventFilter</span><span class="p">(</span><span class="n">QObject</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">QEvent</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">QEvent</span><span class="o">::</span><span class="n">MouseButtonPress</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">QMouseEvent</span><span class="o">*</span> <span class="n">mouseEvent</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">QMouseEvent</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mouseEvent</span><span class="o">-&gt;</span><span class="n">button</span><span class="p">()</span> <span class="o">==</span> <span class="n">Qt</span><span class="o">::</span><span class="n">LeftButton</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">result_point_</span> <span class="o">=</span> <span class="n">mouseEvent</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">();</span>
                <span class="n">removeEventFilter</span><span class="p">();</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">handle_</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">handle_</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 事件已处理</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">QEvent</span><span class="o">::</span><span class="n">KeyPress</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">QKeyEvent</span><span class="o">*</span> <span class="n">keyEvent</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">QKeyEvent</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">keyEvent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">()</span> <span class="o">==</span> <span class="n">Qt</span><span class="o">::</span><span class="n">Key_Escape</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cancelled_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">removeEventFilter</span><span class="p">();</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">handle_</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">handle_</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">QObject</span><span class="o">::</span><span class="n">eventFilter</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 等待按键的 awaiter</span>
<span class="k">class</span> <span class="nc">KeyAwaiter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QObject</span> <span class="p">{</span>
    <span class="n">Q_OBJECT</span>

<span class="nl">public:</span>
    <span class="n">KeyAwaiter</span><span class="p">(</span><span class="n">QWidget</span><span class="o">*</span> <span class="n">widget</span><span class="p">,</span> <span class="k">const</span> <span class="n">QString</span><span class="o">&amp;</span> <span class="n">hint</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">widget_</span><span class="p">(</span><span class="n">widget</span><span class="p">),</span> <span class="n">hint_</span><span class="p">(</span><span class="n">hint</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">handle_</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
        <span class="n">showHint</span><span class="p">(</span><span class="n">hint_</span><span class="p">);</span>
        <span class="n">installEventFilter</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">removeEventFilter</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cancelled_</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"用户取消操作"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result_key_</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">QWidget</span><span class="o">*</span> <span class="n">widget_</span><span class="p">;</span>
    <span class="n">QString</span> <span class="n">hint_</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result_key_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">handle_</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">cancelled_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">showHint</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span><span class="o">&amp;</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">widget_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">widget_</span><span class="o">-&gt;</span><span class="n">setStatusTip</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">installEventFilter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">widget_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">widget_</span><span class="o">-&gt;</span><span class="n">installEventFilter</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">removeEventFilter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">widget_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">widget_</span><span class="o">-&gt;</span><span class="n">removeEventFilter</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">eventFilter</span><span class="p">(</span><span class="n">QObject</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">QEvent</span><span class="o">*</span> <span class="n">event</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">QEvent</span><span class="o">::</span><span class="n">KeyPress</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">QKeyEvent</span><span class="o">*</span> <span class="n">keyEvent</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">QKeyEvent</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
            <span class="n">result_key_</span> <span class="o">=</span> <span class="n">keyEvent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">();</span>
            <span class="n">removeEventFilter</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">handle_</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">handle_</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">QObject</span><span class="o">::</span><span class="n">eventFilter</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">event</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h5 id="343-协程ui交互的实际应用">3.4.3 协程UI交互的实际应用</h5> <p>使用上述框架，我们可以实现非常自然的UI交互逻辑：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 绘制线条的协程函数 - 代码看起来是同步的！</span>
<span class="n">Task</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">drawLineCommand</span><span class="p">(</span><span class="n">QWidget</span><span class="o">*</span> <span class="n">canvas</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="c1">// 获取起点</span>
        <span class="n">QPoint</span> <span class="n">startPoint</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">PointAwaiter</span><span class="p">(</span><span class="n">canvas</span><span class="p">,</span> <span class="s">"请选择起点"</span><span class="p">);</span>

        <span class="c1">// 显示临时标记</span>
        <span class="n">showTemporaryMarker</span><span class="p">(</span><span class="n">startPoint</span><span class="p">);</span>

        <span class="c1">// 获取终点</span>
        <span class="n">QPoint</span> <span class="n">endPoint</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">PointAwaiter</span><span class="p">(</span><span class="n">canvas</span><span class="p">,</span> <span class="s">"请选择终点"</span><span class="p">);</span>

        <span class="c1">// 绘制线条</span>
        <span class="n">drawLine</span><span class="p">(</span><span class="n">startPoint</span><span class="p">,</span> <span class="n">endPoint</span><span class="p">);</span>

        <span class="k">co_return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"绘制线条被取消:"</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
        <span class="k">co_return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 复杂的多步骤交互</span>
<span class="n">Task</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">drawRectangleCommand</span><span class="p">(</span><span class="n">QWidget</span><span class="o">*</span> <span class="n">canvas</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="c1">// 第一个角点</span>
        <span class="n">QPoint</span> <span class="n">corner1</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">PointAwaiter</span><span class="p">(</span><span class="n">canvas</span><span class="p">,</span> <span class="s">"选择矩形第一个角点"</span><span class="p">);</span>

        <span class="c1">// 对角点</span>
        <span class="n">QPoint</span> <span class="n">corner2</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">PointAwaiter</span><span class="p">(</span><span class="n">canvas</span><span class="p">,</span> <span class="s">"选择矩形对角点"</span><span class="p">);</span>

        <span class="c1">// 让用户确认</span>
        <span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">KeyAwaiter</span><span class="p">(</span><span class="n">canvas</span><span class="p">,</span> <span class="s">"按回车确认，按ESC取消"</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">Qt</span><span class="o">::</span><span class="n">Key_Return</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">drawRectangle</span><span class="p">(</span><span class="n">corner1</span><span class="p">,</span> <span class="n">corner2</span><span class="p">);</span>
            <span class="k">co_return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">co_return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 用户取消</span>
        <span class="p">}</span>

    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"绘制矩形被取消:"</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
        <span class="k">co_return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 嵌套命令的例子 - 组合多个协程</span>
<span class="n">Task</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">complexDrawingCommand</span><span class="p">(</span><span class="n">QWidget</span><span class="o">*</span> <span class="n">canvas</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 先画一条线</span>
    <span class="kt">bool</span> <span class="n">lineResult</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">drawLineCommand</span><span class="p">(</span><span class="n">canvas</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lineResult</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">co_return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 再画一个矩形</span>
    <span class="kt">bool</span> <span class="n">rectResult</span> <span class="o">=</span> <span class="k">co_await</span> <span class="nf">drawRectangleCommand</span><span class="p">(</span><span class="n">canvas</span><span class="p">);</span>

    <span class="k">co_return</span> <span class="n">lineResult</span> <span class="o">&amp;&amp;</span> <span class="n">rectResult</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="344-协程任务的启动和管理">3.4.4 协程任务的启动和管理</h5> <p>为了在Qt应用中使用协程，我们需要一个任务调度器：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">CoroutineScheduler</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QObject</span> <span class="p">{</span>
    <span class="n">Q_OBJECT</span>

<span class="nl">public:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">schedule</span><span class="p">(</span><span class="n">Task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 使用QTimer让协程在事件循环中执行</span>
        <span class="n">QTimer</span><span class="o">::</span><span class="n">singleShot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">,</span> <span class="n">task</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">)]()</span> <span class="k">mutable</span> <span class="p">{</span>
            <span class="k">try</span> <span class="p">{</span>
                <span class="c1">// 协程会在需要等待时自动暂停</span>
                <span class="c1">// 当用户操作完成时会自动恢复</span>
                <span class="n">T</span> <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_result</span><span class="p">();</span>
                <span class="n">emit</span> <span class="n">taskCompleted</span><span class="p">(</span><span class="n">QVariant</span><span class="o">::</span><span class="n">fromValue</span><span class="p">(</span><span class="n">result</span><span class="p">));</span>
            <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"协程执行异常:"</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
                <span class="n">emit</span> <span class="n">taskFailed</span><span class="p">(</span><span class="n">QString</span><span class="o">::</span><span class="n">fromStdString</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()));</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">}</span>

<span class="n">signals</span><span class="o">:</span>
    <span class="kt">void</span> <span class="nf">taskCompleted</span><span class="p">(</span><span class="k">const</span> <span class="n">QVariant</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">taskFailed</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">QObject</span><span class="o">&gt;&gt;</span> <span class="n">activeTasks_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 在主窗口中使用</span>
<span class="k">class</span> <span class="nc">MainWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QMainWindow</span> <span class="p">{</span>
    <span class="n">Q_OBJECT</span>

<span class="nl">public:</span>
    <span class="n">MainWindow</span><span class="p">(</span><span class="n">QWidget</span><span class="o">*</span> <span class="n">parent</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="o">:</span> <span class="n">QMainWindow</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">setupUI</span><span class="p">();</span>

        <span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scheduler_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CoroutineScheduler</span><span class="o">::</span><span class="n">taskCompleted</span><span class="p">,</span>
                <span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MainWindow</span><span class="o">::</span><span class="n">onTaskCompleted</span><span class="p">);</span>
        <span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scheduler_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">CoroutineScheduler</span><span class="o">::</span><span class="n">taskFailed</span><span class="p">,</span>
                <span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MainWindow</span><span class="o">::</span><span class="n">onTaskFailed</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">private</span> <span class="n">slots</span><span class="o">:</span>
    <span class="kt">void</span> <span class="nf">onDrawLineClicked</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">scheduler_</span><span class="p">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">drawLineCommand</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">canvas</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">onDrawRectClicked</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">scheduler_</span><span class="p">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">drawRectangleCommand</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">canvas</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">onComplexDrawClicked</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">scheduler_</span><span class="p">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">complexDrawingCommand</span><span class="p">(</span><span class="n">ui</span><span class="o">-&gt;</span><span class="n">canvas</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">onTaskCompleted</span><span class="p">(</span><span class="k">const</span> <span class="n">QVariant</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">statusBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">showMessage</span><span class="p">(</span><span class="s">"操作完成"</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">onTaskFailed</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span><span class="o">&amp;</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">statusBar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">showMessage</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="s">"操作失败: %1"</span><span class="p">).</span><span class="n">arg</span><span class="p">(</span><span class="n">error</span><span class="p">),</span> <span class="mi">5000</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">CoroutineScheduler</span> <span class="n">scheduler_</span><span class="p">;</span>
    <span class="c1">// UI 组件...</span>
<span class="p">};</span>
</code></pre></div></div> <h5 id="345-与传统方式的详细对比">3.4.5 与传统方式的详细对比</h5> <p><strong>1. 代码复杂度对比：</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 传统状态机方式 - 分散的逻辑</span>
<span class="k">class</span> <span class="nc">TraditionalLineDrawer</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="n">State</span> <span class="p">{</span> <span class="n">WaitingStart</span><span class="p">,</span> <span class="n">WaitingEnd</span> <span class="p">};</span>
    <span class="n">State</span> <span class="n">state_</span> <span class="o">=</span> <span class="n">WaitingStart</span><span class="p">;</span>
    <span class="n">QPoint</span> <span class="n">startPoint_</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">onMouseClick</span><span class="p">(</span><span class="n">QPoint</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">state_</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">WaitingStart</span><span class="p">:</span>
                <span class="n">startPoint_</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
                <span class="n">state_</span> <span class="o">=</span> <span class="n">WaitingEnd</span><span class="p">;</span>
                <span class="n">showHint</span><span class="p">(</span><span class="s">"选择终点"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">WaitingEnd</span><span class="p">:</span>
                <span class="n">drawLine</span><span class="p">(</span><span class="n">startPoint_</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
                <span class="n">state_</span> <span class="o">=</span> <span class="n">WaitingStart</span><span class="p">;</span>
                <span class="n">showHint</span><span class="p">(</span><span class="s">"选择起点"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">onKeyPress</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="n">Qt</span><span class="o">::</span><span class="n">Key_Escape</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">state_</span> <span class="o">=</span> <span class="n">WaitingStart</span><span class="p">;</span>
            <span class="n">showHint</span><span class="p">(</span><span class="s">"操作已取消"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// QEventLoop方式 - 需要手动管理循环</span>
<span class="k">class</span> <span class="nc">EventLoopLineDrawer</span> <span class="p">{</span>
    <span class="n">QPoint</span> <span class="n">getPoint</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span><span class="o">&amp;</span> <span class="n">hint</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">QEventLoop</span> <span class="n">loop</span><span class="p">;</span>
        <span class="n">QPoint</span> <span class="n">result</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">got_point</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">auto</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="n">canvas</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Canvas</span><span class="o">::</span><span class="n">clicked</span><span class="p">,</span>
                                <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">QPoint</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                                    <span class="n">result</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
                                    <span class="n">got_point</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                                    <span class="n">loop</span><span class="p">.</span><span class="n">quit</span><span class="p">();</span>
                                <span class="p">});</span>

        <span class="n">showHint</span><span class="p">(</span><span class="n">hint</span><span class="p">);</span>
        <span class="n">loop</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>

        <span class="n">disconnect</span><span class="p">(</span><span class="n">connection</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">drawLine</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">QPoint</span> <span class="n">start</span> <span class="o">=</span> <span class="n">getPoint</span><span class="p">(</span><span class="s">"选择起点"</span><span class="p">);</span>
        <span class="n">QPoint</span> <span class="n">end</span> <span class="o">=</span> <span class="n">getPoint</span><span class="p">(</span><span class="s">"选择终点"</span><span class="p">);</span>
        <span class="n">drawLine</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 协程方式 - 自然的线性逻辑</span>
<span class="n">Task</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">coroutineLineDrawer</span><span class="p">(</span><span class="n">QWidget</span><span class="o">*</span> <span class="n">canvas</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">QPoint</span> <span class="n">start</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">PointAwaiter</span><span class="p">(</span><span class="n">canvas</span><span class="p">,</span> <span class="s">"选择起点"</span><span class="p">);</span>
    <span class="n">QPoint</span> <span class="n">end</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">PointAwaiter</span><span class="p">(</span><span class="n">canvas</span><span class="p">,</span> <span class="s">"选择终点"</span><span class="p">);</span>
    <span class="n">drawLine</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>2. 错误处理对比：</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 协程方式的异常处理更自然</span>
<span class="n">Task</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">robustDrawCommand</span><span class="p">(</span><span class="n">QWidget</span><span class="o">*</span> <span class="n">canvas</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="n">QPoint</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">PointAwaiter</span><span class="p">(</span><span class="n">canvas</span><span class="p">,</span> <span class="s">"选择起点"</span><span class="p">);</span>
        <span class="n">QPoint</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">co_await</span> <span class="n">PointAwaiter</span><span class="p">(</span><span class="n">canvas</span><span class="p">,</span> <span class="s">"选择终点"</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">isValidLine</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">drawLine</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
            <span class="k">co_return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">invalid_argument</span><span class="p">(</span><span class="s">"无效的线条参数"</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">showError</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="s">"操作失败: %1"</span><span class="p">).</span><span class="n">arg</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()));</span>
        <span class="k">co_return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">invalid_argument</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">showWarning</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="s">"参数错误: %1"</span><span class="p">).</span><span class="n">arg</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()));</span>
        <span class="k">co_return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="346-注意事项和最佳实践">3.4.6 注意事项和最佳实践</h5> <p><strong>1. 内存管理：</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 确保协程对象的生命周期管理</span>
<span class="k">class</span> <span class="nc">SafeCoroutineScheduler</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">TaskWrapper</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">TaskWrapper</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">TypedTaskWrapper</span> <span class="o">:</span> <span class="n">TaskWrapper</span> <span class="p">{</span>
        <span class="n">Task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">;</span>
        <span class="n">TypedTaskWrapper</span><span class="p">(</span><span class="n">Task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="n">task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{}</span>
        <span class="kt">void</span> <span class="n">execute</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* 执行逻辑 */</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TaskWrapper</span><span class="o">&gt;&gt;</span> <span class="n">activeTasks_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="nf">schedule</span><span class="p">(</span><span class="n">Task</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">wrapper</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">TypedTaskWrapper</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
        <span class="n">activeTasks_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">wrapper</span><span class="p">));</span>
        <span class="c1">// 任务完成后自动清理</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p><strong>2. 线程安全：</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 确保协程恢复在正确的线程中执行</span>
<span class="kt">void</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">handle_</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>

    <span class="c1">// 使用 QMetaObject::invokeMethod 确保在主线程恢复</span>
    <span class="n">QMetaObject</span><span class="o">::</span><span class="n">invokeMethod</span><span class="p">(</span><span class="n">qApp</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">,</span> <span class="n">handle</span><span class="p">]()</span> <span class="p">{</span>
        <span class="c1">// 设置事件过滤器等操作</span>
        <span class="n">installEventFilter</span><span class="p">();</span>
    <span class="p">},</span> <span class="n">Qt</span><span class="o">::</span><span class="n">QueuedConnection</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>3. 取消机制：</strong></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 支持取消的协程框架</span>
<span class="k">class</span> <span class="nc">CancellableTask</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">cancelled_</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>

<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="nf">cancel</span><span class="p">()</span> <span class="p">{</span> <span class="n">cancelled_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">bool</span> <span class="n">isCancelled</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">cancelled_</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Awaiter</span><span class="p">&gt;</span>
    <span class="k">auto</span> <span class="k">operator</span> <span class="nf">co_await</span><span class="p">(</span><span class="n">Awaiter</span> <span class="n">awaiter</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">CancellableAwaiter</span> <span class="p">{</span>
            <span class="n">Awaiter</span> <span class="n">inner</span><span class="p">;</span>
            <span class="n">CancellableTask</span><span class="o">*</span> <span class="n">task</span><span class="p">;</span>

            <span class="kt">bool</span> <span class="n">await_ready</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">isCancelled</span><span class="p">()</span> <span class="o">||</span> <span class="n">inner</span><span class="p">.</span><span class="n">await_ready</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="kt">void</span> <span class="nf">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">isCancelled</span><span class="p">())</span> <span class="p">{</span>
                    <span class="n">inner</span><span class="p">.</span><span class="n">await_suspend</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">auto</span> <span class="nf">await_resume</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">isCancelled</span><span class="p">())</span> <span class="p">{</span>
                    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"操作被取消"</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">inner</span><span class="p">.</span><span class="n">await_resume</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="k">return</span> <span class="n">CancellableAwaiter</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">awaiter</span><span class="p">),</span> <span class="k">this</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h5 id="347-性能和兼容性考虑">3.4.7 性能和兼容性考虑</h5> <p><strong>编译要求：</strong></p> <ul> <li>需要C++20支持的编译器（GCC 10+, Clang 11+, MSVC 2019 16.8+）</li> <li>CMake中需要设置：<code class="language-plaintext highlighter-rouge">set(CMAKE_CXX_STANDARD 20)</code> </li> </ul> <p><strong>性能特点：</strong></p> <ul> <li>协程的内存开销通常比线程小得多</li> <li>切换开销比线程上下文切换低</li> <li>但比直接的状态机略有开销</li> </ul> <p><strong>适用场景：</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>✅ 复杂的多步骤用户交互
✅ 需要频繁嵌套的操作流程
✅ 对代码可读性要求高的项目
✅ 团队熟悉现代C++特性

❌ 简单的单步交互（过度设计）
❌ 对C++20支持有限制的项目
❌ 性能要求极其苛刻的场景
</code></pre></div></div> <p>协程方式为Qt UI交互提供了一种现代化、高效且易于维护的解决方案，特别适合需要复杂用户输入流程的应用场景。通过合理的设计和实现，可以显著提高代码的可读性、可维护性和开发效率。</p> <p>#include “ui_interaction.moc” // 包含MOC生成的文件</p> <h3 id="4-qt-事件循环源码分析">4. Qt 事件循环源码分析</h3> <p>下面深入剖析 Qt 事件循环的源码。在事件循环处理事件前，事件通过 <code class="language-plaintext highlighter-rouge">sendEvent</code> 或 <code class="language-plaintext highlighter-rouge">postEvent</code> 进行派发，前者使事件立即执行，后者将事件先插入队列，再由事件循环取出执行，接下来着重阐述事件循环获取并发送队列中事件的运转过程。</p> <p>在 Qt GUI 应用程序入口 <code class="language-plaintext highlighter-rouge">main</code> 函数中，能看到应用启动与事件循环引入过程：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">a</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="n">MainWindow</span> <span class="n">w</span><span class="p">;</span>
    <span class="n">w</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>实例化 <code class="language-plaintext highlighter-rouge">QApplication</code> 为程序设置基本环境与参数，创建并显示主窗口后，调用 <code class="language-plaintext highlighter-rouge">a.exec()</code> 启动事件循环，使程序能响应鼠标点击、按键等事件。</p> <ol> <li> <strong><code class="language-plaintext highlighter-rouge">QCoreApplication::exec</code> 函数</strong>：</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">QCoreApplication</span><span class="o">::</span><span class="n">exec</span><span class="p">()</span>
<span class="p">{</span>
   <span class="p">...</span>
    <span class="n">threadData</span><span class="o">-&gt;</span><span class="n">quitNow</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">QEventLoop</span> <span class="n">eventLoop</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">d_func</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">in_exec</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">self</span><span class="o">-&gt;</span><span class="n">d_func</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">aboutToQuitEmitted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">returnCode</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
   <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <p>此函数创建并启动 <code class="language-plaintext highlighter-rouge">QEventLoop</code> 对象，通过调用其 <code class="language-plaintext highlighter-rouge">exec</code> 方法运行事件循环，该循环负责管理事件队列与处理事件。</p> <ol> <li> <strong><code class="language-plaintext highlighter-rouge">QEventLoop::exec</code> 函数</strong>：</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">QEventLoop</span><span class="o">::</span><span class="n">exec</span><span class="p">(</span><span class="n">ProcessEventsFlags</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">exit</span><span class="p">.</span><span class="n">loadAcquire</span><span class="p">())</span>
        <span class="n">processEvents</span><span class="p">(</span><span class="n">flags</span> <span class="o">|</span> <span class="n">WaitForMoreEvents</span> <span class="o">|</span> <span class="n">EventLoopExec</span><span class="p">);</span>
    <span class="n">ref</span><span class="p">.</span><span class="n">exceptionCaught</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">returnCode</span><span class="p">.</span><span class="n">loadRelaxed</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">QEventLoop::exec</code> 包含循环，持续调用 <code class="language-plaintext highlighter-rouge">processEvents</code> 处理事件。<code class="language-plaintext highlighter-rouge">WaitForMoreEvents</code> 标志表明无新事件时，循环将阻塞等待。</p> <ol> <li> <strong><code class="language-plaintext highlighter-rouge">QCoreApplication::processEvents</code> 函数</strong>：</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">QCoreApplication</span><span class="o">::</span><span class="n">processEvents</span><span class="p">(</span><span class="n">QEventLoop</span><span class="o">::</span><span class="n">ProcessEventsFlags</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ms</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">QThreadData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">QThreadData</span><span class="o">::</span><span class="n">current</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">hasEventDispatcher</span><span class="p">())</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="n">QElapsedTimer</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">start</span><span class="p">.</span><span class="n">start</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">eventDispatcher</span><span class="p">.</span><span class="n">loadRelaxed</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">processEvents</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">QEventLoop</span><span class="o">::</span><span class="n">WaitForMoreEvents</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="p">.</span><span class="n">elapsed</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">ms</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">processEvents</code> 方法调用当前线程的事件调度器 <code class="language-plaintext highlighter-rouge">QAbstractEventDispatcher</code>，不同系统平台有不同实现，以 Windows 平台的 <code class="language-plaintext highlighter-rouge">QEventDispatcherWin32</code> 为例分析。在长时间循环中周期性调用 <code class="language-plaintext highlighter-rouge">processEvents()</code>，可避免界面卡死，且能在不中断操作流程时处理用户输入、动画刷新等。</p> <ol> <li> <strong><code class="language-plaintext highlighter-rouge">QEventDispatcherWin32</code> 的事件处理</strong>：</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">QEventDispatcherWin32</span><span class="o">::</span><span class="n">processEvents</span><span class="p">(</span><span class="n">QEventLoop</span><span class="o">::</span><span class="n">ProcessEventsFlags</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Q_D</span><span class="p">(</span><span class="n">QEventDispatcherWin32</span><span class="p">);</span>
   <span class="p">...</span>
    <span class="c1">// 防止死锁，每次迭代发送已发布事件</span>
    <span class="n">sendPostedEvents</span><span class="p">();</span>
   <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div> <ol> <li> <strong><code class="language-plaintext highlighter-rouge">QEventDispatcherWin32::sendPostedEvents</code></strong>：</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">QEventDispatcherWin32</span><span class="o">::</span><span class="n">sendPostedEvents</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Q_D</span><span class="p">(</span><span class="n">QEventDispatcherWin32</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sendPostedEventsTimerId</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">KillTimer</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">internalHwnd</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">sendPostedEventsTimerId</span><span class="p">);</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">sendPostedEventsTimerId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">d</span><span class="o">-&gt;</span><span class="n">wakeUps</span><span class="p">.</span><span class="n">storeRelaxed</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">QCoreApplicationPrivate</span><span class="o">::</span><span class="n">sendPostedEvents</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">threadData</span><span class="p">.</span><span class="n">loadRelaxed</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div> <p>该部分展示事件调度器处理事件队列，最终调用 <code class="language-plaintext highlighter-rouge">QCoreApplication</code> 的 <code class="language-plaintext highlighter-rouge">sendPostEvents</code> 方法。</p> <ol> <li> <strong><code class="language-plaintext highlighter-rouge">QCoreApplicationPrivate::sendPostedEvents</code>：事件发送逻辑</strong>：</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">QCoreApplicationPrivate</span><span class="o">::</span><span class="n">sendPostedEvents</span><span class="p">(</span><span class="n">QObject</span> <span class="o">*</span><span class="n">receiver</span><span class="p">,</span> <span class="kt">int</span> <span class="n">event_type</span><span class="p">,</span>
                                               <span class="n">QThreadData</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">receiver</span> <span class="o">&amp;&amp;</span> <span class="n">receiver</span><span class="o">-&gt;</span><span class="n">d_func</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">threadData</span> <span class="o">!=</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">qWarning</span><span class="p">(</span><span class="s">"QCoreApplication::sendPostedEvents: Cannot send "</span>
                 <span class="s">"posted events for objects in another thread"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
   <span class="p">...</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">postEventList</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="p">...</span>
        <span class="n">QEvent</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">pe</span><span class="p">.</span><span class="n">event</span><span class="p">;</span>
        <span class="n">QObject</span> <span class="o">*</span> <span class="n">r</span> <span class="o">=</span> <span class="n">pe</span><span class="p">.</span><span class="n">receiver</span><span class="p">;</span>
      <span class="p">...</span>
        <span class="n">QCoreApplication</span><span class="o">::</span><span class="n">sendEvent</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
      <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>代码先检查线程，确保事件在所属线程发送，然后遍历事件列表，调用 <code class="language-plaintext highlighter-rouge">sendEvent</code> 方法将事件发送给目标对象。</p> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-什么是-qapp">1. 什么是 <code class="language-plaintext highlighter-rouge">qApp</code>？</h4> <p>在 Qt 应用中，<code class="language-plaintext highlighter-rouge">qApp</code> 作为全局 “事件中枢”，扮演着举足轻重的角色。它负责接收来自操作系统的事件，并对 Qt 内部所有事件的分发、循环、退出以及信号槽的运行等进行调度管理。<code class="language-plaintext highlighter-rouge">qApp</code> 是 Qt 提供的宏，用于指代当前应用程序的全局实例，具体定义为：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define qApp (static_cast&lt;QCoreApplication *&gt;(QCoreApplication::instance()))
</span></code></pre></div></div> <p>通过 <code class="language-plaintext highlighter-rouge">QCoreApplication::instance()</code> 获取当前正在运行的 <code class="language-plaintext highlighter-rouge">QCoreApplication</code> 对象实例，再经 <code class="language-plaintext highlighter-rouge">static_cast&lt;QCoreApplication *&gt;()</code> 转换为 <code class="language-plaintext highlighter-rouge">QCoreApplication</code> 类型指针，从而为开发者提供了在程序各处便捷访问全局 <code class="language-plaintext highlighter-rouge">QApplication</code> 或 <code class="language-plaintext highlighter-rouge">QCoreApplication</code> 对象的途径。</p> <p><code class="language-plaintext highlighter-rouge">qApp</code> 犹如应用程序的大脑与心脏，不仅承接操作系统的事件输入，还主宰着调度、分发、事件循环、定时器管理、信号槽机制等全局行为。在实际开发中，<code class="language-plaintext highlighter-rouge">qApp</code> 具有诸多常见使用场景：</p> <ul> <li> <strong>访问应用全局状态</strong>：如需设置全局字体、语言或路径等应用全局状态信息，可借助 <code class="language-plaintext highlighter-rouge">qApp</code> 完成。例如设置全局字体为宋体：</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">QFont</span> <span class="nf">font</span><span class="p">(</span><span class="s">"宋体"</span><span class="p">);</span>
<span class="n">qApp</span><span class="o">-&gt;</span><span class="n">setFont</span><span class="p">(</span><span class="n">font</span><span class="p">);</span>
</code></pre></div></div> <ul> <li> <strong>捕获所有控件的事件</strong>：在事件过滤器中，通过 <code class="language-plaintext highlighter-rouge">qApp</code> 能够捕获所有控件的事件。假设存在全局事件过滤器类 <code class="language-plaintext highlighter-rouge">GlobalEventFilter</code>，操作如下：</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GlobalEventFilter</span> <span class="n">filter</span><span class="p">;</span>
<span class="n">qApp</span><span class="o">-&gt;</span><span class="n">installEventFilter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">filter</span><span class="p">);</span>
</code></pre></div></div> <p>如此，在 <code class="language-plaintext highlighter-rouge">GlobalEventFilter</code> 类的 <code class="language-plaintext highlighter-rouge">eventFilter</code> 函数中，便可处理应用中所有控件的事件。</p> <ul> <li> <strong>进行跨模块通信</strong>：例如在子模块中，若要退出程序，可调用 <code class="language-plaintext highlighter-rouge">qApp-&gt;quit()</code>。假设在名为 <code class="language-plaintext highlighter-rouge">SubModule</code> 的子模块类中有函数 <code class="language-plaintext highlighter-rouge">exitApp</code>：</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">SubModule</span><span class="o">::</span><span class="n">exitApp</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">qApp</span><span class="o">-&gt;</span><span class="n">quit</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>需注意，在主程序中必须创建 <code class="language-plaintext highlighter-rouge">QApplication</code>（非 GUI 应用则使用 <code class="language-plaintext highlighter-rouge">QCoreApplication</code>），示例代码如下：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">app</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="c1">// 主程序其他代码</span>
    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>此 <code class="language-plaintext highlighter-rouge">app</code> 实例即 <code class="language-plaintext highlighter-rouge">qApp</code> 所指向的对象。</p> <p><code class="language-plaintext highlighter-rouge">qApp</code> 的职责广泛，具体可通过以下类比与实际功能示例说明：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| 类似角色 | 在 Qt 中的名字 | 职责描述 | 功能示例及应用场景 |
| ---- | ---- | ---- | ---- |
| 🧠 大脑 | `QCoreApplication` | 管理事件、线程以及应用程序的生命周期，是应用程序运行的核心 | `qApp-&gt;exec()` 启动应用程序的事件循环，使应用开始接收和处理事件；`qApp-&gt;quit()` 用于关闭应用程序，可在用户点击关闭按钮等场景下调用 |
| 💓 心跳 | `QEventLoop` | 维持事件循环持续运行，确保应用程序能不断接收和处理事件 | `qApp-&gt;processEvents()` 主动处理当前事件队列中的事件，适用于需立即处理事件的场景；`qApp-&gt;hasPendingEvents()` 检查是否有未处理的事件，可在循环中判断 |
| 🕹️ 调度员 | `notify()` | 决定将接收到的事件分发给哪个对象处理 | `qApp-&gt;notify(receiver, event)` 将事件 `event` 分发给指定接收者 `receiver`，自定义事件分发逻辑时可重写此函数 |
| 📬 邮局 | `postEvent()` | 管理事件队列，将事件放入队列等待处理 | `qApp-&gt;postEvent(obj, event)` 将事件 `event` 发送到对象 `obj` 的事件队列，常用于异步处理事件场景，如多线程编程中一个线程向另一个线程的对象发送事件 |
| 📅 日历 | `QTimer` | 提供统一定时机制，定时触发特定事件或任务 | 可通过 `QTimer::singleShot(time, qApp, [](){ /* 定时执行的代码 */ });` 实现单次定时任务，如应用启动后延迟执行操作；也可创建 `QTimer` 对象并连接其 `timeout` 信号到相应槽函数实现周期性任务，如定时更新界面数据 |
| 🧭 导航 | - | 获取当前路径、应用名称等全局信息，方便程序各处使用 | `qApp-&gt;applicationDirPath()` 获取应用程序安装目录路径，适用于读取应用配置文件等场景；`qApp-&gt;applicationName()` 获取应用程序名称，可用于日志记录或显示应用标题 |
| 🧵 线程管家 | `qApp-&gt;thread()` | 代表 GUI 线程，方便管理与 GUI 相关的线程操作 | 在需确保某些操作在 GUI 线程执行的场景下，可通过判断当前线程是否为 `qApp-&gt;thread()` 决定，如更新界面元素必须在 GUI 线程执行 |
</code></pre></div></div> <p>Qt 中所有事件最初由操作系统发出，<code class="language-plaintext highlighter-rouge">qApp</code>（即 <code class="language-plaintext highlighter-rouge">QApplication</code> 实例）负责接收并分发给对应的 Qt 对象（控件、窗口等）。Qt 的事件循环每次仅处理一个事件，处理完一个事件后才取下一个事件。具体特点如下： ✔️ 每个事件按事件队列先进先出的顺序处理。 ✔️ 当前事件必须处理完毕，才会继续处理下一个事件。 ❌ 但并非“阻塞式的同步调用”那种一直等待结果才继续，而是类似任务队列，事件处理函数正常返回即可继续，此时事件进一步的处理可另起线程进行。</p> <h4 id="2-多线程场景下的事件处理问题">2. 多线程场景下的事件处理问题</h4> <p>在 Qt 中，只有主线程（即 GUI 线程）能够对 UI 控件进行操作，原因主要有以下两点：</p> <ol> <li> <p><strong>事件循环的主线程限制</strong>：子线程不能直接调用 UI 控件的方法或访问 UI，否则会产生未定义行为，甚至导致程序崩溃。这是因为 UI 组件的创建与管理均在主线程中完成，其生命周期与主线程紧密相关。若子线程对 UI 组件进行操作，极有可能在 UI 组件尚未完全创建或已被销毁时进行访问，进而引发错误。</p> </li> <li> <p><strong>UI 框架的线程安全性</strong>：Qt 的 UI 框架并非线程安全。若多个线程同时对 UI 组件进行操作，极易引发数据竞争。例如，当两个线程同时试图修改同一个按钮的文本时，按钮的文本内容将处于不可预测状态，严重时会致使程序崩溃。</p> </li> </ol> <p>Qt 的 UI 更新依赖于事件循环，主事件循环运行在主线程，负责处理各类 UI 事件，如绘制、重绘、鼠标点击等。而子线程没有自身的主事件循环，无法正确处理这些 UI 事件。若在子线程中进行 UI 操作，很可能导致 UI 组件无法正确更新或重绘。</p> <p>在 Qt 客户端程序中，子线程不能执行 UI 操作，可通过信号/槽机制（<code class="language-plaintext highlighter-rouge">Qt::QueuedConnection</code>）或使用 <code class="language-plaintext highlighter-rouge">QMetaObject::invokeMethod</code> 实现子线程与主线程的通信，从而安全地更新 UI。以下是示例代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;QApplication&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QWidget&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QLabel&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QVBoxLayout&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QThread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;QMetaObject&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">WorkerThread</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QThread</span> <span class="p">{</span>
    <span class="n">Q_OBJECT</span>
<span class="nl">signals:</span>
    <span class="kt">void</span> <span class="n">updateSignal</span><span class="p">(</span><span class="k">const</span> <span class="n">QString</span><span class="o">&amp;</span><span class="p">);</span>

<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">run</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">QThread</span><span class="o">::</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="n">emit</span> <span class="n">updateSignal</span><span class="p">(</span><span class="s">"Updated from thread"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MainWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span> <span class="p">{</span>
    <span class="n">Q_OBJECT</span>

<span class="nl">public:</span>
    <span class="n">MainWindow</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">QLabel</span><span class="o">*</span> <span class="n">label</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QLabel</span><span class="p">(</span><span class="s">"Initial text"</span><span class="p">);</span>
        <span class="n">QVBoxLayout</span><span class="o">*</span> <span class="n">layout</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QVBoxLayout</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="n">layout</span><span class="o">-&gt;</span><span class="n">addWidget</span><span class="p">(</span><span class="n">label</span><span class="p">);</span>

        <span class="n">WorkerThread</span><span class="o">*</span> <span class="kr">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WorkerThread</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="n">connect</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">WorkerThread</span><span class="o">::</span><span class="n">updateSignal</span><span class="p">,</span> <span class="p">[</span><span class="n">label</span><span class="p">](</span><span class="k">const</span> <span class="n">QString</span><span class="o">&amp;</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">label</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
        <span class="p">});</span>
        <span class="kr">thread</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">QApplication</span> <span class="n">a</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="n">MainWindow</span> <span class="n">w</span><span class="p">;</span>
    <span class="n">w</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上述示例中，<code class="language-plaintext highlighter-rouge">WorkerThread</code> 子线程通过 <code class="language-plaintext highlighter-rouge">updateSignal</code> 信号将消息发送到主线程，主线程接收到信号后更新 <code class="language-plaintext highlighter-rouge">QLabel</code> 的文本。若直接在子线程中更新 <code class="language-plaintext highlighter-rouge">QLabel</code> 的文本，就会出现问题。</p> <p>总之，为确保程序的稳定性与正确性，UI 操作应在主线程中进行，子线程可借助信号与槽机制或 <code class="language-plaintext highlighter-rouge">QMetaObject::invokeMethod</code> 与主线程通信，由主线程完成 UI 更新。</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/6_internet.md/">（七）内核那些事儿：操作系统对网络包的处理</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/5_fileSystem.md/">（六）内核那些事儿：文件系统</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/4_interaction.md/">（五）内核那些事儿：系统和程序的交互</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_device.md/">（四）内核那些事儿：设备管理与驱动开发</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_signal.md/">（三）内核那些事儿：CPU中断和信号</a> </li> </div> </div> <div class="col-sm-4"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <script src="/assets/js/toc-depth.js"></script> </body> </html>