<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> （七）内核那些事儿：操作系统对网络包的处理 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/toc-custom.css"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/6_internet.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-8"> <div class="post"> <header class="post-header"> <h1 class="post-title">（七）内核那些事儿：操作系统对网络包的处理</h1> <p class="post-meta"> Created on September 15, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/kernel"> <i class="fa-solid fa-hashtag fa-sm"></i> kernel</a>   ·   <a href="/blog/category/os"> <i class="fa-solid fa-tag fa-sm"></i> OS</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="七内核那些事儿操作系统对网络包的处理">（七）内核那些事儿：操作系统对网络包的处理</h2> <p>网络通信是现代计算机系统的核心功能之一。操作系统作为硬件与应用程序之间的桥梁，需要提供完整的网络支持框架，确保数据包能够可靠、高效地在网络中传输。本章将深入探讨操作系统如何处理网络数据包，从硬件层面的信号接收到应用层的数据使用。</p> <h3 id="操作系统网络支持概览">操作系统网络支持概览</h3> <p>操作系统提供了以下主要网络支持：</p> <h4 id="1-网络协议栈tcpip-协议栈"><strong>1. 网络协议栈（TCP/IP 协议栈）</strong></h4> <p>操作系统内核实现了完整的网络协议栈，支持多种网络协议：</p> <ul> <li> <strong>应用层协议</strong>：HTTP/HTTPS、FTP、SMTP、DNS 等</li> <li> <strong>传输层协议</strong>：TCP（可靠传输）、UDP（无连接传输）、SCTP 等</li> <li> <strong>网络层协议</strong>：IP（IPv4/IPv6）、ICMP、IGP、BGP 等路由协议</li> <li> <strong>链路层协议</strong>：Ethernet、WiFi（802.11）、PPP、ARP 等</li> </ul> <p><strong>核心功能包括</strong>：</p> <ul> <li> <strong>数据分段与重组</strong>：处理 MTU 限制，将大数据分割成适合传输的包</li> <li> <strong>校验与纠错</strong>：确保数据传输的完整性和正确性</li> <li> <strong>路由决策</strong>：根据目标地址选择最优传输路径</li> <li> <strong>拥塞控制</strong>：TCP 的拥塞窗口管理，避免网络过载</li> <li> <strong>流量控制</strong>：接收方向发送方反馈接收能力</li> </ul> <h4 id="2-socket-编程接口"><strong>2. Socket 编程接口</strong></h4> <p>操作系统提供了标准化的网络编程接口（BSD Socket API），应用程序通过统一的函数调用使用网络：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 典型的 TCP 服务器端编程流程</span>
<span class="kt">int</span> <span class="n">server_fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>        <span class="c1">// 创建 socket</span>
<span class="n">bind</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">server_addr</span><span class="p">));</span>     <span class="c1">// 绑定地址和端口</span>
<span class="n">listen</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="n">SOMAXCONN</span><span class="p">);</span>                           <span class="c1">// 监听连接</span>
<span class="kt">int</span> <span class="n">client_fd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">client_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>   <span class="c1">// 接受连接</span>
<span class="kt">ssize_t</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">client_fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// 接收数据</span>
<span class="n">send</span><span class="p">(</span><span class="n">client_fd</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">response</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>         <span class="c1">// 发送数据</span>
<span class="n">close</span><span class="p">(</span><span class="n">client_fd</span><span class="p">);</span>                                       <span class="c1">// 关闭连接</span>
</code></pre></div></div> <p><strong>关键系统调用</strong>：</p> <ul> <li> <strong>socket()</strong>：创建通信端点</li> <li> <strong>bind()</strong>：将 socket 绑定到特定地址</li> <li> <strong>listen()/accept()</strong>：服务器端监听和接受连接</li> <li> <strong>connect()</strong>：客户端发起连接</li> <li> <strong>send()/recv()</strong> 或 <strong>sendto()/recvfrom()</strong>：数据传输</li> <li> <strong>close()</strong>：关闭连接</li> </ul> <h4 id="3-中断管理与驱动支持"><strong>3. 中断管理与驱动支持</strong></h4> <p><strong>网卡中断处理机制</strong>：</p> <ul> <li> <strong>硬件中断</strong>：网卡接收到数据包后，通过中断线通知 CPU</li> <li> <strong>中断处理程序</strong>：驱动程序注册的中断服务例程（ISR）</li> <li> <strong>软中断</strong>：将网络包处理推迟到软中断上下文，避免长时间占用硬件中断</li> </ul> <p><strong>现代优化技术</strong>：</p> <ul> <li> <strong>NAPI（New API）</strong>：轮询与中断结合，高负载时使用轮询减少中断开销</li> <li> <strong>中断合并</strong>：将多个中断合并为一个，减少 CPU 开销</li> <li> <strong>多队列网卡</strong>：每个 CPU 核心对应一个接收队列，提高并行处理能力</li> </ul> <h4 id="4-数据缓冲与内存管理"><strong>4. 数据缓冲与内存管理</strong></h4> <p>操作系统维护多种缓冲区以优化网络性能：</p> <ul> <li> <strong>接收缓冲区（RX Buffer）</strong>：存储从网卡接收的数据包</li> <li> <strong>发送缓冲区（TX Buffer）</strong>：缓存待发送的数据包</li> <li> <strong>Socket 缓冲区</strong>：应用层和内核层之间的数据缓冲</li> <li> <strong>重组缓冲区</strong>：用于 IP 分片重组的临时内存</li> </ul> <p><strong>内存管理策略</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Linux 内核中的 sk_buff 结构（简化版）</span>
<span class="k">struct</span> <span class="n">sk_buff</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>     <span class="c1">// 链表指针</span>
    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>          <span class="c1">// 关联的网络设备</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>      <span class="c1">// 数据指针</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tail</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>       <span class="c1">// 缓冲区边界</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">data_len</span><span class="p">;</span>      <span class="c1">// 数据长度</span>
    <span class="c1">// ...更多字段</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="5-路由与防火墙"><strong>5. 路由与防火墙</strong></h4> <p><strong>路由子系统</strong>：</p> <ul> <li> <strong>路由表</strong>：存储网络拓扑信息和最优路径</li> <li> <strong>路由缓存</strong>：缓存最近使用的路由决策，提高查找速度</li> <li> <strong>策略路由</strong>：基于源地址、服务类型等进行路由决策</li> </ul> <p><strong>防火墙与包过滤</strong>：</p> <ul> <li> <strong>Netfilter 框架</strong>：Linux 内核的包过滤框架</li> <li> <strong>iptables/nftables</strong>：用户空间的防火墙配置工具</li> <li> <strong>连接跟踪</strong>：跟踪网络连接状态，支持状态防火墙</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># iptables 规则示例</span>
iptables <span class="nt">-A</span> INPUT <span class="nt">-p</span> tcp <span class="nt">--dport</span> 80 <span class="nt">-j</span> ACCEPT    <span class="c"># 允许 HTTP 流量</span>
iptables <span class="nt">-A</span> INPUT <span class="nt">-p</span> tcp <span class="nt">--dport</span> 22 <span class="nt">-s</span> 192.168.1.0/24 <span class="nt">-j</span> ACCEPT  <span class="c"># 限制 SSH 访问</span>
</code></pre></div></div> <h4 id="6-多路复用与事件通知机制"><strong>6. 多路复用与事件通知机制</strong></h4> <p>为了支持高并发网络应用，操作系统提供了多种 I/O 多路复用机制：</p> <p><strong>select() 系统调用</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fd_set</span> <span class="n">readfds</span><span class="p">,</span> <span class="n">writefds</span><span class="p">;</span>
<span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span>
<span class="n">FD_SET</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ready</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">sockfd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">readfds</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">writefds</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timeout</span><span class="p">);</span>
</code></pre></div></div> <p><strong>poll() 系统调用</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">pollfd</span> <span class="n">fds</span><span class="p">[</span><span class="n">MAX_CLIENTS</span><span class="p">];</span>
<span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">server_fd</span><span class="p">;</span>
<span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ready</span> <span class="o">=</span> <span class="n">poll</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre></div></div> <p><strong>epoll() 系统调用（Linux 特有）</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">epfd</span> <span class="o">=</span> <span class="n">epoll_create1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ev</span><span class="p">,</span> <span class="n">events</span><span class="p">[</span><span class="n">MAX_EVENTS</span><span class="p">];</span>
<span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
<span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">sockfd</span><span class="p">;</span>
<span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">nfds</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epfd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">MAX_EVENTS</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
</code></pre></div></div> <p><strong>性能对比</strong>：</p> <ul> <li> <strong>select/poll</strong>：O(n) 时间复杂度，适合少量连接</li> <li> <strong>epoll</strong>：O(1) 时间复杂度，适合大量连接（C10K 问题的解决方案）</li> </ul> <hr> <h2 id="1-数据包从网卡进来之后的流程">1. 数据包从网卡进来之后的流程</h2> <p>我们以 Linux 为例，从硬件到应用层描述数据包进入的完整路径：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[物理介质] -&gt; [网卡硬件] -&gt; [网卡驱动] -&gt; [内核协议栈] -&gt; [Socket缓冲区] -&gt; [用户进程]
</code></pre></div></div> <h3 id="详细处理流程"> <strong>详细处理流程</strong>：</h3> <h4 id="第一阶段硬件层面的数据接收"><strong>第一阶段：硬件层面的数据接收</strong></h4> <ol> <li> <p><strong>物理信号转换</strong></p> <ul> <li>网线/无线电波携带的模拟信号到达网卡</li> <li>网卡的 PHY 芯片将模拟信号转换为数字信号</li> <li>MAC 控制器从数字信号中提取以太网帧</li> </ul> </li> <li> <p><strong>硬件过滤与校验</strong></p> <ul> <li> <strong>MAC 地址过滤</strong>：检查目标 MAC 地址是否匹配</li> <li> <strong>CRC 校验</strong>：验证帧完整性，丢弃错误帧</li> <li> <strong>VLAN 标签处理</strong>：解析 VLAN 信息（如果存在）</li> </ul> </li> </ol> <h4 id="第二阶段中断与驱动处理"><strong>第二阶段：中断与驱动处理</strong></h4> <ol> <li> <p><strong>中断触发机制</strong></p> <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// 网卡驱动中断处理函数示例</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ethernet_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">private_data</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">netdev_priv</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

    <span class="c1">// 禁用网卡中断，避免中断风暴</span>
    <span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

    <span class="c1">// 调度软中断进行数据包处理</span>
    <span class="n">napi_schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">napi</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><strong>NAPI 轮询处理</strong></p> <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// NAPI 轮询函数示例</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ethernet_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">napi_struct</span> <span class="o">*</span><span class="n">napi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">budget</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">private_data</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">napi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">private_data</span><span class="p">,</span> <span class="n">napi</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">work_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span> <span class="o">=</span> <span class="n">receive_packet</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="c1">// 将数据包传递给协议栈</span>
        <span class="n">netif_receive_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="n">work_done</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">work_done</span> <span class="o">&lt;</span> <span class="n">budget</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 处理完所有包，重新启用中断</span>
        <span class="n">napi_complete</span><span class="p">(</span><span class="n">napi</span><span class="p">);</span>
        <span class="n">enable_irq</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">work_done</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> </ol> <h4 id="第三阶段内核协议栈处理"><strong>第三阶段：内核协议栈处理</strong></h4> <ol> <li> <p><strong>链路层处理（L2）</strong></p> <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// 以太网帧处理</span>
<span class="kt">int</span> <span class="nf">eth_type_trans</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">eth</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

    <span class="c1">// 移除以太网头部</span>
    <span class="n">skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">ETH_HLEN</span><span class="p">);</span>

    <span class="c1">// 根据 EtherType 确定上层协议</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">eth</span><span class="o">-&gt;</span><span class="n">h_proto</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">ETH_P_IP</span><span class="p">:</span>   <span class="k">return</span> <span class="n">ETH_P_IP</span><span class="p">;</span>      <span class="c1">// IPv4</span>
        <span class="k">case</span> <span class="n">ETH_P_IPV6</span><span class="p">:</span> <span class="k">return</span> <span class="n">ETH_P_IPV6</span><span class="p">;</span>    <span class="c1">// IPv6</span>
        <span class="k">case</span> <span class="n">ETH_P_ARP</span><span class="p">:</span>  <span class="k">return</span> <span class="n">ETH_P_ARP</span><span class="p">;</span>     <span class="c1">// ARP</span>
        <span class="nl">default:</span>         <span class="k">return</span> <span class="n">ETH_P_802_3</span><span class="p">;</span>   <span class="c1">// 其他</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><strong>网络层处理（L3 - IP）</strong></p> <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// IP 包处理流程</span>
<span class="kt">int</span> <span class="nf">ip_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
           <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">orig_dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

    <span class="c1">// IP 头部校验</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">!=</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">ip_fast_csum</span><span class="p">((</span><span class="n">u8</span><span class="o">*</span><span class="p">)</span><span class="n">iph</span><span class="p">,</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

    <span class="c1">// TTL 检查</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">ttl</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

    <span class="c1">// 路由决策</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ip_route_input</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">,</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">,</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">tos</span><span class="p">,</span> <span class="n">dev</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>

    <span class="c1">// 分片重组（如果需要）</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">frag_off</span> <span class="o">&amp;</span> <span class="n">htons</span><span class="p">(</span><span class="n">IP_MF</span> <span class="o">|</span> <span class="n">IP_OFFSET</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">skb</span> <span class="o">=</span> <span class="n">ip_defrag</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">IP_DEFRAG_LOCAL_DELIVER</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 传递给传输层</span>
    <span class="k">return</span> <span class="n">ip_local_deliver</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

<span class="nl">drop:</span>
    <span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><strong>传输层处理（L4 - TCP/UDP）</strong></p> <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// TCP 包处理</span>
<span class="kt">int</span> <span class="nf">tcp_v4_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">th</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

    <span class="c1">// 查找对应的 socket</span>
    <span class="n">sk</span> <span class="o">=</span> <span class="n">__inet_lookup_skb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcp_hashinfo</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">,</span> <span class="n">th</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">no_tcp_socket</span><span class="p">;</span>

    <span class="c1">// 检查 socket 状态</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">==</span> <span class="n">TCP_TIME_WAIT</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">do_time_wait</span><span class="p">;</span>

    <span class="c1">// 将数据包添加到 socket 接收队列</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tcp_prequeue</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">discard_and_relse</span><span class="p">;</span>

    <span class="c1">// 处理 TCP 状态机</span>
    <span class="n">tcp_v4_do_rcv</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">no_tcp_socket:</span>
    <span class="c1">// 发送 RST 包</span>
    <span class="n">tcp_v4_send_reset</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
    <span class="k">goto</span> <span class="n">discard_it</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> </ol> <h4 id="第四阶段socket-层与应用层交互"><strong>第四阶段：Socket 层与应用层交互</strong></h4> <ol> <li> <p><strong>Socket 缓冲区管理</strong></p> <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// 将数据添加到 socket 接收队列</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">tcp_queue_rcv</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hdrlen</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 检查接收缓冲区是否有空间</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rcvbuf</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 将数据包链接到接收队列</span>
    <span class="n">__skb_queue_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_receive_queue</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_rmem_alloc</span> <span class="o">+=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">truesize</span><span class="p">;</span>

    <span class="c1">// 唤醒等待数据的进程</span>
    <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_data_ready</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><strong>唤醒阻塞进程</strong></p> <div class="language-c highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// 数据就绪回调函数</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sock_def_readable</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sk_has_sleeper</span><span class="p">(</span><span class="n">sk</span><span class="p">))</span>
        <span class="n">wake_up_interruptible_sync_poll</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_sleep</span><span class="p">,</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">);</span>
    <span class="n">sk_wake_async</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">SOCK_WAKE_WAITD</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>
    <span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_callback_lock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><strong>用户空间数据读取</strong></p> </li> </ol> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 用户程序通过 recv() 系统调用读取数据</span>
<span class="kt">ssize_t</span> <span class="nf">sock_recvmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">addr_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

    <span class="c1">// 从 socket 接收队列复制数据到用户缓冲区</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">recvmsg</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr_len</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">msg</span><span class="o">-&gt;</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="n">addr_len</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="完整流程图"> <strong>完整流程图</strong>：</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────┐
│   物理介质      │ ← 电信号/光信号/无线电波
│ (网线/无线)     │
└────────┬────────┘
         ↓ 物理层转换
┌─────────────────┐
│   网卡硬件      │ ← PHY芯片，MAC控制器
│ (NIC Hardware)  │
└────────┬────────┘
         ↓ 硬件中断/DMA
┌─────────────────┐
│  网卡驱动程序   │ ← 中断处理，NAPI轮询
│ (NIC Driver)    │
└────────┬────────┘
         ↓ netif_receive_skb()
┌─────────────────┐
│  内核协议栈     │ ← 分层处理: L2→L3→L4
│   链路层(L2)    │   (Ethernet → IP → TCP/UDP)
│   网络层(L3)    │
│   传输层(L4)    │
└────────┬────────┘
         ↓ Socket匹配
┌─────────────────┐
│  Socket缓冲区   │ ← sk_receive_queue
│ (Socket Buffer) │
└────────┬────────┘
         ↓ 系统调用 (recv/read)
┌─────────────────┐
│  用户进程代码   │ ← 应用程序处理数据
│ (User Process)  │
└─────────────────┘
</code></pre></div></div> <hr> <h2 id="2-发送数据包的流程反向过程">2. 发送数据包的流程（反向过程）</h2> <p>了解接收流程后，我们来看看数据包是如何从应用程序发送到网络的：</p> <h3 id="发送流程概览"> <strong>发送流程概览</strong>：</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[用户进程] -&gt; [系统调用] -&gt; [Socket层] -&gt; [协议栈] -&gt; [网卡驱动] -&gt; [网卡硬件] -&gt; [物理介质]
</code></pre></div></div> <h4 id="应用层发送数据"><strong>应用层发送数据</strong></h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 用户程序发送数据</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">message</span> <span class="o">=</span> <span class="s">"Hello, Network!"</span><span class="p">;</span>
<span class="kt">ssize_t</span> <span class="n">sent</span> <span class="o">=</span> <span class="n">send</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">message</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div> <h4 id="系统调用处理"><strong>系统调用处理</strong></h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// sys_sendto 系统调用</span>
<span class="n">SYSCALL_DEFINE6</span><span class="p">(</span><span class="n">sendto</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
                <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
                <span class="kt">int</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">address</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

    <span class="c1">// 获取 socket 对象</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

    <span class="c1">// 调用协议族的发送函数</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">sock_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

    <span class="n">sockfd_put_light</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
<span class="nl">out:</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="tcp-协议层处理"><strong>TCP 协议层处理</strong></h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// TCP 发送处理</span>
<span class="kt">int</span> <span class="nf">tcp_sendmsg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">tcp_sock</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="n">tcp_sk</span><span class="p">(</span><span class="n">sk</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

    <span class="c1">// 检查连接状态</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_state</span> <span class="o">!=</span> <span class="n">TCP_ESTABLISHED</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EPIPE</span><span class="p">;</span>

    <span class="c1">// 分配 sk_buff</span>
    <span class="n">skb</span> <span class="o">=</span> <span class="n">sk_stream_alloc_skb</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">select_size</span><span class="p">(</span><span class="n">sk</span><span class="p">),</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_allocation</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skb</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

    <span class="c1">// 复制用户数据到内核缓冲区</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">skb_add_data</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">__kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 添加到发送队列</span>
    <span class="n">tcp_push</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">mss_now</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">nonagle</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="ip-层路由与封装"><strong>IP 层路由与封装</strong></h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// IP 层发送</span>
<span class="kt">int</span> <span class="nf">ip_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flowi</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">sk</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rtable</span> <span class="o">*</span><span class="n">rt</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span><span class="p">;</span>

    <span class="c1">// 路由查找</span>
    <span class="n">rt</span> <span class="o">=</span> <span class="n">ip_route_output_flow</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">rt</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">no_route</span><span class="p">;</span>

    <span class="c1">// 构建 IP 头部</span>
    <span class="n">skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="p">));</span>
    <span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">tos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">tot_len</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ip_ident</span><span class="o">++</span><span class="p">);</span>
    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">frag_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ttl</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">IPPROTO_TCP</span><span class="p">;</span>
    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl4_src</span><span class="p">;</span>
    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl4_dst</span><span class="p">;</span>
    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">iph</span><span class="o">-&gt;</span><span class="n">check</span> <span class="o">=</span> <span class="n">ip_fast_csum</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">iph</span><span class="p">,</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">);</span>

    <span class="c1">// 传递给网络设备层</span>
    <span class="k">return</span> <span class="n">dst_output</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="网络设备层处理"><strong>网络设备层处理</strong></h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 网络设备发送</span>
<span class="kt">int</span> <span class="nf">dev_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">netdev_queue</span> <span class="o">*</span><span class="n">txq</span><span class="p">;</span>

    <span class="c1">// 选择发送队列</span>
    <span class="n">txq</span> <span class="o">=</span> <span class="n">netdev_pick_tx</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>

    <span class="c1">// 检查设备状态</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IFF_UP</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">kfree_skb</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENETDOWN</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 调用驱动程序发送函数</span>
    <span class="k">return</span> <span class="n">dev_hard_start_xmit</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">txq</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <hr> <h2 id="3-高级特性与性能优化">3. 高级特性与性能优化</h2> <h3 id="零拷贝zero-copy技术"><strong>零拷贝（Zero-Copy）技术</strong></h3> <p>传统的网络 I/O 需要多次数据拷贝，零拷贝技术减少了不必要的拷贝操作：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// sendfile() 系统调用 - 直接在内核空间传输文件</span>
<span class="kt">ssize_t</span> <span class="nf">sendfile</span><span class="p">(</span><span class="kt">int</span> <span class="n">out_fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_fd</span><span class="p">,</span> <span class="kt">off_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>

<span class="c1">// splice() 系统调用 - 在两个文件描述符间传输数据</span>
<span class="kt">ssize_t</span> <span class="nf">splice</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd_in</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off_in</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd_out</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off_out</span><span class="p">,</span>
               <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="c1">// 内存映射 + write</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">mapped</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">file_size</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">write</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">mapped</span><span class="p">,</span> <span class="n">file_size</span><span class="p">);</span>
<span class="n">munmap</span><span class="p">(</span><span class="n">mapped</span><span class="p">,</span> <span class="n">file_size</span><span class="p">);</span>
</code></pre></div></div> <p><strong>性能提升</strong>：</p> <ul> <li>减少 CPU 使用率</li> <li>降低内存带宽占用</li> <li>减少上下文切换</li> <li>适合大文件传输场景</li> </ul> <h3 id="网络包过滤与处理"><strong>网络包过滤与处理</strong></h3> <h4 id="ebpfextended-berkeley-packet-filter"><strong>eBPF（Extended Berkeley Packet Filter）</strong></h4> <p>eBPF 允许在内核空间运行用户定义的程序，实现高性能的包处理：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// eBPF 程序示例：丢弃特定端口的包</span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/bpf.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/if_ether.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/ip.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/tcp.h&gt;</span><span class="cp">
</span>
<span class="n">SEC</span><span class="p">(</span><span class="s">"prog"</span><span class="p">)</span>
<span class="kt">int</span> <span class="nf">packet_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">__sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data_end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">skb</span><span class="o">-&gt;</span><span class="n">data_end</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">eth</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">eth</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">eth</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">data_end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">XDP_PASS</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">eth</span><span class="o">-&gt;</span><span class="n">h_proto</span> <span class="o">!=</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_IP</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">XDP_PASS</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">eth</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">eth</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ip</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">data_end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">XDP_PASS</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">XDP_PASS</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">tcp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ip</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">tcp</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tcp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">data_end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">XDP_PASS</span><span class="p">;</span>

    <span class="c1">// 丢弃目标端口为 8080 的包</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">tcp</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8080</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">XDP_DROP</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">XDP_PASS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="xdpexpress-data-path"><strong>XDP（eXpress Data Path）</strong></h4> <p>XDP 在驱动层直接处理网络包，实现最低延迟的包处理：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// XDP 程序：简单的负载均衡</span>
<span class="n">SEC</span><span class="p">(</span><span class="s">"xdp"</span><span class="p">)</span>
<span class="kt">int</span> <span class="nf">load_balancer</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdp_md</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data_end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">data_end</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">eth</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">eth</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">eth</span><span class="p">);</span>

    <span class="c1">// 边界检查</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ip</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ip</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">data_end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">XDP_PASS</span><span class="p">;</span>

    <span class="c1">// 基于源 IP 的简单哈希负载均衡</span>
    <span class="n">__u32</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">%</span> <span class="mi">4</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">// 转发到服务器 1</span>
            <span class="k">return</span> <span class="n">bpf_redirect_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">// 转发到服务器 2</span>
            <span class="k">return</span> <span class="n">bpf_redirect_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server_map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nl">default:</span>
            <span class="k">return</span> <span class="n">XDP_PASS</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="dpdkdata-plane-development-kit"><strong>DPDK（Data Plane Development Kit）</strong></h3> <p>DPDK 绕过内核，在用户空间直接处理网络包：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// DPDK 应用程序示例</span>
<span class="cp">#include</span> <span class="cpf">&lt;rte_eal.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;rte_ethdev.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;rte_mbuf.h&gt;</span><span class="cp">
</span>
<span class="cp">#define RX_RING_SIZE 1024
#define TX_RING_SIZE 1024
#define NUM_MBUFS 8191
#define MBUF_CACHE_SIZE 250
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">rte_mempool</span> <span class="o">*</span><span class="n">mbuf_pool</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">portid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 初始化 EAL</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">rte_eal_init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">"Error with EAL initialization</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="c1">// 创建内存池</span>
    <span class="n">mbuf_pool</span> <span class="o">=</span> <span class="n">rte_pktmbuf_pool_create</span><span class="p">(</span><span class="s">"MBUF_POOL"</span><span class="p">,</span> <span class="n">NUM_MBUFS</span><span class="p">,</span>
        <span class="n">MBUF_CACHE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">RTE_MBUF_DEFAULT_BUF_SIZE</span><span class="p">,</span> <span class="n">rte_socket_id</span><span class="p">());</span>

    <span class="c1">// 配置网络端口</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">port_init</span><span class="p">(</span><span class="n">portid</span><span class="p">,</span> <span class="n">mbuf_pool</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">rte_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">,</span> <span class="s">"Cannot init port %"</span><span class="n">PRIu16</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">portid</span><span class="p">);</span>

    <span class="c1">// 主循环：接收和处理包</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">rte_mbuf</span> <span class="o">*</span><span class="n">bufs</span><span class="p">[</span><span class="n">BURST_SIZE</span><span class="p">];</span>
        <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">nb_rx</span> <span class="o">=</span> <span class="n">rte_eth_rx_burst</span><span class="p">(</span><span class="n">portid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bufs</span><span class="p">,</span> <span class="n">BURST_SIZE</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nb_rx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// 处理接收到的包</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nb_rx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">process_packet</span><span class="p">(</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="c1">// 发送处理后的包</span>
        <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">nb_tx</span> <span class="o">=</span> <span class="n">rte_eth_tx_burst</span><span class="p">(</span><span class="n">portid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bufs</span><span class="p">,</span> <span class="n">nb_rx</span><span class="p">);</span>

        <span class="c1">// 释放未发送的包</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">nb_tx</span> <span class="o">&lt;</span> <span class="n">nb_rx</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">nb_tx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nb_rx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">rte_pktmbuf_free</span><span class="p">(</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>DPDK 优势</strong>：</p> <ul> <li>绕过内核协议栈，减少上下文切换</li> <li>轮询模式，避免中断开销</li> <li>大页内存，减少 TLB 缺失</li> <li>CPU 亲和性，避免缓存颠簸</li> <li>零拷贝，直接在用户空间处理包</li> </ul> <hr> <h2 id="4-实际应用场景">4. 实际应用场景</h2> <h3 id="高性能-web-服务器"><strong>高性能 Web 服务器</strong></h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用 epoll 的高性能服务器示例</span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/epoll.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="cp">#define MAX_EVENTS 10000
#define BUFFER_SIZE 4096
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">server_fd</span><span class="p">,</span> <span class="n">epoll_fd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ev</span><span class="p">,</span> <span class="n">events</span><span class="p">[</span><span class="n">MAX_EVENTS</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">address</span><span class="p">;</span>

    <span class="c1">// 创建服务器 socket</span>
    <span class="n">server_fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// 设置非阻塞</span>
    <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">fcntl</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>

    <span class="c1">// 绑定地址</span>
    <span class="n">address</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">address</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>
    <span class="n">address</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>
    <span class="n">bind</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">));</span>

    <span class="c1">// 监听连接</span>
    <span class="n">listen</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="n">SOMAXCONN</span><span class="p">);</span>

    <span class="c1">// 创建 epoll 实例</span>
    <span class="n">epoll_fd</span> <span class="o">=</span> <span class="n">epoll_create1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">// 添加服务器 socket 到 epoll</span>
    <span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
    <span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">server_fd</span><span class="p">;</span>
    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">server_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>

    <span class="c1">// 主事件循环</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">nfds</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">MAX_EVENTS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">nfds</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="n">server_fd</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 新连接</span>
                <span class="kt">int</span> <span class="n">client_fd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server_fd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">client_fd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 设置非阻塞</span>
                    <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">fcntl</span><span class="p">(</span><span class="n">client_fd</span><span class="p">,</span> <span class="n">F_GETFL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                    <span class="n">fcntl</span><span class="p">(</span><span class="n">client_fd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>

                    <span class="c1">// 添加到 epoll</span>
                    <span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span> <span class="o">|</span> <span class="n">EPOLLET</span><span class="p">;</span>  <span class="c1">// 边缘触发</span>
                    <span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">client_fd</span><span class="p">;</span>
                    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span> <span class="n">client_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 客户端数据</span>
                <span class="kt">int</span> <span class="n">client_fd</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
                <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>

                <span class="kt">ssize_t</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">client_fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 处理请求并发送响应</span>
                    <span class="n">handle_request</span><span class="p">(</span><span class="n">client_fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">errno</span> <span class="o">!=</span> <span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// 连接关闭或错误</span>
                    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span> <span class="n">EPOLL_CTL_DEL</span><span class="p">,</span> <span class="n">client_fd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
                    <span class="n">close</span><span class="p">(</span><span class="n">client_fd</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="网络监控与分析"><strong>网络监控与分析</strong></h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用原始套接字进行网络监控</span>
<span class="cp">#include</span> <span class="cpf">&lt;netinet/ip.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netinet/tcp.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netinet/if_ether.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sock_fd</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">65536</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">saddr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">saddr_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">saddr</span><span class="p">);</span>

    <span class="c1">// 创建原始套接字</span>
    <span class="n">sock_fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_PACKET</span><span class="p">,</span> <span class="n">SOCK_RAW</span><span class="p">,</span> <span class="n">htons</span><span class="p">(</span><span class="n">ETH_P_ALL</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sock_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"Socket Error"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 接收数据包</span>
        <span class="kt">ssize_t</span> <span class="n">data_size</span> <span class="o">=</span> <span class="n">recvfrom</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">65536</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saddr</span><span class="p">,</span> <span class="p">(</span><span class="n">socklen_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">saddr_len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">perror</span><span class="p">(</span><span class="s">"Recvfrom error"</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 解析以太网头部</span>
        <span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="n">eth</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">ntohs</span><span class="p">(</span><span class="n">eth</span><span class="o">-&gt;</span><span class="n">h_proto</span><span class="p">)</span> <span class="o">==</span> <span class="n">ETH_P_IP</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 解析 IP 头部</span>
            <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="o">*</span><span class="p">)(</span><span class="n">buffer</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span><span class="p">));</span>

            <span class="n">printf</span><span class="p">(</span><span class="s">"IP Packet: %s -&gt; "</span><span class="p">,</span> <span class="n">inet_ntoa</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">));</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">inet_ntoa</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">daddr</span><span class="p">));</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 解析 TCP 头部</span>
                <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">tcph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="o">*</span><span class="p">)(</span><span class="n">buffer</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ethhdr</span><span class="p">)</span> <span class="o">+</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"TCP Packet: Port %d -&gt; %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">tcph</span><span class="o">-&gt;</span><span class="n">source</span><span class="p">),</span> <span class="n">ntohs</span><span class="p">(</span><span class="n">tcph</span><span class="o">-&gt;</span><span class="n">dest</span><span class="p">));</span>

                <span class="c1">// 进行流量统计、异常检测等</span>
                <span class="n">analyze_tcp_packet</span><span class="p">(</span><span class="n">iph</span><span class="p">,</span> <span class="n">tcph</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">close</span><span class="p">(</span><span class="n">sock_fd</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <hr> <h2 id="5-网络安全与防护">5. 网络安全与防护</h2> <h3 id="ddos-防护机制"><strong>DDoS 防护机制</strong></h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 简单的 SYN flood 防护</span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/netfilter.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/netfilter_ipv4.h&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">__u32</span> <span class="n">src_ip</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span> <span class="n">syn_table</span><span class="p">[</span><span class="n">SYN_TABLE_SIZE</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">syn_flood_hook</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
                                   <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">tcph</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>

    <span class="n">tcph</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>

    <span class="c1">// 检查是否为 SYN 包</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tcph</span><span class="o">-&gt;</span><span class="n">syn</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tcph</span><span class="o">-&gt;</span><span class="n">ack</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span> <span class="o">%</span> <span class="n">SYN_TABLE_SIZE</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

        <span class="c1">// 检查频率</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">syn_table</span><span class="p">[</span><span class="n">hash</span><span class="p">].</span><span class="n">src_ip</span> <span class="o">==</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">now</span><span class="p">,</span> <span class="n">syn_table</span><span class="p">[</span><span class="n">hash</span><span class="p">].</span><span class="n">timestamp</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">syn_table</span><span class="p">[</span><span class="n">hash</span><span class="p">].</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>

                <span class="c1">// 超过阈值，丢弃包</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">syn_table</span><span class="p">[</span><span class="n">hash</span><span class="p">].</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">SYN_THRESHOLD</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">"SYN flood detected from %pI4</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">);</span>
                    <span class="k">return</span> <span class="n">NF_DROP</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// 重置计数器</span>
                <span class="n">syn_table</span><span class="p">[</span><span class="n">hash</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">syn_table</span><span class="p">[</span><span class="n">hash</span><span class="p">].</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 新的源 IP</span>
            <span class="n">syn_table</span><span class="p">[</span><span class="n">hash</span><span class="p">].</span><span class="n">src_ip</span> <span class="o">=</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">;</span>
            <span class="n">syn_table</span><span class="p">[</span><span class="n">hash</span><span class="p">].</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">syn_table</span><span class="p">[</span><span class="n">hash</span><span class="p">].</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="流量整形与-qos"><strong>流量整形与 QoS</strong></h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 使用 tc (traffic control) 配置 QoS</span>
<span class="c"># 为网卡 eth0 添加根队列规则</span>
tc qdisc add dev eth0 root handle 1: htb default 30

<span class="c"># 创建主类别</span>
tc class add dev eth0 parent 1: classid 1:1 htb rate 100mbit

<span class="c"># 为 HTTP 流量创建高优先级类别</span>
tc class add dev eth0 parent 1:1 classid 1:10 htb rate 80mbit ceil 100mbit
tc class add dev eth0 parent 1:1 classid 1:20 htb rate 15mbit ceil 100mbit
tc class add dev eth0 parent 1:1 classid 1:30 htb rate 5mbit ceil 100mbit

<span class="c"># 添加过滤器</span>
tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 <span class="se">\</span>
    match ip dport 80 0xffff flowid 1:10

tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 <span class="se">\</span>
    match ip dport 443 0xffff flowid 1:10
</code></pre></div></div> <hr> <h2 id="6-性能监控与调试">6. 性能监控与调试</h2> <h3 id="网络性能监控工具"><strong>网络性能监控工具</strong></h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看网络接口统计信息</span>
<span class="nb">cat</span> /proc/net/dev

<span class="c"># 使用 ss 查看 socket 状态</span>
ss <span class="nt">-tuln</span>  <span class="c"># 查看监听端口</span>
ss <span class="nt">-i</span>     <span class="c"># 显示详细的 socket 信息</span>

<span class="c"># 使用 iftop 监控网络流量</span>
iftop <span class="nt">-i</span> eth0

<span class="c"># 使用 tcpdump 抓包分析</span>
tcpdump <span class="nt">-i</span> eth0 <span class="nt">-w</span> capture.pcap
tcpdump <span class="nt">-r</span> capture.pcap <span class="nt">-A</span>  <span class="c"># 显示 ASCII 内容</span>

<span class="c"># 查看网络连接状态统计</span>
netstat <span class="nt">-s</span>
</code></pre></div></div> <h3 id="内核网络调试"><strong>内核网络调试</strong></h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 启用网络包跟踪</span>
<span class="nb">echo </span>1 <span class="o">&gt;</span> /sys/kernel/debug/tracing/events/net/enable

<span class="c"># 查看网络包处理路径</span>
<span class="nb">cat</span> /sys/kernel/debug/tracing/trace

<span class="c"># 调整网络缓冲区大小</span>
<span class="nb">echo</span> <span class="s1">'net.core.rmem_max = 16777216'</span> <span class="o">&gt;&gt;</span> /etc/sysctl.conf
<span class="nb">echo</span> <span class="s1">'net.core.wmem_max = 16777216'</span> <span class="o">&gt;&gt;</span> /etc/sysctl.conf
sysctl <span class="nt">-p</span>

<span class="c"># 查看 TCP 连接状态</span>
<span class="nb">cat</span> /proc/net/tcp
</code></pre></div></div> <hr> <h2 id="7-总结与最佳实践">7. 总结与最佳实践</h2> <h3 id="关键知识点回顾"><strong>关键知识点回顾</strong></h3> <ol> <li> <p><strong>网络包处理是多层协作的结果</strong></p> <ul> <li>硬件层：物理信号转换和基础过滤</li> <li>驱动层：中断处理和 NAPI 轮询</li> <li>协议栈：分层解析和路由决策</li> <li>Socket层：缓冲管理和进程通信</li> </ul> </li> <li> <p><strong>性能优化技术多样化</strong></p> <ul> <li>零拷贝技术减少数据拷贝开销</li> <li>eBPF/XDP 实现可编程的包处理</li> <li>DPDK 提供用户空间的高性能方案</li> </ul> </li> <li> <p><strong>安全防护不可忽视</strong></p> <ul> <li>DDoS 防护需要在多个层次实施</li> <li>包过滤和防火墙是基础安全措施</li> <li>流量整形有助于服务质量保障</li> </ul> </li> </ol> <h3 id="编程最佳实践"><strong>编程最佳实践</strong></h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 高效的网络编程建议</span>

<span class="c1">// 1. 使用合适的 I/O 多路复用机制</span>
<span class="cp">#ifdef __linux__
</span>    <span class="c1">// Linux 系统优先使用 epoll</span>
    <span class="kt">int</span> <span class="n">epfd</span> <span class="o">=</span> <span class="n">epoll_create1</span><span class="p">(</span><span class="n">EPOLL_CLOEXEC</span><span class="p">);</span>
<span class="cp">#elif defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
</span>    <span class="c1">// BSD 系统使用 kqueue</span>
    <span class="kt">int</span> <span class="n">kq</span> <span class="o">=</span> <span class="n">kqueue</span><span class="p">();</span>
<span class="cp">#else
</span>    <span class="c1">// 其他系统降级到 poll</span>
    <span class="k">struct</span> <span class="n">pollfd</span> <span class="n">fds</span><span class="p">[</span><span class="n">MAX_FDS</span><span class="p">];</span>
<span class="cp">#endif
</span>
<span class="c1">// 2. 正确设置 socket 选项</span>
<span class="kt">int</span> <span class="n">enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enable</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">enable</span><span class="p">));</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enable</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">enable</span><span class="p">));</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="n">TCP_NODELAY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">enable</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">enable</span><span class="p">));</span>

<span class="c1">// 3. 使用适当的缓冲区大小</span>
<span class="kt">int</span> <span class="n">buf_size</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>  <span class="c1">// 1MB</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_RCVBUF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf_size</span><span class="p">));</span>
<span class="n">setsockopt</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_SNDBUF</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf_size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf_size</span><span class="p">));</span>

<span class="c1">// 4. 错误处理要完善</span>
<span class="kt">ssize_t</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EWOULDBLOCK</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 非阻塞 socket，稍后重试</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 真正的错误</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"recv failed"</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 连接已关闭</span>
    <span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="调试与优化指南"><strong>调试与优化指南</strong></h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 网络性能调优检查清单</span>

<span class="c"># 1. 检查网卡驱动和硬件</span>
ethtool eth0                    <span class="c"># 查看网卡状态</span>
ethtool <span class="nt">-S</span> eth0                 <span class="c"># 查看网卡统计信息</span>
ethtool <span class="nt">-k</span> eth0                 <span class="c"># 查看网卡功能</span>

<span class="c"># 2. 系统网络参数优化</span>
<span class="nb">echo</span> <span class="s1">'net.core.netdev_max_backlog = 5000'</span> <span class="o">&gt;&gt;</span> /etc/sysctl.conf
<span class="nb">echo</span> <span class="s1">'net.ipv4.tcp_congestion_control = bbr'</span> <span class="o">&gt;&gt;</span> /etc/sysctl.conf
<span class="nb">echo</span> <span class="s1">'net.ipv4.tcp_window_scaling = 1'</span> <span class="o">&gt;&gt;</span> /etc/sysctl.conf

<span class="c"># 3. 中断和 CPU 亲和性</span>
<span class="nb">cat</span> /proc/interrupts | <span class="nb">grep </span>eth0
<span class="nb">echo </span>2 <span class="o">&gt;</span> /proc/irq/24/smp_affinity  <span class="c"># 将中断绑定到特定 CPU</span>

<span class="c"># 4. 内存和缓存优化</span>
<span class="nb">echo </span>3 <span class="o">&gt;</span> /proc/sys/vm/drop_caches   <span class="c"># 清理缓存</span>
hugeadm <span class="nt">--list-all-mounts</span>          <span class="c"># 检查大页内存</span>
</code></pre></div></div> <p>通过深入理解网络包处理机制，我们能够更好地设计高性能网络应用，充分利用操作系统提供的网络功能，并在需要时进行针对性的优化。网络编程不仅需要掌握 API 的使用，更需要理解底层的工作原理，这样才能写出真正高效、可靠的网络程序。</p> <hr> <blockquote> <p><strong>学习建议</strong>：网络编程涉及多个层次的知识，建议先理解基本的 Socket 编程，再深入学习协议栈原理，最后探索高级优化技术。实践中遇到性能问题时，要学会使用各种监控和调试工具来定位瓶颈。</p> </blockquote> <p><strong>知识体系导航</strong>：</p> <ul> <li>✅ <strong>当前章节</strong>：网络包处理 - 从硬件到应用的完整数据路径</li> <li>🔗 <strong>相关章节</strong>：中断和信号机制、设备管理、系统调用</li> <li>🚀 <strong>后续章节</strong>：进程管理、内存管理等核心机制</li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/5_fileSystem.md/">（六）内核那些事儿：文件系统</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/4_interaction.md/">（五）内核那些事儿：系统和程序的交互</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_device.md/">（四）内核那些事儿：设备管理与驱动开发</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_signal.md/">（三）内核那些事儿：CPU中断和信号</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/1_program.md/">（二）内核那些事儿：程序启动到运行的完整过程</a> </li> </div> </div> <div class="col-sm-4"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <script src="/assets/js/toc-depth.js"></script> </body> </html>