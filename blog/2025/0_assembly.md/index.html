<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> （一）汇编：汇编基础 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/toc-custom.css"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/0_assembly.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-8"> <div class="post"> <header class="post-header"> <h1 class="post-title">（一）汇编：汇编基础</h1> <p class="post-meta"> Created on September 15, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/%E6%B1%87%E7%BC%96"> <i class="fa-solid fa-hashtag fa-sm"></i> 汇编</a>   ·   <a href="/blog/category/%E6%B1%87%E7%BC%96"> <i class="fa-solid fa-tag fa-sm"></i> 汇编</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="汇编语言基础">汇编语言基础</h2> <h3 id="1-概念与分类">1. 概念与分类</h3> <h4 id="11-什么是汇编语言">1.1 什么是汇编语言？</h4> <p>汇编语言是一种低级编程语言，它通过助记符（mnemonics）直接表示处理器指令集的机器码操作。与高级语言不同，汇编语言与硬件架构紧密关联，每条汇编指令通常映射为一条特定处理器架构的机器指令。</p> <p><strong>核心特征</strong>：</p> <ol> <li> <strong>底层特性</strong>：作为最接近机器语言的编程语言，汇编允许直接操作 CPU 寄存器、内存地址等硬件资源</li> <li> <strong>执行效率</strong>：由于消除了解释和转换开销，汇编程序通常具有卓越的性能表现，适用于对执行速度和资源利用有严格要求的场景</li> <li> <strong>精确控制</strong>：提供对硬件资源的精细控制能力，使其成为开发操作系统内核、设备驱动、实时系统等底层软件的理想选择</li> </ol> <h4 id="12-汇编语言分类">1.2 汇编语言分类</h4> <p>汇编语言因处理器架构和指令集而异，主要分类如下：</p> <table> <thead> <tr> <th>架构类型</th> <th>适用处理器</th> <th>主要应用场景</th> <th>特点</th> </tr> </thead> <tbody> <tr> <td><strong>x86 汇编</strong></td> <td>Intel/AMD 32 位</td> <td>桌面计算机、服务器</td> <td>CISC 架构，指令复杂多样</td> </tr> <tr> <td><strong>x86-64 汇编</strong></td> <td>Intel/AMD 64 位</td> <td>现代桌面、服务器</td> <td>扩展地址空间，增强寄存器集</td> </tr> <tr> <td><strong>ARM 汇编</strong></td> <td>ARM 处理器</td> <td>移动设备、嵌入式</td> <td>RISC 架构，低功耗高效</td> </tr> <tr> <td><strong>MIPS 汇编</strong></td> <td>MIPS 处理器</td> <td>网络设备、嵌入式</td> <td>简洁指令集，流水线优化</td> </tr> <tr> <td><strong>RISC-V 汇编</strong></td> <td>RISC-V 处理器</td> <td>学术研究、新兴平台</td> <td>开源架构，模块化设计</td> </tr> </tbody> </table> <h4 id="13-汇编与高级语言的关系">1.3 汇编与高级语言的关系</h4> <p><strong>与其他编译型语言的关系</strong>：</p> <ol> <li> <strong>直接编译语言</strong>（Rust、Go、Swift）： <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code> C/C++源码 → 预处理 → 编译 → 汇编代码 → 汇编 → 机器码 → 链接 → 可执行文件
</code></pre></div> </div> <ul> <li>编译器直接生成目标平台汇编代码</li> <li>优化器对汇编代码质量影响显著</li> </ul> </li> <li> <strong>虚拟机语言</strong>（Java、C#）： <ul> <li>编译为中间字节码</li> <li>JIT 编译器将字节码转换为本地汇编代码</li> <li>运行时优化能够生成高质量汇编代码</li> </ul> </li> </ol> <h4 id="14-总结">1.4 总结</h4> <p>汇编语言作为连接高级语言和机器码的桥梁，提供了对硬件资源的直接控制能力。掌握汇编语言有助于：</p> <ol> <li> <strong>深入理解计算机系统</strong>：了解程序的底层执行机制</li> <li> <strong>性能优化</strong>：识别和消除性能瓶颈</li> <li> <strong>系统编程</strong>：开发操作系统、驱动程序等底层软件</li> <li> <strong>逆向工程</strong>：分析和理解已编译程序的行为</li> <li> <strong>安全研究</strong>：理解漏洞原理和利用技术</li> </ol> <p>现代开发中，虽然直接编写汇编代码的需求减少，但理解汇编原理对于成为优秀的系统程序员仍然至关重要。通过学习汇编，我们能够更好地理解编译器优化、调试复杂问题，并编写出更高效的代码。</p> <h3 id="2-汇编语法结构">2. 汇编语法结构</h3> <h4 id="21-基本语法格式">2.1 基本语法格式</h4> <p>汇编指令通常遵循以下格式：</p> <pre><code class="language-assembly">[标签:] 操作码 [操作数1] [, 操作数2] [; 注释]
</code></pre> <p><strong>语法要素</strong>：</p> <ul> <li> <strong>标签</strong>：用于标识代码位置，便于跳转和引用</li> <li> <strong>操作码</strong>：指令的助记符，如 MOV、ADD 等</li> <li> <strong>操作数</strong>：指令的参数，可以是寄存器、内存地址或立即数</li> <li> <strong>注释</strong>：以分号开始的说明文字</li> </ul> <h4 id="22-核心指令集">2.2 核心指令集</h4> <h5 id="221-数据传输指令">2.2.1 数据传输指令</h5> <pre><code class="language-assembly">; 基本数据传输
MOV AX, BX           ; 将BX寄存器的值复制到AX寄存器
MOV [address], AX    ; 将AX寄存器的值存储到指定内存地址
MOV EAX, 100         ; 将立即数100加载到EAX寄存器

; 数据交换
XCHG AX, BX          ; 交换AX和BX寄存器的值

; 地址传输
LEA EAX, [EBX + 4]   ; 将地址EBX+4加载到EAX（不访问内存）
</code></pre> <h5 id="222-算术指令">2.2.2 算术指令</h5> <pre><code class="language-assembly">; 基本算术运算
ADD AX, BX           ; AX = AX + BX
SUB AX, BX           ; AX = AX - BX
INC AX               ; AX = AX + 1
DEC BX               ; BX = BX - 1

; 乘除运算
MUL BX               ; 无符号乘法：AX * BX，结果存储在DX:AX
IMUL BX              ; 有符号乘法
DIV CX               ; 无符号除法：DX:AX ÷ CX，商在AX，余数在DX
IDIV CX              ; 有符号除法

; 位运算
SHL AX, 1            ; 逻辑左移1位
SHR BX, 2            ; 逻辑右移2位
SAR CX, 1            ; 算术右移1位（保持符号位）
ROL DX, 3            ; 循环左移3位
</code></pre> <h5 id="223-逻辑指令">2.2.3 逻辑指令</h5> <pre><code class="language-assembly">; 位逻辑运算
AND AX, BX           ; AX = AX &amp; BX（按位与）
OR AX, BX            ; AX = AX | BX（按位或）
XOR AX, BX           ; AX = AX ^ BX（按位异或）
NOT AX               ; AX = ~AX（按位取反）

; 测试指令
TEST AX, BX          ; 执行AND运算但不保存结果，只设置标志位
</code></pre> <h5 id="224-比较与跳转指令">2.2.4 比较与跳转指令</h5> <pre><code class="language-assembly">; 比较指令
CMP AX, BX           ; 比较AX和BX，结果影响标志位寄存器

; 无条件跳转
JMP label            ; 无条件跳转到label

; 条件跳转（基于标志位）
JE label             ; 若相等则跳转（ZF=1）
JNE label            ; 若不相等则跳转（ZF=0）
JG label             ; 若大于则跳转（有符号比较）
JA label             ; 若大于则跳转（无符号比较）
JL label             ; 若小于则跳转（有符号比较）
JB label             ; 若小于则跳转（无符号比较）
JZ label             ; 若为零则跳转（ZF=1）
JNZ label            ; 若非零则跳转（ZF=0）
JS label             ; 若为负则跳转（SF=1）
JC label             ; 若进位则跳转（CF=1）
JO label             ; 若溢出则跳转（OF=1）
</code></pre> <h5 id="225-栈操作指令">2.2.5 栈操作指令</h5> <pre><code class="language-assembly">; 栈操作
PUSH AX              ; 将AX压入栈
POP BX               ; 从栈弹出到BX
PUSHF                ; 压入标志寄存器
POPF                 ; 弹出到标志寄存器

; 多寄存器操作
PUSHA                ; 压入所有通用寄存器
POPA                 ; 弹出所有通用寄存器
</code></pre> <h5 id="226-字符串处理指令">2.2.6 字符串处理指令</h5> <pre><code class="language-assembly">; 字符串传输
MOVSB                ; 传输一个字节 [EDI] = [ESI]
MOVSW                ; 传输一个字
MOVSD                ; 传输一个双字

; 字符串比较
CMPSB                ; 比较字节 [ESI] 与 [EDI]
REPE CMPSB           ; 重复比较直到不相等或ECX=0

; 字符串搜索
SCASB                ; 在[EDI]中搜索AL的值
REPNE SCASB          ; 重复搜索直到找到或ECX=0

; 字符串填充
STOSB                ; 将AL存储到[EDI]
REP STOSB            ; 重复存储ECX次
</code></pre> <h4 id="23-高级抽象能力实现">2.3 高级抽象能力实现</h4> <p>汇编语言本身不提供高级控制结构，但可以通过组合基本指令实现：</p> <h5 id="231-循环结构实现">2.3.1 循环结构实现</h5> <pre><code class="language-assembly">; for循环等效实现
        MOV ECX, 10          ; 初始化循环计数器
loop_start:
        ; 循环体代码
        PUSH ECX             ; 保护计数器
        ; ... 具体操作 ...
        POP ECX              ; 恢复计数器
        DEC ECX              ; 计数器递减
        JNZ loop_start       ; 若计数器不为零则继续循环

; while循环等效实现
        MOV EAX, [condition] ; 加载条件变量
while_start:
        CMP EAX, 0           ; 检查条件
        JE while_end         ; 条件为假则退出
        ; 循环体代码
        MOV EAX, [condition] ; 重新检查条件
        JMP while_start      ; 继续循环
while_end:
</code></pre> <h5 id="232-条件分支实现">2.3.2 条件分支实现</h5> <pre><code class="language-assembly">; if-else结构
        CMP EAX, EBX         ; 比较两个值
        JE equal_case        ; 相等时跳转
        JG greater_case      ; 大于时跳转
        ; else情况的代码
        JMP end_if           ; 跳过其他分支

equal_case:
        ; 相等时的处理代码
        JMP end_if

greater_case:
        ; 大于时的处理代码
        ; 直接进入end_if

end_if:
        ; 后续代码

; switch-case结构（跳转表实现）
        MOV EBX, [switch_var]
        CMP EBX, 0
        JE case_0
        CMP EBX, 1
        JE case_1
        CMP EBX, 2
        JE case_2
        JMP default_case

case_0:
        ; case 0的处理
        JMP switch_end
case_1:
        ; case 1的处理
        JMP switch_end
case_2:
        ; case 2的处理
        JMP switch_end
default_case:
        ; 默认情况的处理
switch_end:
</code></pre> <h5 id="233-函数调用机制">2.3.3 函数调用机制</h5> <pre><code class="language-assembly">; 函数调用示例
main:
        PUSH 10              ; 压入参数2
        PUSH 5               ; 压入参数1
        CALL my_function     ; 调用函数
        ADD ESP, 8           ; 清理栈上参数（2个4字节参数）
        ; EAX包含返回值
        JMP program_end

my_function:
        ; 函数序言(Prologue)
        PUSH EBP             ; 保存调用者的栈帧基址
        MOV EBP, ESP         ; 建立新的栈帧基址
        SUB ESP, 8           ; 分配局部变量空间

        ; 函数体
        MOV EAX, [EBP + 8]   ; 获取第一个参数
        ADD EAX, [EBP + 12]  ; 加上第二个参数
        MOV [EBP - 4], EAX   ; 存储到局部变量

        ; 函数尾声(Epilogue)
        MOV ESP, EBP         ; 释放局部变量空间
        POP EBP              ; 恢复调用者的栈帧基址
        RET                  ; 返回调用点

program_end:
</code></pre> <p><strong>函数调用的底层机制</strong>：</p> <ul> <li> <p><strong><code class="language-plaintext highlighter-rouge">CALL</code> 指令</strong>等效于：</p> <pre><code class="language-assembly">PUSH EIP             ; 保存返回地址
JMP target           ; 跳转到目标函数
</code></pre> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">RET</code> 指令</strong>等效于：</p> <pre><code class="language-assembly">POP EIP              ; 恢复返回地址
</code></pre> </li> </ul> <h3 id="3-寄存器系统">3. 寄存器系统</h3> <h4 id="31-通用寄存器详解">3.1 通用寄存器详解</h4> <p>x86-32 架构的 8 个通用寄存器各有特定用途和硬件特性：</p> <table> <thead> <tr> <th>寄存器</th> <th>全称</th> <th>主要用途</th> <th>硬件特性</th> </tr> </thead> <tbody> <tr> <td><strong>EAX</strong></td> <td>Accumulator</td> <td>算术运算、函数返回值</td> <td>乘除法默认操作数</td> </tr> <tr> <td><strong>EBX</strong></td> <td>Base</td> <td>内存寻址基址</td> <td>间接寻址基址</td> </tr> <tr> <td><strong>ECX</strong></td> <td>Counter</td> <td>循环计数、字符串操作</td> <td>LOOP 指令自动递减</td> </tr> <tr> <td><strong>EDX</strong></td> <td>Data</td> <td>扩展精度运算</td> <td>乘除法高位结果</td> </tr> <tr> <td><strong>ESI</strong></td> <td>Source Index</td> <td>字符串源地址</td> <td>字符串指令源指针</td> </tr> <tr> <td><strong>EDI</strong></td> <td>Destination Index</td> <td>字符串目标地址</td> <td>字符串指令目标指针</td> </tr> <tr> <td><strong>EBP</strong></td> <td>Base Pointer</td> <td>栈帧基址</td> <td>局部变量和参数访问</td> </tr> <tr> <td><strong>ESP</strong></td> <td>Stack Pointer</td> <td>栈顶指针</td> <td>栈操作自动更新</td> </tr> </tbody> </table> <p><strong>寄存器子集访问</strong>：</p> <pre><code class="language-assembly">; 32位寄存器EAX的不同位宽访问
MOV EAX, 0x12345678  ; 32位：EAX = 12345678h
MOV AX, 0x9ABC       ; 16位：AX = 9ABCh, EAX = 12349ABCh
MOV AL, 0xEF         ; 8位低：AL = EFh, EAX = 12349AEFh
MOV AH, 0xCD         ; 8位高：AH = CDh, EAX = 1234CDEFh
</code></pre> <h4 id="32-标志位寄存器eflags">3.2 标志位寄存器(EFLAGS)</h4> <p>标志位寄存器包含多个单比特标志，反映指令执行结果的状态：</p> <table> <thead> <tr> <th>标志位</th> <th>名称</th> <th>位置</th> <th>含义</th> <th>影响指令</th> </tr> </thead> <tbody> <tr> <td><strong>CF</strong></td> <td>Carry Flag</td> <td>0</td> <td>进位/借位标志</td> <td>算术运算、移位</td> </tr> <tr> <td><strong>PF</strong></td> <td>Parity Flag</td> <td>2</td> <td>奇偶校验标志</td> <td>逻辑运算</td> </tr> <tr> <td><strong>AF</strong></td> <td>Auxiliary Flag</td> <td>4</td> <td>辅助进位标志</td> <td>BCD 运算</td> </tr> <tr> <td><strong>ZF</strong></td> <td>Zero Flag</td> <td>6</td> <td>零标志</td> <td>比较、算术运算</td> </tr> <tr> <td><strong>SF</strong></td> <td>Sign Flag</td> <td>7</td> <td>符号标志</td> <td>算术运算</td> </tr> <tr> <td><strong>TF</strong></td> <td>Trap Flag</td> <td>8</td> <td>陷阱标志</td> <td>单步调试</td> </tr> <tr> <td><strong>IF</strong></td> <td>Interrupt Flag</td> <td>9</td> <td>中断允许标志</td> <td>中断控制</td> </tr> <tr> <td><strong>DF</strong></td> <td>Direction Flag</td> <td>10</td> <td>方向标志</td> <td>字符串操作</td> </tr> <tr> <td><strong>OF</strong></td> <td>Overflow Flag</td> <td>11</td> <td>溢出标志</td> <td>有符号算术</td> </tr> </tbody> </table> <pre><code class="language-assembly">; 标志位示例
MOV AL, 0xFF
ADD AL, 1            ; CF=1, ZF=1, SF=0 (结果0x00，产生进位)

MOV AX, 0x7FFF
ADD AX, 1            ; OF=1, SF=1 (有符号溢出)

CMP EAX, EBX         ; 设置标志位但不改变操作数
TEST EAX, EAX        ; 检查EAX是否为0，设置ZF
</code></pre> <h4 id="33-段寄存器与系统寄存器">3.3 段寄存器与系统寄存器</h4> <p><strong>段寄存器</strong>（16 位）：</p> <pre><code class="language-assembly">; 段寄存器在保护模式下作为段选择器
MOV AX, CS           ; 代码段选择器
MOV BX, DS           ; 数据段选择器
MOV CX, SS           ; 栈段选择器
MOV DX, ES           ; 额外段选择器
</code></pre> <p><strong>控制寄存器</strong>（特权级操作）：</p> <ul> <li> <strong>CR0</strong>：控制处理器模式和缓存</li> <li> <strong>CR2</strong>：页面故障地址</li> <li> <strong>CR3</strong>：页目录基址寄存器</li> <li> <strong>CR4</strong>：处理器功能扩展</li> </ul> <p><strong>指令指针寄存器</strong>：</p> <ul> <li> <strong>EIP</strong>：指向下一条待执行指令，不能直接修改</li> </ul> <h3 id="4-栈机制与内存管理">4. 栈机制与内存管理</h3> <h4 id="41-栈的物理实现">4.1 栈的物理实现</h4> <p>x86 架构栈的关键特性：</p> <ol> <li> <strong>向低地址增长</strong>：栈顶地址小于栈底地址</li> <li> <strong>双寄存器管理</strong>：ESP 指向栈顶，EBP 提供稳定基址</li> <li> <strong>自动对齐</strong>：现代系统要求 16 字节栈对齐</li> </ol> <pre><code class="language-assembly">; 栈操作的底层实现
PUSH EAX             ; 等效于：SUB ESP, 4; MOV [ESP], EAX
POP EBX              ; 等效于：MOV EBX, [ESP]; ADD ESP, 4

; 栈帧布局示例
;   高地址
;   +--------+
;   | 参数n  | [EBP + 4n]
;   | ...    |
;   | 参数1  | [EBP + 8]
;   | 返回地址| [EBP + 4]
;   +--------+
;   | 旧EBP  | [EBP] &lt;- EBP指向这里
;   +--------+
;   | 局部变量| [EBP - 4]
;   | ...    | [EBP - 8]
;   +--------+ &lt;- ESP指向这里
;   低地址
</code></pre> <h4 id="42-函数调用约定详解">4.2 函数调用约定详解</h4> <p><strong>cdecl 约定</strong>（C 语言默认）：</p> <pre><code class="language-assembly">; 调用者代码
PUSH param2          ; 参数逆序压栈
PUSH param1
CALL function
ADD ESP, 8           ; 调用者清理栈

; 被调用函数
function:
    PUSH EBP
    MOV EBP, ESP
    ; 函数体
    MOV ESP, EBP     ; 或使用LEAVE指令
    POP EBP
    RET              ; 返回值在EAX
</code></pre> <p><strong>stdcall 约定</strong>（Windows API）：</p> <pre><code class="language-assembly">; 调用者代码
PUSH param2
PUSH param1
CALL function        ; 无需手动清理栈

; 被调用函数
function:
    PUSH EBP
    MOV EBP, ESP
    ; 函数体
    MOV ESP, EBP
    POP EBP
    RET 8            ; 被调用者清理8字节参数
</code></pre> <p><strong>fastcall 约定</strong>（寄存器传参）：</p> <pre><code class="language-assembly">; 前两个参数通过ECX和EDX传递
MOV ECX, param1
MOV EDX, param2
PUSH param3          ; 剩余参数压栈
CALL function
</code></pre> <h3 id="5-汇编到高级语言的抽象映射">5. 汇编到高级语言的抽象映射</h3> <h4 id="51-数据结构的内存布局">5.1 数据结构的内存布局</h4> <p><strong>结构体内存布局</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// C++结构体</span>
<span class="k">struct</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>      <span class="c1">// 偏移量0，4字节</span>
    <span class="kt">char</span> <span class="n">flag</span><span class="p">;</span>  <span class="c1">// 偏移量4，1字节</span>
    <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>   <span class="c1">// 偏移量8，8字节（因对齐）</span>
<span class="p">};</span>
</code></pre></div></div> <p>汇编访问：</p> <pre><code class="language-assembly">; 假设Point结构体地址在EBX
MOV EAX, [EBX + 0]   ; 访问x成员
MOV CL, [EBX + 4]    ; 访问flag成员
MOVSD XMM0, [EBX + 8]; 访问y成员（浮点）
</code></pre> <p><strong>数组访问</strong>：</p> <pre><code class="language-assembly">; int array[10]; 访问array[i]
MOV EBX, array_base  ; 数组基址
MOV EAX, index       ; 索引值
MOV ECX, [EBX + EAX*4] ; array[index]，4是int大小
</code></pre> <h4 id="52-汇编层面的函数实现机制">5.2 汇编层面的函数实现机制</h4> <p>汇编语言中的函数本质上是带有入口和出口点的代码块。函数调用过程涉及：</p> <ul> <li>参数传递：通过栈或特定寄存器</li> <li>控制流转移：保存返回地址并跳转到函数入口</li> <li>局部状态管理：分配和释放栈空间</li> <li>返回值传递：通常使用特定寄存器(如EAX/RAX)</li> </ul> <p>典型x86函数调用示例：</p> <pre><code class="language-assembly">section .text
global _start

_start:
    ; 函数调用准备
    push 5           ; 压入参数
    call calculate   ; 调用函数
    add esp, 4       ; 清理栈上参数
    ; 处理返回值(位于EAX)
    jmp exit

calculate:
    ; 函数入口处理
    push ebp
    mov ebp, esp
    
    ; 函数主体
    mov eax, [ebp+8] ; 获取参数
    add eax, eax     ; 计算参数的两倍作为返回值
    
    ; 函数退出处理
    mov esp, ebp
    pop ebp
    ret              ; 返回调用点
    
exit:
    ; 程序结束处理
</code></pre> <h4 id="53-面向对象特性实现">5.3 面向对象特性实现</h4> <p><strong>成员函数调用</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Rectangle</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">area</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">Rectangle</span> <span class="n">r</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">area</span><span class="p">();</span>

<span class="c1">// 在汇编层面等效于：</span>

<span class="kt">int</span> <span class="nf">area</span><span class="p">(</span><span class="n">Rectangle</span><span class="o">*</span> <span class="k">this</span><span class="p">)</span> <span class="p">{</span> 
    <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">*</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Rectangle</span> <span class="n">r</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">area</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>
</code></pre></div></div> <p>汇编实现：</p> <pre><code class="language-assembly">; C++: rect.area()
; 转换为: area(&amp;rect)
MOV ECX, rect_address    ; this指针通过ECX传递（fastcall）
CALL Rectangle_area

Rectangle_area:
    ; ECX = this指针
    MOV EAX, [ECX + 0]   ; 加载width
    MUL DWORD [ECX + 4]  ; 乘以height
    RET                  ; 返回值在EAX
</code></pre> <p><strong>虚函数机制</strong>：</p> <pre><code class="language-assembly">; 虚函数调用：obj-&gt;virtualMethod()
MOV EBX, obj_address     ; 对象地址
MOV EAX, [EBX]           ; 加载虚函数表指针
CALL [EAX + method_offset] ; 间接调用虚函数
</code></pre> <h4 id="54-异常处理机制">5.4 异常处理机制</h4> <p><strong>结构化异常处理(SEH)</strong>：</p> <pre><code class="language-assembly">; Windows SEH frame设置
PUSH exception_handler   ; 异常处理函数地址
PUSH DWORD PTR FS:[0]    ; 链接到异常链
MOV FS:[0], ESP          ; 安装新的异常处理器

; 受保护代码
; ...

; 清理异常处理器
POP DWORD PTR FS:[0]
ADD ESP, 4               ; 清理处理器地址
</code></pre> <h4 id="55-变长参数的实现机制">5.5 变长参数的实现机制</h4> <p>C/C++中的变长参数函数(如printf)在汇编层面通过特定的参数传递约定和栈操作实现：</p> <ol> <li> <strong>参数计数</strong>：通常通过固定参数(如printf的格式字符串)显式或隐式指示后续参数数量和类型</li> <li> <strong>参数传递</strong>：所有参数按顺序压入栈中</li> <li> <strong>参数访问</strong>：函数通过累加偏移量遍历栈上参数</li> </ol> <p>例如，va_arg宏在实现上通过维护一个指向当前参数的指针，并根据请求的类型计算偏移量来获取下一个参数：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用变长参数的简化伪代码</span>
<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">args</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 指向第一个可变参数</span>
    <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// 访问第i个参数</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在汇编层面，这可能转换为：</p> <pre><code class="language-assembly">; 假设count参数在[ebp+8]位置
mov ecx, [ebp+8]    ; 加载参数数量
xor eax, eax        ; 初始化总和为0
mov edx, ebp
add edx, 12         ; 指向第一个可变参数

sum_loop:
    add eax, [edx]  ; 添加当前参数到总和
    add edx, 4      ; 移动到下一个参数
    dec ecx         ; 计数减1
    jnz sum_loop    ; 如果还有参数，继续循环
</code></pre> <h3 id="6-常见问题解答">6. 常见问题解答</h3> <h4 id="61-内存栈与汇编栈的关系">6.1 内存栈与汇编栈的关系</h4> <ul> <li>内存的栈（高级视角） <ul> <li> <strong>概念</strong>：内存中的栈是操作系统分配给程序的一块连续内存区域，遵循<strong>后进先出（LIFO）</strong>原则。</li> <li> <strong>用途</strong>：</li> <li>存储函数调用的上下文（如返回地址、局部变量）。</li> <li>传递函数参数（某些架构）。</li> <li>保存寄存器状态。</li> <li> <strong>特点</strong>：</li> <li>由操作系统自动管理（入栈/出栈）。</li> <li>通常向下增长（从高地址到低地址）。</li> <li>大小有限（如Linux默认8MB），可能导致栈溢出。</li> </ul> </li> <li>汇编的栈（底层视角） <ul> <li> <strong>概念</strong>：汇编中的栈是通过<strong>特定寄存器和指令</strong>操作的内存区域，与内存的栈是同一物理区域。</li> <li> <strong>核心元素</strong>：</li> <li> <strong>栈指针寄存器</strong>（如x86的<code class="language-plaintext highlighter-rouge">ESP</code>/<code class="language-plaintext highlighter-rouge">RSP</code>）：指向当前栈顶。</li> <li> <strong>基址指针寄存器</strong>（如x86的<code class="language-plaintext highlighter-rouge">EBP</code>/<code class="language-plaintext highlighter-rouge">RBP</code>）：辅助定位局部变量和参数。</li> <li> <strong>典型指令</strong>：</li> <li> <code class="language-plaintext highlighter-rouge">PUSH</code>：将数据压入栈顶（栈指针减小）。</li> <li> <code class="language-plaintext highlighter-rouge">POP</code>：从栈顶弹出数据（栈指针增大）。</li> <li> <code class="language-plaintext highlighter-rouge">CALL</code>：调用函数时自动保存返回地址到栈。</li> <li> <code class="language-plaintext highlighter-rouge">RET</code>：从栈恢复返回地址并跳转。</li> </ul> </li> <li>两者关系 内存的栈是抽象概念，而汇编的栈是具体实现方式。例如： <pre><code class="language-assembly">  ; x86汇编示例：函数调用栈操作
  push ebp        ; 保存旧的基址指针（入栈）
  mov ebp, esp    ; 设置新基址指针
  sub esp, 16     ; 为局部变量分配空间（栈向下增长）
  ; ... 函数逻辑 ...
  mov esp, ebp    ; 释放局部变量空间
  pop ebp         ; 恢复旧基址指针（出栈）
  ret             ; 返回（从栈弹出返回地址）
</code></pre> </li> </ul> <p>两者是同一事物的不同层面：</p> <ul> <li> <strong>内存的栈</strong>：操作系统管理的内存区域，用于函数调用和局部变量。</li> <li> <strong>汇编的栈</strong>：通过寄存器和指令操作该区域的具体实现。</li> </ul> <p><strong>内存栈（高级视角）</strong>：</p> <ul> <li>操作系统分配的连续内存区域</li> <li>遵循 LIFO 原则</li> <li>存储函数调用上下文、局部变量、参数</li> <li>自动管理，大小限制（如 Linux 默认 8MB）</li> </ul> <p><strong>汇编栈（底层实现）</strong>：</p> <ul> <li>通过 ESP/RSP 和 EBP/RBP 寄存器操作的内存区域</li> <li>使用 PUSH/POP/CALL/RET 指令</li> <li>与内存栈是同一物理区域的不同抽象层次</li> </ul> <pre><code class="language-assembly">; 栈操作示例
PUSH EBP             ; 保存调用者栈帧
MOV EBP, ESP         ; 建立当前栈帧
SUB ESP, 16          ; 分配局部变量空间
; ... 函数逻辑 ...
MOV ESP, EBP         ; 释放局部变量
POP EBP              ; 恢复调用者栈帧
RET                  ; 返回
</code></pre> <h4 id="62-不同架构的差异">6.2 不同架构的差异</h4> <table> <thead> <tr> <th>特性</th> <th>x86-32</th> <th>x86-64</th> <th>ARM</th> </tr> </thead> <tbody> <tr> <td>寄存器数量</td> <td>8 个通用</td> <td>16 个通用</td> <td>16 个通用</td> </tr> <tr> <td>寄存器宽度</td> <td>32 位</td> <td>64 位</td> <td>32/64 位</td> </tr> <tr> <td>调用约定</td> <td>栈传参</td> <td>寄存器+栈</td> <td>寄存器优先</td> </tr> <tr> <td>指令集类型</td> <td>CISC</td> <td>CISC</td> <td>RISC</td> </tr> </tbody> </table> <h4 id="63-c如何内联汇编">6.3 c++如何内联汇编？</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="c1">// GCC内联汇编语法</span>
   <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
       <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
       <span class="k">asm</span><span class="p">(</span><span class="s">"addl %1, %0"</span> <span class="o">:</span> <span class="s">"=r"</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">:</span> <span class="s">"r"</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s">"0"</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
       <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
   <span class="p">}</span>
</code></pre></div></div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/6_internet.md/">（七）内核那些事儿：操作系统对网络包的处理</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/5_fileSystem.md/">（六）内核那些事儿：文件系统</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/4_interaction.md/">（五）内核那些事儿：系统和程序的交互</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_device.md/">（四）内核那些事儿：设备管理与驱动开发</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_signal.md/">（三）内核那些事儿：CPU中断和信号</a> </li> </div> </div> <div class="col-sm-4"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <script src="/assets/js/toc-depth.js"></script> </body> </html>