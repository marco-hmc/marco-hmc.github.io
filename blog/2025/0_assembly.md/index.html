<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 汇编 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/0_assembly.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">汇编</h1> <p class="post-meta"> Created on March 06, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/asm"> <i class="fa-solid fa-hashtag fa-sm"></i> asm</a>   ·   <a href="/blog/category/language"> <i class="fa-solid fa-tag fa-sm"></i> language</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="汇编">汇编</h2> <h3 id="1-concepts">1. concepts</h3> <ul> <li><strong>什么是汇编？</strong></li> </ul> <p>汇编语言（Assembly Language）是一种低级编程语言，它直接与计算机硬件交互。汇编语言使用助记符（mnemonics）来表示机器指令和操作码，这些助记符更易于人类理解和记忆。汇编语言与机器语言一一对应，每一条汇编指令通常对应一条机器指令。</p> <ol> <li> <strong>低级语言</strong>：汇编语言是最接近机器语言的编程语言，直接操作硬件资源，如寄存器、内存地址等。</li> <li> <strong>高效</strong>：由于汇编语言直接与硬件交互，程序执行效率高，适用于对性能要求极高的场合。</li> <li> <strong>可控性强</strong>：程序员可以精确控制硬件资源的使用，适用于嵌入式系统、驱动程序等领域。</li> </ol> <ul> <li> <p><strong>汇编有哪些种类？</strong> 汇编语言根据不同的处理器架构和指令集有不同的种类。以下是几种常见的汇编语言：</p> <ol> <li> <strong>x86 汇编</strong>： <ul> <li>用于 Intel 和 AMD 的 x86 架构处理器。</li> <li>常用于桌面计算机和服务器。</li> <li>典型的汇编器有 NASM、MASM 等。</li> </ul> </li> <li> <strong>x86-64 汇编</strong>： <ul> <li>用于 64 位的 x86 架构处理器。</li> <li>支持更大的内存地址空间和更多的寄存器。</li> <li>典型的汇编器有 NASM、MASM 等。</li> </ul> </li> <li> <strong>ARM 汇编</strong>： <ul> <li>用于 ARM 架构处理器。</li> <li>常用于移动设备、嵌入式系统等。</li> <li>典型的汇编器有 ARM 汇编器、GNU 汇编器（GAS）等。</li> </ul> </li> <li> <strong>MIPS 汇编</strong>： <ul> <li>用于 MIPS 架构处理器。</li> <li>常用于嵌入式系统、路由器等。</li> <li>典型的汇编器有 GNU 汇编器（GAS）等。</li> </ul> </li> <li> <strong>RISC-V 汇编</strong>： <ul> <li>用于 RISC-V 开放指令集架构。</li> <li>常用于研究和教育领域。</li> <li>典型的汇编器有 GNU 汇编器（GAS）等。</li> </ul> </li> </ol> </li> <li> <p><strong>C/C++ 和汇编的关系是什么？</strong></p> <ol> <li> <strong>编译过程</strong>： <ul> <li>C/C++ 源代码在编译过程中会被转换为汇编代码，然后再被汇编器转换为机器代码。</li> <li>编译器（如 GCC、Clang）会生成中间的汇编代码，程序员可以查看和优化这些汇编代码。</li> </ul> </li> <li> <strong>内嵌汇编</strong>： <ul> <li>C/C++ 支持内嵌汇编（Inline Assembly），允许在 C/C++ 代码中直接编写汇编代码。</li> <li>内嵌汇编可以用于优化性能关键的代码段，或者直接操作硬件资源。</li> </ul> </li> <li> <strong>函数调用约定</strong>： <ul> <li>C/C++ 和汇编语言之间的函数调用需要遵循特定的调用约定（Calling Convention），如参数传递、栈帧管理等。</li> <li>调用约定确保 C/C++ 函数和汇编函数之间可以正确地相互调用。</li> </ul> </li> </ol> </li> <li> <p><strong>其他编译型语言和汇编的关系是什么？</strong></p> </li> </ul> <p>其他编译型语言（如 Java、C#、Go 等）与汇编语言之间的关系也类似，主要体现在以下几个方面：</p> <ol> <li> <strong>编译过程</strong>： <ul> <li>其他编译型语言的源代码在编译过程中也会被转换为汇编代码，然后再被汇编器转换为机器代码。</li> <li>编译器会生成中间的汇编代码，程序员可以查看这些汇编代码以了解编译器的优化策略。</li> </ul> </li> <li> <strong>虚拟机和字节码</strong>： <ul> <li>一些编译型语言（如 Java、C#）会先编译为字节码，然后在虚拟机上运行。</li> <li>虚拟机（如 JVM、CLR）会将字节码转换为汇编代码，再转换为机器代码执行。</li> </ul> </li> <li> <strong>性能优化</strong>： <ul> <li>高级语言的编译器会进行各种优化，将高层次的语言结构转换为高效的汇编代码。</li> <li>程序员可以通过查看汇编代码来了解编译器的优化效果，并进行手动优化。</li> </ul> </li> </ol> <h3 id="2-汇编的语法">2. 汇编的语法</h3> <h4 id="21-汇编的基本语法能力">2.1 汇编的基本语法能力</h4> <ol> <li> <p><strong>数据传输指令（Data Transfer Instructions）</strong>：</p> <ul> <li> <strong>MOV</strong>：将数据从一个位置传输到另一个位置。</li> </ul> <pre><code class="language-assembly">MOV AX, BX  ; 将 BX 寄存器的值传输到 AX 寄存器
MOV [address], AX  ; 将 AX 寄存器的值传输到内存地址 address
</code></pre> </li> <li> <p><strong>算术指令（Arithmetic Instructions）</strong>：</p> <ul> <li> <strong>ADD</strong>：执行加法运算。</li> </ul> <pre><code class="language-assembly">ADD AX, BX  ; 将 AX 和 BX 寄存器的值相加，结果存储在 AX 中
</code></pre> <ul> <li> <strong>SUB</strong>：执行减法运算。</li> </ul> <pre><code class="language-assembly">SUB AX, BX  ; 将 BX 从 AX 中减去，结果存储在 AX 中
</code></pre> <ul> <li> <strong>MUL</strong>：执行乘法运算。</li> </ul> <pre><code class="language-assembly">MUL BX  ; 将 AX 寄存器的值与 BX 寄存器的值相乘，结果存储在 AX 中
</code></pre> <ul> <li> <strong>DIV</strong>：执行除法运算。</li> </ul> <pre><code class="language-assembly">DIV BX  ; 将 AX 寄存器的值除以 BX 寄存器的值，商存储在 AX 中，余数存储在 DX 中
</code></pre> </li> <li> <p><strong>逻辑指令（Logical Instructions）</strong>：</p> <ul> <li> <strong>AND</strong>：执行按位与运算。</li> </ul> <pre><code class="language-assembly">AND AX, BX  ; 将 AX 和 BX 寄存器的值按位与，结果存储在 AX 中
</code></pre> <ul> <li> <strong>OR</strong>：执行按位或运算。</li> </ul> <pre><code class="language-assembly">OR AX, BX  ; 将 AX 和 BX 寄存器的值按位或，结果存储在 AX 中
</code></pre> <ul> <li> <strong>XOR</strong>：执行按位异或运算。</li> </ul> <pre><code class="language-assembly">XOR AX, BX  ; 将 AX 和 BX 寄存器的值按位异或，结果存储在 AX 中
</code></pre> <ul> <li> <strong>NOT</strong>：执行按位取反运算。</li> </ul> <pre><code class="language-assembly">NOT AX  ; 将 AX 寄存器的值按位取反
</code></pre> </li> <li> <p><strong>控制流指令（Control Flow Instructions）</strong>：</p> <ul> <li> <strong>JMP</strong>：无条件跳转。</li> </ul> <pre><code class="language-assembly">JMP label  ; 跳转到标签 label 处执行
</code></pre> <ul> <li> <strong>JE/JZ</strong>：条件跳转（如果等于/如果为零）。</li> </ul> <pre><code class="language-assembly">JE label  ; 如果零标志位（ZF）为 1，则跳转到标签 label 处执行
</code></pre> <ul> <li> <strong>JNE/JNZ</strong>：条件跳转（如果不等于/如果不为零）。</li> </ul> <pre><code class="language-assembly">JNE label  ; 如果零标志位（ZF）为 0，则跳转到标签 label 处执行
</code></pre> <ul> <li> <strong>CALL</strong>：调用子程序。</li> </ul> <pre><code class="language-assembly">CALL subroutine  ; 调用子程序 subroutine
</code></pre> <ul> <li> <strong>RET</strong>：从子程序返回。</li> </ul> <pre><code class="language-assembly">RET  ; 从子程序返回
</code></pre> </li> <li> <p><strong>栈操作指令（Stack Operations Instructions）</strong>：</p> <ul> <li> <strong>PUSH</strong>：将数据压入栈。 <pre><code class="language-assembly">PUSH AX  ; 将 AX 寄存器的值压入栈
</code></pre> </li> <li> <strong>POP</strong>：从栈中弹出数据。 <pre><code class="language-assembly">POP AX  ; 从栈中弹出数据到 AX 寄存器
</code></pre> </li> </ul> </li> </ol> <h5 id="211-总结">2.1.1 总结</h5> <ul> <li>对于二元操作符，一般都是<code class="language-plaintext highlighter-rouge">OPER [dst] [src]</code>的形式</li> <li>提供 <ul> <li>数据传输指令：内存和寄存器的数据读写</li> <li>算术指令：加减乘除</li> <li>逻辑指令：与或非异或</li> <li>控制流指令：跳转、调用、返回</li> <li>栈操作指令：入栈出栈（往内存添加新内容的方式）</li> </ul> </li> </ul> <h4 id="22-汇编的抽象能力">2.2 汇编的抽象能力</h4> <p>汇编语言的能力直接由底层的机器指令（Machine Instructions）支持。机器指令是处理器能够直接执行的最基本的指令集，汇编语言通过助记符（mnemonics）来表示这些机器指令，使得编写和阅读代码更加方便。</p> <p>汇编语言本身是对机器指令的直接表示，因此它没有高级编程语言中的抽象概念，如 <code class="language-plaintext highlighter-rouge">for</code> 循环、<code class="language-plaintext highlighter-rouge">if</code> 判断、类（class）和函数等。然而，汇编语言可以通过组合基本的机器指令来实现这些高级编程结构。</p> <h5 id="221-循环loop">2.2.1 循环（Loop）</h5> <p>汇编语言中没有直接的 <code class="language-plaintext highlighter-rouge">for</code> 循环，但可以通过条件跳转和计数器寄存器来实现循环。</p> <pre><code class="language-assembly">MOV CX, 10      ; 初始化计数器寄存器 CX 为 10
loop_start:
    ; 循环体代码
    DEC CX      ; 计数器减 1
    JNZ loop_start  ; 如果 CX 不为零，跳转到 loop_start
</code></pre> <h5 id="222-条件判断if-else">2.2.2 条件判断（If-Else）</h5> <p>汇编语言中没有直接的 <code class="language-plaintext highlighter-rouge">if</code> 判断，但可以通过条件跳转指令来实现条件判断。</p> <pre><code class="language-assembly">CMP AX, BX      ; 比较 AX 和 BX
JE equal        ; 如果 AX 等于 BX，跳转到 equal
    ; 不相等时执行的代码
JMP end_if      ; 跳转到 end_if
equal:
    ; 相等时执行的代码
end_if:
</code></pre> <h5 id="223-函数function">2.2.3 函数（Function）</h5> <p>汇编语言中没有直接的函数定义，但可以通过子程序调用和返回指令来实现函数。</p> <pre><code class="language-assembly">CALL my_function  ; 调用子程序 my_function
    ; 主程序代码
JMP end_program

my_function:
    ; 子程序代码
    RET  ; 返回主程序

end_program:
</code></pre> <h3 id="3-汇编的寄存器">3. 汇编的寄存器</h3> <p>寄存器是 cpu 存储数据的地方，是数据的缓存。这些寄存器的意义和用途是由硬件架构设计者（即 CPU 制造商）赋予的，而不是开发者的习惯方式。 这些寄存器的功能和用途在 CPU 的设计和指令集架构（ISA）中已经定义好，CPU 在执行某些操作时会自动使用这些寄存器。 因此这些寄存器数据的更新往往都是在某个指令执行后。</p> <h4 id="31-x86-汇编有哪些寄存器">3.1 x86-汇编有哪些寄存器？</h4> <p>在 x86 架构中，32 位寄存器的名称通常以 <code class="language-plaintext highlighter-rouge">E</code> 开头，表示 “Extended”（扩展）。这些寄存器是从 16 位寄存器扩展而来的，用于支持 32 位操作。以下是常见的 32 位寄存器及其用途：</p> <h5 id="311-通用寄存器">3.1.1 通用寄存器</h5> <ol> <li> <strong>EAX</strong>：累加器寄存器（Accumulator Register） <ul> <li> <strong>用途</strong>：通常用于函数返回值和算术运算。</li> <li> <strong>硬件支持</strong>：在许多算术和逻辑指令中，EAX 被默认用作操作数或结果寄存器。例如，<code class="language-plaintext highlighter-rouge">ADD</code>、<code class="language-plaintext highlighter-rouge">SUB</code>、<code class="language-plaintext highlighter-rouge">MUL</code> 和 <code class="language-plaintext highlighter-rouge">DIV</code> 指令通常会使用 EAX。</li> </ul> </li> <li> <strong>EBX</strong>：基址寄存器（Base Register） <ul> <li> <strong>用途</strong>：通常用于内存地址计算。</li> <li> <strong>硬件支持</strong>：在某些内存寻址模式中，EBX 可以用作基址寄存器。例如，在基址加变址寻址模式中，EBX 可以与其他寄存器组合来计算内存地址。</li> </ul> </li> <li> <strong>ECX</strong>：计数寄存器（Count Register） <ul> <li> <strong>用途</strong>：通常用于特定的循环和位移指令。</li> <li> <strong>硬件支持</strong>：在循环指令（如 <code class="language-plaintext highlighter-rouge">LOOP</code>）和位移指令（如 <code class="language-plaintext highlighter-rouge">SHL</code>、<code class="language-plaintext highlighter-rouge">SHR</code>）中，ECX 被用作计数器。例如，<code class="language-plaintext highlighter-rouge">LOOP</code> 指令会自动减少 ECX 的值，并根据其值决定是否继续循环。</li> </ul> </li> <li> <strong>EDX</strong>：数据寄存器（Data Register） <ul> <li> <strong>用途</strong>：在与 EAX 一起进行某些类型的乘法和除法运算时使用。</li> <li> <strong>硬件支持</strong>：在乘法和除法指令中，EDX 通常与 EAX 一起使用。例如，<code class="language-plaintext highlighter-rouge">MUL</code> 和 <code class="language-plaintext highlighter-rouge">DIV</code> 指令会使用 EAX 和 EDX 来存储操作数和结果。</li> </ul> </li> <li> <strong>ESI</strong>：源索引寄存器（Source Index Register） <ul> <li> <strong>用途</strong>：通常在字符串和数组操作中用作源地址。</li> <li> <strong>硬件支持</strong>：在字符串操作指令（如 <code class="language-plaintext highlighter-rouge">MOVS</code>、<code class="language-plaintext highlighter-rouge">LODS</code>）中，ESI 被用作源地址寄存器。CPU 会自动使用 ESI 指向源数据，并根据操作自动更新 ESI 的值。</li> </ul> </li> <li> <strong>EDI</strong>：目标索引寄存器（Destination Index Register） <ul> <li> <strong>用途</strong>：通常在字符串和数组操作中用作目标地址。</li> <li> <strong>硬件支持</strong>：在字符串操作指令（如 <code class="language-plaintext highlighter-rouge">MOVS</code>、<code class="language-plaintext highlighter-rouge">STOS</code>）中，EDI 被用作目标地址寄存器。CPU 会自动使用 EDI 指向目标数据，并根据操作自动更新 EDI 的值。</li> </ul> </li> <li> <strong>EBP</strong>：基指针寄存器（Base Pointer Register） <ul> <li> <strong>用途</strong>：通常用于基于堆栈的函数调用中，指向堆栈底部。</li> <li> <strong>硬件支持</strong>：在函数调用过程中，EBP 通常用作栈帧指针。函数调用时，CPU 会自动保存调用者的 EBP，并在函数返回时恢复它。通过 EBP，可以方便地访问函数的参数和局部变量。</li> </ul> </li> <li> <strong>ESP</strong>：堆栈指针寄存器（Stack Pointer Register） <ul> <li> <strong>用途</strong>：总是指向堆栈顶部的当前位置。</li> <li> <strong>硬件支持</strong>：ESP 是堆栈操作的核心寄存器。入栈（<code class="language-plaintext highlighter-rouge">PUSH</code>）和出栈（<code class="language-plaintext highlighter-rouge">POP</code>）指令会自动更新 ESP 的值。函数调用（<code class="language-plaintext highlighter-rouge">CALL</code>）和返回（<code class="language-plaintext highlighter-rouge">RET</code>）指令也会使用 ESP 来管理堆栈。</li> </ul> </li> <li> <strong>EIP</strong>：指令指针寄存器（Instruction Pointer Register） <ul> <li> <strong>用途</strong>：指向下一条要执行的指令。</li> <li> <strong>硬件支持</strong>：EIP 是控制程序执行流程的关键寄存器。CPU 会自动更新 EIP 的值，以指向下一条要执行的指令。跳转（<code class="language-plaintext highlighter-rouge">JMP</code>）、调用（<code class="language-plaintext highlighter-rouge">CALL</code>）和返回（<code class="language-plaintext highlighter-rouge">RET</code>）指令会修改 EIP 的值，以实现程序的控制流。</li> </ul> </li> </ol> <h5 id="312-段寄存器segment-registers">3.1.2 段寄存器（Segment Registers）</h5> <p>段寄存器用于分段内存管理，帮助 CPU 访问不同的内存段。 简单来说，段寄存器的值可以被认为是存储内存地址的一部分，来帮助 cpu 访问不同的内存段。 x86-32 架构中有六个段寄存器：</p> <ol> <li> <strong>CS（Code Segment）</strong>：代码段寄存器，指向当前执行代码的段。</li> <li> <strong>DS（Data Segment）</strong>：数据段寄存器，指向数据段。</li> <li> <strong>SS（Stack Segment）</strong>：堆栈段寄存器，指向堆栈段。</li> <li> <strong>ES（Extra Segment）</strong>：附加段寄存器，通常用于字符串操作。</li> <li> <strong>FS</strong>：附加段寄存器，通常用于线程本地存储（TLS）。</li> <li> <strong>GS</strong>：附加段寄存器，通常用于线程本地存储（TLS）。</li> </ol> <h5 id="313-控制寄存器control-registers">3.1.3 控制寄存器（Control Registers）</h5> <p>控制寄存器用于控制 CPU 的操作模式和状态。 完整地来说，控制寄存器存储 cpu 的一些状态位，以及一些关键状态变量，如一些关键地址。 x86-32 架构中有五个主要的控制寄存器：</p> <ol> <li> <strong>CR0</strong>：控制寄存器 0，控制 CPU 的操作模式（如保护模式和实模式）。</li> <li> <strong>CR1</strong>：保留，未使用。</li> <li> <strong>CR2</strong>：控制寄存器 2，存储导致页面错误的线性地址。</li> <li> <strong>CR3</strong>：控制寄存器 3，存储页目录基址，用于分页机制。</li> <li> <strong>CR4</strong>：控制寄存器 4，控制扩展功能（如分页扩展、调试扩展等）。 <ul> <li> <strong>VME（Virtual-8086 Mode Extensions）</strong>：启用虚拟 8086 模式扩展。</li> <li> <strong>PVI（Protected-Mode Virtual Interrupts）</strong>：启用保护模式虚拟中断。</li> <li> <strong>TSD（Time Stamp Disable）</strong>：禁用时间戳。</li> <li> <strong>DE（Debugging Extensions）</strong>：启用调试扩展。</li> <li> <strong>PSE（Page Size Extensions）</strong>：启用页面大小扩展。</li> <li> <strong>PAE（Physical Address Extension）</strong>：启用物理地址扩展。</li> <li> <strong>MCE（Machine Check Enable）</strong>：启用机器检查。</li> <li> <strong>PGE（Page Global Enable）</strong>：启用全局页面。</li> <li> <strong>PCE（Performance-Monitoring Counter Enable）</strong>：启用性能监控计数器。</li> <li> <strong>OSFXSR（Operating System Support for FXSAVE and FXRSTOR instructions）</strong>：操作系统支持 FXSAVE 和 FXRSTOR 指令。</li> <li> <strong>OSXMMEXCPT（Operating System Support for Unmasked SIMD Floating-Point Exceptions）</strong>：操作系统支持未屏蔽的 SIMD 浮点异常。</li> </ul> </li> </ol> <h5 id="314-调试寄存器debug-registers">3.1.4 调试寄存器（Debug Registers）</h5> <p>调试寄存器用于硬件断点和调试。x86-32 架构中有八个调试寄存器：</p> <ol> <li> <strong>DR0</strong>：调试寄存器 0，存储第一个断点地址。</li> <li> <strong>DR1</strong>：调试寄存器 1，存储第二个断点地址。</li> <li> <strong>DR2</strong>：调试寄存器 2，存储第三个断点地址。</li> <li> <strong>DR3</strong>：调试寄存器 3，存储第四个断点地址。</li> <li> <strong>DR4</strong>：保留，未使用。</li> <li> <strong>DR5</strong>：保留，未使用。</li> <li> <strong>DR6</strong>：调试状态寄存器，存储断点状态。</li> <li> <strong>DR7</strong>：调试控制寄存器，控制断点条件。</li> </ol> <h5 id="315-浮点寄存器floating-point-registers">3.1.5 浮点寄存器（Floating Point Registers）</h5> <p>浮点寄存器用于浮点运算。x86-32 架构中有八个 80 位的浮点寄存器，组成浮点堆栈：</p> <ol> <li> <strong>ST0</strong>：浮点堆栈寄存器 0。</li> <li> <strong>ST1</strong>：浮点堆栈寄存器 1。</li> <li> <strong>ST2</strong>：浮点堆栈寄存器 2。</li> <li> <strong>ST3</strong>：浮点堆栈寄存器 3。</li> <li> <strong>ST4</strong>：浮点堆栈寄存器 4。</li> <li> <strong>ST5</strong>：浮点堆栈寄存器 5。</li> <li> <strong>ST6</strong>：浮点堆栈寄存器 6。</li> <li> <strong>ST7</strong>：浮点堆栈寄存器 7。</li> </ol> <h5 id="316-simd-寄存器simd-registers">3.1.6 SIMD 寄存器（SIMD Registers）</h5> <p>SIMD 寄存器用于单指令多数据（SIMD）操作，支持多媒体和科学计算。x86-32 架构中有八个 128 位的 XMM 寄存器：</p> <ol> <li> <strong>XMM0</strong>：SIMD 寄存器 0。</li> <li> <strong>XMM1</strong>：SIMD 寄存器 1。</li> <li> <strong>XMM2</strong>：SIMD 寄存器 2。</li> <li> <strong>XMM3</strong>：SIMD 寄存器 3。</li> <li> <strong>XMM4</strong>：SIMD 寄存器 4。</li> <li> <strong>XMM5</strong>：SIMD 寄存器 5。</li> <li> <strong>XMM6</strong>：SIMD 寄存器 6。</li> <li> <strong>XMM7</strong>：SIMD 寄存器 7。</li> </ol> <h4 id="32-x86-64-寄存器和-x86-32-寄存器的不同">3.2 x86-64 寄存器和 x86-32 寄存器的不同？</h4> <ul> <li> <p><strong>通用寄存器</strong> RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, RIP 这些寄存器的能力和 32 位的一模一样。 为了表示区分，前缀换成了 R。</p> </li> <li> <p><strong>扩展通用寄存器</strong> R8-R15</p> </li> <li> <p><strong>段寄存器的变化</strong> 在 x86-64 架构中，段寄存器的使用有所减少。虽然段寄存器（如 CS、DS、SS、ES、FS、GS）仍然存在，但它们的作用被大大简化。大多数情况下，段寄存器的值被设置为零，除了 FS 和 GS 寄存器，它们仍然用于特定的系统级任务（如线程本地存储）。</p> </li> <li> <p><strong>SIMD 寄存器的扩展</strong> 在 x86-64 架构中，SIMD 寄存器也得到了扩展，以支持更高效的多媒体和科学计算：</p> <ul> <li> <strong>XMM0-XMM15</strong>：扩展的 128 位 SIMD 寄存器（在 x86-32 中只有 XMM0-XMM7）</li> <li> <strong>YMM0-YMM15</strong>：256 位 SIMD 寄存器（用于 AVX 指令集）</li> <li> <strong>ZMM0-ZMM31</strong>：512 位 SIMD 寄存器（用于 AVX-512 指令集）</li> </ul> </li> <li> <p><strong>控制寄存器的变化</strong> 在 x86-64 架构中，控制寄存器（如 CR0、CR2、CR3、CR4）仍然存在，并且功能基本保持不变。然而，x86-64 架构引入了新的控制寄存器来支持扩展的功能：</p> <ul> <li> <strong>CR8</strong>：用于控制任务优先级（Task Priority Register, TPR）</li> </ul> </li> <li> <p><strong>标志寄存器的变化</strong> 在 x86-64 架构中，标志寄存器（EFLAGS）扩展为 64 位，称为 RFLAGS。RFLAGS 寄存器包含了更多的状态位，用于控制和反映 CPU 的状态。</p> </li> </ul> <h3 id="4-汇编的堆栈是什么">4. 汇编的堆栈是什么？</h3> <p>在汇编语言中，堆栈是一种重要的数据结构，用于存储函数调用、局部变量和返回地址等信息。堆栈是一种“后进先出”（LIFO）的数据结构，最后放入堆栈的元素将首先被取出。</p> <p>在 x86 架构的汇编语言中，堆栈操作主要涉及到两个寄存器：ESP 和 EBP。</p> <ul> <li> <p><strong>ESP（Stack Pointer）</strong>：这个寄存器总是指向堆栈的顶部，即最后一个被压入堆栈的元素。</p> </li> <li> <p><strong>EBP（Base Pointer）</strong>：这个寄存器通常用作帧指针，在函数调用时保存堆栈的底部位置。</p> </li> </ul> <p>以下是一些常见的堆栈操作：</p> <ul> <li> <p><strong>PUSH</strong>：将一个值压入堆栈。这个操作会将 ESP 寄存器减小（因为在 x86 架构中，堆栈从高地址向低地址增长），然后将值存储在 ESP 指向的新位置。</p> </li> <li> <p><strong>POP</strong>：从堆栈中弹出一个值。这个操作会将 ESP 指向的值复制到指定的位置，然后将 ESP 寄存器增大。</p> </li> <li> <p><strong>CALL</strong>：调用一个函数。这个操作会将返回地址（即 CALL 指令后面的地址）压入堆栈，然后跳转到函数的地址。</p> </li> <li> <p><strong>RET</strong>：从函数返回。这个操作会从堆栈中弹出返回地址，然后跳转到这个地址。</p> </li> </ul> <p>在函数调用中，通常会有一个称为“函数前奏”的部分，用于保存旧的 EBP 值并设置新的 EBP 值，以及一个称为“函数尾声”的部分，用于恢复旧的 EBP 值。这样可以在函数中使用 EBP 寄存器来访问参数和局部变量，而不会影响到其他函数的堆栈帧。</p> <h3 id="5-汇编到c的高级抽象">5. 汇编到c++的高级抽象</h3> <h4 id="51-汇编是如何处理函数的">5.1 汇编是如何处理函数的？</h4> <p>在汇编语言中，函数被处理为一段可以从其他地方调用的代码块。这个代码块有一个入口点（函数开始的地方）和一个或多个出口点（函数返回的地方）。</p> <p>当一个函数被调用时，程序的控制流会跳转到函数的入口点，开始执行函数内的代码。当函数完成后，控制流会跳转回到函数被调用的地方。</p> <p>函数的参数通常通过堆栈或寄存器传递。返回值也是如此。具体的传递方式取决于所使用的调用约定。</p> <p>以下是一个简单的汇编函数示例（使用 x86 汇编）：</p> <pre><code class="language-assembly">section .text
global _start

_start:
    ; Call the function with argument 5
    push 5
    call my_function
    add esp, 4  ; Clean up the stack
    ; ...

my_function:
    ; Function prologue
    push ebp
    mov ebp, esp

    ; The function's argument is now at [ebp + 8]
    mov eax, [ebp + 8]  ; Move the argument into eax

    ; Function epilogue
    mov esp, ebp
    pop ebp
    ret
</code></pre> <p>在这个例子中，<code class="language-plaintext highlighter-rouge">my_function</code> 是一个函数，它接受一个参数（通过堆栈传递）。函数的开始部分（函数前奏）设置了一个新的堆栈帧，函数的结束部分（函数尾声）清理了堆栈帧并返回到函数被调用的地方。</p> <h4 id="52-汇编没有自定义类型的概念c是怎么实现自定义类型这个概念的">5.2 汇编没有自定义类型的概念，C++是怎么实现自定义类型这个概念的？</h4> <h5 id="521-成员变量">5.2.1 成员变量</h5> <p>C++ 中的自定义类型（如类和结构体）在编译时会被转换为一种或多种基本类型的组合。编译器会为每个自定义类型生成一种布局，这种布局定义了类型的每个成员在内存中的位置。</p> <p>例如，如果你在 C++ 中定义了一个类：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>编译器可能会为这个类生成如下的内存布局：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+---------+
|   a     |  4 bytes
+---------+
|   b     |  8 bytes
+---------+
</code></pre></div></div> <p>在这个布局中，<code class="language-plaintext highlighter-rouge">a</code> 占用了前 4 个字节，<code class="language-plaintext highlighter-rouge">b</code> 占用了接下来的 8 个字节。当你创建一个 <code class="language-plaintext highlighter-rouge">MyClass</code> 的实例时，编译器会在内存中为这个实例分配 12 个字节的空间。</p> <p>当你访问 <code class="language-plaintext highlighter-rouge">MyClass</code> 的成员时，例如 <code class="language-plaintext highlighter-rouge">myObject.a</code>，编译器会生成汇编代码，这些代码会计算 <code class="language-plaintext highlighter-rouge">a</code> 在内存中的位置，并从这个位置读取或写入数据。</p> <p>因此，虽然汇编语言没有自定义类型的概念，但是通过内存布局和地址计算，编译器可以实现 C++ 的自定义类型。</p> <h5 id="522-成员函数">5.2.2 成员函数</h5> <p>C++中的类成员函数在汇编中的实现主要依赖于”this”指针。”this”指针是一个隐含的参数，它在每个非静态成员函数中都存在，指向调用该成员函数的对象。</p> <p>例如，考虑以下 C++代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">setA</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>在这个例子中，<code class="language-plaintext highlighter-rouge">setA</code>函数在汇编层面上看起来可能类似于一个普通的函数，它接受两个参数：一个是”this”指针，指向要修改的对象；另一个是要设置的值。在函数内部，它使用”this”指针来访问和修改对象的成员。</p> <p>当你调用<code class="language-plaintext highlighter-rouge">myObject.setA(10);</code>时，编译器实际上会生成类似于以下的代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">setA</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myObject</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</code></pre></div></div> <p>这里，<code class="language-plaintext highlighter-rouge">&amp;myObject</code>就是”this”指针，它被传递给<code class="language-plaintext highlighter-rouge">setA</code>函数，以便函数知道要操作哪个对象。</p> <p>需要注意的是，这只是一种可能的实现方式，具体的实现可能会因编译器和目标平台的不同而有所不同。例如，”this”指针可能会通过寄存器而不是通过堆栈来传递，这取决于具体的调用约定。</p> <h4 id="53-汇编是如何实现多态的">5.3 汇编是如何实现多态的？</h4> <p>在汇编语言中，多态的实现主要依赖于间接寻址和跳转表。这些概念在高级语言如 C++ 中的虚函数和虚函数表（vtable）中有所体现。</p> <p>在 C++ 中，当一个类有虚函数时，编译器会为该类生成一个虚函数表。这个表包含了指向类的每个虚函数的指针。每个类的对象都有一个指向这个表的指针。当我们通过基类指针调用虚函数时，实际上是通过这个表来查找并调用正确的函数。</p> <p>在汇编层面，这个过程可以被分解为以下步骤：</p> <ol> <li>从对象的内存中加载虚函数表的地址。</li> <li>使用虚函数在表中的偏移量来从表中加载函数的地址。</li> <li>使用加载的地址来间接调用函数。</li> </ol> <p>以下是一个简化的示例，展示了这个过程（使用伪汇编）：</p> <pre><code class="language-assembly">; 假设 obj 是对象的地址，vtable_offset 是虚函数表的偏移量，
; func_offset 是函数在虚函数表中的偏移量

mov eax, [obj + vtable_offset]  ; 加载虚函数表的地址
mov eax, [eax + func_offset]    ; 加载函数的地址
call eax                        ; 调用函数
</code></pre> <p>这就是在汇编层面实现多态的基本方式。具体的实现可能会因编译器和目标平台的不同而有所不同。</p> <h4 id="54-汇编是如何处理不定长参数的">5.4 汇编是如何处理不定长参数的？</h4> <p>在汇编语言中，处理不定长参数通常依赖于堆栈和约定。在 C 语言中，这种情况通常出现在如 printf 这样的函数中，它们可以接受任意数量的参数。</p> <p>在 x86 架构的汇编语言中，函数的参数通常通过堆栈传递。对于不定长参数的函数，所有的参数都会被压入堆栈，然后函数会根据需要从堆栈中取出参数。</p> <p>例如，考虑以下的 C 函数：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在这个函数中，<code class="language-plaintext highlighter-rouge">count</code> 参数告诉函数有多少个额外的参数。函数使用 <code class="language-plaintext highlighter-rouge">va_arg</code> 宏来从堆栈中取出这些参数。</p> <p>在汇编层面，这个过程可能看起来像这样（使用伪汇编）：</p> <pre><code class="language-assembly">; 假设 ebp 是堆栈帧的基址，count 是在 [ebp + 8] 的位置

mov ecx, [ebp + 8]  ; 加载 count
add ebp, 12         ; 跳过 count 参数
mov eax, 0          ; 初始化 total 为 0

sum_loop:
    add eax, [ebp]  ; 添加下一个参数到 total
    add ebp, 4      ; 移动到下一个参数
    dec ecx         ; 减少 count
    jnz sum_loop    ; 如果 count 不为 0，继续循环

; 此时，eax 包含总和
</code></pre> <p>这只是一个简化的示例，实际的实现可能会更复杂，并且可能会因编译器和目标平台的不同而有所不同。</p> <h3 id="2-汇编基础">2. 汇编基础</h3> <h4 id="21-理解-push-pop-指令的等效过程">2.1 理解 Push ,Pop 指令的等效过程</h4> <h5 id="push-指令"> <code class="language-plaintext highlighter-rouge">push</code> 指令</h5> <p><code class="language-plaintext highlighter-rouge">push</code> 指令用于将数据压入栈中。它的等效过程可以分为两步：</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">push</span> <span class="nb">eax</span><span class="c1">;</span>
<span class="o">//</span> <span class="err">等同于两条伪指令</span>
<span class="err">1</span><span class="nf">.</span> <span class="nv">sub</span> <span class="nb">esp</span><span class="p">,</span> <span class="mi">4</span><span class="c1">;   // 将 esp 减 4，因为栈向下生长，伪指令，仅供理解</span>
<span class="err">2</span><span class="nf">.</span> <span class="nv">mov</span> <span class="p">[</span><span class="nb">esp</span><span class="p">],</span> <span class="nb">eax</span><span class="c1">; // 将 eax 放到 esp 指向的内存中，伪指令，仅供理解</span>
</code></pre></div></div> <p>解释：</p> <ol> <li> <code class="language-plaintext highlighter-rouge">sub esp, 4</code>：将栈指针 <code class="language-plaintext highlighter-rouge">esp</code> 减少 4 个字节，因为栈是向下生长的。</li> <li> <code class="language-plaintext highlighter-rouge">mov [esp], eax</code>：将 <code class="language-plaintext highlighter-rouge">eax</code> 寄存器的值存储到 <code class="language-plaintext highlighter-rouge">esp</code> 指向的内存位置。</li> </ol> <h5 id="pop-指令"> <code class="language-plaintext highlighter-rouge">pop</code> 指令</h5> <p><code class="language-plaintext highlighter-rouge">pop</code> 指令用于从栈中弹出数据。它的等效过程可以分为两步：</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">pop</span> <span class="nb">eax</span><span class="c1">;</span>
<span class="o">//</span> <span class="err">等同于两条伪指令</span>
<span class="err">1</span><span class="nf">.</span> <span class="nv">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">esp</span><span class="p">]</span><span class="c1">; // 将 esp 指向的内存值放到 eax 中，伪指令，仅供理解</span>
<span class="err">2</span><span class="nf">.</span> <span class="nv">add</span> <span class="nb">esp</span><span class="p">,</span> <span class="mi">4</span><span class="c1">;    // 将 esp 加 4，因为栈向下生长，伪指令，仅供理解</span>
</code></pre></div></div> <p>解释：</p> <ol> <li> <code class="language-plaintext highlighter-rouge">mov eax, [esp]</code>：将 <code class="language-plaintext highlighter-rouge">esp</code> 指向的内存位置的值加载到 <code class="language-plaintext highlighter-rouge">eax</code> 寄存器中。</li> <li> <code class="language-plaintext highlighter-rouge">add esp, 4</code>：将栈指针 <code class="language-plaintext highlighter-rouge">esp</code> 增加 4 个字节，因为栈是向下生长的。</li> </ol> <h4 id="22-深入理解-calljmpret-指令的等效过程">2.2 深入理解 call,jmp,ret 指令的等效过程</h4> <h5 id="call-指令"> <code class="language-plaintext highlighter-rouge">call</code> 指令</h5> <p><code class="language-plaintext highlighter-rouge">call</code> 指令用于调用一个函数。它的等效过程可以分为三步：</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">call</span> <span class="err">内存</span><span class="o">/</span><span class="err">立即数</span><span class="o">/</span><span class="err">寄存器</span><span class="c1">;</span>
<span class="o">//</span> <span class="err">等同于三条伪指令</span>
<span class="err">1</span><span class="nf">.</span> <span class="nv">push</span> <span class="nv">eip</span><span class="c1">;   // 将当前 EIP（下一条指令的地址）压入栈中</span>
<span class="err">2</span><span class="nf">.</span> <span class="nv">mov</span> <span class="nv">eip</span><span class="p">,</span> <span class="err">目标地址</span><span class="c1">; // 将 EIP 修改为目标地址</span>
<span class="err">3</span><span class="nf">.</span> <span class="nv">jmp</span> <span class="nv">eip</span><span class="c1">;    // 跳转到新的 EIP 执行</span>
</code></pre></div></div> <p>解释：</p> <ol> <li>将当前指令的下一条指令地址（EIP）压入栈中，以便函数返回时使用。</li> <li>将 EIP 修改为目标函数的地址。</li> <li>跳转到新的 EIP 执行目标函数。</li> </ol> <h5 id="jmp-指令"> <code class="language-plaintext highlighter-rouge">jmp</code> 指令</h5> <p><code class="language-plaintext highlighter-rouge">jmp</code> 指令用于无条件跳转到指定地址。它的等效过程可以分为两步：</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">jmp</span> <span class="err">内存</span><span class="o">/</span><span class="err">立即数</span><span class="o">/</span><span class="err">寄存器</span><span class="c1">;</span>
<span class="o">//</span> <span class="err">等同于两条伪指令</span>
<span class="err">1</span><span class="nf">.</span> <span class="nv">mov</span> <span class="nv">eip</span><span class="p">,</span> <span class="err">目标地址</span><span class="c1">; // 将 EIP 修改为目标地址</span>
<span class="err">2</span><span class="nf">.</span> <span class="nv">jmp</span> <span class="nv">eip</span><span class="c1">;    // 跳转到新的 EIP 执行</span>
</code></pre></div></div> <p>解释：</p> <ol> <li>将 EIP 修改为目标地址。</li> <li>跳转到新的 EIP 执行目标地址的指令。</li> </ol> <h5 id="ret-指令"> <code class="language-plaintext highlighter-rouge">ret</code> 指令</h5> <p><code class="language-plaintext highlighter-rouge">ret</code> 指令用于从函数返回。它的等效过程可以分为三步：</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">ret</span><span class="c1">;</span>
<span class="o">//</span> <span class="err">等同于三条伪指令</span>
<span class="err">1</span><span class="nf">.</span> <span class="nv">mov</span> <span class="nv">eip</span><span class="p">,</span> <span class="p">[</span><span class="nb">esp</span><span class="p">]</span><span class="c1">; // 将栈顶数据（返回地址）加载到 EIP 中</span>
<span class="err">2</span><span class="nf">.</span> <span class="nv">add</span> <span class="nb">esp</span><span class="p">,</span> <span class="mi">4</span><span class="c1">;    // 将 esp 加 4，恢复栈指针</span>
<span class="err">3</span><span class="nf">.</span> <span class="nv">jmp</span> <span class="nv">eip</span><span class="c1">;    // 跳转到新的 EIP 执行</span>
</code></pre></div></div> <p>解释：</p> <ol> <li>将栈顶数据（返回地址）加载到 EIP 中。</li> <li>将栈指针 <code class="language-plaintext highlighter-rouge">esp</code> 增加 4 个字节，恢复栈指针。</li> <li>跳转到新的 EIP 执行返回地址的指令。</li> </ol> <p>通过理解 <code class="language-plaintext highlighter-rouge">push</code>、<code class="language-plaintext highlighter-rouge">pop</code>、<code class="language-plaintext highlighter-rouge">call</code>、<code class="language-plaintext highlighter-rouge">jmp</code> 和 <code class="language-plaintext highlighter-rouge">ret</code> 指令的等效过程，可以更深入地理解函数调用和返回的底层机制。我们可以不用 call 指令来调用一个函数，完全来模拟函数调用，只需要手动的将函数要返回的下条指令所对应 EIP 的值压入栈，然后分配栈内存，手动的 jmp 到我们想跳转的函数地址。</p> <h4 id="23-获取-eip-的值">2.3 获取 EIP 的值</h4> <p>获取 EIP/RIP 的值对于协程的实现非常重要，因为有了 EIP/RIP 的值，我们就可以知道当前执行的位置，并且可以在需要时跳转到这个位置，从而实现协程的手动切换。以下是几种获取 EIP/RIP 值的方法：</p> <ul> <li><strong>使用内置函数获取返回地址</strong></li> </ul> <p>在 Clang 编译器下，可以使用内置函数 <code class="language-plaintext highlighter-rouge">__builtin_return_address</code> 来获取返回地址：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">infoPtr</span><span class="o">-&gt;</span><span class="n">reRIP</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</code></pre></div></div> <p>这个函数返回当前函数的返回地址，即 EIP/RIP 的值。类似的函数在 Windows 平台上也存在，但具体名称可能不同。</p> <ul> <li> <strong>使用汇编获取返回地址</strong> 我们也可以使用汇编代码来获取 EIP/RIP 的值。以下是一个在 Windows 平台上使用 MSVC 编译器的示例：</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">__declspec</span><span class="p">(</span><span class="kr">naked</span><span class="p">)</span> <span class="kt">int</span> <span class="kr">__stdcall</span> <span class="nf">CoroutineGetRIP</span><span class="p">()</span> <span class="p">{</span>
    <span class="kr">__asm</span> <span class="p">{</span>
        <span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="p">[</span><span class="n">esp</span><span class="p">]</span>  <span class="c1">// 将栈顶的返回地址（EIP）移动到 eax 寄存器</span>
        <span class="n">ret</span>             <span class="c1">// 返回</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>在这个示例中，<code class="language-plaintext highlighter-rouge">__declspec(naked)</code> 关键字表示函数没有标准的函数前序和后序代码，允许我们完全控制函数的入口和出口。<code class="language-plaintext highlighter-rouge">mov eax, [esp]</code> 指令将栈顶的返回地址（EIP）移动到 <code class="language-plaintext highlighter-rouge">eax</code> 寄存器，然后 <code class="language-plaintext highlighter-rouge">ret</code> 指令返回。</p> <ul> <li><strong>使用标签获取当前地址</strong></li> </ul> <p>我们还可以使用汇编中的标签来获取当前地址。这种方法在需要知道机器码长度并强行加指令大小时非常有用：</p> <div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">__asm</span> <span class="err">{</span>
    <span class="nf">call</span> <span class="nv">NEXT</span>  <span class="o">//</span> <span class="err">调用</span> <span class="nv">NEXT</span> <span class="err">标签</span>
    <span class="nl">NEXT:</span>
    <span class="nf">pop</span> <span class="nb">eax</span>    <span class="o">//</span> <span class="err">将返回地址（</span><span class="nv">EIP</span><span class="err">）弹出到</span> <span class="nb">eax</span> <span class="err">寄存器</span>
<span class="err">}</span>
</code></pre></div></div> <p>在这个示例中，<code class="language-plaintext highlighter-rouge">call NEXT</code> 指令将当前 EIP 压入栈中并跳转到 <code class="language-plaintext highlighter-rouge">NEXT</code> 标签，<code class="language-plaintext highlighter-rouge">pop eax</code> 指令将栈顶的返回地址（EIP）弹出到 <code class="language-plaintext highlighter-rouge">eax</code> 寄存器。</p> <p>在协程实现中，获取 EIP/RIP 的过程可能比较隐蔽，尤其是在使用 Boost 库的汇编版本时，但核心原理是相同的。通过获取和保存 EIP/RIP 的值，可以在需要时恢复协程的执行位置，从而实现协程的切换。</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_%E6%80%BB%E7%BA%BF.md/">总线</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_coroutine.md/">coroutine了解</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_process.md/">进程</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_io.md/">磁盘结构</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/1_threads.md/">c++的多线程</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>