<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> C++对象的内存模型设计 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/0_cppMemModel.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">C++对象的内存模型设计</h1> <p class="post-meta"> Created on April 12, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/cpp"> <i class="fa-solid fa-hashtag fa-sm"></i> cpp</a>   <a href="/blog/tag/grammar"> <i class="fa-solid fa-hashtag fa-sm"></i> grammar</a>   <a href="/blog/tag/class"> <i class="fa-solid fa-hashtag fa-sm"></i> class</a>   ·   <a href="/blog/category/language"> <i class="fa-solid fa-tag fa-sm"></i> language</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="c对象的内存模型设计">C++对象的内存模型设计</h2> <h3 id="0-prerequisites">0. prerequisites</h3> <ul> <li><strong>什么是对象？为什么要有对象？</strong></li> </ul> <p>在长久的 c/c++开发来说，逐渐发展出来三种开发范式</p> <ul> <li>面向过程编程： <ul> <li>像 C 一样，普通的程序</li> </ul> </li> <li>抽象数据类型模型（ADT）： <ul> <li>提供封装和抽象的能力。</li> </ul> </li> <li>面向对象模型： <ul> <li>在 ADT 的基础上，增加继承和多态。</li> <li>C++通过 class 的 pointers 和 references 来支持多态，这种程序设计风格被称为“面向对象”。</li> </ul> </li> </ul> <p>这三种范式反映的其实是对数据结构的不同要求，面向过程这种范式不强调数据结构的概念，最多就是<code class="language-plaintext highlighter-rouge">struct</code>封装一些成员变量。 而当业务逐渐复杂起来，这些成员变量会有大量相关的函数，那将这些成员函数和成员变量绑定到一块，其实也就是 ADT编程了； 而进一步的，但这些数据结构需要有继承关系的时候，然后需要有多态的时候，也就是面向对象编程oop了。</p> <h3 id="1-对象内存模型的设计">1. 对象内存模型的设计</h3> <p>而对象内存模型的设计，其实说白了就是 c++如何以零抽象成本实现，封装，继承，多态。 而 C++内存对象模型的设计，实际上是 C++编译器这一层的工作。c++编译器其实就是将 C++翻译成汇编语言的，而汇编语言操作的是硬件对象，无非就是是内存和寄存器上的读写操作，以及 cpu 的计算操作。 再具体一点，结合 C++对象的需求展开，C++零抽象成本实现对象需要考虑的就是，如何从编译器层面（或者说汇编层面，又或者说怎么操作寄存器和 ALU 等等）实现以下这些：</p> <ul> <li>成员变量和成员函数的存储</li> <li>成员函数的使用</li> <li>静态成员变量和静态成员函数的存储以及使用</li> <li>继承对象的存储和实现</li> <li>多态的实现</li> </ul> <h4 id="11-成员变量和成员函数的存储">1.1 成员变量和成员函数的存储？</h4> <ul> <li>成员变量的存储</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>
<span class="n">foo</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
</code></pre></div></div> <p>对于编译器来说<code class="language-plaintext highlighter-rouge">foo</code>是一个栈上的值，基于这个值所在的地址，进行与<code class="language-plaintext highlighter-rouge">a</code>相关特定的偏移值，按照<code class="language-plaintext highlighter-rouge">int</code>类型去读值，就可以得到<code class="language-plaintext highlighter-rouge">a</code>了。</p> <ul> <li>访问限制符号 public/ private/ protected 正如我前面说的，汇编层不会有这些概念。 这些操作实际上都是编译器去限制函的调用。 编译器识别到如果在外部调用 private 函数的时候，就中断了编译。 因此，如果查编译器内存布局规则，计算偏移值，通过偏移的方式是可以取<code class="language-plaintext highlighter-rouge">private</code>的成员变量的。</li> </ul> <h4 id="12-成员函数如何存储和使用">1.2 成员函数如何存储和使用？</h4> <ul> <li>成员函数的存储</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">func1</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">func2</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>
<span class="n">foo</span><span class="p">.</span><span class="n">func1</span><span class="p">();</span>
</code></pre></div></div> <p>一般的成员函数实际起到的就是封装，和非成员函数相比，编译器的做法都是差不多的。 唯一不同的是，调用成员函数实际上，会隐式带着一个<code class="language-plaintext highlighter-rouge">this</code>指针。 即调用<code class="language-plaintext highlighter-rouge">foo.func1()</code>等价于调用非成员函数的<code class="language-plaintext highlighter-rouge">xcvvd_foo_func1(this)</code>。 前面的<code class="language-plaintext highlighter-rouge">xcvvd</code>是 c++为了支持函数重载做的符号调整，一般还会带上类名信息，以及传入一个 this 指针，当内部使用成员变量的时候，编译器能够解读，并自动补上 this，所以是根据 this 然后偏移地址去读写值。</p> <h4 id="13-静态成员变量和静态成员函数的存储和使用">1.3 静态成员变量和静态成员函数的存储和使用</h4> <ul> <li> <p>静态成员变量 同理，其实和普通的静态变量是一样的，只是需要藏在对象里面，实现了封装的目的而已。 静态成员变量和静态变量都是存在静态区，和类无关。</p> </li> <li> <p>静态成员函数 如果和静态函数对比的话，其实有点不妥。 因为静态函数的<code class="language-plaintext highlighter-rouge">static</code>表示的是静态函数的作用域被限制在定义它的源文件内，其他源文件无法访问该函数。</p> </li> </ul> <p>而静态成员函数表明的是，函数在这个类的内部，但是不会传 this 指针的。 注意的是，因为静态成员函数在内部，所以其实这个函数是可以访问私有成员的。</p> <h4 id="14-继承的实现">1.4 继承的实现</h4> <p>对于基类的成员变量来说，基类的数据成员直接放在派生类对象中。 对于基类的非虚成员函数来说，也没有特别操作。</p> <p>而为了解决菱形继承问题，即基类不管被派生多少次，永远只会存在一个实例（subobjet），则需要添加一个指针，指向一个 base table。 即将公共数据放在一个表格上</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">virtual</span> <span class="n">A</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">virtual</span> <span class="n">A</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">c</span><span class="p">;</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span><span class="p">,</span> <span class="k">public</span> <span class="n">C</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">d</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div></div> <p>B 有一个<code class="language-plaintext highlighter-rouge">vbptr</code>指向 A 的数据，C 也有一个<code class="language-plaintext highlighter-rouge">vbptr</code>指向 A 的数据。 <code class="language-plaintext highlighter-rouge">D.a</code>使用哪一个<code class="language-plaintext highlighter-rouge">vbptr</code>则取决于编译器了。</p> <h4 id="15-多态的实现">1.5 多态的实现</h4> <p>类的多态主要说的是虚函数。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">();</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="p">};</span>
<span class="n">A</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">B</span><span class="p">();</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span>
</code></pre></div></div> <p>编译器能够知道这个<code class="language-plaintext highlighter-rouge">foo</code>是一个虚函数，也能够知道是第几个。 因此<code class="language-plaintext highlighter-rouge">b-&gt;foo()</code>其实类似于<code class="language-plaintext highlighter-rouge">b-&gt;virtualFunTable[0]()</code>。 <code class="language-plaintext highlighter-rouge">virtualFunTable[0]</code>是 b 的虚函数表，偏移是编译器能够算出来的。 编译器是要知道<code class="language-plaintext highlighter-rouge">foo()</code>这个符号，和函数地址的映射关系的，知道偏移地址也是理所应当的。 取出这个函数，再调用一下。 而<code class="language-plaintext highlighter-rouge">new B()</code>的时候，是按照<code class="language-plaintext highlighter-rouge">B</code>去构造的，得到的<code class="language-plaintext highlighter-rouge">b</code>的<code class="language-plaintext highlighter-rouge">virtualFunTable</code>这个虚函数表就是 B 的。</p> <blockquote> <p>A 也有这个表，如果是<code class="language-plaintext highlighter-rouge">new A()</code>，就是 A 的虚函数表。</p> </blockquote> <h4 id="16-类对象所占的空间">1.6 类对象所占的空间</h4> <ol> <li>成员函数无论是静态还是非静态，都不占用对象空间。</li> <li>静态成员变量跟着类走，不占用对象的空间。</li> <li> <p>虚函数表是基于类的，类对象持有一个指针指向这个表就可以了，这个表的 size 不属于类对象的。因此虚函数，无论有几个，都只占用一个函数指针大小的对象空间。</p> </li> <li>非静态成员变量跟着对象走，占用类对象的空间。</li> <li>如果类中有多个数据成员，编译器为了提高访问速度和性能，会字节对齐。</li> <li>非静态的数据成员</li> <li>虚继承的话，就再多一个指针</li> </ol> <p>一个类只要有虚函数，类对象就会有虚函数表指针(vptr)，虚函数表指针指向虚函数表(vtbl)。</p> <p><img src="./imgs/3_class_image.png" alt="alt text"></p> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-class-和-struct-的区别">1. class 和 struct 的区别</h4> <p>struct 的默认访问修饰符是 public；而 class 的默认访问修饰符是 private。 除此之外使用时没有区别。</p> <p>但是他们背后直接承载的设计意义有一定区别。 class 它还会引入它所支持的封装和继承的哲学，是 oop 概念的 而 struct 作为 c 语言的关键字，更多时候是作为纯粹数据类型集合而存在的，C 语言的 struct 没有继承，也没有成员函数。</p> <h4 id="2-空类对象所占的空间是多少为什么">2. 空类对象所占的空间是多少，为什么？</h4> <p>1byte。这是为了确保每个空类对象都有一个唯一的地址，从而使得不同的空类对象在内存中是可区分的。</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_%E6%80%BB%E7%BA%BF.md/">总线</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_coroutine.md/">coroutine了解</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_process.md/">进程</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_io.md/">磁盘结构</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/1_threads.md/">c++的多线程</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>