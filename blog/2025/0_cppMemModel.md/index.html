<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> （一）C++对象内存模型那些事儿：基本概念 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A blog for documenting my own study notes. "> <meta name="keywords" content="blog, cpp, programmer"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/toc-custom.css"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/0_cppMemModel.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-8"> <div class="post"> <header class="post-header"> <h1 class="post-title">（一）C++对象内存模型那些事儿：基本概念</h1> <p class="post-meta"> Created on September 15, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/class"> <i class="fa-solid fa-hashtag fa-sm"></i> Class</a>   ·   <a href="/blog/category/c"> <i class="fa-solid fa-tag fa-sm"></i> C++</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="一c对象内存模型那些事儿基本概念">（一）C++对象内存模型那些事儿：基本概念</h2> <h3 id="0-引言为什么需要对象">0. 引言：为什么需要对象？</h3> <p>在 C/C++的发展历程中，逐渐形成了三种主要的编程范式，每种范式都是为了解决特定的问题：</p> <h4 id="面向过程编程">面向过程编程</h4> <p>面向过程编程以 C 语言为代表，程序被看作是一系列函数的集合，强调执行的过程和步骤。数据和操作是分离的，最多通过<code class="language-plaintext highlighter-rouge">struct</code>封装一些成员变量。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">num1</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">num1</span><span class="p">,</span> <span class="n">num2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"两数之和为: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这种方式适用于简单程序，但随着业务复杂度增加，维护和复用变得困难。</p> <h4 id="抽象数据类型模型adt">抽象数据类型模型（ADT）</h4> <p>ADT 将数据结构和操作该数据的函数封装在一起，形成独立单元，对外隐藏实现细节，只暴露必要接口。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Stack</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">topIndex</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">Stack</span><span class="p">()</span> <span class="o">:</span> <span class="n">topIndex</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">topIndex</span> <span class="o">&lt;</span> <span class="mi">99</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">[</span><span class="o">++</span><span class="n">topIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">topIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">topIndex</span><span class="o">--</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 栈空错误</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Stack</span> <span class="n">stack</span><span class="p">;</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"弹出元素: "</span> <span class="o">&lt;&lt;</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在这个栈的 ADT 实现中，数据（<code class="language-plaintext highlighter-rouge">data</code>数组和<code class="language-plaintext highlighter-rouge">topIndex</code>）和操作它们的函数（<code class="language-plaintext highlighter-rouge">push</code>和<code class="language-plaintext highlighter-rouge">pop</code>）被封装在<code class="language-plaintext highlighter-rouge">Stack</code>类中，使用者无需了解栈的内部实现细节，只需通过提供的接口进行操作。</p> <h4 id="面向对象模型">面向对象模型</h4> <p>面向对象在 ADT 基础上增加了继承和多态特性，通过指针和引用支持动态绑定。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"动物发出声音"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Animal</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// 虚析构函数</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Dog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"汪汪汪"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cat</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"喵喵喵"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">makeSound</span><span class="p">(</span><span class="n">Animal</span><span class="o">&amp;</span> <span class="n">animal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">animal</span><span class="p">.</span><span class="n">speak</span><span class="p">();</span> <span class="c1">// 多态调用</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Dog</span> <span class="n">dog</span><span class="p">;</span>
    <span class="n">Cat</span> <span class="n">cat</span><span class="p">;</span>
    <span class="n">makeSound</span><span class="p">(</span><span class="n">dog</span><span class="p">);</span> <span class="c1">// 输出: 汪汪汪</span>
    <span class="n">makeSound</span><span class="p">(</span><span class="n">cat</span><span class="p">);</span> <span class="c1">// 输出: 喵喵喵</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>面向对象编程通过继承和多态进一步增强了代码的灵活性和扩展性。</p> <p>这三种范式的演进反映了随着业务需求的变化，对数据结构的不同要求。面向过程编程适用于简单的程序逻辑，随着业务复杂度增加，ADT 通过封装和抽象提升了代码的可维护性和复用性，而面向对象编程则在 ADT 的基础上，通过继承和多态进一步增强了代码的灵活性和扩展性，更好地应对复杂的业务场景。</p> <p>封装，继承和多态实际上都是为了适应变化快，业务复杂的场景下逐渐总结出来的一种范式。</p> <p>虽然现代语言（如 Go、Rust）更倾向于组合而非继承，但理解 C++的 OOP 实现机制仍然很有价值。</p> <p>本文将深入探讨编译器如何在底层支持 OOP 特性，实现零抽象成本的封装、继承和多态。</p> <h3 id="1-对象内存模型的设计原理">1. 对象内存模型的设计原理</h3> <p>C++对象内存模型的核心目标是以零抽象成本实现封装、继承和多态。由于 C++是编译型语言，需要转换为汇编语言执行，因此理解 OOP 的零成本实现，实际上就是理解编译器如何在汇编层面实现以下功能：</p> <ul> <li>成员变量和成员函数的存储与访问</li> <li>静态成员变量和静态成员函数的存储以及使用</li> <li>继承关系的内存布局</li> <li>多态的虚函数机制</li> </ul> <h4 id="11-成员变量和成员函数的存储机制">1.1 成员变量和成员函数的存储机制</h4> <h5 id="成员变量的内存布局">成员变量的内存布局</h5> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>      <span class="c1">// 偏移量: 0</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>      <span class="c1">// 偏移量: 4 (假设int为4字节)</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>    <span class="c1">// foo对象在栈上分配</span>
    <span class="n">foo</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 访问偏移量0处的数据</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>编译器处理成员变量访问的机制：</p> <ol> <li> <code class="language-plaintext highlighter-rouge">foo</code>对象在栈上有固定地址</li> <li>成员变量按声明顺序存储，编译器计算每个成员的偏移量</li> <li>访问<code class="language-plaintext highlighter-rouge">foo.a</code>时，编译器使用<code class="language-plaintext highlighter-rouge">foo地址 + 偏移量</code>的方式定位数据</li> </ol> <h5 id="访问控制的实现">访问控制的实现</h5> <p><code class="language-plaintext highlighter-rouge">public</code>、<code class="language-plaintext highlighter-rouge">private</code>、<code class="language-plaintext highlighter-rouge">protected</code>等访问控制符只在编译期生效：</p> <ul> <li>编译器在语法分析阶段检查访问权限</li> <li>违反访问控制的代码会产生编译错误</li> <li>在汇编层面不存在访问控制概念</li> </ul> <p><strong>注意</strong>：理论上可以通过计算偏移量访问<code class="language-plaintext highlighter-rouge">private</code>成员，但这严重违反封装原则，在实际编程中不应使用。</p> <h4 id="12-成员函数的存储和调用机制">1.2 成员函数的存储和调用机制</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">func1</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">func2</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>
    <span class="n">foo</span><span class="p">.</span><span class="n">func1</span><span class="p">();</span> <span class="c1">// 等价于 Foo::func1(&amp;foo)</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>从编译器角度看，成员函数与非成员函数的处理有相似之处，但存在关键区别。成员函数并非为每个对象实例单独存储一份副本，而是所有对象共享同一份代码，这些代码存储在程序的代码段中，这一点和普通的非成员函数无区别。</p> <p>只是成员函数调用时，会隐式携带一个<code class="language-plaintext highlighter-rouge">this</code>指针。例如，调用<code class="language-plaintext highlighter-rouge">foo.func1()</code>实际上等价于调用经过编译器特殊处理的类似非成员函数形式，如<code class="language-plaintext highlighter-rouge">_Z3foo4func1EP3Foo</code>（这里<code class="language-plaintext highlighter-rouge">_Z3foo4func1EP3Foo</code>是编译器为支持函数重载及标识函数所属类而生成的修饰后的函数名，不同编译器生成规则不同）。编译器在处理函数重载时，会对函数名进行修饰，添加类名、参数类型等信息，以确保同名函数在符号表中的唯一性。</p> <p>成员函数的特点：</p> <ol> <li> <strong>共享存储</strong>：所有对象共享同一份成员函数代码，存储在程序代码段</li> <li> <strong>隐式 this 指针</strong>：编译器为非静态成员函数隐式添加<code class="language-plaintext highlighter-rouge">this</code>参数</li> <li> <strong>名称修饰</strong>：编译器对函数名进行修饰以支持重载和命名空间</li> </ol> <p>当成员函数访问成员变量时，编译器使用<code class="language-plaintext highlighter-rouge">this</code>指针：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Foo</span><span class="o">::</span><span class="n">func1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 编译器转换为: this-&gt;a = 10;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>建议</strong>：对于不访问成员变量的函数，使用<code class="language-plaintext highlighter-rouge">static</code>修饰可避免不必要的<code class="language-plaintext highlighter-rouge">this</code>指针传递。</p> <h4 id="13-静态成员的存储机制">1.3 静态成员的存储机制</h4> <p>静态成员变量静态成员变量与普通静态变量非常相似性，它们都存放在静态存储区。只是静态成员变量的作用域、访问方式不同而已。静态成员变量是类的成员变量，但它们不属于类的某个具体对象，而是属于整个类本身。所有对象共享同一个静态成员变量，这使得它们在内存中只占用一份空间。</p> <p>静态成员函数将静态成员函数与普通静态函数其实也比较相似。静态函数的<code class="language-plaintext highlighter-rouge">static</code>表示的是静态函数的作用域被限制在定义它的源文件内，其他源文件无法访问该函数。</p> <p>而静态成员函数的<code class="language-plaintext highlighter-rouge">static</code>表明的是，函数在这个类的内部，但是不会传 this 指针的。注意的是，因为静态成员函数在内部，所以其实这个函数是可以访问私有成员的。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>           <span class="c1">// 类级别变量</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">printCount</span><span class="p">();</span>   <span class="c1">// 类级别函数</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">Foo</span><span class="o">::</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 静态成员需要类外定义</span>
</code></pre></div></div> <p>静态成员的特点：</p> <ul> <li> <strong>静态成员变量</strong>：存储在静态存储区，所有对象共享，不占用对象空间</li> <li> <strong>静态成员函数</strong>：无<code class="language-plaintext highlighter-rouge">this</code>指针，可访问类的私有成员，体现了封装层次</li> </ul> <h4 id="14-继承的内存布局">1.4 继承的内存布局</h4> <h5 id="普通继承">普通继承</h5> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">baseData</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">derivedData</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// Derived对象内存布局: [baseData][derivedData]</span>
</code></pre></div></div> <p>基类成员变量直接嵌入派生类对象中，派生类可直接调用基类的非虚函数。</p> <p>在 C++的继承体系中，对于基类的成员变量，基类的数据成员会直接放置在派生类对象中。这意味着派生类对象的内存布局包含了基类成员变量的空间，就如同派生类自身的成员变量一样。</p> <p>对于基类的非虚成员函数，在派生类中也没有特别的额外操作。派生类对象可以直接调用这些非虚成员函数，其调用机制与普通成员函数调用类似，遵循常规的函数调用规则。</p> <p>然而，在菱形继承场景下，会出现一些问题。例如：</p> <h5 id="虚继承解决菱形继承问题">虚继承解决菱形继承问题</h5> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>  <span class="c1">// 虚继承</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>  <span class="c1">// 虚继承</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span><span class="p">,</span> <span class="k">public</span> <span class="n">C</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>如果不使用虚继承，从<code class="language-plaintext highlighter-rouge">B</code>和<code class="language-plaintext highlighter-rouge">C</code>继承而来的<code class="language-plaintext highlighter-rouge">A</code>类子对象会在<code class="language-plaintext highlighter-rouge">D</code>类对象中存在两份，这不仅浪费内存，还可能导致访问<code class="language-plaintext highlighter-rouge">A</code>类成员时的歧义。为了解决菱形继承问题，使基类不管被派生多少次，都只存在一个子对象实例，C++引入了虚继承。</p> <p>当使用虚继承时（如上述代码中<code class="language-plaintext highlighter-rouge">B</code>和<code class="language-plaintext highlighter-rouge">C</code>对<code class="language-plaintext highlighter-rouge">A</code>的虚继承），派生类（<code class="language-plaintext highlighter-rouge">B</code>和<code class="language-plaintext highlighter-rouge">C</code>）会添加一个虚基类指针（<code class="language-plaintext highlighter-rouge">vbptr</code>），该指针指向一个虚基类表（<code class="language-plaintext highlighter-rouge">vbtable</code>），通过这个表再指向虚基类（<code class="language-plaintext highlighter-rouge">A</code>）的数据。在<code class="language-plaintext highlighter-rouge">D</code>类对象中，只有一个指向虚基类<code class="language-plaintext highlighter-rouge">A</code>数据的<code class="language-plaintext highlighter-rouge">vbptr</code>。</p> <p>虚基类表（<code class="language-plaintext highlighter-rouge">vbtable</code>）记录了虚基类相对于派生类对象起始地址的偏移量等信息。当访问<code class="language-plaintext highlighter-rouge">D</code>类对象中的虚基类成员（如<code class="language-plaintext highlighter-rouge">D.a</code>）时，编译器会根据<code class="language-plaintext highlighter-rouge">vbptr</code>找到对应的虚基类表（<code class="language-plaintext highlighter-rouge">vbtable</code>），然后依据表中的偏移量信息，准确地定位到虚基类<code class="language-plaintext highlighter-rouge">A</code>的成员变量<code class="language-plaintext highlighter-rouge">a</code>在<code class="language-plaintext highlighter-rouge">D</code>类对象内存中的位置，从而实现对虚基类成员的正确访问。这种机制保证了在菱形继承结构中，虚基类子对象的唯一性，避免了数据冗余和访问歧义问题。</p> <p>虚继承的实现机制：</p> <ol> <li> <strong>虚基类指针（vbptr）</strong>：派生类对象包含指向虚基类表的指针</li> <li> <strong>虚基类表（vbtable）</strong>：记录虚基类相对于对象起始地址的偏移量</li> <li> <strong>唯一性保证</strong>：确保虚基类在最终派生类中只有一个实例</li> </ol> <p>如果不使用虚继承，从<code class="language-plaintext highlighter-rouge">B</code>和<code class="language-plaintext highlighter-rouge">C</code>继承而来的<code class="language-plaintext highlighter-rouge">A</code>类子对象会在<code class="language-plaintext highlighter-rouge">D</code>类对象中存在两份，这不仅浪费内存，还可能导致访问<code class="language-plaintext highlighter-rouge">A</code>类成员时的歧义。为了解决菱形继承问题，使基类不管被派生多少次，都只存在一个子对象实例，C++引入了虚继承。</p> <p>当使用虚继承时（如上述代码中<code class="language-plaintext highlighter-rouge">B</code>和<code class="language-plaintext highlighter-rouge">C</code>对<code class="language-plaintext highlighter-rouge">A</code>的虚继承），派生类（<code class="language-plaintext highlighter-rouge">B</code>和<code class="language-plaintext highlighter-rouge">C</code>）会添加一个虚基类指针（<code class="language-plaintext highlighter-rouge">vbptr</code>），该指针指向一个虚基类表（<code class="language-plaintext highlighter-rouge">vbtable</code>），通过这个表再指向虚基类（<code class="language-plaintext highlighter-rouge">A</code>）的数据。在<code class="language-plaintext highlighter-rouge">D</code>类对象中，只有一个指向虚基类<code class="language-plaintext highlighter-rouge">A</code>数据的<code class="language-plaintext highlighter-rouge">vbptr</code>。</p> <p>虚基类表（<code class="language-plaintext highlighter-rouge">vbtable</code>）记录了虚基类相对于派生类对象起始地址的偏移量等信息。当访问<code class="language-plaintext highlighter-rouge">D</code>类对象中的虚基类成员（如<code class="language-plaintext highlighter-rouge">D.a</code>）时，编译器会根据<code class="language-plaintext highlighter-rouge">vbptr</code>找到对应的虚基类表（<code class="language-plaintext highlighter-rouge">vbtable</code>），然后依据表中的偏移量信息，准确地定位到虚基类<code class="language-plaintext highlighter-rouge">A</code>的成员变量<code class="language-plaintext highlighter-rouge">a</code>在<code class="language-plaintext highlighter-rouge">D</code>类对象内存中的位置，从而实现对虚基类成员的正确访问。这种机制保证了在菱形继承结构中，虚基类子对象的唯一性，避免了数据冗余和访问歧义问题。</p> <h4 id="15-多态的虚函数机制">1.5 多态的虚函数机制</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">getType</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// 虚函数</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Animal</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Dog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">getType</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// 重写虚函数</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Animal</span><span class="o">*</span> <span class="n">animal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Dog</span><span class="p">();</span>
    <span class="n">animal</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">();</span> <span class="c1">// 动态绑定，调用Dog::getType()</span>
    <span class="k">delete</span> <span class="n">animal</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>当编译器处理这段代码时，会为包含虚函数的类（如<code class="language-plaintext highlighter-rouge">A</code>类）创建虚函数表（<code class="language-plaintext highlighter-rouge">virtual function table</code>，简称<code class="language-plaintext highlighter-rouge">vtable</code>）。在类<code class="language-plaintext highlighter-rouge">A</code>中，由于<code class="language-plaintext highlighter-rouge">foo</code>函数被声明为虚函数，编译器会在<code class="language-plaintext highlighter-rouge">A</code>类对应的虚函数表中为<code class="language-plaintext highlighter-rouge">foo</code>函数分配一个条目，记录其函数地址。对于派生类<code class="language-plaintext highlighter-rouge">B</code>，编译器同样会为其生成虚函数表，并且因为<code class="language-plaintext highlighter-rouge">B</code>重写了<code class="language-plaintext highlighter-rouge">A</code>中的虚函数<code class="language-plaintext highlighter-rouge">foo</code>，<code class="language-plaintext highlighter-rouge">B</code>的虚函数表中对应<code class="language-plaintext highlighter-rouge">foo</code>函数条目的地址将指向<code class="language-plaintext highlighter-rouge">B::foo</code>的实现。</p> <p>当执行<code class="language-plaintext highlighter-rouge">A* b = new B();</code>时，<code class="language-plaintext highlighter-rouge">new B()</code>按照<code class="language-plaintext highlighter-rouge">B</code>类的构造函数进行对象构造，此时<code class="language-plaintext highlighter-rouge">b</code>指针虽然声明为<code class="language-plaintext highlighter-rouge">A*</code>类型，但实际指向的是<code class="language-plaintext highlighter-rouge">B</code>类对象。<code class="language-plaintext highlighter-rouge">B</code>类对象的内存布局中包含一个指向<code class="language-plaintext highlighter-rouge">B</code>类虚函数表的指针（通常称为虚函数表指针，<code class="language-plaintext highlighter-rouge">vptr</code>）。</p> <p>当调用<code class="language-plaintext highlighter-rouge">b-&gt;foo();</code>时，编译器首先根据<code class="language-plaintext highlighter-rouge">b</code>指针找到<code class="language-plaintext highlighter-rouge">B</code>类对象，进而通过对象中的<code class="language-plaintext highlighter-rouge">vptr</code>找到<code class="language-plaintext highlighter-rouge">B</code>类的虚函数表（<code class="language-plaintext highlighter-rouge">vtable</code>）。由于编译器在编译阶段就确定了虚函数<code class="language-plaintext highlighter-rouge">foo</code>在虚函数表中的索引位置（假设为 0），所以<code class="language-plaintext highlighter-rouge">b-&gt;foo()</code>的调用过程实际上类似于通过<code class="language-plaintext highlighter-rouge">b</code>指针找到<code class="language-plaintext highlighter-rouge">B</code>类对象的虚函数表指针<code class="language-plaintext highlighter-rouge">vptr</code>，再由<code class="language-plaintext highlighter-rouge">vptr</code>找到<code class="language-plaintext highlighter-rouge">B</code>类的虚函数表<code class="language-plaintext highlighter-rouge">vtable</code>，然后根据索引 0 获取到<code class="language-plaintext highlighter-rouge">B::foo</code>函数的地址，即<code class="language-plaintext highlighter-rouge">vtable[0]</code>，最后调用该函数，也就是执行<code class="language-plaintext highlighter-rouge">vtable[0]()</code>。</p> <p>虚函数的实现机制：</p> <ol> <li> <strong>虚函数表（vtable）</strong>：每个包含虚函数的类都有一个虚函数表，存储虚函数地址</li> <li> <strong>虚函数表指针（vptr）</strong>：每个对象包含指向其类虚函数表的指针</li> <li> <strong>动态绑定</strong>：运行时通过 vptr 找到正确的虚函数表，再根据函数索引调用相应函数</li> </ol> <p>虚函数调用过程：<code class="language-plaintext highlighter-rouge">animal-&gt;getType()</code> → <code class="language-plaintext highlighter-rouge">animal-&gt;vptr-&gt;vtable[index]()</code></p> <h4 id="16-类对象的内存占用">1.6 类对象的内存占用</h4> <p>类对象的大小由以下因素决定：</p> <ol> <li> <strong>非静态成员变量</strong>：直接占用对象空间</li> <li> <strong>虚函数表指针（vptr）</strong>：如果有虚函数，占用一个指针大小</li> <li> <strong>虚基类指针（vbptr）</strong>：如果有虚继承，占用一个指针大小</li> <li> <strong>内存对齐</strong>：编译器按对齐规则调整内存布局</li> <li> <strong>不占用空间的成员</strong>： <ul> <li>成员函数（存储在代码段）</li> <li>静态成员变量（存储在静态区）</li> </ul> </li> </ol> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Empty</span> <span class="p">{};</span>                    <span class="c1">// 大小: 1字节（保证唯一地址）</span>
<span class="k">class</span> <span class="nc">WithData</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>        <span class="c1">// 大小: 4字节</span>
<span class="k">class</span> <span class="nc">WithVirtual</span> <span class="p">{</span>               <span class="c1">// 大小: 8字节（64位系统）</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">{}</span>        <span class="c1">// vptr占用8字节</span>
<span class="p">};</span>
</code></pre></div></div> <p><img src="./imgs/3_class_image.png" alt="alt text"></p> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-class-和-struct-的区别">1. class 和 struct 的区别</h4> <p><strong>主要区别</strong>：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">struct</code>默认访问权限为<code class="language-plaintext highlighter-rouge">public</code> </li> <li> <code class="language-plaintext highlighter-rouge">class</code>默认访问权限为<code class="language-plaintext highlighter-rouge">private</code> </li> </ul> <p>除此之外使用时没有区别。</p> <p><strong>设计理念</strong>：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">class</code>体现 OOP 思想，强调封装和继承</li> <li> <code class="language-plaintext highlighter-rouge">struct</code>继承自 C 语言，更适合作为纯数据容器</li> </ul> <p><strong>功能等价性</strong>：两者都支持继承、多态和模板。</p> <h4 id="2-空类对象的大小">2. 空类对象的大小</h4> <p><strong>答案</strong>：1 字节</p> <p><strong>原因</strong>：确保每个对象都有唯一的内存地址，使得不同的空类对象在内存中可区分。</p> <h4 id="3-空指针能否调用成员函数">3. 空指针能否调用成员函数</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">bar</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bar method called."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">unsafeBar</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 编译器可能优化掉此判断</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 其他操作...</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">*&gt;</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">();</span> <span class="c1">// 可以执行，但不安全</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>答案</strong>：理论上可以，但属于未定义行为（UB）。</p> <p><strong>风险</strong>：</p> <ul> <li>如果函数内访问成员变量会导致程序崩溃</li> <li>编译器可能基于”this 不为空”的假设进行优化，导致意外行为</li> <li>实际开发中应避免这种用法</li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/6_internet.md/">（七）内核那些事儿：操作系统对网络包的处理</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/5_fileSystem.md/">（六）内核那些事儿：文件系统</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/4_interaction.md/">（五）内核那些事儿：系统和程序的交互</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_device.md/">（四）内核那些事儿：设备管理与驱动开发</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_signal.md/">（三）内核那些事儿：CPU中断和信号</a> </li> </div> </div> <div class="col-sm-4"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <script src="/assets/js/toc-depth.js"></script> </body> </html>