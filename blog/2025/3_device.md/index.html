<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> （四）内核那些事儿：设备管理与驱动开发 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A blog for documenting my own study notes. "> <meta name="keywords" content="blog, cpp, programmer"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/toc-custom.css"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/3_device.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-8"> <div class="post"> <header class="post-header"> <h1 class="post-title">（四）内核那些事儿：设备管理与驱动开发</h1> <p class="post-meta"> Created on September 15, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/kernel"> <i class="fa-solid fa-hashtag fa-sm"></i> Kernel</a>   ·   <a href="/blog/category/os"> <i class="fa-solid fa-tag fa-sm"></i> OS</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="四内核那些事儿设备管理与驱动开发">（四）内核那些事儿：设备管理与驱动开发</h2> <h3 id="1-操作系统与硬件的桥梁">1. 操作系统与硬件的桥梁</h3> <p>设备管理是操作系统连接软件与硬件的核心机制。理解这个过程的关键在于掌握<strong>分层架构</strong>：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>用户应用程序
    ↓ (系统调用)
虚拟文件系统 (VFS)
    ↓ (设备文件)
设备驱动程序
    ↓ (硬件抽象层)
硬件控制器
    ↓ (电信号)
物理硬件设备
</code></pre></div></div> <h4 id="11-硬件识别与枚举过程">1.1 硬件识别与枚举过程</h4> <p>当硬件设备连接到系统时，会发生以下步骤：</p> <ol> <li> <strong>物理检测</strong>：总线控制器（如 PCI、USB）检测到新设备插入</li> <li> <strong>设备识别</strong>：读取设备的标识信息（Vendor ID、Device ID、Class Code）</li> <li> <strong>驱动匹配</strong>：内核根据设备 ID 查找对应的驱动程序</li> <li> <strong>资源分配</strong>：为设备分配 I/O 端口、中断号、内存地址等资源</li> <li> <strong>设备注册</strong>：通过设备模型和 udev 在 <code class="language-plaintext highlighter-rouge">/dev/</code> 下创建设备文件，供用户空间访问</li> </ol> <h4 id="12-设备接入的完整流程详解">1.2 设备接入的完整流程详解</h4> <p><strong>阶段 1：硬件层面的设备发现</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>物理插入 → 总线控制器检测 → 电气信号确认 → 设备枚举开始
</code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// USB设备插入时的物理检测</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">usb_hub_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">usb_hub</span> <span class="o">*</span><span class="n">hub</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>

    <span class="c1">// 检测到端口状态变化</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">USB_PORT_STAT_CONNECTION</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 设备插入，开始枚举过程</span>
        <span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hub</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>阶段 2：设备识别与信息读取</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 读取设备描述符获取身份信息</span>
<span class="k">struct</span> <span class="n">usb_device_descriptor</span> <span class="p">{</span>
    <span class="n">__u16</span> <span class="n">idVendor</span><span class="p">;</span>     <span class="c1">// 厂商ID (如: 0x046d = Logitech)</span>
    <span class="n">__u16</span> <span class="n">idProduct</span><span class="p">;</span>    <span class="c1">// 产品ID (如: 0xc52b = 鼠标型号)</span>
    <span class="n">__u8</span>  <span class="n">bDeviceClass</span><span class="p">;</span> <span class="c1">// 设备类别 (如: 0x03 = HID设备)</span>
    <span class="n">__u8</span>  <span class="n">bDeviceSubClass</span><span class="p">;</span>
    <span class="n">__u8</span>  <span class="n">bDeviceProtocol</span><span class="p">;</span> <span class="c1">// 协议 (如: 0x02 = 鼠标协议)</span>
<span class="p">};</span>

<span class="c1">// 内核读取这些信息</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_enumerate_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">usb_device_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>

    <span class="c1">// 发送GET_DESCRIPTOR请求</span>
    <span class="n">usb_get_descriptor</span><span class="p">(</span><span class="n">udev</span><span class="p">,</span> <span class="n">USB_DT_DEVICE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">));</span>

    <span class="n">printk</span><span class="p">(</span><span class="s">"发现设备: VID=0x%04x, PID=0x%04x, Class=0x%02x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
           <span class="n">desc</span><span class="o">-&gt;</span><span class="n">idVendor</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">idProduct</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bDeviceClass</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>阶段 3：驱动程序匹配与绑定</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 驱动程序注册时声明支持的设备</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">mouse_id_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// 支持所有HID鼠标设备</span>
    <span class="p">{</span> <span class="n">USB_INTERFACE_INFO</span><span class="p">(</span><span class="n">USB_INTERFACE_CLASS_HID</span><span class="p">,</span>
                         <span class="n">USB_INTERFACE_SUBCLASS_BOOT</span><span class="p">,</span>
                         <span class="n">USB_INTERFACE_PROTOCOL_MOUSE</span><span class="p">)</span> <span class="p">},</span>
    <span class="c1">// 支持特定厂商的鼠标</span>
    <span class="p">{</span> <span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x046d</span><span class="p">,</span> <span class="mh">0xc52b</span><span class="p">)</span> <span class="p">},</span> <span class="c1">// Logitech特定型号</span>
    <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">mouse_driver</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"usbhid"</span><span class="p">,</span>
    <span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">mouse_probe</span><span class="p">,</span>        <span class="c1">// 设备匹配时调用</span>
    <span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span> <span class="n">mouse_disconnect</span><span class="p">,</span>
    <span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">mouse_id_table</span><span class="p">,</span>  <span class="c1">// 支持的设备列表</span>
<span class="p">};</span>

<span class="c1">// 内核自动匹配过程</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">usb_match_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 遍历驱动的id_table，查找匹配项</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">id</span> <span class="o">=</span> <span class="n">drv</span><span class="o">-&gt;</span><span class="n">id_table</span><span class="p">;</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">match_flags</span><span class="p">;</span> <span class="n">id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">usb_match_id</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">id</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 找到匹配的驱动</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="13-驱动程序的核心职责">1.3 驱动程序的核心职责</h4> <p>驱动程序需要实现以下核心功能：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 驱动程序的基本结构</span>
<span class="k">struct</span> <span class="n">device_driver</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>      <span class="c1">// 设备发现时调用</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>     <span class="c1">// 设备移除时调用</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>    <span class="c1">// 电源管理</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">);</span>     <span class="c1">// 电源管理</span>
<span class="p">};</span>

<span class="c1">// 文件操作接口 - 设备驱动与用户空间交互的核心接口</span>
<span class="k">struct</span> <span class="n">file_operations</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="2-linux-设备模型与-udev-机制">2. Linux 设备模型与 udev 机制</h3> <h4 id="21-linux-设备模型-device-model">2.1 Linux 设备模型 (Device Model)</h4> <p>设备模型是 Linux 内核中的一个<strong>统一框架</strong>，用于组织和管理所有硬件设备：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 设备模型的核心结构</span>
<span class="k">struct</span> <span class="n">device</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>      <span class="c1">// 父设备（总线关系）</span>
    <span class="k">struct</span> <span class="n">device_private</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>   <span class="c1">// 私有数据</span>
    <span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>        <span class="c1">// 内核对象（sysfs接口）</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">init_name</span><span class="p">;</span>      <span class="c1">// 设备名称</span>
    <span class="k">struct</span> <span class="n">device_type</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>   <span class="c1">// 设备类型</span>
    <span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">;</span>       <span class="c1">// 所属总线</span>
    <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span> <span class="c1">// 绑定的驱动</span>
    <span class="n">dev_t</span> <span class="n">devt</span><span class="p">;</span>                 <span class="c1">// 设备号 (major:minor)</span>
<span class="p">};</span>
</code></pre></div></div> <p><strong>设备模型层次结构</strong>：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/sys/devices/
├── pci0000:00/           # PCI总线
│   ├── 0000:00:1d.0/     # USB控制器
│   │   ├── usb2/         # USB总线
│   │   │   └── 2-1/      # USB端口1
│   │   │       └── 2-1:1.0/  # USB接口
│   │   │           └── input/input2/  # 输入设备
│   │   │               └── event2     # 事件设备
</code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 当驱动调用device_add()时发生什么</span>
<span class="kt">int</span> <span class="nf">device_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1. 分配设备号</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devt</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_attr_dev</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 2. 创建sysfs目录和属性文件</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">kobject_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">parent</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="c1">// 这会在 /sys/devices/ 下创建目录</span>

    <span class="c1">// 3. 通知设备子系统</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">class_device_add</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 4. 发送uevent通知用户空间</span>
    <span class="n">kobject_uevent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="n">KOBJ_ADD</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="22-udev---用户空间设备管理器">2.2 udev - 用户空间设备管理器</h4> <p>udev 是运行在<strong>用户空间</strong>的守护进程，负责：</p> <ul> <li>监听内核设备事件</li> <li>根据规则创建/删除设备文件</li> <li>设置设备文件权限和所有者</li> <li>创建设备符号链接</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 内核发送uevent的过程</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">kobject_uevent_env</span><span class="p">(</span><span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
                              <span class="k">enum</span> <span class="n">kobject_action</span> <span class="n">action</span><span class="p">,</span>
                              <span class="kt">char</span> <span class="o">*</span><span class="n">envp_ext</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// 1. 构造环境变量</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">envp</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">"ACTION=add"</span><span class="p">,</span>                    <span class="c1">// 动作类型</span>
        <span class="s">"DEVPATH=/devices/pci0000:00/..."</span><span class="p">,</span> <span class="c1">// 设备路径</span>
        <span class="s">"SUBSYSTEM=input"</span><span class="p">,</span>               <span class="c1">// 子系统</span>
        <span class="s">"DEVNAME=input/event2"</span><span class="p">,</span>          <span class="c1">// 设备名称</span>
        <span class="s">"MAJOR=13"</span><span class="p">,</span>                      <span class="c1">// 主设备号</span>
        <span class="s">"MINOR=66"</span><span class="p">,</span>                      <span class="c1">// 次设备号</span>
        <span class="nb">NULL</span>
    <span class="p">};</span>

    <span class="c1">// 2. 通过netlink socket发送给udev</span>
    <span class="k">return</span> <span class="n">netlink_broadcast_filtered</span><span class="p">(</span><span class="n">uevent_sock</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
                                    <span class="n">kobj_bcast_filter</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>udev 规则文件示例</strong>：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># /etc/udev/rules.d/50-input.rules</span>
<span class="c"># 为所有输入事件设备创建设备文件</span>
<span class="nv">KERNEL</span><span class="o">==</span><span class="s2">"event*"</span>, <span class="nv">SUBSYSTEM</span><span class="o">==</span><span class="s2">"input"</span>, <span class="nv">MODE</span><span class="o">=</span><span class="s2">"0644"</span>, <span class="nv">GROUP</span><span class="o">=</span><span class="s2">"input"</span>

<span class="c"># 为鼠标设备创建特殊符号链接</span>
<span class="nv">KERNEL</span><span class="o">==</span><span class="s2">"event*"</span>, <span class="nv">SUBSYSTEM</span><span class="o">==</span><span class="s2">"input"</span>, ATTRS<span class="o">{</span>name<span class="o">}==</span><span class="s2">"*Mouse*"</span>, <span class="se">\</span>
    SYMLINK+<span class="o">=</span><span class="s2">"input/mouse%n"</span>

<span class="c"># 为触摸板设备设置特殊权限</span>
<span class="nv">KERNEL</span><span class="o">==</span><span class="s2">"event*"</span>, <span class="nv">SUBSYSTEM</span><span class="o">==</span><span class="s2">"input"</span>, ATTRS<span class="o">{</span>name<span class="o">}==</span><span class="s2">"*TouchPad*"</span>, <span class="se">\</span>
    <span class="nv">MODE</span><span class="o">=</span><span class="s2">"0664"</span>, <span class="nv">GROUP</span><span class="o">=</span><span class="s2">"input"</span>
</code></pre></div></div> <h3 id="3-输入设备实例鼠标驱动开发">3. 输入设备实例：鼠标驱动开发</h3> <h4 id="31-鼠标硬件工作原理">3.1 鼠标硬件工作原理</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>光学传感器 → 微控制器 → USB/PS2接口 → 主机控制器 → CPU
     ↑              ↓
  LED照明      按键状态检测
</code></pre></div></div> <h4 id="32-驱动程序实现要点">3.2 驱动程序实现要点</h4> <p><strong>步骤 1：设备注册与初始化</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 鼠标驱动初始化</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mouse_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">intf</span><span class="p">,</span>
                       <span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">intf</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">mouse_device</span> <span class="o">*</span><span class="n">mouse</span><span class="p">;</span>

    <span class="c1">// 1. 分配设备结构体</span>
    <span class="n">mouse</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mouse_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

    <span class="c1">// 2. 配置USB端点</span>
    <span class="n">mouse</span><span class="o">-&gt;</span><span class="n">usbdev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
    <span class="n">mouse</span><span class="o">-&gt;</span><span class="n">irq_in</span> <span class="o">=</span> <span class="n">usb_rcvintpipe</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">-&gt;</span><span class="n">bEndpointAddress</span><span class="p">);</span>

    <span class="c1">// 3. 分配URB（USB请求块）</span>
    <span class="n">mouse</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

    <span class="c1">// 4. 分配DMA缓冲区</span>
    <span class="n">mouse</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">usb_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mouse</span><span class="o">-&gt;</span><span class="n">data_dma</span><span class="p">);</span>

    <span class="c1">// 5. 注册输入设备</span>
    <span class="n">mouse</span><span class="o">-&gt;</span><span class="n">input_dev</span> <span class="o">=</span> <span class="n">input_allocate_device</span><span class="p">();</span>
    <span class="n">input_set_capability</span><span class="p">(</span><span class="n">mouse</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">EV_KEY</span><span class="p">,</span> <span class="n">BTN_LEFT</span><span class="p">);</span>
    <span class="n">input_set_capability</span><span class="p">(</span><span class="n">mouse</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">EV_REL</span><span class="p">,</span> <span class="n">REL_X</span><span class="p">);</span>
    <span class="n">input_set_capability</span><span class="p">(</span><span class="n">mouse</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">,</span> <span class="n">EV_REL</span><span class="p">,</span> <span class="n">REL_Y</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">input_register_device</span><span class="p">(</span><span class="n">mouse</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>步骤 2：中断处理与数据解析</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// USB中断回调函数 - 由驱动程序执行，运行在内核空间</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">mouse_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 执行环境：</span>
    <span class="c1">// - 运行在：内核空间</span>
    <span class="c1">// - 执行者：内核中断处理机制</span>
    <span class="c1">// - 触发者：USB硬件控制器</span>
    <span class="c1">// - 上下文：中断上下文（不能睡眠）</span>

    <span class="k">struct</span> <span class="n">mouse_device</span> <span class="o">*</span><span class="n">mouse</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">mouse</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">input_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">mouse</span><span class="o">-&gt;</span><span class="n">input_dev</span><span class="p">;</span>

    <span class="c1">// 解析鼠标数据包格式</span>
    <span class="c1">// data[0]: 按键状态位 [中键][右键][左键][保留位...]</span>
    <span class="c1">// data[1]: X轴增量 (-127 到 +127)</span>
    <span class="c1">// data[2]: Y轴增量 (-127 到 +127)</span>
    <span class="c1">// data[3]: 滚轮增量</span>

    <span class="kt">int</span> <span class="n">left_pressed</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right_pressed</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x_movement</span> <span class="o">=</span> <span class="p">(</span><span class="kt">signed</span> <span class="kt">char</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">y_movement</span> <span class="o">=</span> <span class="p">(</span><span class="kt">signed</span> <span class="kt">char</span><span class="p">)</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

    <span class="c1">// 转换为标准输入事件</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left_pressed</span> <span class="o">!=</span> <span class="n">mouse</span><span class="o">-&gt;</span><span class="n">last_left_state</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">input_report_key</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">BTN_LEFT</span><span class="p">,</span> <span class="n">left_pressed</span><span class="p">);</span>
        <span class="n">mouse</span><span class="o">-&gt;</span><span class="n">last_left_state</span> <span class="o">=</span> <span class="n">left_pressed</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">x_movement</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">input_report_rel</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">REL_X</span><span class="p">,</span> <span class="n">x_movement</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">y_movement</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">input_report_rel</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">REL_Y</span><span class="p">,</span> <span class="n">y_movement</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 提交事件批次到输入子系统</span>
    <span class="n">input_sync</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

    <span class="c1">// 重新提交URB继续接收数据</span>
    <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="33-执行模型详解">3.3 执行模型详解</h4> <p><strong>重要概念</strong>：</p> <ul> <li> <strong>设备文件</strong>：只是一个接口/通道，不包含可执行代码</li> <li> <strong>驱动程序</strong>：真正执行数据处理的代码，在系统启动/模块加载时常驻内存</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│   用户进程      │     │    内核驱动      │     │     硬件        │
│                 │     │                  │     │                 │
│ read() 调用     │────▶│ 从事件队列读取   │     │ 鼠标移动        │
│ (阻塞等待)      │     │                  │     │       ↓         │
│                 │     │                  │     │ USB数据包发送   │
│ 返回事件数据    │◀────│ copy_to_user()   │     │       ↓         │
│                 │     │                  │     │ 触发中断        │
└─────────────────┘     │                  │     │       ↓         │
                        │ mouse_irq()      │◀────│ 硬件中断        │
                        │ ↓                │     │                 │
                        │ 解析数据包       │     └─────────────────┘
                        │ ↓                │
                        │ input_report_*() │
                        │ ↓                │
                        │ 放入事件队列     │
                        └──────────────────┘

执行者：           用户态进程         内核驱动程序           硬件控制器
何时执行：         用户调用read()     硬件中断触发           用户操作硬件
</code></pre></div></div> <p><strong>完整执行时序</strong>：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>时刻1: 鼠标硬件动作
[硬件] 用户移动鼠标 → 光学传感器检测位移

时刻2: 硬件中断产生
[硬件] USB鼠标控制器 → 通过USB总线发送数据包

时刻3: USB控制器中断
[硬件] USB Host Controller → 产生硬件中断 IRQ_USB

时刻4: 内核中断处理
[内核] CPU响应中断 → 保存当前进程上下文 → 跳转到中断向量

时刻5: USB栈处理
[内核] USB中断处理程序 → 识别是哪个URB完成 → 调用回调函数

时刻6: 驱动程序执行
[驱动] mouse_irq() 函数被调用 → 解析数据 → 生成输入事件

时刻7: 输入子系统处理
[内核] input_report_*() → 将事件放入事件队列

时刻8: 用户程序读取
[用户] 用户程序调用 read() → 从设备文件读取事件
</code></pre></div></div> <h4 id="34-用户空间交互">3.4 用户空间交互</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 用户程序读取设备文件</span>
<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/input/event2"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">input_event</span> <span class="n">event</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">EV_REL</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">code</span> <span class="o">==</span> <span class="n">REL_X</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cursor_x</span> <span class="o">+=</span> <span class="n">event</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>  <span class="c1">// 更新光标X坐标</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">code</span> <span class="o">==</span> <span class="n">REL_Y</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cursor_y</span> <span class="o">+=</span> <span class="n">event</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>  <span class="c1">// 更新光标Y坐标</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">EV_KEY</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">code</span> <span class="o">==</span> <span class="n">BTN_LEFT</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">handle_left_click</span><span class="p">();</span>     <span class="c1">// 处理左键点击</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 或者通过命令行工具</span>
<span class="nb">cat</span> /dev/input/event2  <span class="c"># 读取原始输入事件</span>
evtest /dev/input/event2  <span class="c"># 测试输入设备</span>

<span class="c"># 或者通过X11/Wayland等图形系统处理</span>
<span class="c"># evdev → libinput → X11/Wayland → 应用程序</span>
</code></pre></div></div> <h4 id="35-关键技术点">3.5 关键技术点</h4> <ol> <li> <strong>异步 I/O</strong>：鼠标使用中断传输，无需 CPU 轮询</li> <li> <strong>事件驱动</strong>：通过 input 子系统统一管理所有输入事件</li> <li> <strong>缓冲管理</strong>：内核维护事件队列，防止数据丢失</li> <li> <strong>电源管理</strong>：支持设备休眠和唤醒</li> </ol> <h3 id="4-文件操作接口详解">4. 文件操作接口详解</h3> <p>在 Linux 中，<strong>“一切皆文件”</strong> 的设计理念使得设备也被抽象为文件。当用户程序操作设备文件时，内核会调用驱动程序中对应的函数：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>用户程序调用    →    系统调用    →    VFS层    →    驱动程序函数
open()         →    sys_open()  →    vfs_open() →    fops-&gt;open()
read()         →    sys_read()  →    vfs_read() →    fops-&gt;read()
</code></pre></div></div> <h4 id="41-各个函数指针详解">4.1 各个函数指针详解</h4> <p><strong>open() - 设备打开</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 当用户程序调用 open("/dev/mydevice", O_RDWR) 时触发</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_device_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

    <span class="c1">// 1. 获取设备结构体（通过次设备号）</span>
    <span class="kt">int</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">MINOR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">);</span>
    <span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_devices</span><span class="p">[</span><span class="n">minor</span><span class="p">];</span>

    <span class="c1">// 2. 检查设备状态</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">is_busy</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>  <span class="c1">// 设备忙</span>
    <span class="p">}</span>

    <span class="c1">// 3. 初始化设备</span>
    <span class="n">my_device_hw_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

    <span class="c1">// 4. 设置文件私有数据（重要！）</span>
    <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

    <span class="c1">// 5. 更新使用计数</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">usage_count</span><span class="o">++</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 成功</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>read() - 从设备读取数据</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">my_device_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
                              <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">kernel_buffer</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="kt">size_t</span> <span class="n">bytes_to_copy</span><span class="p">;</span>

    <span class="c1">// 1. 从硬件读取数据到内核缓冲区</span>
    <span class="n">bytes_to_copy</span> <span class="o">=</span> <span class="n">my_device_hw_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">kernel_buffer</span><span class="p">,</span>
                                      <span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_buffer</span><span class="p">)));</span>

    <span class="c1">// 2. 将数据从内核空间复制到用户空间</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">kernel_buffer</span><span class="p">,</span> <span class="n">bytes_to_copy</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>  <span class="c1">// 内存访问错误</span>
    <span class="p">}</span>

    <span class="c1">// 3. 更新文件偏移</span>
    <span class="o">*</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">bytes_to_copy</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">bytes_to_copy</span><span class="p">;</span>  <span class="c1">// 返回实际读取的字节数</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>write() - 向设备写入数据</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">my_device_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
                               <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">kernel_buffer</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="kt">size_t</span> <span class="n">bytes_to_write</span><span class="p">;</span>

    <span class="n">bytes_to_write</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">kernel_buffer</span><span class="p">));</span>

    <span class="c1">// 1. 从用户空间复制数据到内核空间</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">kernel_buffer</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">bytes_to_write</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 2. 将数据写入硬件</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">my_device_hw_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">kernel_buffer</span><span class="p">,</span> <span class="n">bytes_to_write</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>  <span class="c1">// I/O错误</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">bytes_to_write</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">bytes_to_write</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>ioctl() - 设备控制</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 定义ioctl命令</span>
<span class="cp">#define MY_DEVICE_IOC_MAGIC 'M'
#define MY_DEVICE_SET_SPEED    _IOW(MY_DEVICE_IOC_MAGIC, 1, int)
#define MY_DEVICE_GET_STATUS   _IOR(MY_DEVICE_IOC_MAGIC, 2, int)
</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">my_device_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
                            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">MY_DEVICE_SET_SPEED</span><span class="p">:</span>
        <span class="c1">// 从用户空间获取参数</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="n">user_ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

        <span class="c1">// 设置设备速度</span>
        <span class="n">my_device_set_speed</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">MY_DEVICE_GET_STATUS</span><span class="p">:</span>
        <span class="c1">// 获取设备状态</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">my_device_get_status</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

        <span class="c1">// 返回给用户空间</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)))</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="nl">default:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>  <span class="c1">// 不支持的命令</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>release() - 关闭设备</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">my_device_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

    <span class="c1">// 1. 清理资源</span>
    <span class="n">my_device_hw_cleanup</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

    <span class="c1">// 2. 减少使用计数</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">usage_count</span><span class="o">--</span><span class="p">;</span>

    <span class="c1">// 3. 如果没有进程使用，关闭硬件</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">usage_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">my_device_hw_shutdown</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="5-输出设备实例显示器驱动开发">5. 输出设备实例：显示器驱动开发</h3> <h4 id="51-显示系统架构">5.1 显示系统架构</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>应用程序 → OpenGL/Vulkan → GPU驱动 → 硬件GPU → 显示控制器 → 显示器
    ↓                          ↓              ↓
合成器(Compositor)         帧缓冲区        HDMI/DP信号
</code></pre></div></div> <h4 id="52-drmdirect-rendering-manager驱动框架">5.2 DRM(Direct Rendering Manager)驱动框架</h4> <p><strong>步骤 1：硬件抽象与初始化</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// DRM驱动的核心结构</span>
<span class="k">struct</span> <span class="n">drm_driver</span> <span class="n">my_gpu_driver</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">driver_features</span> <span class="o">=</span> <span class="n">DRIVER_GEM</span> <span class="o">|</span> <span class="n">DRIVER_MODESET</span> <span class="o">|</span> <span class="n">DRIVER_ATOMIC</span><span class="p">,</span>
    <span class="p">.</span><span class="n">load</span> <span class="o">=</span> <span class="n">my_gpu_load</span><span class="p">,</span>
    <span class="p">.</span><span class="n">unload</span> <span class="o">=</span> <span class="n">my_gpu_unload</span><span class="p">,</span>
    <span class="p">.</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_gpu_fops</span><span class="p">,</span>
    <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"my-gpu"</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_gpu_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_gpu_device</span> <span class="o">*</span><span class="n">gpu</span><span class="p">;</span>

    <span class="c1">// 1. 初始化硬件</span>
    <span class="n">gpu</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">gpu</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

    <span class="c1">// 2. 映射GPU寄存器</span>
    <span class="n">gpu</span><span class="o">-&gt;</span><span class="n">mmio</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                        <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="c1">// 3. 分配显存</span>
    <span class="n">gpu</span><span class="o">-&gt;</span><span class="n">vram_size</span> <span class="o">=</span> <span class="n">my_gpu_get_vram_size</span><span class="p">(</span><span class="n">gpu</span><span class="p">);</span>
    <span class="n">gpu</span><span class="o">-&gt;</span><span class="n">vram_base</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

    <span class="c1">// 4. 注册中断处理</span>
    <span class="n">request_irq</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">my_gpu_irq_handler</span><span class="p">,</span>
                <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">"my-gpu"</span><span class="p">,</span> <span class="n">gpu</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>步骤 2：模式设置与显示管道</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 显示管道配置</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_gpu_crtc_mode_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_crtc</span> <span class="o">*</span><span class="n">crtc</span><span class="p">,</span>
                                <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">mode</span><span class="p">,</span>
                                <span class="k">struct</span> <span class="n">drm_display_mode</span> <span class="o">*</span><span class="n">adjusted_mode</span><span class="p">,</span>
                                <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span>
                                <span class="k">struct</span> <span class="n">drm_framebuffer</span> <span class="o">*</span><span class="n">fb</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_gpu_device</span> <span class="o">*</span><span class="n">gpu</span> <span class="o">=</span> <span class="n">crtc_to_gpu</span><span class="p">(</span><span class="n">crtc</span><span class="p">);</span>

    <span class="c1">// 1. 配置像素时钟</span>
    <span class="n">my_gpu_set_pixel_clock</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">clock</span><span class="p">);</span>

    <span class="c1">// 2. 设置显示时序</span>
    <span class="n">my_gpu_write_reg</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="n">HTOTAL_REG</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">htotal</span><span class="p">);</span>
    <span class="n">my_gpu_write_reg</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="n">VTOTAL_REG</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vtotal</span><span class="p">);</span>
    <span class="n">my_gpu_write_reg</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="n">HSYNC_REG</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">hsync_start</span><span class="p">);</span>
    <span class="n">my_gpu_write_reg</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="n">VSYNC_REG</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">vsync_start</span><span class="p">);</span>

    <span class="c1">// 3. 配置帧缓冲地址</span>
    <span class="n">my_gpu_write_reg</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="n">FB_BASE_REG</span><span class="p">,</span> <span class="n">fb</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
    <span class="n">my_gpu_write_reg</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="n">FB_STRIDE_REG</span><span class="p">,</span> <span class="n">fb</span><span class="o">-&gt;</span><span class="n">pitches</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="c1">// 4. 启用显示输出</span>
    <span class="n">my_gpu_write_reg</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="n">DISPLAY_CTRL_REG</span><span class="p">,</span> <span class="n">DISPLAY_ENABLE</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>步骤 3：内存管理与渲染</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// GEM (Graphics Execution Manager) 对象管理</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_gpu_gem_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">drm_file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
                            <span class="k">struct</span> <span class="n">drm_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
                            <span class="kt">uint64_t</span> <span class="n">size</span><span class="p">,</span>
                            <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">handle_p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>

    <span class="c1">// 1. 分配GPU内存对象</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">drm_gem_object_alloc</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

    <span class="c1">// 2. 分配实际的显存</span>
    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">vram_addr</span> <span class="o">=</span> <span class="n">my_gpu_alloc_vram</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

    <span class="c1">// 3. 创建用户句柄</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">drm_gem_handle_create</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">handle_p</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 页错误处理（GPU内存映射）</span>
<span class="k">static</span> <span class="n">vm_fault_t</span> <span class="nf">my_gpu_gem_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">drm_gem_object</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">;</span>

    <span class="c1">// 将GPU显存映射到用户空间</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">vram_addr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">vmf_insert_pfn</span><span class="p">(</span><span class="n">vmf</span><span class="o">-&gt;</span><span class="n">vma</span><span class="p">,</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">,</span> <span class="n">pfn</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>步骤 4：中断处理与同步</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// GPU中断处理</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">my_gpu_irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_gpu_device</span> <span class="o">*</span><span class="n">gpu</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">status</span> <span class="o">=</span> <span class="n">my_gpu_read_reg</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="n">IRQ_STATUS_REG</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">VBLANK_IRQ</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 垂直消隐中断：通知用户空间可以提交新帧</span>
        <span class="n">drm_crtc_handle_vblank</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpu</span><span class="o">-&gt;</span><span class="n">crtc</span><span class="p">);</span>

        <span class="c1">// 更新帧缓冲（避免撕裂）</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">gpu</span><span class="o">-&gt;</span><span class="n">pending_flip</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">my_gpu_update_scanout</span><span class="p">(</span><span class="n">gpu</span><span class="p">,</span> <span class="n">gpu</span><span class="o">-&gt;</span><span class="n">pending_flip</span><span class="p">);</span>
            <span class="n">gpu</span><span class="o">-&gt;</span><span class="n">pending_flip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">RENDER_COMPLETE_IRQ</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 渲染完成中断：通知等待的进程</span>
        <span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpu</span><span class="o">-&gt;</span><span class="n">render_wait_queue</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="53-用户空间接口">5.3 用户空间接口</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 用户程序使用示例</span>
<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/dri/card0"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>

<span class="c1">// 1. 获取显示器信息</span>
<span class="n">drmModeRes</span> <span class="o">*</span><span class="n">resources</span> <span class="o">=</span> <span class="n">drmModeGetResources</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

<span class="c1">// 2. 创建帧缓冲</span>
<span class="k">struct</span> <span class="n">drm_mode_create_fb</span> <span class="n">create_fb</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">1920</span><span class="p">,</span>
    <span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1080</span><span class="p">,</span>
    <span class="p">.</span><span class="n">pixel_format</span> <span class="o">=</span> <span class="n">DRM_FORMAT_XRGB8888</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">DRM_IOCTL_MODE_ADDFB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">create_fb</span><span class="p">);</span>

<span class="c1">// 3. 设置显示模式</span>
<span class="n">drmModeSetCrtc</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">crtc_id</span><span class="p">,</span> <span class="n">fb_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
               <span class="o">&amp;</span><span class="n">connector_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mode</span><span class="p">);</span>

<span class="c1">// 4. 页面翻转（垂直同步）</span>
<span class="n">drmModePageFlip</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">crtc_id</span><span class="p">,</span> <span class="n">new_fb_id</span><span class="p">,</span>
                <span class="n">DRM_MODE_PAGE_FLIP_EVENT</span><span class="p">,</span> <span class="n">userdata</span><span class="p">);</span>
</code></pre></div></div> <h3 id="6-完整设备文件创建时间线">6. 完整设备文件创建时间线</h3> <p>让我们追踪一个鼠标插入时的完整过程：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 时间线：鼠标插入 → 设备文件出现</span>

时刻1: 硬件检测
<span class="o">[</span>内核] USB控制器检测到新设备插入

时刻2: 设备枚举
<span class="o">[</span>内核] 读取设备描述符: <span class="nv">VID</span><span class="o">=</span>046d, <span class="nv">PID</span><span class="o">=</span>c52b <span class="o">(</span>Logitech鼠标<span class="o">)</span>

时刻3: 驱动匹配
<span class="o">[</span>内核] usbhid驱动匹配成功，调用probe函数

时刻4: 资源分配
<span class="o">[</span>内核] 分配设备号 13:66 <span class="o">(</span>INPUT_MAJOR:66<span class="o">)</span>

时刻5: 设备注册
<span class="o">[</span>内核] input_register_device<span class="o">()</span> → device_add<span class="o">()</span>

时刻6: sysfs创建
<span class="o">[</span>内核] 在/sys/devices/.../ 创建设备目录
<span class="o">[</span>内核] 在/sys/class/input/ 创建event2符号链接

时刻7: uevent发送
<span class="o">[</span>内核] 发送netlink消息:
        <span class="nv">ACTION</span><span class="o">=</span>add
        <span class="nv">SUBSYSTEM</span><span class="o">=</span>input
        <span class="nv">DEVNAME</span><span class="o">=</span>input/event2
        <span class="nv">MAJOR</span><span class="o">=</span>13
        <span class="nv">MINOR</span><span class="o">=</span>66

时刻8: udev处理
<span class="o">[</span>udev] 接收uevent消息
<span class="o">[</span>udev] 匹配规则文件
<span class="o">[</span>udev] 执行: <span class="nb">mknod</span> /dev/input/event2 c 13 66
<span class="o">[</span>udev] 设置权限: <span class="nb">chmod </span>644 /dev/input/event2
<span class="o">[</span>udev] 创建符号链接: <span class="nb">ln</span> <span class="nt">-s</span> event2 /dev/input/mouse0

时刻9: 用户可见
<span class="o">[</span>用户] <span class="nb">ls</span> /dev/input/ 可以看到新的设备文件
</code></pre></div></div> <h3 id="7-驱动开发核心要点总结">7. 驱动开发核心要点总结</h3> <h4 id="71-通用驱动开发步骤">7.1 通用驱动开发步骤</h4> <ol> <li> <strong>硬件理解</strong>：阅读设备数据手册，理解寄存器布局和时序要求</li> <li> <strong>接口设计</strong>：确定设备类型（字符/块/网络设备）和用户接口</li> <li> <strong>资源管理</strong>：正确分配和释放 I/O 端口、内存、中断等资源</li> <li> <strong>中断处理</strong>：实现高效的中断服务例程，避免长时间占用 CPU</li> <li> <strong>错误处理</strong>：处理硬件故障、超时等异常情况</li> <li> <strong>电源管理</strong>：支持设备的休眠和唤醒功能</li> <li> <strong>并发控制</strong>：使用适当的锁机制保证多线程安全</li> </ol> <h4 id="72-完整的驱动注册示例">7.2 完整的驱动注册示例</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 定义file_operations结构体</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">my_device_fops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">owner</span>   <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">open</span>    <span class="o">=</span> <span class="n">my_device_open</span><span class="p">,</span>
    <span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">my_device_read</span><span class="p">,</span>
    <span class="p">.</span><span class="n">write</span>   <span class="o">=</span> <span class="n">my_device_write</span><span class="p">,</span>
    <span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">my_device_ioctl</span><span class="p">,</span>
    <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">my_device_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// 设备初始化</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_device_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

    <span class="c1">// 1. 分配设备号</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">alloc_chrdev_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev_number</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"my_device"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

    <span class="c1">// 2. 创建字符设备</span>
    <span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_cdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_device_fops</span><span class="p">);</span>
    <span class="n">my_cdev</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>

    <span class="c1">// 3. 添加设备到系统</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_cdev</span><span class="p">,</span> <span class="n">dev_number</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev_number</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 4. 创建设备文件 /dev/my_device</span>
    <span class="n">device_create</span><span class="p">(</span><span class="n">my_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">dev_number</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">"my_device"</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="73-调试技巧">7.3 调试技巧</h4> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1. 查看设备信息</span>
lspci <span class="nt">-v</span>                    <span class="c"># PCI设备</span>
lsusb <span class="nt">-v</span>                    <span class="c"># USB设备</span>
<span class="nb">cat</span> /proc/interrupts        <span class="c"># 中断统计</span>
<span class="nb">cat</span> /proc/iomem             <span class="c"># 内存映射</span>

<span class="c"># 2. 驱动调试</span>
dmesg | <span class="nb">grep </span>my-driver      <span class="c"># 内核日志</span>
debugfs                     <span class="c"># 调试文件系统</span>
ftrace                      <span class="c"># 函数跟踪</span>

<span class="c"># 3. 用户空间测试</span>
evtest /dev/input/event2    <span class="c"># 测试输入设备</span>
xrandr                      <span class="c"># 测试显示设备</span>

<span class="c"># 4. 查看设备模型结构</span>
<span class="nb">ls</span> <span class="nt">-la</span> /sys/devices/
<span class="nb">ls</span> <span class="nt">-la</span> /sys/class/input/

<span class="c"># 5. 查看设备属性</span>
udevadm info <span class="nt">-a</span> <span class="nt">-p</span> /sys/class/input/event2

<span class="c"># 6. 监控udev事件</span>
udevadm monitor

<span class="c"># 7. 测试udev规则</span>
udevadm <span class="nb">test</span> /sys/class/input/event2
</code></pre></div></div> <h4 id="74-性能优化">7.4 性能优化</h4> <ol> <li> <strong>减少内存拷贝</strong>：使用 DMA 直接传输，避免 CPU 参与数据搬移</li> <li> <strong>中断合并</strong>：批量处理中断事件，减少上下文切换开销</li> <li> <strong>异步处理</strong>：使用工作队列处理耗时操作，避免阻塞中断上下文</li> <li> <strong>缓存友好</strong>：合理设计数据结构，提高缓存命中率</li> </ol> <h4 id="75-核心理解要点">7.5 核心理解要点</h4> <ol> <li> <strong>设备文件不是驱动直接创建的</strong>，而是通过设备模型 →udev→ 设备文件的流程</li> <li> <strong>设备文件是数据通道</strong>：硬件事件 → 驱动解析 → 输入子系统 → 设备文件 → 用户程序</li> <li> <strong>驱动的核心作用</strong>： <ul> <li>硬件抽象：将原始电信号转换为标准化事件</li> <li>资源管理：分配和管理硬件资源</li> <li>事件转换：将硬件特定格式转换为通用格式</li> </ul> </li> <li> <strong>异步性</strong>：硬件事件立即触发中断，驱动立即处理并放入事件队列</li> <li> <strong>file_operations 是驱动的”接口合同”</strong>：定义了驱动必须实现的操作</li> <li> <strong>用户空间-内核空间数据传输</strong>：必须使用 <code class="language-plaintext highlighter-rouge">copy_to_user()</code>/<code class="language-plaintext highlighter-rouge">copy_from_user()</code> </li> <li> <strong>私有数据传递</strong>：通过 <code class="language-plaintext highlighter-rouge">file-&gt;private_data</code> 在函数调用间传递设备信息</li> <li> <strong>设备模型提供统一框架</strong>，udev 负责根据内核事件和用户定义的规则来创建实际的设备文件</li> <li> <strong>驱动程序在系统启动/模块加载时就常驻内存</strong>，等待硬件事件触发执行</li> </ol> <p>通过理解这些核心概念和实现细节，我们可以更好地掌握操作系统如何与硬件协同工作，以及如何编写高质量的设备驱动程序。设备管理的精妙之处在于：它将复杂的硬件操作抽象成了简单的文件操作，让用户程序可以用统一的方式访问各种不同的硬件设备，同时通过分层设计实现了内核空间硬件管理与用户空间策略决策的完美分离。</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/6_internet.md/">（七）内核那些事儿：操作系统对网络包的处理</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/5_fileSystem.md/">（六）内核那些事儿：文件系统</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/4_interaction.md/">（五）内核那些事儿：系统和程序的交互</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_signal.md/">（三）内核那些事儿：CPU中断和信号</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/1_program.md/">（二）内核那些事儿：程序启动到运行的完整过程</a> </li> </div> </div> <div class="col-sm-4"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <script src="/assets/js/toc-depth.js"></script> </body> </html>