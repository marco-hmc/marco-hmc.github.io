<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> （一）模板那些事儿：是什么？ | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/toc-custom.css"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/0_template_introduction/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-8"> <div class="post"> <header class="post-header"> <h1 class="post-title">（一）模板那些事儿：是什么？</h1> <p class="post-meta"> Created on May 25, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/cpp"> <i class="fa-solid fa-hashtag fa-sm"></i> cpp</a>   <a href="/blog/tag/template"> <i class="fa-solid fa-hashtag fa-sm"></i> template</a>   ·   <a href="/blog/category/cpp"> <i class="fa-solid fa-tag fa-sm"></i> cpp</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="一模板那些事儿是什么">（一）模板那些事儿：是什么？</h2> <ol> <li> <strong>模板基础</strong>：介绍模板的基本概念和语法，包括函数模板和类模板的定义和使用。</li> <li> <strong>模板参数</strong>：详细讲解模板参数的类型，包括类型模板参数、非类型模板参数和模板模板参数。</li> <li> <strong>模板实例化</strong>：解释模板实例化的概念和时机，包括显式实例化和隐式实例化。</li> <li> <strong>模板特化</strong>：介绍模板特化的概念和应用场景，包括部分特化和全特化。</li> </ol> <h3 id="1-模板基础">1. 模板基础</h3> <h4 id="11-什么是模板">1.1 什么是模板</h4> <p>从应用层次来看，C++中的模板堪称一种极为强大的泛型编程工具，它使得编写与类型无关的代码成为可能。借助模板，只需完成一次代码编写，就能在各种不同场景中重复运用，无需针对每种类型都另行编写代码。</p> <p>从概念层面来讲，对于编译器而言，模板可看作是一种基于类型的编程模式，也可称之为面向类型编程。模板的值对象涵盖类型与常量。模板特化类似于针对类型进行条件判断，它允许针对特定类型提供专门的模板实现。例如，当模板在处理多种不同类型时，如果对某些特定类型存在特殊需求，便可借助模板特化来予以满足。而模板递归则是通过持续不断地实例化模板来逐步展开。这表明模板具备类似于变量、条件判断（if - else）以及循环（loop）的能力，只不过这些能力的实现方式与常规 C++开发存在差异。正因如此，不少人觉得 C++的模板近乎一门独立的语言，基于此的编程方式便被称作模板元编程。</p> <ul> <li> <strong>狭义泛型编程层面</strong>：如前文所述，由于编写的是与类型无关的代码，一旦声明具体类型并完成模板实例化，代码即可实现复用。例如，编写一个简单的交换函数模板：</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>然而，这种实现并非尽善尽美，它无法处理指针类型的交换。为解决此问题，可以利用模板特化来实现针对指针类型的交换函数。在这个例子中，仅需对指针类型这一个例子进行特化。但倘若需要对具有某种性质的一类类型进行特化，情况又当如何呢？</p> <p>例如，对于一个容器类型的<code class="language-plaintext highlighter-rouge">clear()</code>函数，POD 类型（Plain Old Data，即具有平凡构造函数、平凡析构函数、平凡拷贝构造函数且为标准布局的数据类型，像 C++中的基本数据类型<code class="language-plaintext highlighter-rouge">int</code>、<code class="language-plaintext highlighter-rouge">char</code>等以及满足特定条件的自定义结构体和类都属于 POD 类型）和自定义类型的实现要求便有所不同。POD 类型通常不涉及复杂的资源管理，其析构函数的概念相对薄弱，在<code class="language-plaintext highlighter-rouge">clear()</code>函数中直接使用<code class="language-plaintext highlighter-rouge">memset(0)</code>来清理内存即可；而自定义类型可能涉及资源管理，调用<code class="language-plaintext highlighter-rouge">clear()</code>时需要逐个调用元素的析构函数。此时，模板的条件判断能力就显得至关重要。那该如何通过模板特化来实现呢？</p> <p>实际上，一般模板特化的实现更近似于<code class="language-plaintext highlighter-rouge">switch - case</code>的形式，只能有一个特化的实现，而无法达成类似于<code class="language-plaintext highlighter-rouge">if - else</code>的多重特化。为解决这一难题，C++11 引入了<code class="language-plaintext highlighter-rouge">std::enable_if</code>，它允许在模板参数中运用条件表达式，进而实现更为灵活的模板特化。通过这种方式，能够依据类型的特性来选择不同的实现。</p> <ul> <li> <strong>模板内容划分</strong> 关于模板的内容我会从两方面展开讲，简单划分为入门内容（语法层面），进阶内容（模板元编程层面）展开。具体如下：</li> </ul> <ol> <li> <p><strong>入门使用-简单泛型编程（Generic Programming）</strong>：</p> <ul> <li> <strong>函数模板</strong>：函数模板允许编写与类型无关的函数，通过类型参数化实现函数的泛型。例如，<code class="language-plaintext highlighter-rouge">std::sort</code> 可以对任何类型的容器进行排序。</li> <li> <strong>类模板</strong>：类模板允许编写与类型无关的类，通过类型参数化实现类的泛型。例如，<code class="language-plaintext highlighter-rouge">std::map&lt;Key, Value&gt;</code> 可以存储任何类型的键值对。</li> <li> <strong>变量模板</strong>：主要是用于模板元编程，类型特征那套，也可以用于表示<code class="language-plaintext highlighter-rouge">pi</code>在不同类型下的大小吧，比如说精度要求不高，可以<code class="language-plaintext highlighter-rouge">float</code>和<code class="language-plaintext highlighter-rouge">double</code>各定义一个<code class="language-plaintext highlighter-rouge">pi</code>吧。</li> <li> <strong>模板参数</strong>：模板允许编写与类型无关的代码，通过类型参数化实现代码复用。例如，<code class="language-plaintext highlighter-rouge">std::vector&lt;T&gt;</code> 可以存储任何类型的元素。</li> <li> <strong>模板特化</strong>：模板特化允许为特定类型提供特殊的实现，从而优化特定类型的操作。例如，<code class="language-plaintext highlighter-rouge">std::hash</code> 可以为不同类型提供不同的哈希函数。</li> </ul> </li> <li> <p><strong>进阶使用-模板元编程（Template Metaprogramming）</strong>：</p> <ul> <li> <strong>类型特征（Type Traits）</strong>：通过模板元编程，可以实现类型特征，用于在编译期检查和操作类型。进一步地，可以认为是一种函数。其参数为类型或者字面量。例如，<code class="language-plaintext highlighter-rouge">std::is_integral</code> 可以用于检查一个类型是否是整型。</li> <li> <strong>递归模板</strong>：模板元编程通常使用递归模板来实现复杂的编译期计算。例如，计算编译期常量、生成类型列表等。</li> <li> <strong>条件编译</strong>：通过模板元编程，可以实现条件编译，根据不同的模板参数生成不同的代码。而 SAFINAE 是模板元编程，利用 type traits 实现条件编译的一种常见手段。</li> </ul> </li> <li> <p><strong>模板实践</strong></p> <ul> <li>不定长参数</li> <li>类型擦除</li> <li>表达式模板</li> </ul> </li> </ol> <h4 id="12-模板的基本语法">1.2 模板的基本语法</h4> <p>模板的基本语法包括模板声明、模板定义和模板实例化。模板声明和定义使用 <code class="language-plaintext highlighter-rouge">template</code> 关键字，后跟模板参数列表。模板参数列表可以包含类型参数和非类型参数。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="c1">// 函数模板</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="n">T</span> <span class="n">functionName</span><span class="p">(</span><span class="n">T</span> <span class="n">parameter</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="p">{</span>
    <span class="c1">// 类模板</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">ClassName</span> <span class="p">{</span>
      <span class="nl">public:</span>
        <span class="n">T</span> <span class="n">memberFunction</span><span class="p">(</span><span class="n">T</span> <span class="n">parameter</span><span class="p">)</span> <span class="p">{}</span>

      <span class="k">private</span><span class="o">:</span>
        <span class="n">T</span> <span class="n">memberVariable</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="p">{</span>

    <span class="c1">// C++14（变量模板）</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">is_integral_v</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="p">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">fib</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">fib</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">fib</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">fib</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">fib</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span> <span class="o">==</span> <span class="mi">55</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="121-注入类名">1.2.1 注入类名</h5> <p>在 C++中，类模板的注入类名（Injected class name）是指在类模板内部，类模板名可以被用作一个类型名，并且这个名字会隐式地被替换为当前实例化的模板类型。下面详细介绍其含义和使用场景。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// ctor里面的MyClass能直接使用，不需要再考虑模板实例化，这个就是注入类名</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy constructor called."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 模板又实例化一次是多余的。</span>
    <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">MyClass</span> <span class="nf">createInstance</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">MyClass</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre></div></div> <h5 id="122-依赖名称">1.2.2 依赖名称</h5> <ul> <li><strong>依赖名称和 typename</strong></li> </ul> <p>依赖名称是模板定义中，其含义依赖于模板参数的名称。这些名称的类型或值，需在模板实例化时才能确定。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Container</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Iterator print"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">Iterator</span> <span class="nf">getIterator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Iterator</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Container&lt;T&gt;是依赖名称，因为其具体类型依赖于模板参数T</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Container&lt;T&gt;::Iterator同样是依赖名称，其具体类型也依赖于模板参数T</span>
    <span class="k">typename</span> <span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">container</span><span class="p">.</span><span class="n">getIterator</span><span class="p">();</span>
    <span class="n">it</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>依赖名称不仅包括依赖于模板参数实例化的类型，还可能涉及函数名等其他名称，只要其含义依赖于模板参数，均属于依赖名称。</li> <li>当编译器解析到<code class="language-plaintext highlighter-rouge">Container&lt;T&gt;::Iterator</code>时，由于模板尚未实例化，它无法确定这是一个类型。</li> <li>因此，需使用<code class="language-plaintext highlighter-rouge">typename</code>关键字显式告知编译器，<code class="language-plaintext highlighter-rouge">Container&lt;T&gt;::Iterator</code>是一个类型。</li> <li> <p>在函数模板的参数列表中，对于依赖类型名称，<code class="language-plaintext highlighter-rouge">typename</code>关键字通常是可选的，因为编译器能通过上下文推断类型。但在函数返回类型中，如果涉及依赖类型名称，一般必须使用<code class="language-plaintext highlighter-rouge">typename</code> 关键字来明确表明其为类型。而在声明变量时，为避免编译器将依赖名称误解为其他实体（如成员函数），必须加上<code class="language-plaintext highlighter-rouge">typename</code>关键字。</p> </li> <li><strong>依赖名称和 template</strong></li> </ul> <p>在 C++模板编程中，当处理嵌套模板结构时，<code class="language-plaintext highlighter-rouge">template</code> 关键字具有特殊的用途。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Container</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// 定义了一个嵌套的模板函数 print</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">U</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Value: "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 此处 c.print&lt;int&gt;(42); 这样的写法编译器无法识别 print 是一个模板函数。</span>
    <span class="c1">// 因为编译器在解析代码时，对于依赖于模板参数 T 的表达式 c.print，</span>
    <span class="c1">// 它无法预先知道 print 是一个模板。</span>
    <span class="c1">// 使用 c.template print&lt;int&gt;(42); 明确告诉编译器，print 是一个模板函数，</span>
    <span class="c1">// 这样编译器才能正确地实例化这个嵌套的模板函数。</span>
    <span class="n">c</span><span class="p">.</span><span class="k">template</span> <span class="n">print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Container</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">test</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在 <code class="language-plaintext highlighter-rouge">test</code> 函数中，由于 <code class="language-plaintext highlighter-rouge">Container&lt;T&gt;</code> 是依赖于模板参数 <code class="language-plaintext highlighter-rouge">T</code> 的类型，对于 <code class="language-plaintext highlighter-rouge">c.print</code> 这样的表达式，编译器在解析时无法自动识别 <code class="language-plaintext highlighter-rouge">print</code> 是一个模板函数。使用 <code class="language-plaintext highlighter-rouge">template</code> 关键字（即 <code class="language-plaintext highlighter-rouge">c.template print&lt;int&gt;(42);</code>），能够明确告知编译器 <code class="language-plaintext highlighter-rouge">print</code> 是一个模板函数，以便编译器正确地对其进行实例化。这确保了在处理复杂模板结构时，编译器能够准确理解代码意图，避免潜在的编译错误。</p> <h3 id="2-模板参数">2. 模板参数</h3> <h4 id="21-类型模板参数">2.1 类型模板参数</h4> <p>类型模板参数是指在模板定义中，以类型作为参数的一种机制。通过类型模板参数，我们可以让模板适应不同的数据类型，从而提高代码的通用性。例如，在常见的 <code class="language-plaintext highlighter-rouge">std::vector</code> 模板中，<code class="language-plaintext highlighter-rouge">typename T</code> 就是类型模板参数，使得 <code class="language-plaintext highlighter-rouge">std::vector</code> 可以存储各种不同类型的数据，如 <code class="language-plaintext highlighter-rouge">std::vector&lt;int&gt;</code>、<code class="language-plaintext highlighter-rouge">std::vector&lt;double&gt;</code> 等。在模板定义中，通常使用 <code class="language-plaintext highlighter-rouge">typename</code> 或 <code class="language-plaintext highlighter-rouge">class</code> 关键字来声明类型模板参数，二者在这种场景下语义相同。</p> <h4 id="22-非类型模板参数">2.2 非类型模板参数</h4> <p>非类型模板参数是模板参数的一种特殊形式，它用于在模板定义中指定常量值。与类型模板参数不同，非类型模板参数代表的是具体的常量，而非数据类型。这些常量可以是整数、枚举、指针或引用等。</p> <p>使用非类型模板参数能够在编译期确定一些值，从而增强代码的灵活性和效率。例如，我们可以定义一个固定大小的数组模板，通过非类型模板参数指定数组的大小：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">FixedSizeArray</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">data</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
<span class="nl">public:</span>
    <span class="n">FixedSizeArray</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>这里的 <code class="language-plaintext highlighter-rouge">int size</code> 就是非类型模板参数，在实例化模板时，必须提供一个常量值来确定数组的大小，如 <code class="language-plaintext highlighter-rouge">FixedSizeArray&lt;int, 10&gt; arr;</code> 就创建了一个大小为 10 的 <code class="language-plaintext highlighter-rouge">int</code> 类型数组。</p> <h4 id="23-模板模板参数">2.3 模板模板参数</h4> <p>模板模板参数允许我们编写接受其他模板作为参数的模板，这进一步提升了代码的灵活性和重用性。它为模板提供了一种更高层次的抽象，使得我们可以基于不同的模板容器实现通用的功能。</p> <p>例如，假设有一个 <code class="language-plaintext highlighter-rouge">Container</code> 类模板用于存储数据：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="c1">// 类模板示例</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Container</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 模板参数还是模板的示例</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">ContainerType</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Wrapper</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">container</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">container</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">ContainerType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">container</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">Container</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">intWrapper</span><span class="p">;</span>
    <span class="n">intWrapper</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">intWrapper</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上述代码中，<code class="language-plaintext highlighter-rouge">template &lt;typename&gt; class ContainerType</code> 就是模板模板参数，它表示一个接受单个类型参数的模板。<code class="language-plaintext highlighter-rouge">Wrapper</code> 模板可以接受任何符合这种模板形式的容器模板，如 <code class="language-plaintext highlighter-rouge">Container</code>，并对其进行封装，提供统一的接口。</p> <p>实际上，模板也可以看成是一种类型，只不过这种类型是在编译时才能确定的。它为 C++ 提供了强大的元编程能力，使得我们可以在编译期完成一些复杂的计算和代码生成，提高程序的运行效率和灵活性。</p> <h3 id="3-模板实例化">3. 模板实例化</h3> <p>隐式实例化指的是当编译器首次察觉到需要使用某个模板时，会自动为其生成对应的模板实例。也就是说，在代码中首次调用模板函数或创建模板类对象时，编译器根据传入的实际模板参数类型，自动生成具体的函数或类定义。例如：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="c1">// 在此处，由于使用了add函数且传入int类型参数，编译器自动生成int类型的add函数实例，即发生了隐式实例化。</span>

    <span class="kt">double</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">);</span>
    <span class="c1">// 同理，这里传入double类型参数，编译器又会隐式实例化出double类型的add函数实例。</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="32-显式实例化">3.2 显式实例化</h4> <p>显式实例化要求在代码中明确指定模板参数，以此强制编译器生成特定类型的模板实例。其主要应用场景在于优化编译过程，具体表现为：</p> <ul> <li> <strong>提高编译速度</strong>：在大型项目中，若某些模板实例会被频繁使用，提前进行显式实例化，可避免在多个编译单元中重复隐式实例化相同的模板，从而减少编译时间。</li> <li> <strong>减少代码膨胀</strong>：当模板实例化出的代码量较大且相同类型的实例在多处使用时，显式实例化可确保仅生成一份实例代码，避免因多次隐式实例化导致的代码体积增大。</li> </ul> <p>示例如下：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 显式实例化add函数模板，明确指定生成int类型和double类型的add函数实例</span>
<span class="k">template</span> <span class="kt">int</span> <span class="n">add</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">template</span> <span class="kt">double</span> <span class="n">add</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">&gt;(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="c1">// 这里直接使用显式实例化生成的int类型的add函数。</span>
    <span class="kt">double</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">);</span>
    <span class="c1">// 同样，使用显式实例化生成的double类型的add函数。</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>需注意，在进行显式实例化时，要确保显式实例化的声明与模板定义在同一作用域内，否则可能导致链接错误。同时，若在同一编译单元中对同一模板进行多次显式实例化，也会引发编译错误。</p> <ul> <li><strong>显式实例化怎么做？</strong></li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* -------- a.hpp --------- */</span>
<span class="cp">#pragma once
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">&gt;;</span>         <span class="c1">// 声明 A&lt;int&gt; 的显式实例化</span>
<span class="k">extern</span> <span class="k">template</span> <span class="kt">void</span> <span class="n">A</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">&gt;</span><span class="o">::</span><span class="n">f</span><span class="p">();</span>  <span class="c1">// 声明 A&lt;double&gt;::f() 的显式实例化</span>

<span class="cm">/* -------- a.cpp --------- */</span>
<span class="cp">#include</span> <span class="cpf">"a.hpp"</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="k">template</span> <span class="k">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">&gt;;</span>  <span class="c1">// 实例化 A&lt;int&gt;</span>
<span class="k">template</span> <span class="kt">void</span> <span class="n">A</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">&gt;</span><span class="o">::</span><span class="n">f</span><span class="p">();</span>  <span class="c1">// 实例化 A&lt;double&gt;::f()</span>

<span class="cm">/* -------- main.cpp --------- */</span>
<span class="cp">#include</span> <span class="cpf">"a.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{}.</span><span class="n">f</span><span class="p">();</span>
  <span class="n">A</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{}.</span><span class="n">f</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="33-模板链接">3.3 模板链接</h4> <h5 id="331-模板实现不能放在cpp">3.3.1 模板实现不能放在.cpp</h5> <p>在C++ 编程中，通常不建议将模板的实现放在 <code class="language-plaintext highlighter-rouge">.cpp</code> 文件中。这是因为模板的实例化是在编译期进行的，编译器需要同时看到模板的声明和定义，才能根据具体的模板参数生成对应的实例化代码。</p> <p>当模板定义在 <code class="language-plaintext highlighter-rouge">.cpp</code> 文件中时，不同的编译单元（通常是不同的 <code class="language-plaintext highlighter-rouge">.cpp</code> 文件及其对应的 <code class="language-plaintext highlighter-rouge">.h</code> 文件）在编译时是相互独立的。如果一个编译单元只包含了模板的声明，而在另一个编译单元的 <code class="language-plaintext highlighter-rouge">.cpp</code> 文件中有模板的实现，那么在链接阶段就可能会出现问题。因为链接器无法找到模板实例化所需的定义，导致链接错误。</p> <p>为了避免这种情况，一般将模板的声明和定义都放在头文件（<code class="language-plaintext highlighter-rouge">.h</code> 或 <code class="language-plaintext highlighter-rouge">.hpp</code>）中，这样所有包含该头文件的编译单元在编译时都能获取到完整的模板信息，从而顺利进行实例化。</p> <h5 id="332-模板不能具有-c-链接">3.3.2 模板不能具有 C 链接</h5> <p>C++ 的模板不能与 C 语言的链接规范（C linkage）一起使用。链接规范决定了编译器如何生成符号以及链接器如何解析这些符号。C语言和C++ 语言的链接规范有所不同，C++ 为了支持函数重载等特性，其符号命名规则更为复杂。</p> <p>模板是 C++ 特有的高级特性，依赖于 C++ 的编译和链接机制。当使用 <code class="language-plaintext highlighter-rouge">extern "C"</code> 来指定 C 链接规范时，它会改变符号的命名规则，使得模板实例化生成的符号无法按照 C++ 的方式被正确解析。例如：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">jc</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="s">"C++"</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">normal</span><span class="p">();</span>  <span class="c1">// 正确：默认 C++ 链接规范，编译器按照 C++ 的符号命名规则处理该模板函数</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">invalid</span><span class="p">();</span>  <span class="c1">// 错误：不能使用 C 链接，因为 C 链接规范下无法正确处理模板实例化生成的符号</span>
<span class="p">}</span>  <span class="c1">// namespace jc</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div> <p>而使用 <code class="language-plaintext highlighter-rouge">extern "C++"</code> 时，即为默认的 C++ 链接规范，编译器和链接器能够正确处理模板相关的符号。</p> <h5 id="333-模板的外链接与静态链接">3.3.3 模板的外链接与静态链接</h5> <p>在C++ 中，模板通常具有外链接（<strong>external linkage</strong>）特性。这意味着模板的定义在整个程序中是共享的，不同的编译单元可以引用同一个模板实例化生成的代码。当多个编译单元都需要使用某个模板的特定实例时，链接器会确保这些实例是同一个。</p> <p>然而，对于<strong>静态模板函数</strong>（即在模板函数定义前加上 <code class="language-plaintext highlighter-rouge">static</code> 关键字），它会具有内部链接（<strong>internal linkage</strong>）。具有内部链接的实体在当前翻译单元内可见，但在其他翻译单元中不可见。这是因为 <code class="language-plaintext highlighter-rouge">static</code> 关键字改变了模板函数的链接属性，使得每个编译单元都拥有自己独立的该静态模板函数的实例，而不会与其他编译单元共享。例如：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>  <span class="c1">// 外部链接，不同编译单元可共享该模板实例化生成的代码</span>
<span class="kt">void</span> <span class="nf">external</span><span class="p">();</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>  <span class="c1">// 内部链接，每个编译单元都有自己独立的该静态模板函数实例</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal</span><span class="p">();</span>

<span class="k">namespace</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span>  <span class="c1">// 匿名命名空间内的模板具有内部链接，同样每个编译单元独立实例化</span>
    <span class="kt">void</span> <span class="n">other_internal</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>  <span class="c1">// 无链接：这种在结构体内部定义的模板不能被重复声明，仅在结构体内部使用</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span> <span class="n">x</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div> <p>理解模板的链接特性对于编写大型项目以及避免链接错误至关重要。在实际编程中，应根据需求合理选择模板的链接方式，以确保代码的正确性和高效性。</p> <h3 id="4-模板特化">4. 模板特化</h3> <h3 id="4-模板特化-1">4. 模板特化</h3> <p>在 C++ 模板编程领域，模板特化（Template Specialization）是一项极为关键的技术。它赋予开发者针对特定的模板参数设定独特实现的能力，进而显著增强代码的灵活性与性能表现。模板特化主要细分为部分特化和全特化两种类型。</p> <p>模板特化在众多实际编程场景中具有不可或缺的作用：</p> <ul> <li> <strong>优化特定类型</strong>：当涉及某些特定类型时，为其量身定制优化后的实现，能够有效提升程序性能。例如，在处理 <code class="language-plaintext highlighter-rouge">int</code> 类型数据时，由于其使用频率高且特性明确，可提供特殊实现以加快处理速度。</li> <li> <strong>处理特殊情况</strong>：针对特定类型或者特定条件下的特殊状况，模板特化可发挥重要作用。以指针类型为例，因其涉及解引用操作和内存管理等复杂问题，通过为指针类型提供特殊实现，能够更妥善地处理这些情况。</li> <li> <strong>实现类型特征</strong>：借助模板特化，能够实现类型特征（type traits），这对于在编译阶段检测类型属性至关重要。比如，通过模板特化实现检查某个类型是否为指针类型、是否为整数类型等功能。</li> </ul> <h4 id="41-模板特化">4.1 模板特化</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">FullSpecialization</span> <span class="p">{</span>
    <span class="c1">// 主模板</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
      <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Primary template"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// 模板特化</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Full specialization for int"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace FullSpecialization</span>

</code></pre></div></div> <h4 id="42-模板偏特化">4.2 模板偏特化</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">PartialSpecialization</span> <span class="p">{</span>
    <span class="c1">// 主模板</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
      <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Primary template"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// 偏特化-部分模板参数特化</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Partial specialization: second parameter is int"</span>
                      <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace PartialSpecialization</span>
</code></pre></div></div> <h4 id="43-特化的推断规则">4.3 特化的推断规则</h4> <p>在C++ 中，当存在多个模板都能匹配给定的模板参数时，编译器会依据偏序规则来选择最合适的模板。若无法明确判断哪个模板更特化，编译器将报出歧义错误。</p> <p>所谓“更特化”，可以这样理解：对于两个模板，如果在所有能使其中一个模板匹配的模板参数实例化情况下，另一个模板也能匹配，并且存在至少一种情况，使得后者匹配而前者不匹配，那么前者就是更特化的模板。换个角度看，如果把模板参数的匹配情况看作集合，更特化的模板所对应的参数匹配集合是另一个模板参数匹配集合的真子集。</p> <p>以下通过代码示例详细说明：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 3</span>
    <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 0 推断为 int，匹配第一个模板</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

    <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// 两个模板均匹配，第二个模板更特殊。T*是T的真子集</span>

    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">pp</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 两个模板均匹配，第三个模板更特殊。const T*是T和T*的真子集</span>
<span class="p">}</span>
</code></pre></div></div> <p>通过这样的规则和示例，希望能帮助你更清晰地理解模板特化的推断过程。</p> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-不同源文件都使用了vectorint有没有违反-odr-原则实例化了几次代码里面会有多少vectorint的定义">1. 不同源文件都使用了<code class="language-plaintext highlighter-rouge">vector&lt;int&gt;</code>，有没有违反 odr 原则？实例化了几次？代码里面会有多少<code class="language-plaintext highlighter-rouge">vector&lt;int&gt;</code>的定义？</h4> <p>在 C++ 中，模板实例化的行为取决于编译器和链接器的实现。通常情况下，如果多个源文件都使用了相同的模板实例（例如 vector<int>），编译器会在每个使用该模板实例的源文件中生成一份实例化代码。然而，链接器会负责消除重复的实例化代码，只保留一份最终的实例化代码。</int></p> <p>也就是说不同源文件使用了相同的模板实例就会各自实例化，但是链接器会优化，合并重复实例代码。注意，合并了重复的实例代码，只是减轻了代码生成的体积，实例的开销没办法去掉，所以模板用多了，编译会慢一些，开销在于模板实例化。</p> <h4 id="2-什么是-adl">2. 什么是 ADL？</h4> <p>ADL（Argument - Dependent Lookup，依赖于实参的查找）是 C++ 中一种特殊的函数查找机制。在常规的函数调用中，编译器会在函数调用点的作用域以及包含该函数调用的命名空间中查找函数声明。而 ADL 则额外在实参类型所属的命名空间中查找函数声明，这使得在调用函数时，即使函数不在当前作用域内直接可见，只要它在实参类型相关的命名空间中，也能被找到并调用。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">MyNamespace</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">MyType</span> <span class="p">{};</span>

    <span class="kt">void</span> <span class="nf">someFunction</span><span class="p">(</span><span class="n">MyType</span> <span class="n">myArg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Function in MyNamespace called"</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">myTemplateFunction</span><span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">someFunction</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyNamespace</span><span class="o">::</span><span class="n">MyType</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">myTemplateFunction</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上述代码中，<code class="language-plaintext highlighter-rouge">myTemplateFunction</code> 模板函数内部调用 <code class="language-plaintext highlighter-rouge">someFunction</code> 时，虽然 <code class="language-plaintext highlighter-rouge">someFunction</code> 不在 <code class="language-plaintext highlighter-rouge">myTemplateFunction</code> 的直接作用域内，但因为 <code class="language-plaintext highlighter-rouge">arg</code> 的类型是 <code class="language-plaintext highlighter-rouge">MyNamespace::MyType</code>，ADL 机制会在 <code class="language-plaintext highlighter-rouge">MyNamespace</code> 命名空间中查找 <code class="language-plaintext highlighter-rouge">someFunction</code>，从而成功调用该函数。这展示了 ADL 如何让模板函数在不明确知道具体类型细节的情况下，利用参数类型在相应命名空间中找到合适的函数进行调用。</p> <h4 id="3-下面这些代码的注释处为什么不行">3. 下面这些代码的注释处为什么不行？</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">StringLinkErrorTpl</span> <span class="p">{</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">S</span> <span class="p">{</span>
      <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>  <span class="c1">// external linked object</span>
    <span class="kt">void</span> <span class="nf">syntax_literal_string_ok_example</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">S</span><span class="o">&lt;</span><span class="n">str</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">i</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">syntax_literal_string_fail_example</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>  <span class="c1">// running linked object</span>
        <span class="c1">// S&lt;str&gt; i; // not ok</span>
        <span class="c1">// i.print();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">task</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">syntax_literal_string_ok_example</span><span class="p">();</span>
        <span class="n">syntax_literal_string_fail_example</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace StringLinkErrorTpl</span>

<span class="k">namespace</span> <span class="n">PtrLinkErrorTpl</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span> <span class="n">buf</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">ArrPtr</span> <span class="p">{};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fun</span><span class="p">)()&gt;</span>
    <span class="k">struct</span> <span class="nc">FuncPtr</span> <span class="p">{};</span>

    <span class="kt">void</span> <span class="nf">task</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
        <span class="n">ArrPtr</span><span class="o">&lt;</span><span class="n">buffer</span><span class="o">&gt;</span> <span class="n">arrPtr</span><span class="p">;</span>

        <span class="c1">// int buffer2[5] = {1, 2, 3, 4, 5};  // not ok</span>
        <span class="c1">// ArrPtr&lt;buffer2&gt; arrPtr2;</span>

        <span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">};</span>
        <span class="n">FuncPtr</span><span class="o">&lt;</span><span class="n">func</span><span class="o">&gt;</span> <span class="n">funcPtr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace PtrLinkErrorTpl</span>
</code></pre></div></div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/5_template_typeErasure/">（六）模板那些事儿：类型擦除</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/5_openmp/">（五）多线程那些事儿：并行库 openmp</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/4_template_expressTpl/">（五）模板那些事儿：模板元</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/4_tbb/">（四）多线程那些事儿：并行库 tbb</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_threadUsage/">（三）多线程那些事儿：怎么用好</a> </li> </div> </div> <div class="col-sm-4"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <script src="/assets/js/toc-depth.js"></script> </body> </html>