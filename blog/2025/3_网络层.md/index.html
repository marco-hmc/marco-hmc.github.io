<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> L3-网络层 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/3_%E7%BD%91%E7%BB%9C%E5%B1%82.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">L3-网络层</h1> <p class="post-meta"> Created on May 03, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/category/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"> <i class="fa-solid fa-tag fa-sm"></i> 计算机网络</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="l3-网络层">L3-网络层</h2> <h3 id="1-基本概念">1. 基本概念</h3> <ol> <li> <strong>IP 协议(Internet Protocol)</strong>:IP 协议是网络层的核心协议,它定义了 IP 地址和数据包的格式,并负责将数据包从源主机发送到目标主机.IP 协议包括 IPv4 和 IPv6 两个版本.</li> <li> <strong>ICMP 协议(Internet Control Message Protocol)</strong>:ICMP 协议用于发送和接收网络控制消息,如错误报告/路由更改通知等.例如,当你使用 ping 命令测试网络连通性时,就是使用的 ICMP 协议.</li> <li> <strong>路由协议</strong>:路由协议用于在路由器之间交换路由信息,以建立路由表.常见的路由协议包括 RIP/OSPF/BGP 等.</li> <li> <strong>ARP 协议(Address Resolution Protocol)</strong>:ARP 协议用于将 IP 地址映射为 MAC 地址.当一个主机需要将数据包发送到同一网络中的另一个主机时,它会使用 ARP 协议查找目标主机的 MAC 地址.</li> <li> <strong>IGMP 协议(Internet Group Management Protocol)</strong>:IGMP 协议用于管理多播组,它允许主机加入或离开一个多播组,以接收或停止接收多播数据.</li> </ol> <p>以上就是网络层的主要协议.需要注意的是,这些协议都是为了实现网络层的主要功能:将数据包从源主机发送到目标主机,无论它们是否在同一网络中.</p> <h3 id="2-ip-协议">2. IP 协议</h3> <p>IP 协议是一个无连接的、不可靠的协议，它不保证数据包一定能被成功地发送到目标主机，也不保证数据包的顺序。这些功能需要由更高层的协议（如 TCP 协议）来提供。</p> <h4 id="21-什么是-ip-地址">2.1 什么是 IP 地址？</h4> <p>IP 地址（Internet Protocol Address）是用于标识网络上每个设备的唯一数字标签。它是 IP 协议的核心部分，用于在网络中定位和识别设备。</p> <h4 id="22-ip-数据包的结构是怎么样的">2.2 IP 数据包的结构是怎么样的？</h4> <p><img src="imgs/3_%E7%BD%91%E7%BB%9C%E5%B1%82_image.png" alt="alt text"></p> <ul> <li>4 位版本号(version)： 指定 IP 协议的版本，对于 IPv4 来说就是 4。</li> <li>4 位头部长度(header length)： 4bit 表示最大的数字是 15, 因此 IP 头部最大长度是 60 字节。</li> <li>8 位服务类型(Type Of Service)： 3 位优先权字段(已经弃用)，4 位 TOS 字段，和 1 位保留字段(必须置为 0)。 4 位 TOS 分别表示: 最小延时，最大吞吐量，最高可靠性，最小成本。 这四者相互冲突，只能选择一个。 对于 ssh/telnet 这样的应用程序，最小延时比较重要。 对于 ftp 这样的程序，最大吞吐量比较重要。</li> <li>16 位总长度(total length)： IP 数据报整体占多少个字节。</li> <li> <strong>8 位生存时间(Time To Live, TTL)</strong>： 数据报到达目的地的最大报文跳数。一般是 64，每次经过一个路由 TTL -= 1，一直减到 0 还没到达，那么就丢弃了。这个字段主要是用来防止出现路由循环。</li> <li>8 位协议: 表示上层协议的类型。</li> <li>16 位头部校验和: 使用 CRC 进行校验, 来鉴别头部是否损坏。</li> <li>32 位源地址和 32 位目标地址: 表示发送端和接收端。</li> </ul> <h4 id="23-有了-mac-地址为什么还要有-ip-地址">2.3 有了 mac 地址，为什么还要有 IP 地址？</h4> <p>MAC 地址和 IP 地址虽然都用于标识网络中的设备，但它们在网络通信中扮演的角色是不同的，因此两者都是必要的。</p> <ol> <li> <strong>全局唯一性</strong>：MAC 地址是全球唯一的，它在生产时被硬编码到网络接口卡上。然而，MAC 地址只在本地网络中有意义，不能用于在全球范围内定位设备。相反，IP 地址是在全球范围内唯一的，可以用于在互联网上定位设备。</li> <li> <strong>路由</strong>：IP 地址不仅标识了设备，还提供了设备的网络位置信息。IP 地址由网络部分和主机部分组成，这使得路由器可以根据 IP 地址的网络部分将数据包转发到正确的网络。而 MAC 地址没有这种网络位置信息，不能用于路由。</li> <li> <strong>灵活性</strong>：IP 地址可以动态分配和更改，这使得设备可以移动到不同的网络而不需要更改硬件。而 MAC 地址是固定的，不能更改。</li> <li> <strong>抽象层次</strong>：MAC 地址和 IP 地址存在于不同的网络模型层次。MAC 地址存在于数据链路层，直接与物理硬件相关。而 IP 地址存在于网络层，提供了一个从物理硬件抽象出来的地址系统，使得上层应用可以不关心底层的物理连接细节。</li> </ol> <p>因此，虽然有了 MAC 地址，但我们仍然需要 IP 地址来进行全球范围的网络通信。</p> <h4 id="24-接入网络的时候ip-地址是怎么分配的">2.4 接入网络的时候，IP 地址是怎么分配的？</h4> <p>接入网络时，IP 地址的分配通常通过动态主机配置协议（DHCP）进行。以下是基本的步骤：</p> <ol> <li> <strong>DHCP 发现（DHCP Discover）</strong>：当设备连接到网络并需要 IP 地址时，它会发送一个 DHCP 发现消息。这个消息是一个广播消息，会被网络中的所有设备接收到。</li> <li> <strong>DHCP 提供（DHCP Offer）</strong>：网络中的 DHCP 服务器会接收到 DHCP 发现消息，然后从它的地址池中选择一个可用的 IP 地址。然后，DHCP 服务器会将这个 IP 地址以及其他网络配置（如子网掩码、默认网关、DNS 服务器等）封装在 DHCP 提供消息中，然后发送给请求的设备。</li> <li> <strong>DHCP 请求（DHCP Request）</strong>：设备接收到 DHCP 提供消息后，会从中选择一个 DHCP 服务器（如果有多个的话），然后向这个服务器发送 DHCP 请求消息，请求使用提供的 IP 地址。</li> <li> <strong>DHCP 应答（DHCP Acknowledgement）</strong>：DHCP 服务器接收到 DHCP 请求消息后，会发送一个 DHCP 应答消息，确认设备可以使用提供的 IP 地址。</li> </ol> <p>以上就是接入网络时 IP 地址的分配过程。需要注意的是，分配的 IP 地址通常有一个租期，当租期到期后，设备需要重新请求 IP 地址。</p> <h4 id="25-什么是dhcp">2.5 什么是dhcp？</h4> <p>DHCP(动态主机配置协议)是一个网络协议,用于自动分配网络配置信息给网络设备,使其能够连接和通信在IP网络.这些配置信息包括IP地址/子网掩码/默认网关/DNS服务器等.</p> <p>DHCP的工作过程通常被称为DORA过程(Discover, Offer, Request, Acknowledge):</p> <ol> <li> <p><strong>发现(Discover)</strong>:客户端发送DHCP发现消息,寻找可用的DHCP服务器.这个消息是一个广播消息,会被网络中的所有设备接收.</p> </li> <li> <p><strong>提供(Offer)</strong>:DHCP服务器接收到发现消息后,会向客户端发送DHCP提供消息,提供一个可用的IP地址和其他网络配置信息.</p> </li> <li> <p><strong>请求(Request)</strong>:客户端接收到提供消息后,会向DHCP服务器发送DHCP请求消息,请求使用提供的IP地址和其他网络配置信息.</p> </li> <li> <p><strong>应答(Acknowledge)</strong>:DHCP服务器接收到请求消息后,会向客户端发送DHCP应答消息,确认客户端可以使用提供的网络配置信息.</p> </li> </ol> <p>通过这个过程,客户端可以自动获取到网络配置信息,无需手动配置.</p> <ul> <li> <strong>dhcp服务器在哪里</strong> DHCP 服务器通常位于网络的核心位置，例如在企业网络中，它可能是一台专门的服务器或者是一台运行 DHCP 服务的路由器。在家庭网络中，DHCP 服务器通常是无线路由器。</li> </ul> <p>DHCP 服务器的主要任务是管理和分配 IP 地址。当一个设备连接到网络并请求 IP 地址时，DHCP 服务器会从其地址池中选择一个可用的 IP 地址，并将其分配给请求的设备。</p> <p>需要注意的是，虽然 DHCP 服务器通常位于网络的核心位置，但它并不一定需要与请求 IP 地址的设备在同一子网中。通过使用 DHCP 中继代理，DHCP 服务器可以为位于不同子网的设备分配 IP 地址。</p> <h4 id="26-ip-地址不会被用完吗">2.6 IP 地址不会被用完吗？</h4> <p>原始的 IPv4 地址空间包含约 43 亿个地址，由于互联网的快速发展，这些地址已经基本上被分配完了。这就是为什么我们需要 IPv6 的一个重要原因。IPv6 地址空间包含约 340 多万亿万亿万亿个地址，这个数量远远超过了地球上每个人、每个设备需要的地址数量，因此在可预见的未来，IPv6 地址不会被用完。</p> <p>同时，还有一些技术被用来节省和复用 IPv4 地址，例如 NAT（网络地址转换）和 CIDR（无类别域间路由）。NAT 允许多个设备共享一个公网 IP 地址，而 CIDR 则通过更灵活的地址分配方式，减少了 IP 地址的浪费。</p> <h4 id="27-什么是-nat">2.7 什么是 NAT</h4> <p>NAT，全称为网络地址转换（Network Address Translation），是一种在网络通信过程中转换 IP 地址的技术。它主要用于 IPv4 网络，以解决 IPv4 地址短缺的问题。</p> <p>NAT 的工作原理是在私有网络（如家庭或企业网络）和公共网络（如互联网）之间设置一个 NAT 设备（通常是路由器）。私有网络中的设备使用私有 IP 地址，这些地址只在私有网络中有效，不能用于互联网。当私有网络中的设备需要与互联网上的设备通信时，NAT 设备会将私有 IP 地址转换为公网 IP 地址。</p> <p>NAT 有几种不同的类型，包括静态 NAT、动态 NAT 和端口地址转换（PAT）。静态 NAT 为每个私有 IP 地址提供一个固定的公网 IP 地址，动态 NAT 为每个私有 IP 地址提供一个从公网 IP 地址池中动态分配的公网 IP 地址，而 PAT（也称为 NAT Overload）则允许多个私有 IP 地址共享一个公网 IP 地址，通过使用不同的端口号来区分不同的设备。</p> <p>NAT 不仅可以解决 IP 地址短缺的问题，还可以提供一定的安全性，因为私有网络中的设备的 IP 地址在互联网上是不可见的。</p> <h4 id="28-什么是-cidr">2.8 什么是 CIDR</h4> <p>CIDR，全称为无类别域间路由（Classless Inter-Domain Routing），是一种用于 IP 地址分配和路由的方法。它的主要目标是优化 IPv4 地址的使用，以延缓 IPv4 地址空间的耗尽，并简化路由表。</p> <p>在 CIDR 之前，IP 地址被分为 A、B、C 三类，每类地址有固定的网络部分和主机部分，这种方式在地址分配上非常浪费。例如，一个类 B 地址可以提供 65534 个主机地址，如果一个组织只有 1000 台设备，那么剩下的大部分地址就会被浪费。</p> <p>CIDR 通过引入可变长度的子网掩码来解决这个问题。在 CIDR 中，IP 地址被写成“IP 地址/前缀长度”的形式，例如 192.0.2.0/24。这里的“/24”表示前 24 位是网络部分，后 8 位是主机部分。这样，我们就可以根据实际需要来划分网络和主机部分，从而更灵活地分配 IP 地址。</p> <p>CIDR 还有助于简化路由表。在 CIDR 中，可以使用一个路由表项来表示一组连续的 IP 地址，这被称为路由聚合或前缀聚合。这大大减少了路由表的大小，从而提高了路由效率。</p> <p>例如，如果我们有以下四个网络：</p> <ul> <li>192.0.2.0/24</li> <li>192.0.3.0/24</li> <li>192.0.4.0/24</li> <li>192.0.5.0/24</li> </ul> <p>在没有 CIDR 的情况下，我们需要在路由表中为每个网络创建一个条目。但在 CIDR 中，我们可以将这四个网络聚合为一个单一的 192.0.2.0/22 网络，这样只需要一个路由表条目。</p> <p>总的来说，CIDR 通过灵活的地址分配和路由聚合，有效地解决了 IPv4 地址短缺和路由表过大的问题。</p> <h3 id="3-arp-协议">3. ARP 协议</h3> <p>ARP 协议是地址解析协议(Address Resolution Protocol)的缩写.它是一种用于将 IP 地址解析为对应的 MAC 地址的协议,也可以说是一种用于在网络中获取目标设备的物理地址的协议. ARP 协议通过广播的方式发送请求,询问某个 IP 地址对应的 MAC 地址,然后将获取到的 MAC 地址缓存起来,以便后续的通信中直接使用.ARP 协议在局域网中起到了非常重要的作用,它使得不同设备之间可以通过 IP 地址进行通信,而无需关心物理地址.</p> <ol> <li> <p>设备 A 需要向设备 B 发送数据,但只知道设备 B 的 IP 地址,不知道其 MAC 地址.</p> </li> <li> <p>设备 A 在网络上广播一个 ARP 请求消息,询问谁拥有设备 B 的 IP 地址.</p> </li> <li> <p>所有收到 ARP 请求的设备都会检查自己的 IP 地址,如果 IP 地址匹配,则设备 B 会向设备 A 发送一个 ARP 响应消息,包含其 MAC 地址.</p> </li> <li> <p>设备 A 收到 ARP 响应后,就可以将数据包发送到设备 B 的 MAC 地址了.</p> </li> </ol> <p>通过这个过程,ARP 协议可以将 IP 地址解析为 MAC 地址,使得设备可以在网络中进行通信.</p> <h4 id="31-arp-协议用在什么场景">3.1 ARP 协议用在什么场景？</h4> <p>ARP 协议（地址解析协议）主要用于在网络通信中将 IP 地址映射为 MAC 地址。它在以下场景中非常重要：</p> <ol> <li> <p><strong>局域网通信</strong>：当两台在同一局域网（例如，同一 WiFi 网络）中的设备需要进行通信时，发送设备需要知道接收设备的 MAC 地址。但在网络层，设备通常只知道接收设备的 IP 地址。这时，发送设备就会使用 ARP 协议，通过广播一个 ARP 请求消息，询问谁拥有接收设备的 IP 地址。接收设备收到 ARP 请求后，如果发现 IP 地址匹配，就会回复一个 ARP 响应消息，包含其 MAC 地址。这样，发送设备就可以知道接收设备的 MAC 地址，从而进行通信。</p> </li> <li> <p><strong>路由器转发</strong>：当一个数据包需要从一个网络传输到另一个网络时，路由器需要知道下一跳的 MAC 地址。这时，路由器就会使用 ARP 协议来获取下一跳的 MAC 地址。</p> </li> <li> <p><strong>虚拟私有网络（VPN）和网络地址转换（NAT）</strong>：在这些场景中，IP 地址可能会被改变。因此，需要使用 ARP 协议来获取新的 IP 地址对应的 MAC 地址。</p> </li> </ol> <p>总的来说，ARP 协议在任何需要将 IP 地址映射为 MAC 地址的场景中都会被使用。</p> <h4 id="32-arp-协议的工作原理">3.2 ARP 协议的工作原理</h4> <ol> <li> <p>当一个设备需要发送数据到目标设备时,它首先检查自己的 ARP 缓存表(ARP Cache)中是否有目标设备的 MAC 地址.如果有,设备就可以直接使用该 MAC 地址发送数据.</p> </li> <li> <p>如果 ARP 缓存表中没有目标设备的 MAC 地址,设备就会发送一个 ARP 请求广播消息到局域网上的所有设备.该 ARP 请求消息包含了设备的 IP 地址和 MAC 地址为广播地址(FF:FF:FF:FF:FF:FF).</p> </li> <li> <p>其他设备收到 ARP 请求消息后,会检查自己的 IP 地址是否与请求中的目标 IP 地址匹配.如果匹配,设备会将自己的 MAC 地址作为 ARP 响应消息发送回去.</p> </li> <li> <p>发起 ARP 请求的设备收到 ARP 响应消息后,会将目标设备的 IP 地址和 MAC 地址存储到 ARP 缓存表中,以便后续的通信中直接使用.</p> </li> <li> <p>如果在一定时间内没有收到 ARP 响应消息,设备会认为目标设备不可达或不存在.</p> </li> </ol> <p>通过这种方式,ARP 协议实现了将 IP 地址解析为对应的 MAC 地址,从而使设备能够通过 IP 地址进行通信.同时,设备也会定期更新 ARP 缓存表中的条目,以确保缓存的 MAC 地址是最新的.</p> <h4 id="33-arp-欺骗">3.3 ARP 欺骗</h4> <ul> <li> <strong>ARP 欺骗</strong>(英语:<strong>ARP spoofing</strong>),又称<strong>ARP 毒化</strong>(<strong>ARP poisoning</strong>,网络上多译为<strong>ARP 病毒</strong>)或<strong>ARP 攻击</strong>,是针对以太网地址解析协议(ARP)的一种攻击技术.此种攻击可让攻击者获取局域网上的数据包甚至可篡改数据包,且可让网络上特定计算机或所有计算机无法正常连线</li> <li>运作机制 <ul> <li>ARP 欺骗的运作原理是由攻击者发送假的 ARP 数据包到网上,尤其是送到网关上.其目的是要让送至特定的 IP 地址的流量被错误送到攻击者所取代的地方.因此攻击者可将这些流量另行转送到真正的网关(被动式数据包嗅探,passive sniffing)或是篡改后再转送(<a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/1739730" rel="external nofollow noopener" target="_blank">中间人攻击</a>,man-in-the-middle attack).攻击者亦可将 ARP 数据包导到不存在的 MAC 地址以达到阻断服务攻击的效果,例如 netcut 软件</li> <li>例如某一的 IP 地址是 192.168.0.254,其 MAC 地址为 00-11-22-33-44-55,网络上的计算机内 ARP 表会有这一笔 ARP 记录.攻击者发动攻击时,会大量发出已将 192.168.0.254 的 MAC 地址篡改为 00-55-44-33-22-11 的 ARP 数据包.那么网络上的计算机若将此伪造的 ARP 写入自身的 ARP 表后,计算机若要透过网上网关连到其他计算机时,数据包将被导到 00-55-44-33-22-11 这个 MAC 地址,因此攻击者可从此 MAC 地址截收到数据包,可篡改后再送回真正的网关,或是什么也不做,让网上无法连线.</li> </ul> </li> <li> <strong>简单案例分析</strong>:这里用一个最简单的案例来说明 ARP 欺骗的核心步骤.假设在一个 LAN 里,只有三台主机 A/B/C,且 C 是攻击者 <ol> <li>攻击者聆听局域网上的 MAC 地址.它只要收到两台主机洪泛的 ARP Request,就可以进行欺骗活动.</li> <li>主机 A/B 都洪泛了 ARP Request.攻击者现在有了两台主机的 IP/MAC 地址,开始攻击.</li> <li>攻击者发送一个 ARP Reply 给主机 B,把此包 protocol header 里的 sender IP 设为 A 的 IP 地址,sender mac 设为攻击者自己的 MAC 地址.</li> <li>主机 B 收到 ARP Reply 后,更新它的 ARP 表,把主机 A 的 MAC 地址(IP_A, MAC_A)改为(IP_A, MAC_C).</li> <li>当主机 B 要发送数据包给主机 A 时,它根据 ARP 表来封装数据包的 Link 报头,把目的 MAC 地址设为 MAC_C,而非 MAC_A.</li> <li>当交换机收到 B 发送给 A 的数据包时,根据此包的目的 MAC 地址(MAC_C)而把数据包转发给攻击者 C.</li> <li>攻击者收到数据包后,可以把它存起来后再发送给 A,达到偷听效果.攻击者也可以篡改数据后才发送数据包给 A,造成伤害</li> </ol> </li> <li>防制方法 <ul> <li>最理想的防制方法是网上内的每台计算机的 ARP 一律改用静态的方式,不过这在大型的网上是不可行的,因为需要经常更新每台计算机的 ARP 表</li> <li>另外一种方法,例如<a href="https://baike.baidu.com/item/DHCP%20snooping" rel="external nofollow noopener" target="_blank">DHCP snooping</a>,网上设备可借由<a href="https://baike.baidu.com/item/DHCP" rel="external nofollow noopener" target="_blank">DHCP</a>保留网络上各计算机的 MAC 地址,在伪造的 ARP 数据包发出时即可侦测到.此方式已在一些厂牌的网上设备产品所支持</li> <li>有一些软件可监听网络上的 ARP 回应,若侦测出有不正常变动时可发送邮箱通知管理者.例如 UNIX 平台的<a href="https://baike.baidu.com/item/Arpwatch" rel="external nofollow noopener" target="_blank">Arpwatch</a>以及 Windows 上的 XArp v2 或一些网上设备的 Dynamic ARP inspection 功能</li> </ul> </li> </ul> <h3 id="3-路由协议">3. 路由协议</h3> <h4 id="3-1-路由器干什么的">3. 1 路由器干什么的</h4> <p>路由器是网络中的关键设备,它在网络层(OSI 模型的第三层)上工作,主要有以下几个作用:</p> <ol> <li> <p><strong>数据包转发</strong>:路由器的主要功能是接收来自一个网络的数据包,并将其转发到另一个网络.路由器根据数据包的目标 IP 地址和自己的路由表来决定如何转发数据包.</p> </li> <li> <p><strong>路由选择</strong>:路由器使用路由协议(如 RIP/OSPF/BGP 等)来与其他路由器交换路由信息,并根据这些信息来建立和更新自己的路由表.路由表中的每一条路由都指示了如何到达一个特定的网络.</p> </li> <li> <p><strong>网络连接</strong>:路由器可以连接不同类型(如以太网/Wi-Fi/光纤等)和不同协议(如 IPv4/IPv6 等)的网络.这使得不同网络中的设备可以互相通信.</p> </li> <li> <p><strong>网络分割</strong>:路由器可以将一个大网络分割为多个小网络(或子网),每个小网络都有自己的网络地址.这可以提高网络的管理效率和数据传输效率,同时也可以提高网络的安全性.</p> </li> <li> <p><strong>网络服务</strong>:一些路由器还提供了 DHCP/NAT/防火墙等网络服务.</p> </li> </ol> <p>总的来说,路由器是实现网络互联的关键设备,它使得不同网络中的设备可以互相通信.</p> <h4 id="32-静态路由是什么">3.2 静态路由是什么?</h4> <p>静态路由就是在路由器上,配置一条一条规则.下一跳是谁就配置下一跳.<br> MAC 头和 IP 头变与不变.分为欧洲十国游和玄奘西行型<br> IP 头不变,mac 变,不换护照欧洲十国游,ip 变,换护照玄奘西行.<br></p> <h4 id="33-对路由协议的了解与介绍内部网关协议-igp-包括-ripospf和外部网关协议-egp-和-bgp">3.3 对路由协议的了解与介绍.内部网关协议 IGP 包括 RIP,OSPF,和外部网关协议 EGP 和 BGP.</h4> <ul> <li> <p>RIP”路由信息协议(Route Information Protocol)”的简写,主要传递路由信息,通过每隔 30 秒广播一次路由表,维护相邻路由器的位置关系,同时根据收到的路由表信息使用动态规划的方式计算自己的路由表信息.RIP 是一个距离矢量路由协议,最大跳数为 16 跳,16 跳以及超过 16 跳的网络则认为目标网络不可达.</p> </li> <li> <p>OSPF:详见:https://zhuanlan.zhihu.com/p/41341540</p> </li> </ul> <h3 id="4-icmp">4. ICMP</h3> <h4 id="41-什么是-icmp-协议">4.1 什么是 ICMP 协议</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ICMP(Internet Control Message Protocol,互联网控制报文协议)是网络层的一个协议.它用于在IP主机/路由器之间传递控制消息,这些控制消息通常被用于IP操作的诊断以及提供有关异常情况的反馈,例如,目标主机不可达/网络拥塞等.
</code></pre></div></div> <ul> <li> <p>ICMP 全称是 Internet Control Message Protocol,也就是互联网控制报文协议,<strong>其协议号为</strong><code class="language-plaintext highlighter-rouge">1</code></p> </li> <li> <p>ICMP 主要的功能包括:</p> <ul> <li><strong>确认 IP 包是否成功送达目标地址</strong></li> <li> <strong>报告发送过程中 IP 包被废弃的原因</strong>和<strong>改善网络设置</strong>等</li> </ul> </li> <li> <p>在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址,那么这个具体的原因将由 ICMP 负责通知</p> </li> <li> <p>ICMP 大致可以分为两大类:</p> <ul> <li>一类是<strong>用于诊断</strong>的查询消息,也就是’<strong>查询报文类型</strong>’</li> <li>另一类是<strong>通知出错原因</strong>的错误消息,也就是’<strong>差错报文类型</strong>’</li> </ul> <p><img src="imgs/network/icmp.png" alt="icmp" style="zoom:50%;"></p> </li> <li> <p>查询报文类型</p> <ul> <li> <p>回送消息 __ 类型 <code class="language-plaintext highlighter-rouge">0</code> 和<code class="language-plaintext highlighter-rouge"> 8</code></p> </li> <li> <p>回送消息用于进行通信的主机或路由器之间,<strong>判断所发送的数据包是否已经成功到达对端的一种消息</strong>,<code class="language-plaintext highlighter-rouge"> ping</code> 命令就是利用这个消息实现的</p> </li> <li> <p>可以向对端主机<strong>发送回送请求的消息</strong>( <code class="language-plaintext highlighter-rouge">ICMP Echo Request Message</code> ,类型<code class="language-plaintext highlighter-rouge">8</code>),也可以接收对端主机发回来的回送应答消息( <code class="language-plaintext highlighter-rouge">ICMP Echo Reply Message</code> ,类型<code class="language-plaintext highlighter-rouge"> 0</code> )</p> <p><img src="imgs/network/icmp_echo_reply.png" alt="icmp_echo_reply" style="zoom:67%;"></p> </li> </ul> </li> <li> <p>差错报文类型</p> <ul> <li> <p>目标不可达消息 __ 类型 为<code class="language-plaintext highlighter-rouge"> 3</code></p> <ul> <li> <p>IP 路由器无法将 IP 数据包发送给目标地址时,会给发送端主机返回一个目标不可达的 ICMP 消息,并在这个消息中显示不可达的具体原因,原因记录在 ICMP 包头的代码字段.由此,根据 ICMP 不可达的具体消息,发送端主机也就可以了解此次发送不可达的具体原因</p> </li> <li> <p>举例 6 种常见的目标不可达类型的代码:</p> <p><img src="imgs/network/icmp_unreachable.png" alt="icmp_unreachable" style="zoom:50%;"></p> </li> <li> <p>网络不可达</p> <ul> <li>IP 地址是分为网络号和主机号的,所以当路由器中的路由器表匹配不到接收方 IP 的网络号,就通过 ICMP 协议以网络不可达( <code class="language-plaintext highlighter-rouge">Network Unreachable </code>)的原因告知主机</li> </ul> </li> <li> <p>主机不可达</p> <ul> <li>当路由表中没有该主机的信息,或者该主机没有连接到网络,那么会通过 ICMP 协议以主机不可达( <code class="language-plaintext highlighter-rouge">Host Unreachable </code>)的原因告知主机</li> </ul> </li> <li> <p>协议不可达</p> <ul> <li>当主机使用 TCP 协议访问对端主机时,能找到对端的主机了,可是<strong>对端主机的防火墙已经禁止 TCP 协议访问</strong>,那么会通过 ICMP 协议以协议不可达的原因告知主机</li> </ul> </li> <li> <p>需要进行分片但设置了不分片位</p> <ul> <li>发送端主机发送 IP 数据报时,<strong>将 IP 首部的分片禁止标志位设置为 1</strong> .<strong>根据这个标志位,途中的路由器遇到超过 MTU 大小的数据包时,不会进行分片,而是直接抛弃</strong> </li> </ul> </li> <li> <p>端口不可达</p> <ul> <li>当主机访问对端主机 8080 端口时,这次能找到对端主机了,防火墙也没有限制,可是发现<strong>对端主机没有进程监听 8080 端口</strong>,那么会通过 ICMP 协议以端口不可达的原因告知主机</li> </ul> </li> </ul> </li> <li> <p>原点抑制消息 __ 类型 <code class="language-plaintext highlighter-rouge">4</code></p> <ul> <li>在使用低速广域线路的情况下,<strong>连接 WAN 的路由器可能会遇到网络拥堵的问题</strong>,<code class="language-plaintext highlighter-rouge">ICMP</code> 原点抑制消息的目的就是为了缓和这种拥堵情况</li> <li>当路由器向低速线路发送数据时,其发送队列的缓存变为零而无法发送出去时,可以向 IP 包的源地址发送一个 ICMP 原点抑制消息</li> <li>收到这个消息的主机借此了解在整个线路的某一处发生了拥堵的情况,从而<strong>增大 IP 包的传输间隔,减少网络拥堵的情况</strong> </li> <li>然而,<strong>由于这种 ICMP 可能会引起不公平的网络通信,一般不被使用</strong> </li> </ul> </li> <li> <p>重定向消息 __ 类型 <code class="language-plaintext highlighter-rouge">5</code></p> <ul> <li>如果<strong>路由器发现发送端主机使用了’不是最优’的路径发送数据,那么它会返回一个 ICMP 重定向消息给这个主机</strong> </li> <li>在这个消息中包含了<strong>最合适的路由信息和源数据</strong>.这主要发生在路由器持有更好的路由信息的情况下</li> <li><strong>路由器会通过这样的 ICMP 消息告知发送端,让它下次发给另外一个路由器</strong></li> </ul> </li> <li> <p>超时消息 __ 类型 <code class="language-plaintext highlighter-rouge">11</code></p> <ul> <li>IP 包中有一个字段叫做 <code class="language-plaintext highlighter-rouge">TTL</code> ( <code class="language-plaintext highlighter-rouge">Time To Live </code>,生存周期),它的值随着<strong>每经过一次路由器就会减 1,直到减到 0 时该 IP 包会被丢弃</strong> </li> <li>此时,<strong>路由器将会发送一个 ICMP 超时消息给发送端主机,并通知该包已被丢弃</strong> </li> <li>设置 IP 包生存周期的主要目的,是为了在<strong>路由控制遇到问题发生循环状况时,避免 IP 包无休止地在网络上被转发</strong> </li> </ul> </li> </ul> </li> </ul> <h4 id="42-icmp-工作原理">4.2 ICMP 工作原理</h4> <p>ICMP(Internet Control Message Protocol,互联网控制报文协议)的工作原理主要涉及发送和接收 ICMP 报文.ICMP 报文通常被用于 IP 操作的诊断以及提供有关异常情况的反馈.</p> <p>以下是 ICMP 的基本工作流程:</p> <ol> <li> <p>当一个设备需要发送一个 ICMP 报文时(例如,使用 ping 命令测试网络连通性),它会创建一个 ICMP 报文,包含一个类型字段(指示报文的类型)和一个代码字段(提供关于报文类型的更多信息),以及其他必要的信息.</p> </li> <li> <p>ICMP 报文被封装在 IP 数据包中,然后发送到目标设备.这个过程中可能会经过多个路由器.</p> </li> <li> <p>当目标设备收到 ICMP 报文时,它会根据报文的类型和代码字段来处理报文.例如,如果报文是一个 ping 请求(ICMP echo request),目标设备会发送一个 ping 响应(ICMP echo reply).</p> </li> <li> <p>如果在发送 ICMP 报文的过程中发生了错误(例如,目标设备不可达),则会发送一个 ICMP 错误报文到源设备.</p> </li> </ol> <p>通过这个过程,ICMP 协议可以帮助我们诊断网络问题,例如,测试网络连通性(使用 ping 命令),确定数据包的传输路径(使用 traceroute 命令),等等.</p> <h4 id="43-ping">4.3 ping</h4> <p>详见:<a href="https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html" rel="external nofollow noopener" target="_blank">Ping 原理与 ICMP 协议</a></p> <p>ping 是使用 ICMP 协议来进行工作的. ICMP:网络控制报文协议</p> <ul> <li>首先,ping 命令会构建一个 ICMP 请求数据包,然后由 ICMP 协议将这个数据包连同目的 IP 地址源 IP 地址一起交给 IP 协议.</li> <li>然后 IP 协议就会构建一个 IP 数据报,并且在映射表中查找目的 IP 对应的 mac 地址,将其交给数据链路层.</li> <li>然后数据链路层就会构建一个数据帧,附上源 mac 地址和目的 mac 地址发送出去.</li> </ul> <p>目的主机接收到数据帧后,就会检查包上的 mac 地址与本机 mac 是否相符,如果相符,就接收并把其中的信息提取出来交给 IP 协议,IP 协议就会将其中的信息提取出来交给 ICMP 协议.然后构建一个 ICMP 应答包,用相同的过程发送回去.</p> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-为什么本地地址是-127001">1. 为什么本地地址是 127.0.0.1?</h4> <p>127.0.0.1 是一个特殊的 IP 地址，被称为本地回环地址或 localhost。这个地址用于在计算机网络中表示当前设备，也就是说，当一个程序需要与运行在同一设备上的另一个程序通信时，可以使用这个地址。</p> <p>这个地址之所以被选择为本地回环地址，是因为在 IPv4 地址空间中，127.0.0.0/8（也就是从 127.0.0.0 到 127.255.255.255 的所有地址）都被保留为本地回环地址。这是由互联网工程任务组（IETF）在 RFC 3330 中规定的。</p> <p>其中，127.0.0.1 是最常用的本地回环地址，但实际上，任何从 127.0.0.0 到 127.255.255.255 的地址都可以作为本地回环地址使用。</p> <p>使用本地回环地址的好处是，可以在没有网络连接的情况下测试网络应用，因为所有发送到本地回环地址的数据包都会被操作系统立即返回，不会真正发送到网络上。</p> <h4 id="2-那如果-arp-缓存的条目没有达到生命周期的末尾但是目标设备的-ip-地址又发生了变换会怎么样呢">2. 那如果 ARP 缓存的条目没有达到生命周期的末尾,但是目标设备的 IP 地址又发生了变换,会怎么样呢?</h4> <p>如果 ARP 缓存的条目没有达到生命周期的末尾,但是目标设备的 IP 地址又发生了变换,那么在 ARP 缓存过期之前,设备可能会继续使用旧的 IP 地址和 MAC 地址对应关系进行通信,这可能导致通信失败.</p> <p>在实际的网络环境中,这种情况很少发生,因为 IP 地址通常是静态的,或者在动态分配时,其生命周期通常远大于 ARP 缓存的生命周期.</p> <p>如果确实出现了这种情况,可以通过手动清除 ARP 缓存来解决.大多数操作系统都提供了清除 ARP 缓存的命令,例如在 Windows 中可以使用<code class="language-plaintext highlighter-rouge">arp -d</code>命令,在 Linux 中可以使用<code class="language-plaintext highlighter-rouge">ip -s -s neigh flush all</code>命令.这样可以强制设备发送新的 ARP 请求,获取最新的 IP 地址和 MAC 地址对应关系.</p> <h4 id="3-ip-不是可以动态的吗如果是动态-ip-那不就-arp-缓存会出现频繁过期吗">3. IP 不是可以动态的吗?如果是动态 IP 那不就 ARP 缓存会出现频繁过期吗</h4> <p>是的,IP 地址可以是动态的,这通常在 DHCP(动态主机配置协议)环境中发生.在这种情况下,设备的 IP 地址可能会在一段时间后改变.</p> <p>然而,ARP 缓存的生命周期通常比较短,通常在几分钟到几个小时之间.这意味着即使 IP 地址改变,ARP 缓存也会在短时间内过期并更新.因此,即使在动态 IP 环境中,ARP 缓存也能有效地维护 IP 地址和 MAC 地址之间的映射.</p> <p>另外,当设备的 IP 地址改变时,设备通常会发送一个 ARP 通告(ARP Announcement),这是一个特殊的 ARP 响应,用于更新其他设备的 ARP 缓存.这样,即使 ARP 缓存还没有过期,其他设备也能立即知道新的 IP 地址和 MAC 地址的对应关系.</p> <h4 id="4-arp-协议有什么用不是只能解决在局域网的通信吗如果两台通信设备不在同一个局域网怎么办">4. arp 协议有什么用?不是只能解决在局域网的通信吗?如果两台通信设备不在同一个局域网,怎么办?</h4> <p>ARP 协议的主要作用是在同一局域网内,将设备的 IP 地址解析为对应的 MAC 地址,从而使设备能够通过 IP 地址进行通信.这是因为在局域网中,设备之间的通信实际上是通过 MAC 地址进行的,而 IP 地址只是用于寻址的.</p> <p>如果两台通信设备不在同一个局域网内,那么它们之间的通信就需要通过路由器进行.在这种情况下,发送设备会将数据发送到其默认网关(通常是路由器),然后由路由器根据目标 IP 地址将数据转发到正确的网络.在这个过程中,ARP 协议仍然起到了重要的作用,因为发送设备需要知道其默认网关的 MAC 地址,而这就是通过 ARP 协议来获取的.</p> <p>因此,虽然 ARP 协议只能在局域网内解析 IP 地址和 MAC 地址,但它在整个网络通信过程中仍然起到了关键的作用.</p> <h4 id="5-对于一个新加入设备怎么知道谁是网关">5. 对于一个新加入设备,怎么知道谁是网关?</h4> <p>新加入的设备通常通过 DHCP(动态主机配置协议)来获取网络配置信息,包括默认网关的 IP 地址.当设备连接到网络时,它会发送一个 DHCP 发现(DHCP Discover)消息,然后 DHCP 服务器会回应一个 DHCP 提供(DHCP Offer)消息,其中包含了网络配置信息.设备接收到这个消息后,就可以知道默认网关的 IP 地址了.</p> <p>如果网络中没有 DHCP 服务器,或者设备是静态配置的,那么默认网关的 IP 地址就需要手动设置.</p> <p>一旦设备知道了默认网关的 IP 地址,它就可以使用 ARP 协议来获取网关的 MAC 地址.设备会发送一个 ARP 请求,询问网关的 IP 地址对应的 MAC 地址,然后网关会回应一个 ARP 响应,其中包含了它的 MAC 地址.设备接收到这个响应后,就可以知道网关的 MAC 地址了.</p> <p>这样,设备就可以通过网关与其他网络进行通信了.</p> <h4 id="6-什么是网络层分片原因与具体实现又是什么">6. 什么是网络层分片？原因与具体实现又是什么？</h4> <p>网络层分片是由 IP 协议(Internet Protocol)决定的.在 IPv4 中,如果一个数据包的大小超过了链路层的最大传输单元(MTU),那么 IP 协议会在网络层进行分片,将大的数据包划分为多个小的数据包,每个小的数据包的大小都不超过 MTU.</p> <p>需要注意的是,在 IPv6 中,网络层不再进行分片,而是由发送端的传输层进行分片.如果一个数据包的大小超过了 MTU,那么发送端需要在传输层将数据包划分为多个小的数据包,然后再发送.这是因为网络层分片会增加网络的复杂性和开销,因此 IPv6 设计者决定将分片的责任交给发送端.</p> <p>网络层分片是指在网络层将大的数据包划分为多个小的数据包的过程.这个过程通常发生在数据包的大小超过链路层的最大传输单元(MTU)时.</p> <p>为什么要进行分片呢?这是因为在链路层中,每种类型的物理介质都有一个最大传输单元(MTU),这是由物理介质的特性决定的.例如,在以太网中,MTU 的大小通常是 1500 字节.如果一个数据包的大小超过了 MTU,那么就需要在网络层进行分片,将大的数据包划分为多个小的数据包,每个小的数据包的大小都不超过 MTU. 分片的过程是在发送端进行的,接收端收到分片后,会根据分片中的信息将它们重新组装成原来的数据包.这个过程是透明的,也就是说,应用层并不知道数据包被分片和重新组装的过程.</p> <p>需要注意的是,分片会增加网络的复杂性和开销,因此在设计网络应用时,应尽量避免发送过大的数据包,以减少分片的需要.</p> <h4 id="7-同一个子网下的-ip-地址为什么一般都是-192168-开始的">7. 同一个子网下的 IP 地址为什么一般都是 192.168 开始的?</h4> <p>192.168.x.x 是一个专门为私有网络(如家庭和企业内部网络)预留的 IP 地址范围,由 RFC 1918 定义.这个地址范围在全球范围内可以重复使用,但在同一个网络内必须是唯一的.</p> <p>除了 192.168.x.x,RFC 1918 还定义了两个其他的私有 IP 地址范围:10.x.x.x 和 172.16.x.x 到 172.31.x.x.然而,由于 192.168.x.x 的地址范围较小,足够大多数家庭和小型企业使用,因此它被广泛用作默认的私有 IP 地址范围.</p> <p>当你设置一个网络设备(如路由器)为 DHCP 服务器时,它通常会默认使用 192.168.x.x 的地址范围为网络内的设备分配 IP 地址.这就是为什么同一个子网下的 IP 地址通常都是以 192.168 开始的.</p> <p><strong>ARP</strong> ARP 协议能实现任意网络层地址到任意物理地址的转换</p> <p>#　 IP</p> <ul> <li> <p>IP 协议在 MAC 帧中的协议号为<code class="language-plaintext highlighter-rouge">0x0800</code></p> </li> <li> <p>IP 首部</p> <p><img src="imgs/network/IP.png" alt="IP" style="zoom: 50%;"></p> </li> <li> <p><strong>什么是 IP 分片</strong></p> <ul> <li>IP 协议在传输数据包时会将数据报文分成若干片进行传输,并在目标系统中进行重组.这以过程就成为分片</li> </ul> </li> <li> <p><strong>为什么要进行 IP 分片</strong></p> <ul> <li>如果 IP 数据报加上数据帧头部后大于 MTU,数据报文就会分成若干片进行传输.那么什么是 MTU 呢?每一种物理网络都会规定链路层数据帧的最大长度,称为链路层 MTU.<strong>在以太网的环境中可传输的最大 IP 报文为 1500 字节</strong>.如果要传输的数据帧的大小超过 1500 字节,即 IP 数据报的长度大于 1472(1500-20-8=1472,UDP)字节,需要分片之后进行传输</li> </ul> </li> <li> <p>IP 分片如何组装</p> <ul> <li>在 IP 头里面有 16bit 的<strong>识别号唯一记录了一个 IP 包的 ID</strong>,以确定这几个分片是否属于同一个包,具有同一个 ID 的 IP 分片将会从新组装.<strong>13bit 的片偏移记录了一个 IP 分片相对于整个包的位置</strong>.<strong>3bit 的标志位记录了该分片后面是否还有新的分片</strong>.这三个分片组成了 IP 分片的所有的信息</li> </ul> </li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_%E6%80%BB%E7%BA%BF.md/">总线</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_coroutine.md/">coroutine了解</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_process.md/">进程</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_io.md/">磁盘结构</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/1_threads.md/">c++的多线程</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>