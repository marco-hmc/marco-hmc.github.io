<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 系统设计 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/0_systemDesign.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">系统设计</h1> <p class="post-meta"> Created on April 26, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"> <i class="fa-solid fa-hashtag fa-sm"></i> 系统设计</a>   ·   <a href="/blog/category/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"> <i class="fa-solid fa-tag fa-sm"></i> 程序设计</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="系统设计">系统设计</h2> <p>系统设计一定是从业务出发的，将需求转换为计算机的抽象设计。</p> <p>需求层次需要考虑：功能需求，以及性能需求。 计算机的抽象设计需要考虑：数据侧（数据库、文件）、交互侧（ui、前端、桌面端）、业务侧（具体功能）、技术选型</p> <h3 id="1-需求考虑">1. 需求考虑</h3> <ul> <li> <strong>功能需求</strong> 这些是最终用户明确要求的系统应提供的基本功能。例如： <ul> <li>“我们需要为这个系统设计哪些功能？”</li> <li>“在我们的设计中需要考虑哪些边界情况？”</li> </ul> </li> <li> <p><strong>性能需求</strong> 这些是系统必须满足的质量约束，根据项目合同的要求。实现这些因素的优先级或程度因项目而异。它们也被称为非行为需求。例如，可移植性、可维护性、可靠性、可扩展性、安全性等。例如：</p> <ul> <li>“这个系统需要处理的预期规模是多少？”</li> <li>“我们的系统的读/写比是多少？”</li> <li>“每秒需要处理多少请求？”</li> <li>“需要多少存储空间？”</li> <li>“负载分配如何处理？”</li> <li>“我们应该使用缓存吗？”</li> <li>“如何处理突发流量？”</li> </ul> </li> </ul> <h3 id="2-实现考虑">2. 实现考虑</h3> <h4 id="21-数据模型设计">2.1. 数据模型设计</h4> <p>一旦我们有了估算，我们可以开始定义数据库模式。在开发的早期阶段这样做有助于我们理解数据流，这是每个系统的核心。在这一步中，我们基本上定义了所有的实体及其之间的关系。</p> <ul> <li>“系统中有哪些不同的实体？”</li> <li>“这些实体之间的关系是什么？”</li> <li>“我们需要多少张表？”</li> <li>“在这里使用 NoSQL 是否更好？”</li> </ul> <h4 id="22-交互设计">2.2 交互设计</h4> <h4 id="23-业务设计">2.3 业务设计</h4> <p>现在我们已经建立了数据模型和 API 设计，是时候确定解决问题所需的系统组件（如负载均衡器、API 网关等），并草拟系统的初步设计。</p> <ul> <li>“设计单体架构还是微服务架构更好？”</li> <li>“我们应该使用哪种类型的数据库？”</li> </ul> <p>一旦我们有了基本的设计框架结构，就可以进一步细分模块，或者说系统主要组件的功能。</p> <h3 id="3-技术选型">3. 技术选型</h3> <h3 id="4-思考层面">4. 思考层面</h3> <p>简易版本的则会强调4个S。即以下四个关键要素：</p> <ol> <li> <strong>场景（Scenario）</strong> <ul> <li>明确系统的 QPS（每秒请求数，特别是峰值时间的请求数）。这与我们设计的系统规模和架构密切相关。如果请求频率非常低，一个 Web 服务器可能就足够了；如果请求频率很高，则需要构建一个 Web 服务器集群，并且需要考虑部分服务器宕机时如何保持系统的可靠性。</li> </ul> </li> <li> <strong>服务（Service）</strong> <ul> <li>根据任务需求，细分主要功能模块。明确每个模块的职责和边界，以便于系统的开发、维护和扩展。</li> </ul> </li> <li> <strong>存储（Storage）</strong> <ul> <li>选择合适的存储结构和数据库。根据数据的特性和访问模式，选择关系型数据库、NoSQL 数据库或其他存储解决方案，以满足系统的性能和扩展需求。</li> </ul> </li> <li> <strong>扩展性（Scale）</strong> <ul> <li>从优化的角度出发，添加新的功能以提升系统性能。</li> <li>从维护的角度出发，确保系统能够应对更大的流量和容灾需求。常见的扩展性措施包括： <ul> <li> <strong>缓存（Cache）</strong>：使用缓存技术减少数据库访问次数，提高系统响应速度。</li> <li> <strong>消息队列（Kafka 等）</strong>：使用消息队列实现异步处理，提升系统的吞吐量和可靠性。</li> <li> <strong>负载均衡（Load Balancing）</strong>：使用负载均衡技术分发请求，确保系统的高可用性和稳定性。</li> </ul> </li> </ul> </li> </ol> <h3 id="3-客户端的架构设计">3. 客户端的架构设计</h3> <h4 id="31-广义客户端概念">3.1 广义客户端概念</h4> <p><strong>广义客户端</strong>的概念包括多个端，如 Web 端、桌面端、移动端，实际上这些端都可以使用各种架构模式（如 MVC、MVVM、微服务等），但是每个平台的架构实现和框架支持有所不同。</p> <p>架构模式的选择受限于<strong>客户端程序框架的支持</strong>。桌面端的框架相对稳定，但更新不够频繁，因此许多传统的架构模式（如 MVC）仍然占主导地位。而 Web 端和移动端的框架和技术栈的更新非常快，支持更多现代的架构模式。</p> <ul> <li> <p><strong>桌面端的停滞和 MVC 主导</strong></p> <ul> <li>过去几年，桌面端应用的开发相对较为<strong>停滞</strong>，尤其是传统桌面应用（如基于 WinForms、WPF 等技术的应用）。这些平台大多以<strong>MVC</strong>或<strong>MVVM</strong>为主的设计模式，且大多数桌面开发框架的更新不如 Web 和移动端活跃。</li> <li>桌面端的开发框架（如 WPF、WinForms、Qt、Electron 等）确实仍然偏向于较为传统的架构模式，如 MVC 或 MVVM，尽管这些框架也有一些现代化的支持，但相较于 Web 端和移动端，它们的创新和更新的速度较慢。</li> <li>对于一些新兴桌面应用开发框架，如<strong>Electron</strong>（跨平台框架），它虽然支持现代化的架构设计（如 MVVM 等），但仍然需要进行一定的封装和适配，才能更好地支持现代前端架构（如 React、Vue 等框架）。</li> <li>对于桌面端而言，虽然框架更新缓慢，但开发者通常可以通过<strong>封装和调整</strong>现有的框架来支持现代的架构模式。例如，在桌面应用中使用类似于 React/Vue 的框架进行组件化开发，或者借助如 Electron 等跨平台框架来实现现代 Web 技术的支持。</li> <li> <strong>桌面端</strong>的架构相对较为传统，主要依赖 MVC 等经典模式，且更新速度较慢，尽管可以通过封装进行现代化改进，但相对复杂。</li> </ul> </li> <li> <p><strong>Web 端和移动端的快速发展</strong></p> <ul> <li> <strong>Web 端</strong>的技术和架构支持非常丰富，且发展迅速。从前端框架的支持（如 React、Vue、Angular 等）到后端架构（如微服务、GraphQL 等），都为 Web 应用提供了高度的灵活性和扩展性。</li> <li>在 Web 端，开发者可以选择更多适合特定应用需求的架构模式和工具。例如，Web 端的前后端分离、微前端架构等都在流行</li> <li>现代 Web 开发不仅支持传统的 MVC 架构，也提供了更复杂的架构模式，如<strong>MVVM</strong>、<strong>Flux/Redux</strong>等，甚至是更高级的组件化架构。由于 Web 应用的浏览器环境和网络特性，Web 端开发框架可以更方便地集成现代架构模式。</li> <li> <strong>移动端</strong>（iOS、Android）的发展同样迅速。iOS（如 SwiftUI）和 Android（如 Jetpack Compose）已经提供了更为现代的架构支持（例如 MVVM、MVI、Redux 等），并且开发者可以灵活地选择符合需求的架构。</li> <li>移动端的更新频繁，许多框架和库的快速迭代，使得这些平台能够灵活地采用各种现代架构，支持更高效的开发和维护。</li> <li>移动端则有更多适合响应式和模块化开发的架构支持（如 MVVM、MVP 等）。</li> <li>对于 Web 端和移动端，由于这些平台本身就支持更多现代化的架构和框架，因此开发者不需要进行过多的封装，可以直接采用最新的技术栈和架构设计。</li> <li> <strong>Web 端和移动端</strong>的架构和框架发展迅速，支持的架构模式更多、更灵活，可以较为容易地采用更现代化的架构模式（如 MVVM、微服务、组件化、Flux 等）。</li> </ul> </li> </ul> <h4 id="32-基本概念">3.2 基本概念</h4> <p><img src="imgs/client_arch_patterns.png" alt="alt text"></p> <p>不管客户端的架构怎么确定，本质上都是为了解耦数据、ui、和业务三个部分。其中数据部分一般被抽象成为 model 模块，ui 部分被抽象成为 view 模块。</p> <p>而数据变化了如何更新到显示上，如何从显示上获取数据等等业务逻辑层面上，则被抽象为 model 和 view 模块的交互方式。这个交互方式可能是以 controller 的模式，或者 presenter 的模式，各有各的好处，需要结合业务场景具体选择。</p> <p>因此可以说，客户端的各种架构设计都是下面这种方式的变化。</p> <ul> <li>model - 数据</li> <li>view - ui/显示</li> <li>interaction - 业务 相对而言 model 和 view 层的变化都比较少，集中讨论和设计的主要以 interaction 方式为主，比如 controller 和 presenter 方式等等。 其好处在于： <ol> <li> <strong>分离关注点</strong>：MVC 模式将数据、业务逻辑和用户界面分离开来，提高了代码的可维护性和可扩展性。</li> <li> <strong>可测试性</strong>：由于模型、视图和控制器是独立的组件，可以分别进行单元测试。</li> <li> <strong>复用性</strong>：视图和模型可以独立复用，视图可以用于不同的模型，模型也可以用于不同的视图。</li> <li> <strong>实现解耦</strong>：如分离关注点，提升可维护性，提升扩展性，提上可测试性等等。</li> </ol> </li> </ul> <h5 id="321-模型">3.2.1 模型</h5> <p>Model 掌管数据源，是应用程序的核心部分，负责处理应用程序的数据逻辑。Model 直接管理数据、逻辑和规则。它有对数据直接访问的权力，通常与数据库交互，执行数据的创建、读取、更新和删除（CRUD）操作。</p> <ul> <li> <p><strong>职责</strong></p> <ul> <li> <strong>数据管理</strong>：处理和管理数据。</li> <li> <strong>业务逻辑</strong>：执行业务逻辑。</li> <li> <strong>数据交互</strong>：与数据库或其他数据源交互。</li> <li> <strong>封装数据</strong>：用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。</li> </ul> </li> <li> <p><strong>数据</strong> 较现代的 Framework 都会建议使用独立的数据对象（DTO，POCO，POJO 等）来替代弱类型的集合对象。数据访问的代码会使用 Data Access 的代码或是 ORM-based Framework，也可以进一步使用 Repository Pattern 与 Unit of Works Pattern 来切割数据源的相依性。</p> </li> <li> <p><strong>monitor 机制</strong> Model 中数据的变化一般会通过一种 monitor 机制被公布。为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，从而，View 可以了解在数据 Model 上发生的改变。</p> </li> </ul> <h5 id="322-视图">3.2.2 视图</h5> <p>View 负责显示数据并与用户交互。视图从模型中获取数据，并将其呈现给用户。视图不包含任何业务逻辑，只负责数据的展示。</p> <ul> <li> <strong>职责</strong> <ul> <li> <strong>数据显示</strong>：负责显示数据。</li> <li> <strong>用户交互</strong>：提供用户交互界面。</li> <li>显示数据。</li> <li>提供用户交互界面。 View 负责数据显示的职责分离原则，</li> </ul> </li> <li>View 负责显示数据，这个部分多为前端应用，而 Controller 会有一个机制将处理的结果 (可能是 Model，集合或是状态等) 交给 View，然后由 View 来决定怎么显示。 例如 Spring Framework 使用 JSP 或相应技术，ASP.NET MVC 则使用 Razor 处理数据的显示。 视图是用户界面部分，负责显示数据。视图从模型中获取数据，并将其呈现给用户。视图不包含任何业务逻辑，只负责数据的展示。</li> </ul> <p>能够实现数据有目的的显示(理论上,这不是必需的)。在 View 中一般没有程序上的逻辑。为了实现 View 上的刷新功能，View 需要访问它监视的数据模型(Model)，因此应该事先在被它监视的数据那里注册。</p> <h4 id="33-常见客户端架构">3.3 常见客户端架构</h4> <h5 id="331-mvc-架构">3.3.1 mvc 架构</h5> <ul> <li> <p><strong>定义</strong> MVC（Model-View-Controller）是一种软件架构模式，用于分离应用程序的不同关注点。它将应用程序分为三个主要部分：模型（Model）、视图（View）和控制器（Controller）。这种分离有助于提高代码的可维护性和可扩展性。</p> <p>MVC 架构是一种将应用程序分为模型、视图和控制器三部分的架构模式。它通过分离关注点，提高了代码的可维护性和可扩展性。尽管 MVC 模式可能会引入一定的复杂性，但它在大型应用程序中具有显著的优势。</p> <ul> <li>MVC 是最古老的模式，已有近 50 年的历史</li> <li>每种模式都有一个负责显示内容和接收用户输入的 “视图” (V)</li> <li>大多数模式包括一个管理业务数据的 “模型” (M)</li> <li>“控制器”、”展示器” 和 “视图模型” 是在视图和模型（在 VIPER 模式中称为 “实体”）之间进行翻译的中介</li> </ul> </li> <li> <p><strong>控制器（Controller）</strong> Controller 负责处理用户输入，并将其转换为对模型的操作。它充当视图和模型之间的中介，处理用户输入并更新模型或视图。 控制器起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。”事件”包括用户的行为和数据 Model 上的改变。</p> <ul> <li> <strong>职责</strong> <ul> <li> <strong>用户输入处理</strong>：处理用户输入。</li> <li> <strong>模型操作</strong>：调用模型更新数据。</li> <li> <strong>视图选择</strong>：选择视图来显示数据。</li> <li>处理用户输入。</li> <li>调用模型更新数据。</li> <li>选择视图来显示数据。</li> </ul> </li> <li>Controller 负责处理消息,较高端的 Framework 会有一个默认的实现来作为 Controller 的基础,例如 Spring 的 DispatcherServlet 或是 ASP.NET MVC 的 Controller 等,在职责分离原则的基础上,每个 Controller 负责的部分不同,因此会将各个 Controller 切割成不同的文件以利维护. 控制器是应用程序的中介部分，负责处理用户输入。控制器从视图接收输入，处理这些输入并更新模型或视图。控制器将用户的动作转换为对模型的操作，并决定哪个视图来显示数据。 起到不同层面间的组织作用,用于控制应用程序的流程.它处理事件并作出响应.”事件”包括用户的行为和数据 Model 上的改变.</li> </ul> </li> <li> <p><strong>MVC 工作流程</strong></p> <ol> <li>用户通过视图与应用程序交互（例如，点击按钮、输入数据）。</li> <li>控制器接收用户输入，并将其转换为对模型的操作。</li> <li>模型处理控制器的请求，更新数据或执行业务逻辑。</li> <li>模型更新数据后，通知视图数据已更新/将更新后的数据返回给控制器。</li> <li>视图获取最新数据，并将其呈现给用户。</li> </ol> <p>“Model”不依赖”View”和”Controller”，也就是说，Model 不关心它会被如何显示或是如何被操作。</p> </li> </ul> <h5 id="332-mvp-架构">3.3.2 MVP 架构</h5> <ul> <li> <p><strong>定义</strong> MVP（Model-View-Presenter）是一种软件架构模式，是对 MVC 模式的改进，旨在解决 MVC 中控制器与视图耦合过紧的问题。MVP 模式将应用程序分为三个主要部分：模型（Model）、视图（View）和展示器（Presenter）。这种分离有助于提高代码的可维护性和可扩展性。</p> </li> <li> <p><strong>展示器（Presenter）</strong>：</p> <ul> <li> <strong>职责</strong>：展示器负责处理用户输入，并将其转换为对模型的操作。它充当视图和模型之间的中介，处理业务逻辑并更新视图。</li> <li> <strong>示例</strong>：在一个电商应用中，展示器可能包括处理用户添加商品到购物车、提交订单等操作。</li> </ul> </li> <li> <p><strong>工作原理</strong> MVP 模式的工作原理如下：</p> <ol> <li>用户通过视图与应用程序交互，触发某个事件（例如点击按钮）。</li> <li>视图将用户输入传递给展示器。</li> <li>展示器接收用户输入，并将其转换为对模型的操作。</li> <li>模型处理展示器的请求，更新数据或执行业务逻辑。</li> <li>模型将更新后的数据返回给展示器。</li> <li>展示器将数据传递给视图，视图更新显示内容。</li> </ol> </li> </ul> <h5 id="333-mvvm-架构">3.3.3 mvvm 架构</h5> <ul> <li> <p><strong>定义</strong> MVVM（Model-View-ViewModel）是一种软件架构模式，特别适用于双向数据绑定的框架。MVVM 模式将应用程序分为三个主要部分：模型（Model）、视图（View）和视图模型（ViewModel）。这种分离有助于提高代码的可维护性和可扩展性，并简化了视图和模型之间的数据绑定。</p> </li> <li> <p><strong>视图模型（ViewModel）</strong>：</p> <ul> <li> <strong>职责</strong>：视图模型负责处理用户输入，并将其转换为对模型的操作。它充当视图和模型之间的中介，处理业务逻辑并更新视图。视图模型通过数据绑定与视图进行通信。</li> <li> <strong>示例</strong>：在一个电商应用中，视图模型可能包括处理用户添加商品到购物车、提交订单等操作。</li> </ul> </li> <li> <p><strong>工作原理</strong> MVVM 模式的工作原理如下：</p> <ol> <li>用户通过视图与应用程序交互，触发某个事件（例如点击按钮）。</li> <li>视图将用户输入传递给视图模型。</li> <li>视图模型接收用户输入，并将其转换为对模型的操作。</li> <li>模型处理视图模型的请求，更新数据或执行业务逻辑。</li> <li>模型将更新后的数据返回给视图模型。</li> <li>视图模型将数据传递给视图，视图通过数据绑定自动更新显示内容。</li> </ol> </li> </ul> <h5 id="334-mvvm-c-架构">3.3.4 mvvm-c 架构</h5> <ul> <li> <p><strong>定义</strong> MVVM-C（Model-View-ViewModel-Coordinator）是一种软件架构模式，是对 MVVM 模式的扩展。它引入了协调器（Coordinator）来管理视图之间的导航和流程控制。MVVM-C 模式将应用程序分为四个主要部分：模型（Model）、视图（View）、视图模型（ViewModel）和协调器（Coordinator）。这种分离有助于提高代码的可维护性和可扩展性，并简化了视图和模型之间的数据绑定和导航逻辑。</p> </li> <li> <p><strong>视图模型（ViewModel）</strong>：</p> <ul> <li> <strong>职责</strong>：视图模型负责处理用户输入，并将其转换为对模型的操作。它充当视图和模型之间的中介，处理业务逻辑并更新视图。视图模型通过数据绑定与视图进行通信。</li> <li> <strong>示例</strong>：在一个电商应用中，视图模型可能包括处理用户添加商品到购物车、提交订单等操作。</li> </ul> </li> <li> <p><strong>协调器（Coordinator）</strong>：</p> <ul> <li> <strong>职责</strong>：协调器负责管理视图之间的导航和流程控制。它处理视图之间的切换和传递数据。</li> <li> <strong>示例</strong>：在一个电商应用中，协调器可能包括处理从商品列表页面到商品详情页面的导航，以及在不同视图之间传递数据。</li> </ul> </li> <li> <p><strong>工作原理</strong> MVVM-C 模式的工作原理如下：</p> <ol> <li>用户通过视图与应用程序交互，触发某个事件（例如点击按钮）。</li> <li>视图将用户输入传递给视图模型。</li> <li>视图模型接收用户输入，并将其转换为对模型的操作。</li> <li>模型处理视图模型的请求，更新数据或执行业务逻辑。</li> <li>模型将更新后的数据返回给视图模型。</li> <li>视图模型将数据传递给视图，视图通过数据绑定自动更新显示内容。</li> <li>协调器管理视图之间的导航和流程控制，处理视图之间的切换和数据传递。</li> </ol> <p>视图模型通过数据绑定与视图进行通信，协调器负责管理视图之间的导航和流程控制。</p> </li> </ul> <h5 id="335-viper-架构">3.3.5 viper 架构</h5> <ul> <li> <p><strong>定义</strong> VIPER（View-Interactor-Presenter-Entity-Router）是一种软件架构模式，旨在实现高度解耦和可测试的代码。VIPER 模式将应用程序分为五个主要部分：视图（View）、交互器（Interactor）、展示器（Presenter）、实体（Entity）和路由器（Router）。这种分离有助于提高代码的可维护性和可扩展性，并简化了视图和模型之间的数据绑定和导航逻辑。</p> </li> <li> <p><strong>组成部分</strong></p> <ol> <li> <strong>视图（View）</strong>：</li> </ol> <ul> <li> <strong>职责</strong>：视图负责显示数据并与用户交互。它从展示器中获取数据，并将用户的输入传递给展示器。</li> <li> <strong>示例</strong>：在一个电商应用中，视图可能包括商品列表页面、购物车页面和订单详情页面。</li> </ul> <ol> <li> <strong>交互器（Interactor）</strong>：</li> </ol> <ul> <li> <strong>职责</strong>：交互器负责处理业务逻辑和数据操作。它从展示器接收请求，操作实体并返回结果。</li> <li> <strong>示例</strong>：在一个电商应用中，交互器可能包括处理用户添加商品到购物车、提交订单等操作。</li> </ul> <ol> <li> <strong>展示器（Presenter）</strong>：</li> </ol> <ul> <li> <strong>职责</strong>：展示器负责处理用户输入，并将其转换为对交互器的操作。它充当视图和交互器之间的中介，处理业务逻辑并更新视图。</li> <li> <strong>示例</strong>：在一个电商应用中，展示器可能包括处理用户添加商品到购物车、提交订单等操作。</li> </ul> <ol> <li> <strong>实体（Entity）</strong>：</li> </ol> <ul> <li> <strong>职责</strong>：实体表示业务数据和模型。它们通常是简单的数据结构，用于存储和传输数据。</li> <li> <strong>示例</strong>：在一个电商应用中，实体可能包括用户、商品和订单等数据结构。</li> </ul> <ol> <li> <strong>路由器（Router）</strong>：</li> </ol> <ul> <li> <strong>职责</strong>：路由器负责管理视图之间的导航和流程控制。它处理视图之间的切换和传递数据。</li> <li> <strong>示例</strong>：在一个电商应用中，路由器可能包括处理从商品列表页面到商品详情页面的导航，以及在不同视图之间传递数据。</li> </ul> </li> <li> <p><strong>工作原理</strong> VIPER 模式的工作原理如下：</p> <ol> <li>用户通过视图与应用程序交互，触发某个事件（例如点击按钮）。</li> <li>视图将用户输入传递给展示器。</li> <li>展示器接收用户输入，并将其转换为对交互器的操作。</li> <li>交互器处理展示器的请求，操作实体并返回结果。</li> <li>展示器将结果传递给视图，视图更新显示内容。</li> <li>路由器管理视图之间的导航和流程控制，处理视图之间的切换和数据传递。</li> </ol> <p>通过这个示例，可以看到 VIPER 模式如何将应用程序分为视图、交互器、展示器、实体和路由器五部分，从而提高代码的可维护性和可扩展性。视图和展示器通过接口进行通信，交互器处理业务逻辑，路由器负责管理视图之间的导航和流程控制。</p> </li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_%E6%80%BB%E7%BA%BF.md/">总线</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_coroutine.md/">coroutine了解</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_process.md/">进程</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_io.md/">磁盘结构</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/1_threads.md/">c++的多线程</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>