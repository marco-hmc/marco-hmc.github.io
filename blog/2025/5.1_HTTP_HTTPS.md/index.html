<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> L5-http | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/5.1_HTTP_HTTPS.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">L5-http</h1> <p class="post-meta"> Created on May 03, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/category/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"> <i class="fa-solid fa-tag fa-sm"></i> 计算机网络</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="l5-http">L5-http</h2> <h3 id="1-concepts">1. concepts</h3> <p>HTTP 是一种超文本传输协议(Hypertext Transfer Protocol)，是一种应用层协议，主要用于在Web浏览器和Web服务器之间传输数据。可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。</p> <p>HTTP协议和TCP/IP协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。怎么通信呢？HTTP先请求，发出请求报文，服务器响应这个请求并返回，这是个怎么样的过程呢？例如，在浏览器输入<code class="language-plaintext highlighter-rouge">"https://www.baidu.com"</code>，浏览器将这个域名发送给DNS服务器，DNS解析IP地址(后面会，另开一篇文章讲述DNS)，接下来，就是解析了IP地址，就到传输层TCP链接，剩下就是TCP的事情了。</p> <p>HTTP协议的内容主要包括以下几个部分:</p> <ol> <li>报文：请求和响应 <ul> <li>通过开始行，可用于区分两种报文</li> </ul> </li> <li>连接管理</li> <li>cookies和session</li> <li>cache</li> </ol> <h3 id="1-请求报文">1. 请求报文</h3> <ul> <li> <code class="language-plaintext highlighter-rouge">[请求行]（必需）</code> GET [resource] [http_version]</li> <li> <code class="language-plaintext highlighter-rouge">[请求头部字段]</code><br> Content-Type: [xxx]</li> <li><code class="language-plaintext highlighter-rouge">[空行]（必需）</code></li> <li><code class="language-plaintext highlighter-rouge">[请求体]</code></li> </ul> <p><img src="./img/request_head_http.jpg" alt="请求格式"></p> <p>从上图来看，在浏览器抓取的报文中，包括3⃣️种首部字段，但是这里有4⃣️种介绍<br></p> <ul> <li>通用首部字段(General): 请求报文和响应报文两方都会使用的首部 但是上图并没有体现</li> <li>响应首部字段(Response Headers): 从服务端向客户端返回🔙响应报文时使用的首部。补充了相应的附加内容，也会要求客户端附加额外的内容信息</li> <li>请求首部字段(Request Headers): 从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级</li> <li>实体首部字段(Entity Header Fields): 针对请求报文和响应报文的实体部分使用的首部。补充了资源内容的更新时间等与实体相关的信息</li> </ul> <h4 id="11-请求行">1.1 请求行</h4> <ul> <li> <p><strong>请求方法</strong>：</p> <ul> <li>HTTP 的请求方法包括 GET、POST、PUT、DELETE 等。这些方法定义了客户端可以对服务器上的资源执行的操作。</li> <li>常见方法： <ul> <li> <strong>GET</strong>：请求指定的资源。通常用于获取数据。</li> <li> <strong>POST</strong>：向指定资源提交数据进行处理请求（例如提交表单或上传文件）。数据包含在请求体中。主要用来传输数据。</li> <li> <strong>PUT</strong>：上传文件，向指定资源位置上传其最新内容。由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</li> <li> <strong>DELETE</strong>：请求服务器删除指定的资源。并且同样不带验证机制。</li> <li> <strong>HEAD</strong>：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。主要用于确认 URL 的有效性以及资源更新的日期时间等。</li> <li> <strong>OPTIONS</strong>：返回服务器针对特定资源所支持的 HTTP 请求方法。查询指定的 URL 能够支持的方法，会返回 <code class="language-plaintext highlighter-rouge">Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</li> <li> <strong>PATCH</strong>：对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</li> <li> <strong>CONNECT</strong>：用于将请求连接转换为透明的 TCP/IP 隧道，通常用于 SSL 加密的代理服务器。客户端可以通过代理服务器与目标服务器建立隧道连接。</li> <li> <strong>TRACE</strong>：回显服务器收到的请求，主要用于诊断。服务器将收到的请求内容原封不动地返回给客户端，用于测试和诊断目的。</li> </ul> </li> </ul> </li> <li> <p><strong>HTTP 版本</strong>：</p> <ul> <li> <p>指定使用的 HTTP 协议版本，如 HTTP/1.0、HTTP/1.1、HTTP/2。</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>GET /index.html HTTP/1.1
Host: www.example.com

POST /submit-form HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 27

name=John&amp;age=30

PUT /upload/file.txt HTTP/1.1
Host: www.example.com
Content-Type: text/plain
Content-Length: 11

Hello World

DELETE /resource/123 HTTP/1.1
Host: www.example.com

HEAD /index.html HTTP/1.1
Host: www.example.com

OPTIONS /resource/123 HTTP/1.1
Host: www.example.com

PATCH /resource/123 HTTP/1.1
Host: www.example.com
Content-Type: application/json
Content-Length: 20

{"name": "John Doe"}

CONNECT www.example.com:443 HTTP/1.1
Host: www.example.com

TRACE /resource/123 HTTP/1.1
Host: www.example.com
</code></pre></div> </div> </li> </ul> </li> <li> <p><strong>URL</strong>：</p> <ul> <li>URL 是统一资源定位符，用于指定网络上的资源的位置。</li> <li>结构：<code class="language-plaintext highlighter-rouge">协议://主机名:端口号/路径?查询参数#片段标识符</code> </li> </ul> </li> </ul> <h4 id="12-请求头">1.2 请求头</h4> <ul> <li>请求头包含了关于请求的元数据，如客户端类型、接受的内容类型等。</li> <li>常见请求头： <ul> <li> <strong>Host</strong>：指定请求的主机名和端口号。</li> <li> <strong>User-Agent</strong>：发出请求的客户端软件的名称。</li> <li> <strong>Accept</strong>：指定客户端能够处理的内容类型。</li> <li> <strong>Content-Type</strong>：请求体的媒体类型。</li> <li> <strong>Authorization</strong>：包含认证信息，用于验证客户端身份。</li> <li> <strong>Cookie</strong>：包含客户端保存的所有 cookie。</li> <li> <strong>If-Modified-Since</strong>：使请求成为条件请求，仅在资源自指定日期以来已被修改的情况下返回资源。</li> <li> <strong>If-None-Match</strong>：使请求成为条件请求，仅在资源的 ETag 与指定的 ETag 不匹配的情况下返回资源。</li> <li> <strong>Referer</strong>：包含发出请求的页面的 URL，服务器可以通过它了解请求的来源。</li> </ul> </li> </ul> <h4 id="13-请求体">1.3 请求体</h4> <p>请求体（Request Body）是指包含在 HTTP 请求中、需要发送到服务器的数据。它只在使用 POST、PUT、PATCH 等方法时存在。 请求体的处理取决于请求头中的 <code class="language-plaintext highlighter-rouge">Content-Type</code>，需要根据不同的类型选择合适的解析方式。</p> <ul> <li>请求体常见内容类型： <ul> <li> <strong>application/json</strong>：发送 JSON 格式的数据，通常用于 API 请求中。</li> <li> <strong>application/x-www-form-urlencoded</strong>：常用于表单提交，数据以 URL 编码的键值对形式传输。</li> <li> <strong>multipart/form-data</strong>：用于文件上传，数据按部分分割并包含文件内容。</li> </ul> </li> <li> <strong>请求体的特点</strong>： <ol> <li> <strong>类型不固定，需自行解析</strong>：请求体的格式可以根据请求的 <code class="language-plaintext highlighter-rouge">Content-Type</code> 进行不同的解析。例如，<code class="language-plaintext highlighter-rouge">application/json</code> 请求体需要解析为 JSON 数据，而 <code class="language-plaintext highlighter-rouge">text/xml</code> 则需要解析为 XML 格式。服务器本身并不会自动解析请求体，解析过程依赖于服务器端的代码实现。</li> <li> <strong>表单提交</strong>： <ul> <li>在表单数据提交时，请求体通常采用 <code class="language-plaintext highlighter-rouge">application/x-www-form-urlencoded</code> 格式。这时，表单数据以 URL 编码的键值对形式传输，多个键值对用 <code class="language-plaintext highlighter-rouge">&amp;</code> 连接，键和值用 <code class="language-plaintext highlighter-rouge">=</code> 连接。</li> <li>若表单中有文件上传，<code class="language-plaintext highlighter-rouge">enctype</code> 属性会设置为 <code class="language-plaintext highlighter-rouge">multipart/form-data</code>，这种格式用于分段发送文件和表单数据。</li> <li>表单提交格式：当使用 <code class="language-plaintext highlighter-rouge">application/x-www-form-urlencoded</code> 格式时，服务器通常将请求体中的数据解析为键值对。例如，表单数据 <code class="language-plaintext highlighter-rouge">username=JohnDoe&amp;password=1234</code> 会被解析为两个参数 <code class="language-plaintext highlighter-rouge">username=JohnDoe</code> 和 <code class="language-plaintext highlighter-rouge">password=1234</code>。</li> </ul> </li> <li> <strong>文件上传</strong>： <ul> <li>使用 <code class="language-plaintext highlighter-rouge">multipart/form-data</code> 格式时，请求体被划分为多个部分。每个部分由服务器指定的 <code class="language-plaintext highlighter-rouge">boundary</code> 分隔。</li> <li>每个部分包括一个描述头，描述头后跟一个空行，接着是数据内容。请求的结束标志是以 <code class="language-plaintext highlighter-rouge">--boundary</code> 结尾。</li> <li>文件上传格式：在 <code class="language-plaintext highlighter-rouge">multipart/form-data</code> 中，数据被分割成多个部分，每部分之间由 <code class="language-plaintext highlighter-rouge">boundary</code> 分隔。每个部分都有头信息（如 <code class="language-plaintext highlighter-rouge">Content-Disposition</code>），其中包含了字段名、文件名等信息，后面跟随实际的内容。</li> </ul> </li> </ol> </li> </ul> <h3 id="2-响应报文">2. 响应报文</h3> <p><img src="./img/response_http.jpg" alt="http返回报文格式"></p> <h4 id="21-响应行">2.1 响应行</h4> <ul> <li> <p><strong>HTTP 版本</strong>：</p> <ul> <li>指定使用的 HTTP 协议版本，如 HTTP/1.0、HTTP/1.1、HTTP/2。</li> </ul> </li> <li> <p><strong>状态码</strong>：</p> <ul> <li>响应状态码表示了请求的处理结果。例如，200 表示请求成功，404 表示请求的资源未找到。</li> <li>常见状态码： <ul> <li> <strong>1xx</strong>：信息性状态码，如 100 Continue。</li> <li> <strong>2xx</strong>：成功状态码，如 200 OK。</li> <li> <strong>3xx</strong>：重定向状态码，如 301 Moved Permanently。</li> <li> <strong>4xx</strong>：客户端错误状态码，如 404 Not Found。</li> <li> <strong>5xx</strong>：服务器错误状态码，如 500 Internal Server Error。</li> </ul> </li> </ul> </li> <li> <p><strong>状态描述</strong>：</p> <ul> <li>对状态码的简短描述，如 “OK”、”Not Found”。</li> </ul> </li> </ul> <h4 id="22-响应头">2.2 响应头</h4> <ul> <li>响应头包含了关于响应的元数据，如内容类型、内容长度等。</li> <li>常见响应头： <ul> <li> <strong>Content-Type</strong>：响应体的媒体类型。</li> <li> <strong>Content-Length</strong>：响应体的长度（字节数）。</li> <li> <strong>Set-Cookie</strong>：设置 cookie。</li> <li> <strong>Cache-Control</strong>：缓存策略。</li> <li> <strong>Location</strong>：重定向的 URL。</li> </ul> </li> <li> <p>HTTP响应首部字段 <img src="imgs/network/response_header.png" alt="response_header" style="zoom:80%;"></p> <ul> <li> <p><strong>Access-Control-Allow-Origin</strong> 一个返回的 HTTP 标头可能会具有 Access-Control-Allow-Origin ，<code class="language-plaintext highlighter-rouge">Access-Control-Allow-Origin</code> 指定一个来源，它告诉浏览器允许该来源进行资源访问.否则-对于没有凭据的请求 <code class="language-plaintext highlighter-rouge">*</code>通配符，告诉浏览器允许任何源访问资源.例如，要允许源 <code class="language-plaintext highlighter-rouge">https://mozilla.org</code> 的代码访问资源，可以指定:</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Access-Control-Allow-Origin: https://mozilla.org
Vary: Origin
</code></pre></div> </div> <p>如果服务器指定单个来源而不是 <code class="language-plaintext highlighter-rouge">*</code>通配符的话 ，则服务器还应在 Vary 响应标头中包含 <code class="language-plaintext highlighter-rouge">Origin</code> ，以向客户端指示 服务器响应将根据原始请求标头的值而有所不同.</p> </li> <li> <p><strong>Keep-Alive</strong> 上面我们提到，HTTP 报文标头会分为四种，这其实是按着<code class="language-plaintext highlighter-rouge">上下文</code>来分类的 还有一种分类是根据<code class="language-plaintext highlighter-rouge">代理</code>进行分类，根据代理会分为<code class="language-plaintext highlighter-rouge">端到端头</code> 和 <code class="language-plaintext highlighter-rouge">逐跳标头</code> 而 Keep-Alive 表示的是 Connection 非持续连接的存活时间，如下</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Connection: Keep-Alive
Keep-Alive: timeout=5， max=997
</code></pre></div> </div> <p>Keep-Alive 有两个参数，它们是以逗号分隔的参数列表，每个参数由一个标识符和一个由等号 = 分隔的值组成. <code class="language-plaintext highlighter-rouge">timeout</code>:指示空闲连接必须保持打开状态的最短时间(以秒为单位). <code class="language-plaintext highlighter-rouge">max</code>:指示在关闭连接之前可以在此连接上发送的最大请求数. 上述 HTTP 代码的意思就是限制最大的超时时间是 5s 和 最大的连接请求是 997 个</p> </li> <li> <p><strong>Transfer-Encoding</strong> 首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式.</p> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>Transfer-Encoding: chunked
</code></pre></div> </div> <p>HTTP /1.1 的传输编码方式仅对分块传输编码有效</p> </li> </ul> </li> </ul> <h4 id="23-响应体">2.3 响应体</h4> <ul> <li>响应体包含了服务器返回的数据。</li> <li>仅在状态码为 2xx 的情况下存在。</li> </ul> <h3 id="3-连接管理">3. 连接管理</h3> <ul> <li> <p><strong>Keep-Alive</strong>：</p> <ul> <li>允许客户端和服务器复用同一连接来进行多个请求/响应交换，减少连接建立和关闭的开销。</li> </ul> </li> <li> <p><strong>Connection</strong>：</p> <ul> <li>在响应头中明确要求关闭连接，意味着一次请求/响应之后连接将被关闭。</li> </ul> </li> </ul> <p>HTTP是一个无状态协议，它自身不对请求和响应之间的通信状态进行保存。使用HTTP协议，每当有新的请求发送时，就会有对应的新响应产生，协议本身并不保留之前一切或响应报文的信息。这是为了处理大量的事务，确保协议的可伸缩性，故意把HTTP协议设计得如此简单，明了。<br> 而且每次请求响应之后，TCP就断开了链接🔗，为了做这一点小事，TCP三次握手🤝四次挥手🙋，有点付出和收获不成正比。那怎么着？</p> <h5 id="keep-alive保持持久链接">keep-alive保持持久链接</h5> <p>HTTP1.1 旨在建立1⃣️次TCP链接后，进行多次请求和响应的交互 任意一端没有明确提出断开链接，则保持TCP链接状态。从慢启动到快速🔜发送，再到拥塞重启，再到快速重传策略，TCP就这样按部就班为客户端和服务端一直服务着。那么持久链接有什么好处呢？<br></p> <ul> <li>管线化: 多数请求发送，不一定要等待响应再发送请求(这个在HTTP2.0，稍后会重点讲一讲)</li> </ul> <p>keep-Alive:timeout=15,max=100 表示15ms内无请求则断开，100ms后，一定断开<br> 前面讲得有点，emmm，笼统？接下来，要真正理解HTTP，要从HTTP的报文说起<br></p> <h3 id="4-cookies-和-session">4. Cookies 和 Session</h3> <h4 id="41-cookies">4.1 cookies</h4> <ul> <li> <strong>Cookies</strong>： <ul> <li>Cookies 是服务器发送到用户浏览器并保存在浏览器上的一种数据，它可以让服务器记住用户的信息。</li> <li>用途：会话管理、个性化设置、跟踪用户行为等。</li> <li> <strong>Cookies</strong> 是服务器发送到用户浏览器并保存在浏览器上的一小块数据。它用于在多个请求之间保存状态信息，以便服务器能够识别和记住客户端用户。虽然 Cookies 在早期用于存储客户端数据，但随着现代浏览器支持多种存储方式，它的应用逐渐减少。</li> </ul> </li> <li>概念 <ul> <li>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务.<strong>HTTP/1.1 引入 Cookie 来保存状态信息</strong> </li> <li> <strong>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据</strong>，<strong>它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器.由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销</strong>(尤其是在移动环境下)</li> <li>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，<strong>Cookie 渐渐被淘汰</strong>.新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API(本地存储和会话存储)或 IndexedDB</li> <li> <ul> <li> <strong>HTTP 协议是无状态的</strong>，即每个请求都是独立的，服务器无法自动记住前一个请求的状态。为了解决这个问题，HTTP/1.1 引入了 <strong>Cookie</strong>，使得客户端可以携带状态信息，维持会话。</li> </ul> </li> <li> <strong>Cookie</strong> 是由服务器发送至客户端并保存在浏览器中的数据。当客户端再次向同一服务器发送请求时，浏览器会自动附带这些 Cookie 信息，用于识别用户。</li> <li>由于每次请求都要携带 Cookie，因此会增加网络请求的负担，尤其是在移动环境下，性能开销较大。</li> </ul> </li> </ul> <h5 id="用途">用途：</h5> <ul> <li> <strong>会话状态管理</strong>：如记录用户的登录状态、购物车内容、游戏进度等。</li> <li> <strong>个性化设置</strong>：如用户自定义设置、主题、语言选择等。</li> <li> <strong>用户行为跟踪</strong>：例如用于广告投放、分析用户行为等。</li> </ul> <h5 id="创建过程">创建过程：</h5> <ul> <li> <p><strong>服务器发送 Cookie</strong>：当服务器响应请求时，会通过 <code class="language-plaintext highlighter-rouge">Set-Cookie</code> 头部字段将 Cookie 数据传送给客户端。</p> <div class="language-http highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.0</span> <span class="m">200</span> <span class="ne">OK</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">text/html</span>
<span class="na">Set-Cookie</span><span class="p">:</span> <span class="s">yummy_cookie=choco</span>
<span class="na">Set-Cookie</span><span class="p">:</span> <span class="s">tasty_cookie=strawberry</span>
</code></pre></div> </div> </li> <li> <p><strong>客户端保存并发送 Cookie</strong>：客户端浏览器会将 Cookie 保存下来，并在后续请求中通过 <code class="language-plaintext highlighter-rouge">Cookie</code> 头部字段发送给服务器。</p> <div class="language-http highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nf">GET</span> <span class="nn">/sample_page.html</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">www.example.org</span>
<span class="na">Cookie</span><span class="p">:</span> <span class="s">yummy_cookie=choco; tasty_cookie=strawberry</span>
</code></pre></div> </div> </li> </ul> <h5 id="分类">分类：</h5> <ul> <li> <strong>会话期 Cookie</strong>：此类 Cookie 只在当前浏览器会话中有效，浏览器关闭后会自动删除。</li> <li> <p><strong>持久性 Cookie</strong>：指定了有效期（<code class="language-plaintext highlighter-rouge">Expires</code>）或最大生存时间（<code class="language-plaintext highlighter-rouge">Max-Age</code>）的 Cookie，会在过期时间之后依然有效。</p> <div class="language-http highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="err">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
</span></code></pre></div> </div> </li> </ul> <h5 id="安全性">安全性：</h5> <ul> <li> <strong>Secure</strong>：如果一个 Cookie 设置了 <code class="language-plaintext highlighter-rouge">Secure</code> 属性，那么它只能通过 HTTPS 协议加密的请求发送给服务器。这可以提高传输过程中的安全性，但并不能完全消除风险，因此敏感数据仍然不建议通过 Cookie 传输。</li> <li> <strong>HttpOnly</strong>：此属性禁止 JavaScript 访问 Cookie，能够防止一些跨站脚本攻击（XSS）。</li> </ul> <h5 id="cookie-的存储与管理">Cookie 的存储与管理：</h5> <ul> <li>Cookie 存储在客户端浏览器中，并且通常以 <strong>Key-Value</strong> 键值对的形式保存。多个 Cookie 之间通过 <code class="language-plaintext highlighter-rouge">;</code> 分隔。</li> <li>Cookie 的存储空间有限，通常为几 KB 大小，因此不适合存储大量数据。</li> <li>每个 Cookie 都有一个过期时间，超过该时间后会失效。</li> </ul> <h4 id="cookie-与-session-的区别">Cookie 与 Session 的区别：</h4> <ul> <li> <strong>Cookie</strong> 存储在客户端，服务器无法直接控制，易受安全威胁（如被盗取）。</li> <li> <strong>Session</strong> 存储在服务器端，客户端通常只保存一个标识符（如 <code class="language-plaintext highlighter-rouge">Session ID</code>）。由于数据存储在服务器端，相对更安全。</li> </ul> <h5 id="浏览器禁用-cookies-时的影响">浏览器禁用 Cookies 时的影响：</h5> <p>当浏览器禁用 Cookies 时，客户端无法发送和接收 Cookie 信息。此时，服务器可能无法识别用户的会话状态，导致每个请求都被视为新的会话，无法保持用户的登录状态。然而，仍然可以通过其他方式（如 URL 参数、Web Storage 或 IndexedDB）来实现会话管理。</p> <h4 id="42-session">4.2 session</h4> <p><strong>Session</strong> 是一种服务器端存储用户状态的机制，它可以弥补 Cookie 的不足。与 Cookie 不同，Session 数据存储在服务器上，而不是客户端，因此更为安全。服务器通过为每个用户生成一个唯一的 <strong>Session ID</strong> 来标识会话。</p> <h5 id="session-的工作原理">Session 的工作原理：</h5> <ul> <li>当用户登录时，服务器会验证其用户名和密码。如果验证通过，服务器会生成一个 <strong>Session ID</strong>，并将相关的用户信息存储在服务器上（如存储在内存、数据库或 Redis 中）。</li> <li>服务器会将 <strong>Session ID</strong> 通过 <code class="language-plaintext highlighter-rouge">Set-Cookie</code> 头部字段发送给客户端，客户端将其存储在浏览器的 Cookie 中。</li> <li>当客户端发起后续请求时，浏览器会自动将 Session ID 发送给服务器，服务器使用该 Session ID 查找对应的会话数据，继续处理用户的请求。</li> </ul> <h5 id="session-与-cookie-的关系">Session 与 Cookie 的关系：</h5> <ul> <li> <strong>Cookie</strong> 是实现 Session 的一种常见方式。尽管 Session 存储在服务器端，但客户端需要通过 Cookie 来携带 Session ID。</li> <li>如果客户端禁用了 Cookie，服务器仍然可以通过其他方式（如 URL 参数、请求头或请求体）来传递 Session ID，从而保持会话。</li> </ul> <h5 id="session-的优势">Session 的优势：</h5> <ul> <li> <strong>安全性</strong>：由于 Session 数据保存在服务器端，攻击者无法直接访问或篡改这些数据。</li> <li> <strong>数据存储</strong>：相比于 Cookie 的存储限制，Session 可以存储更多的数据，因为大部分数据存储在服务器上。</li> </ul> <h5 id="session-的注意事项">Session 的注意事项：</h5> <ul> <li> <strong>Session ID 的安全性</strong>：为了防止 Session 劫持，Session ID 必须足够复杂，且不可被轻易猜测。常见的做法是定期更新 Session ID。</li> <li> <strong>Session 过期</strong>：Session 会有超时时间，通常在一段时间内没有活动的情况下，服务器会销毁该 Session。为了提高安全性，重要操作（如支付、转账等）可能需要重新验证用户身份。</li> </ul> <h5 id="总结">总结：</h5> <ul> <li> <strong>Cookie</strong> 适用于客户端需要保存少量、短期数据的场景，如记住登录状态、用户偏好设置等。</li> <li> <strong>Session</strong> 更适用于存储大量敏感数据和需要保持安全性的场景，通常结合 Cookie 使用，但也可以通过其他方式传递 Session ID。</li> </ul> <hr> <h3 id="示例cookie-和-session-的-http-请求和响应">示例：Cookie 和 Session 的 HTTP 请求和响应</h3> <ol> <li> <p><strong>第一次请求和响应</strong>：</p> <p>客户端请求一个网页，服务器返回包含 Cookie 的响应：</p> <div class="language-http highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nf">GET</span> <span class="nn">/cluster/index.jsp</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Accept</span><span class="p">:</span> <span class="s">text/html</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/5.0</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">localhost:8080</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">Keep-Alive</span>
</code></pre></div> </div> <p>服务器响应：</p> <div class="language-http highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">OK</span>
<span class="na">Set-Cookie</span><span class="p">:</span> <span class="s">JSESSIONID=4918D6ED22B81B587E7AF7517CE24E25.server1; Path=/cluster</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">text/html;charset=ISO-8859-1</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">377</span>
<span class="na">Date</span><span class="p">:</span> <span class="s">Tue, 02 Mar 2010 02:58:32 GMT</span>
</code></pre></div> </div> <p>在这个响应中，服务器通过 <code class="language-plaintext highlighter-rouge">Set-Cookie</code> 头部字段发送了一个 Session ID。</p> </li> <li> <p><strong>第二次请求和响应</strong>：</p> <p>客户端再次访问网页时，携带上次存储的 Cookie：</p> <div class="language-http highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="nf">GET</span> <span class="nn">/cluster/user_details.jsp</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Accept</span><span class="p">:</span> <span class="s">text/html</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/5.0</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">localhost:8080</span>
<span class="na">Cookie</span><span class="p">:</span> <span class="s">JSESSIONID=4918D6ED22B81B587E7AF7517CE24E25.server1</span>
</code></pre></div> </div> <p>服务器响应：</p> <div class="language-http highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">OK</span>
<span class="na">Set-Cookie</span><span class="p">:</span> <span class="s">JSESSIONID=4918D6ED22B81B587E7AF7517CE24E25.server1; Expires=Tue, 02-Mar-2010 22:15:38 GMT</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">text/html</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">252</span>
<span class="na">Date</span><span class="p">:</span> <span class="s">Tue, 02 Mar 2010 05:35:38 GMT</span>
</code></pre></div> </div> <p>服务器根据 <code class="language-plaintext highlighter-rouge">JSESSIONID</code> 查找会话信息，识别用户身份，继续处理用户的请求。</p> </li> </ol> <ul> <li> <p><strong>session和cookie的关系</strong></p> <ul> <li>cookie只是实现session的其中一种方案.虽然是最常用的，但并不是唯一的方法.禁用cookie后还有其他方法存储，比如放在url中</li> <li>现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态.可是实际中因为多种原因，一般不会单独使用</li> <li>用session只需要在客户端保存一个id，<strong>实际上大量数据都是保存在服务端</strong>.如果全部用cookie，数据量大的时候客户端是没有那么多空间的.</li> <li>如果只用cookie不用session，<strong>那么账户信息全部保存在客户端</strong>，一旦被劫持，全部信息都会泄露.并且客户端数据量变大，网络传输的数据量也会变大</li> </ul> </li> </ul> <h3 id="小结">小结：</h3> <ul> <li> <strong>Cookies</strong> 用于在客户端存储少量的状态信息，通常用于保持用户的会话状态、个性化设置等，但容易受到安全攻击。</li> <li> <strong>Session</strong> 将用户状态存储在服务器端，安全性更高，适合处理较为敏感的用户信息，通常通过 Cookie 来传递 Session ID。</li> </ul> <h3 id="5-cache">5. cache</h3> <h2 id="99-quiz">99. quiz</h2> <ol> <li> <p>请求方式和编码方式</p> <ul> <li> <strong>GET</strong> 请求的数据只能通过 URL 进行编码，通常使用 URL 编码（<code class="language-plaintext highlighter-rouge">application/x-www-form-urlencoded</code>）。因此，GET 请求的参数会直接附加在 URL 后面。</li> <li> <strong>POST</strong> 请求的数据可以通过多种方式编码，支持如 <code class="language-plaintext highlighter-rouge">application/x-www-form-urlencoded</code>、<code class="language-plaintext highlighter-rouge">application/json</code>、<code class="language-plaintext highlighter-rouge">multipart/form-data</code> 等不同的编码格式。因此，POST 请求的参数可以放在请求体（Request Body）中。</li> </ul> </li> <li> <p>参数传递方式</p> <ul> <li> <strong>GET</strong> 请求的参数通过 URL 传递，通常是通过查询字符串的形式（<code class="language-plaintext highlighter-rouge">?key1=value1&amp;key2=value2</code>）。这种方式使得参数直接暴露在浏览器地址栏中。</li> <li> <strong>POST</strong> 请求的参数则放在请求体中，不会直接显示在 URL 中，因此较为隐蔽。</li> </ul> </li> <li> <p>安全性</p> <ul> <li> <strong>GET</strong> 请求由于参数暴露在 URL 中，相对不安全，容易受到嗅探或篡改，尤其在 HTTP 协议下。</li> <li> <strong>POST</strong> 请求的参数位于请求体中，相较于 GET 请求较为安全，因为它们不在 URL 中暴露。</li> </ul> </li> <li> <p>请求缓存</p> <ul> <li> <strong>GET</strong> 请求通常会被浏览器缓存，便于快速访问相同的资源。</li> <li> <strong>POST</strong> 请求一般不会被浏览器缓存，除非明确设置缓存规则。</li> </ul> </li> <li> <p>请求长度限制</p> <ul> <li> <strong>GET</strong> 请求的 URL 有长度限制，通常限制在 1024 至 2048 个字符之间（具体限制取决于浏览器和服务器的配置）。</li> <li> <strong>POST</strong> 请求没有长度限制，可以传输更大规模的数据，通常限制在服务器的配置范围内（如 80KB 到 4MB 不等）。</li> </ul> </li> <li> <p>数据存储</p> <ul> <li> <strong>GET</strong> 请求的参数会保存在浏览器的历史记录中，URL 也可以被书签保存。</li> <li> <strong>POST</strong> 请求的参数不会保存在浏览器历史记录中，也不能直接保存为书签。</li> </ul> </li> <li> <p>请求对服务器的副作用</p> <ul> <li> <strong>GET</strong> 请求是幂等的，即它的执行不会对服务器上的资源造成修改。GET 请求的目的是获取数据。</li> <li> <strong>POST</strong> 请求通常会对服务器上的资源产生副作用，例如创建、修改或删除资源。</li> </ul> </li> <li> <p>浏览器回退操作</p> <ul> <li> <strong>GET</strong> 请求在浏览器回退时是无害的，可以直接使用缓存的结果。</li> <li> <strong>POST</strong> 请求则会在浏览器回退时再次提交请求，因此需要额外的确认，避免重复提交。</li> </ul> </li> <li> <p>数据格式支持</p> <ul> <li> <strong>GET</strong> 请求的参数通常是 ASCII 字符串，并且限制了数据的大小。</li> <li> <strong>POST</strong> 请求则可以传输更多格式的数据，包括二进制数据（如文件上传）。</li> </ul> </li> </ol> <p>虽然从 TCP 协议的角度来看，GET 和 POST 都是建立在 TCP 连接上的，实际上它们在 HTTP 请求中的行为有所不同，导致了不同的网络行为和效率差异：</p> <ol> <li> <p><strong>GET 请求</strong>：</p> <ul> <li>对于 GET 请求，浏览器会将 HTTP 请求头（Header）和请求数据（如果有的话）一并发送到服务器。服务器接收到请求后，直接响应 200 OK，并返回数据。</li> <li>因为数据通常较少，GET 请求通常只需要一个 TCP 数据包进行传输。</li> </ul> </li> <li> <p><strong>POST 请求</strong>：</p> <ul> <li>对于 POST 请求，浏览器会先发送请求头（Header），然后等待服务器响应一个 <code class="language-plaintext highlighter-rouge">100 Continue</code> 状态码，表示可以开始发送请求体数据。随后，浏览器会再次发送请求体数据，服务器处理完后返回 200 OK。</li> <li>由于 POST 请求包含两次数据传输，因此通常会比 GET 请求稍慢，但它能够处理更大的数据量。</li> </ul> </li> </ol> <ul> <li> <strong>GET 和 POST 的本质差异</strong> 在于它们传输数据的方式、编码格式、请求体的使用以及服务器如何处理请求。GET 请求适用于获取数据，且适合短小的数据传递；POST 请求则适用于数据较大或涉及资源修改的操作。</li> <li>从 TCP 连接的角度来看，GET 和 POST 的区别体现在数据包的数量和服务器的响应机制上，虽然它们都依赖 TCP 连接，但 POST 请求因其需要分两步传输而稍显复杂，时间和资源消耗上也有所不同。</li> </ul> <p><strong>总结</strong>：虽然 GET 和 POST 都基于 TCP 链接，但 HTTP 协议标准定义了它们的不同行为和使用场景。面试中，理解这两者的差异有助于更好地回答相关问题，展示对 HTTP 协议的深入理解。</p> <h4 id="2-if-modified-since怎么用">2. If-Modified-Since怎么用？</h4> <p>200 表示强缓存Expires/Cache-Control失效，返回新的资源文件<br> 200(from cache):强缓存Expires/Cache-Control两者都有，为国企，Cache-Control 优先Expires时，浏览器获取本地资源<br> 304(Not Modified):协商缓存Last-Modified/Etag未过期，服务端返回状态码304<br></p> <p>但是现在改成这样，磁盘(from disk cache)和内存(memory cache)两种<br> <img src="./img/200_from_cache.png" alt="200_cache" title="200cache"></p> <p>两种缓存策略要配合使用，如果不用强缓存，协商缓存没有什么意义，大部分web服务器都默认开启协商缓存同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】<br></p> <ul> <li>分布式系统里的多台机器的文件的Last-Modified必须保持一直，以免负载均衡到不同机器导致比对失效</li> <li>分布式系统尽量关掉ETag(没太机器生成的Etag都会不太一样)</li> </ul> <p>ok👌，缓存我们了解了，那么缓存，缓存，缓存在哪里呢？拿东西也要找个地方拿撒<br></p> <h4 id="1-网页解析的过程与实现方法">1 网页解析的过程与实现方法</h4> <p>这里仅展示浏览器解析服务器响应的过程，URL解析和交互的完整过程在(9)</p> <ul> <li>首先是html文档解析，浏览器会将html文档生成解析树，也就是DOM树，它由dom元素以及属性节点组成.</li> <li>然后浏览器加载过程中如果遇到了外部css文件或者图片资源，还会另外发送请求来获取css文件和资源，这个请求通常是异步的，不会影响html文档的加载.</li> <li>不过如果浏览器在加载时遇到了js文件，则会挂起渲染的线程，等待js文件加载解析完毕才恢复html的渲染线程.</li> <li> <h2 id="然后是css解析将css文件解析为样式表对象来渲染dom树">然后是css解析，将css文件解析为样式表对象来渲染DOM树.</h2> </li> </ul> <h4 id="22-在浏览器中输入url后执行的全部过程如wwwbaiducom">2.2 在浏览器中输入URL后执行的全部过程(如www.baidu.com)</h4> <ol> <li>首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址;</li> <li>然后建立TCP连接，客户端与服务器通过三次握手建立TCP连接;</li> <li>接着是http连接，客户端向服务器发送http连接请求; (http连接无需额外连接，直接通过已经建立的TCP连接发送)</li> <li>服务器对客户端发来的http请求进行处理，并返回响应;</li> <li>客户端接收到http响应，将结果渲染展示给用户.</li> </ol> <h4 id="23-http10和http11的区别">2.3 http/1.0和http/1.1的区别</h4> <p>HTTP 协议老的标准是 HTTP/1.0 ，目前最通用的标准是 HTTP/1.1 . HTTP1.0 只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，但是最新的http/1.0加入了长连接，只需要在客户端给服务器发送的http报文头部加入Connection:keep-alive HTTP 1.1 支持持久连接，默认进行持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟.</p> <h4 id="http和https的区别">HTTP和HTTPS的区别</h4> <p>从链路层⛓️到IP层再到TCP/UDP层，再到应用层。HTTP是我们经常使用的协议，一个小白，刚开始接触的就是HTTP协议。同时这个协议很容易被人忽略。做前端必须要熟悉HTTP协议，做后端就要知道HTTP协议到底怎么来的。怎么工作的，工作原理是什么。总结了一下，HTTP要讲的东西蛮多的，基本上环环相扣，从简单的HTTP到安全HTTPS，HTTP状态码，基于流的HTTP2.0，缓存技术等等。简单吗？不简单！复杂吗？超复杂。应用层协议一窝蜂，天天有不同，google开发了QUIC，文章最后，一起探讨QUIC。<br> 文章思路:HTTP首部请求与响应报文➡️HTTP状态码➡️GET与POST方法，PUT、DELETE➡️HTTP缓存机制➡️HTTP2.0➡️HTTPS➡️QUIC🔚</p> <h4 id="url与uri的区别">URL与URI的区别</h4> <p>URI，用字符串标识某一互联网资源，而URL表示资源的地点(互联网上所处的位置)。</p> <h4 id="如何增强校验">如何增强校验</h4> <p>举个🌰 终端💻发起续传请求时，URL对应的文件内容服务端已经发生了变化，此时续传的数据肯定是错误的。如何解决这个问题呢？显然此时需要有一个标识文件唯一性的方法。<br> 在 RFC2616 中也有相应的定义，比如实现 Last-Modified 来标识文件的最后修改时间，这样即可判断出续传文件时是否已经发生过改动。同时 FC2616 中还定义有一个 ETag 的头，可以使用 ETag 头来放置文件的唯一标识。<br> 我们来看看文件发生变化之后会触动什么首部字段改变。要知道，首部字段就是告知两端信息的变化的。<br></p> <ul> <li>Last-Modified: 与If-Modified-Since一样都是用于记录📝页面最后修改时间的HTTP头信息的。而Last-Modified是由服务器往客户端发送的HTTP头，而If-Modified-Since则是由客户端往服务器发送的头部信息。</li> </ul> <p>可以看到，再次请求本地存在的缓存页面时， <strong>客户端会通过If-Modified-Since头将先前服务器端发过来的Last-Modified最后修改时间戳发送回去</strong> 这是为了让服务器端进行验证，通过这个时间戳判断客户端的页面是否最新，如果不是最新的，则返回新的内容，如果是最新的，则返回304 Not Modified，告诉客户端本地cache的页面是最新的。这样，客户端就可以直接从本地加载页面了，这样在网路上传输的数据就会大大减少，同时也减轻了服务器的负担。<br></p> <ul> <li>Etag(Entity Tags): 主要为了解决Last-Modified无法解决的一些问题(什么问题？)</li> </ul> <ol> <li>一些文件也许会周期性更改，但是内容不变(仅仅修改了时间)，这时候，并不希望客户端会认为这个文件被改变了，而重新GET</li> <li>某些文件修改频繁，例如在秒以下的单位时间内修改了N次，而，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断</li> <li>某些服务器不能精确得到文件的最后修改时间</li> </ol> <p><code class="language-plaintext highlighter-rouge">etag: "36BE3457520CDFD54CA910564E580EAE"</code> http/1.1引入Etag，唯一的标识，表示文件的版本。<br></p> <ul> <li>If-Range: 判断实体是否发生改变，如果未改变，服务器发送客户端丢失的一部分，否则发送整个实体。一般格式</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If-Range:Rtag|HTTP-Date

If-Range: "36BE3457520CDFD54CA910564E580EAE"
If-Range: Fri, 22 Feb 2019 03:45:02 GMT
</code></pre></div></div> <p>也就是说，If-Range可以使用Etag或者Last-Modified返回的值。当没有Etag却有Last-Modified时，可以把Last-Modified作为If-Range字段的值<br></p> <p>If-Range必须与Range配套使用。如果请求报文中没有Range，那么If-Range就会被忽略。如果服务器不支持If-Range，那么Range就会被忽略掉。<br></p> <p>如果请求报文中的Etag与服务器目标内容的Etag相等，即没有发生变化，那么应答就是206。如果发生了变化，应答报文的状态码为200。<br></p> <p>其他用于增强校验的HTTP头信息: If-Match/If-None-Match、If-Modified-Since/If-Unmodified-Since</p> <p>工作:Etag由服务器端生成，客户端通过If-Range条件判断请求来验证资源是否修改。<br> ➡️第一次请求:发起get，服务器处理请求，返回文件内容以及相应的header，其中包括Etag，状态码200 ➡️第二次请求: 发起get，同时发送If-Range，服务端判断Etag和计算出来的Etag是否匹配，匹配206，不匹配200</p> <p>为了保证资源可靠，首部字段也很给力。<br></p> <h2 id="https-安全相关数字签名数字证书tls">HTTPS 安全相关：数字签名、数字证书、TLS</h2> <h3 id="1-概念">1. 概念</h3> <h4 id="11-什么是-https">1.1 什么是 HTTPS？</h4> <p>HTTPS（HyperText Transfer Protocol Secure）是 HTTP 的安全版本，通过 SSL/TLS 协议对数据进行加密传输，确保数据的机密性和完整性。相比 HTTP，HTTPS 提供了更高的安全性，防止数据在传输过程中被窃取或篡改。</p> <p><a href="https://snailclimb.gitee.io/javaguide/#/./docs/cs-basics/network/http&amp;https" rel="external nofollow noopener" target="_blank">HTTP vs HTTPS</a></p> <h4 id="12-数字证书">1.2 数字证书</h4> <p>数字证书是由权威 CA（Certificate Authority）颁发的，用于验证网站身份和加密通信。数字证书包含网站的信息和 CA 的签名。</p> <ul> <li> <strong>工作原理</strong>： <ol> <li>权威 CA 使用私钥将网站 A 的信息和消息摘要（签名 S）进行加密打包，形成数字证书，并将公钥提供给客户端。</li> <li>网站 A 将自己的信息和数字证书发给客户端。</li> <li>客户端用 CA 的公钥对数字证书进行解密，得到签名 S，并与手动计算的网站信息的消息摘要结果 S* 进行对比。</li> <li>如果签名一致，证明网站 A 可以信任。</li> </ol> </li> </ul> <h3 id="2-https-的具体实现与安全性">2. HTTPS 的具体实现与安全性</h3> <p>HTTPS 包括非对称加密和对称加密两个阶段。在客户端与服务器建立连接时使用非对称加密，连接建立后使用对称加密。</p> <h4 id="21-https-加密流程">2.1 HTTPS 加密流程</h4> <ol> <li>客户端使用 HTTPS 的 URL 访问 Web 服务器，要求与 Web 服务器建立 SSL 连接。</li> <li>Web 服务器收到客户端请求后，将网站的公钥传送给客户端，私钥自己保存。</li> <li>客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥（会话密钥），然后利用网站的公钥将会话密钥加密，并传送给网站。</li> <li>Web 服务器利用自己的私钥解密出会话密钥。</li> <li>Web 服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。</li> </ol> <p>服务器第一次传给客户端的公钥其实是 CA 对网站信息进行加密的数字证书。客户端的对称加密密钥是三个随机数的哈希值（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数）。</p> <h3 id="3-重放与篡改">3. 重放与篡改</h3> <h4 id="31-重放攻击">3.1 重放攻击</h4> <p>重放攻击是指黑客通过截取的包，重复发送多次，达到攻击服务端的目的。为了防止重放攻击，可以使用唯一的时间戳（timestamp）和随机数（nonce）联合起来，做一个不可逆的签名来保证请求的唯一性。</p> <ul> <li> <strong>防御措施</strong>： <ol> <li>验证签名是否合理，确保请求参数没有被篡改。</li> <li>验证时间戳是否过期，确保请求是在最近 60 秒内发出的。</li> <li>验证随机数是否已存在，确保请求不是 60 秒内的重放请求。</li> </ol> </li> </ul> <h4 id="32-篡改攻击">3.2 篡改攻击</h4> <p>篡改攻击是指黑客在数据传输过程中对数据进行修改。为了防止篡改攻击，可以使用消息摘要（如 SHA-256）和数字签名技术，确保数据的完整性和真实性。</p> <h3 id="4-http-和-https-的区别">4. HTTP 和 HTTPS 的区别</h3> <ol> <li> <strong>安全性</strong>：HTTP 是明文传输，HTTPS 通过 SSL/TLS 加密传输，提供更高的安全性。</li> <li> <strong>端口</strong>：HTTP 使用端口 80，HTTPS 使用端口 443。</li> <li> <strong>连接方式</strong>：HTTP 是无状态的，HTTPS 是由 SSL+HTTP 协议构建的可进行加密传输和身份认证的网络协议。</li> <li> <strong>证书</strong>：HTTPS 需要到 CA 申请证书，通常需要一定费用。</li> </ol> <h3 id="5-由-http-升级为-https-的操作步骤">5. 由 HTTP 升级为 HTTPS 的操作步骤</h3> <ol> <li> <strong>申请数字证书</strong>：从权威 CA 申请数字证书。</li> <li> <strong>配置服务器</strong>：在服务器上安装和配置数字证书。</li> <li> <strong>修改网站链接</strong>：将网站的所有 HTTP 链接修改为 HTTPS 链接。</li> <li> <strong>重定向</strong>：设置 HTTP 到 HTTPS 的重定向，确保所有访问都使用 HTTPS。</li> <li> <strong>测试</strong>：测试网站的 HTTPS 连接，确保没有安全漏洞。</li> </ol> <p>通过以上步骤，可以将网站从 HTTP 升级为 HTTPS，提供更高的安全性和用户信任度。</p> <h3 id="参考链接">参考链接</h3> <ul> <li><a href="https://snailclimb.gitee.io/javaguide/#/./docs/cs-basics/network/http&amp;https" rel="external nofollow noopener" target="_blank">HTTP vs HTTPS</a></li> <li><a href="https://github.com/HXWfromDJTU/blog/blob/master/network/http/https.md" rel="external nofollow noopener" target="_blank">HTTPS 加密流程</a></li> <li><a href="https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html" rel="external nofollow noopener" target="_blank">Ping 原理与 ICMP 协议</a></li> </ul> <p>通过理解 HTTPS 的基本概念、实现过程和安全性措施，可以更好地设计和管理安全的网络通信。</p> <h2 id="http20">HTTP/2.0</h2> <h3 id="1-概述">1. 概述</h3> <p>HTTP/2.0 是 HTTP 协议的最新版本，相比 HTTP/1.1，HTTP/2.0 引入了许多新特性，如二进制帧、多路复用、请求优先级、流量控制、服务器推送和首部压缩等。这些改进使得 HTTP/2.0 在性能和效率上有了显著提升。</p> <h3 id="2-http11-的局限性">2. HTTP/1.1 的局限性</h3> <p>HTTP/1.1 在应用层上以纯文本的形式进行通信，每次通信都要带完整的 HTTP 头部，并且不考虑管道模式（pipeline），每次请求和响应都需要单独的连接。这导致了以下问题：</p> <ol> <li> <strong>连接无法复用</strong>：每次请求都需要经历三次握手和慢启动，增加了延迟。</li> <li> <strong>队头阻塞（Head-of-Line Blocking）</strong>：在第一个请求没有收到回复之前，后续请求只能排队等待，导致带宽无法被充分利用。</li> </ol> <h3 id="3-http20-的新特性">3. HTTP/2.0 的新特性</h3> <h4 id="31-二进制分帧">3.1 二进制分帧</h4> <p>HTTP/2.0 引入了二进制分帧层，将 HTTP 消息封装为二进制帧进行传输。每个帧包含帧首部和数据部分，帧首部包含帧的类型、长度、标志和流标识符。</p> <p><img src="./img/frame_http2.jpg" alt="二进制分帧层" title="二进制分帧层"></p> <h4 id="32-多路复用">3.2 多路复用</h4> <p>HTTP/2.0 通过多路复用技术，在一个连接上同时传输多个请求和响应。每个请求和响应被分割成多个帧，这些帧可以乱序发送，然后根据帧首部的流标识符重新组装。</p> <p><img src="./img/http2_multiplex_2.png" alt="HTTP/2.0 多路复用" title="HTTP/2.0 多路复用"></p> <h4 id="33-请求优先级">3.3 请求优先级</h4> <p>HTTP/2.0 允许为每个请求设置优先级，确保重要的请求优先得到处理。例如，浏览器加载网页时，可以优先加载 HTML 内容，然后再加载静态资源文件。</p> <h4 id="34-首部压缩">3.4 首部压缩</h4> <p>HTTP/2.0 使用 HPACK 算法对 HTTP 头部进行压缩，减少了头部的大小和数量，提高了传输效率。</p> <p><img src="./img/header_compress.jpg" alt="首部压缩" title="首部压缩"></p> <h4 id="35-服务器推送">3.5 服务器推送</h4> <p>HTTP/2.0 支持服务器推送（Server Push），服务器可以在客户端请求之前主动推送资源，提高页面加载速度。</p> <p><img src="./img/server_Push.png" alt="服务器推送" title="服务器推送"></p> <h3 id="4-http20-的实现与安全性">4. HTTP/2.0 的实现与安全性</h3> <h4 id="41-https-加密流程">4.1 HTTPS 加密流程</h4> <p>HTTP/2.0 通常与 HTTPS 一起使用，通过 SSL/TLS 协议对数据进行加密传输。以下是 HTTPS 加密流程：</p> <ol> <li>客户端使用 HTTPS 的 URL 访问 Web 服务器，要求与 Web 服务器建立 SSL 连接。</li> <li>Web 服务器收到客户端请求后，将网站的公钥传送给客户端，私钥自己保存。</li> <li>客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥（会话密钥），然后利用网站的公钥将会话密钥加密，并传送给网站。</li> <li>Web 服务器利用自己的私钥解密出会话密钥。</li> <li>Web 服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。</li> </ol> <h4 id="42-重放与篡改">4.2 重放与篡改</h4> <ul> <li> <strong>重放攻击</strong>：黑客通过截取的包，重复发送多次，达到攻击服务端的目的。防御措施包括使用唯一的时间戳和随机数，做一个不可逆的签名来保证请求的唯一性。</li> <li> <strong>篡改攻击</strong>：黑客在数据传输过程中对数据进行修改。防御措施包括使用消息摘要（如 SHA-256）和数字签名技术，确保数据的完整性和真实性。</li> </ul> <h3 id="5-http11-与-http20-的区别">5. HTTP/1.1 与 HTTP/2.0 的区别</h3> <ol> <li> <strong>安全性</strong>：HTTP/1.1 是明文传输，HTTP/2.0 通过 SSL/TLS 加密传输，提供更高的安全性。</li> <li> <strong>连接复用</strong>：HTTP/1.1 每次请求都需要单独的连接，HTTP/2.0 通过多路复用在一个连接上同时传输多个请求和响应。</li> <li> <strong>队头阻塞</strong>：HTTP/1.1 存在队头阻塞问题，HTTP/2.0 通过多路复用解决了这个问题。</li> <li> <strong>首部压缩</strong>：HTTP/1.1 的头部信息冗余较多，HTTP/2.0 使用 HPACK 算法对头部进行压缩，减少了头部的大小和数量。</li> <li> <strong>服务器推送</strong>：HTTP/1.1 只能由客户端发起请求，HTTP/2.0 支持服务器推送，服务器可以在客户端请求之前主动推送资源。</li> </ol> <h3 id="6-由-http11-升级为-http20-的操作步骤">6. 由 HTTP/1.1 升级为 HTTP/2.0 的操作步骤</h3> <ol> <li> <strong>检查服务器支持</strong>：确保服务器支持 HTTP/2.0 协议。</li> <li> <strong>申请数字证书</strong>：从权威 CA 申请数字证书。</li> <li> <strong>配置服务器</strong>：在服务器上安装和配置数字证书，并启用 HTTP/2.0 支持。</li> <li> <strong>修改网站链接</strong>：将网站的所有 HTTP 链接修改为 HTTPS 链接。</li> <li> <strong>重定向</strong>：设置 HTTP 到 HTTPS 的重定向，确保所有访问都使用 HTTPS。</li> <li> <strong>测试</strong>：测试网站的 HTTP/2.0 连接，确保没有安全漏洞。</li> </ol> <h3 id="7-参考链接">7. 参考链接</h3> <ul> <li><a href="https://snailclimb.gitee.io/javaguide/#/./docs/cs-basics/network/http&amp;https" rel="external nofollow noopener" target="_blank">HTTP vs HTTPS</a></li> <li><a href="https://www.zhihu.com/question/34074946/answer/108588042" rel="external nofollow noopener" target="_blank">HTTP/2.0 相比1.0有哪些重大改进？</a></li> <li><a href="https://juejin.im/post/5a4dfb2ef265da43305ee2d0" rel="external nofollow noopener" target="_blank">HTTP—HTTP2.0新特性</a></li> <li><a href="https://blog.csdn.net/yishouwangnian/article/details/52788626?utm_source=blogxgwz8" rel="external nofollow noopener" target="_blank">浏览器允许的并发请求资源数是有限制的-分析</a></li> </ul> <p>通过理解 HTTP/2.0 的基本概念、实现过程和安全性措施，可以更好地设计和管理高效、安全的网络通信。</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_%E6%80%BB%E7%BA%BF.md/">总线</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_coroutine.md/">coroutine了解</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_process.md/">进程</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_io.md/">磁盘结构</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/1_threads.md/">c++的多线程</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>