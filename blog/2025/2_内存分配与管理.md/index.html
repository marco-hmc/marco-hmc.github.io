<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 内存分配管理 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/2_%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E7%AE%A1%E7%90%86.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">内存分配管理</h1> <p class="post-meta"> Created on April 29, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/%E5%86%85%E5%AD%98"> <i class="fa-solid fa-hashtag fa-sm"></i> 内存</a>   ·   <a href="/blog/category/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F"> <i class="fa-solid fa-tag fa-sm"></i> 计算机系统</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="内存分配管理">内存分配管理</h2> <p>广义的内存分配涵盖程序运行的整个过程，包括程序启动时的内存装入，而狭义的内存分配主要指程序运行中动态申请内存的操作，如使用 new 或 malloc 等函数进行的堆内存分配。而内存分配管理一般讨论的都是程序在运行中动态申请内存。</p> <p>那么栈上变量的申请和释放不属于内存分配的内容吗？ 是的。因为栈空间通常在进程创建时确定，局部变量的分配和释放通过栈指针的移动在预分配的栈空间内进行，不会改变栈空间的总大小。一般而言，在 Windows 中，默认的栈大小通常是 1MB，但可以通过编译器或链接器的设置以及使用 Windows API 进行调整；在 Linux 中，通过 ulimit -s 命令可以查看和设置栈的大小，默认一般是 8MB。</p> <p>那对于动态内存的管理，需要考虑的内容是什么呢？</p> <ul> <li> <strong>逻辑地址和物理地址的转换</strong>： <ul> <li>程序使用逻辑地址是为了方便编程和内存管理，逻辑地址在程序看来是连续的，这样可以简化程序设计。</li> <li>但在实际的物理内存中，通过内存管理单元（MMU）和操作系统的内存管理机制，如分页或分段存储，将逻辑地址转换为物理地址。</li> <li>在分页存储中，逻辑地址分为页号和页内偏移量，操作系统通过页表将页号映射为页框号（物理页号），再结合页内偏移量得到物理地址。例如，假设页面大小为 4KB，一个逻辑地址 <code class="language-plaintext highlighter-rouge">0x12345</code> 会被拆分为页号和页内偏移量，根据页表找到对应的页框号，最终得到物理地址。</li> </ul> </li> <li> <strong>内存连续性的考虑</strong>： <ul> <li>对于某些数据结构和算法，连续的内存分配是有益的，例如数组和向量。连续的内存可以利用 CPU 的缓存预取机制，提高访问效率。</li> <li>然而，实现完全连续的内存分配可能是困难的，特别是在多进程和多任务环境下。不同的内存分配算法和管理方式会影响内存的连续性。</li> <li>对于连续内存分配的需求，可以使用一些优化的内存分配算法，如首次适应、最佳适应、最坏适应等，尽量将相邻的空闲内存分配给同一进程，但这可能会导致外部碎片的产生。</li> </ul> </li> <li> <strong>内存释放后的再利用</strong>： <ul> <li>当内存被释放时，无论是堆内存还是动态分区分配中的内存，都需要回收，以便后续的内存分配可以使用。</li> <li>在堆内存管理中，操作系统或运行时环境会使用空闲链表或其他数据结构来记录释放的内存块。例如，使用伙伴系统或边界标记法来管理释放的内存块，以便后续可以将其重新分配给其他需要的进程或程序部分。</li> <li>对于动态分区分配，当一个进程结束或释放内存时，释放的内存会变成空闲分区，需要将其与相邻的空闲分区合并，以减少外部碎片。可以使用紧凑技术将内存碎片合并为更大的可用内存块，但这可能会带来性能开销，因为涉及数据的移动。</li> </ul> </li> </ul> <p>内存分配需要平衡内存的连续性、碎片问题和地址转换等多个因素，同时要考虑不同操作系统的特性和硬件的性能影响，以确保内存资源的高效利用和程序的正常运行。</p> <h3 id="1-连续分配方式">1 连续分配方式</h3> <p>连续分配方式，即一个程序的所有内存空间都是连续的。然后进一步，可以有以下划分：</p> <h4 id="11-单一连续分配">1.1 单一连续分配</h4> <ul> <li> <strong>内存划分</strong>： <ul> <li>在单一连续分配方式中，内存被明确地划分为系统区和用户区。系统区一般位于内存的低地址部分，主要存储操作系统所需的各种数据，如内核代码、系统数据结构、设备驱动程序等；用户区则用于存储用户进程的相关数据。</li> <li>该方式下，内存中仅允许存在一道用户程序，且此用户程序独占整个用户区空间。</li> <li>例如，在早期的单用户、单任务操作系统中，如早期的 DOS 系统，采用这种简单的内存分配模式，因为当时的计算机资源有限，同时运行多个程序的需求不高。 <img src="imgs/image-8.png" alt="Alt text"> </li> </ul> </li> <li> <strong>优缺点</strong>： <ul> <li> <strong>优点</strong>： <ul> <li> <strong>实现简单</strong>：由于只涉及单一用户程序的内存分配，内存管理逻辑相对简单，易于实现和维护。</li> <li> <strong>无外部碎片</strong>：因为整个用户区被一个程序独占，不会出现多个小的、不连续的空闲内存块分散在各处的情况，所以不存在外部碎片。</li> <li> <strong>可采用覆盖技术扩充内存</strong>：当程序的内存需求超过用户区大小时，可使用覆盖技术，即把暂时不用的代码或数据暂存到外存，需要时再调入内存。</li> <li> <strong>不一定需要采取内存保护</strong>：由于只有一个用户程序，在一定程度上减少了不同程序间相互干扰的风险，所以对内存保护的需求相对不那么严格。</li> </ul> </li> <li> <strong>缺点</strong>： <ul> <li> <strong>只能用于单用户/单任务的操作系统中</strong>：这种方式限制了系统的并发能力，无法满足多用户或多任务的需求，不能充分利用系统资源。</li> <li> <strong>有内部碎片</strong>：由于用户区大小是固定的，当用户程序的实际大小小于用户区时，会产生内部碎片，即分配给用户程序的内存未被完全利用，造成内存浪费。</li> <li> <strong>存储器利用率极低</strong>：用户程序通常无法完全填满用户区，导致内存空间闲置，整体的存储资源利用率不高。</li> </ul> </li> </ul> </li> </ul> <h4 id="12-固定分区分配">1.2 固定分区分配</h4> <p>将整个用户空间划分为若干个固定大小（相等或不相等）的分区，每个分区仅装入一道作业，这是早期实现多道程序运行的一种简单内存管理方式。</p> <p><img src="imgs/image-9.png" alt="Alt text"></p> <ul> <li> <strong>分区大小相等</strong>： <ul> <li>当分区大小相等时，系统管理相对简单，但缺乏灵活性。这种方式适合在一台计算机需要控制多个相同对象的场景，例如多个相同的实时监控任务，每个任务所需的内存资源大致相同。</li> <li>例如，一个系统将用户区划分成多个 1MB 的分区，每个分区可以运行一个小型的监控程序，这些程序的内存需求相似。</li> </ul> </li> <li> <p><strong>分区大小不等</strong>：</p> <ul> <li>根据系统中常见作业的大小情况进行划分，增加了灵活性，能够更好地匹配不同大小的进程。</li> <li>例如，可划分出一些较小的分区用于运行小型的工具程序，同时划分几个较大的分区以容纳对内存需求较高的应用程序。</li> </ul> </li> <li>操作系统会构建一个分区说明表来管理分区的分配和回收操作。该表中的每个表项对应一个分区，通常按分区大小排序。表项包含的信息有分区的大小、起始地址以及状态（已分配或未分配）。</li> <li>假设分区说明表如下： | 分区大小 | 起始地址 | 状态 | | :–: | :–: | :–: | | 100KB | 100KB | 已分配 | | 200KB | 200KB | 未分配 | | 500KB | 400KB | 未分配 |</li> </ul> <p><img src="imgs/image-10.png" alt="Alt text"></p> <ul> <li> <strong>优缺点</strong>： <ul> <li> <strong>优点</strong>： <ul> <li> <strong>实现简单</strong>：内存分区的大小和位置相对固定，分配和回收操作易于管理，算法实现相对简单。</li> <li> <strong>无外部碎片</strong>：由于每个分区是一个完整的、独立的空间，不会产生外部碎片。</li> </ul> </li> <li> <strong>缺点</strong>： <ul> <li> <strong>当用户程序太大时</strong>：如果用户程序的内存需求超过最大分区的大小，可能无法找到合适的分区，只能采用覆盖技术，这会增加程序的复杂性，降低性能，因为程序需要不断地在内存和外存之间交换数据。</li> <li> <strong>会产生内部碎片</strong>：由于分区大小固定，当程序所需内存小于分配给它的分区大小时，会产生内部碎片，降低内存利用率。</li> </ul> </li> </ul> </li> </ul> <h4 id="13-动态分区分配">1.3 动态分区分配</h4> <p>动态分区分配，也称为可变分区分配，其特点是不会预先划分内存分区，而是根据进程的大小在进程装入内存时动态创建分区，使分区大小恰好符合进程的需求，因此系统分区的大小和数量是可变的。</p> <p><img src="imgs/image.png" alt="Alt text"></p> <h3 id="2-非连续分配管理方式">2 非连续分配管理方式</h3> <h4 id="21-分页存储">2.1 分页存储</h4> <h5 id="211-基本分页存储管理">2.1.1 基本分页存储管理</h5> <ul> <li> <p><strong>页面分配策略</strong></p> </li> <li>驻留集 <ul> <li>指请求分页存储管理中给进程分配的内存块的集合</li> </ul> </li> <li>页面分配/置换策略 <ul> <li>固定分配 VS 可变分配: 区别在于进程运行期间驻留集大小是否可变</li> <li>局部置换 VS 全局置换: 区别在于发生缺页时是否只能从进程自己的页面中选择一个换出</li> <li>固定分配局部置换: 进程运行前就分配一定数量物理块，缺页时只能换出进程自己的某一页</li> <li>可变分配全局置换: 只要缺页就分配新物理块，可能来自空闲物理块，也可能需换出别的进程页面</li> <li>可变分配局部置换: 频繁缺页的进程。多分配一些物理块;缺页率很低的进程，回收一些物理块。直到缺页率合适</li> </ul> </li> <li>何时调入页面 <ul> <li>预调页策略:一般用于进程运行前</li> <li>请求调页策略:进程运行时，发现缺页再调页</li> </ul> </li> <li>从何处调页 <ul> <li>对换区一采用连续存储方式，速度更快;文件区一一采用离散存储方式，速度更慢。</li> <li>对换区足够大:运行将数据从文件区复制到对换区，之后所有的页面调入/调出都是在内存与对换区之间进行</li> <li>对换区不够大: 不会修改的数据每次都从文件区调入;会修改的数据调出到对换区，需要时再从对换区调入</li> <li>UNIX 方式: 第一次使用的页面都从文件区调入;调出的页面都写回对换区，再次使用时从对换区调入</li> </ul> </li> <li>抖动(颠) 现参 <ul> <li>页面频繁换入换出的现象 主要原因是分配给进程的物理块不够</li> </ul> </li> <li>工作集 <ul> <li>在某段时间间隔里，进程实际访问页面的集合。驻留集大小一般不能小于工作集大小</li> </ul> </li> </ul> <h5 id="212-请求分页存储管理">2.1.2 请求分页存储管理</h5> <p>请求分页存储管理与基本分页存储管理的主要区别:</p> <p>请求调页:在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。 页面置换:若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p> <ul> <li>页表机制 <ul> <li>在基本分页的基础上增加了几个表项</li> <li>状态位: 表示页面是否已在内存中</li> <li>访问字段: 记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考</li> <li>修改位:表示页面调入内存后是否被修改过，只有修改过的页面才需在置换时写回外存</li> <li>外存地址: 页面在外存中存放的位置</li> </ul> </li> <li>缺页中断机构 <ul> <li>找到页表项后检查页面是否已在内存，若没在内存，产生缺页中断</li> <li>缺页中断处理中，需要将目标页面调入内存，有必要时还要换出页面</li> <li>缺页中断属于内中断，属于内中断中的”故障”，即可能被系统修复的异常</li> <li>一条指令在执行过程中可能产生多次缺页中断</li> </ul> </li> <li>地址变换机构 (重点关注与基本分页不同的地方) <ul> <li>找到页表项是需要检查页面是否在内存中</li> <li>若页面不再内存中，需要请求调页</li> <li>若内存空间不够，还需换出页面</li> <li>页面调入内存后，需要修改相应页表项</li> </ul> </li> </ul> <p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断一条指令在执行期间，可能产生多次缺页中断。(如:copy A to B，即将逻辑地址 A 中的数据复制到 逻辑地址 B，而 A/B 属于不同的页面，则有可能产生两次中断)</p> <p><img src="imgs/image-19.png" alt="Alt text"></p> <h5 id="213-页面置换算法">2.1.3 页面置换算法</h5> <ul> <li> <p>什么是分页存储 <img src="imgs/image-13.png" alt="Alt text"> 分页存储是一种内存管理技术，将内存空间分为大小相等的分区，每个分区称为一个”页框”（页框=页帧=内存块=物理块=物理页面）。每个页框有一个编号，即”页框号”，从 0 开始。</p> <ul> <li> <strong>页框</strong>：内存中的固定大小分区，例如每个分区 4KB。</li> <li> <strong>页</strong>：进程的逻辑地址空间也分为与页框大小相等的部分，每个部分称为一个”页”或”页面”。每个页面也有一个编号，即”页号”，从 0 开始。</li> </ul> <p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中，页面与页框有一一对应的关系。各个页面不必连续存放，可以放到不相邻的各个页框中。</p> <p><strong>注意</strong>：分页存储可能产生内部碎片，特别是进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则会产生过大的内部碎片造成浪费。</p> </li> <li> <p>页表 为了知道进程的每个页面在内存中存放的位置，操作系统为每个进程建立一张页表。页表通常存在于 PCB（进程控制块）中。 <img src="imgs/image-14.png" alt="Alt text"></p> </li> <li>分页-分页之后的地址转换 <img src="image.png" alt="Alt text"> <ul> <li> <strong>页号</strong>：逻辑地址 / 页面长度（取除法的整数部分）</li> <li> <strong>页内偏移量</strong>：逻辑地址 % 页面长度（取除法的余数部分）</li> </ul> </li> <li> <p>如何找到所有分区(页框，内存块)以及相关的页表 <img src="imgs/image-1.png" alt="Alt text"></p> </li> <li>单级页表的问题 <ul> <li>所有页表项必须连续存放，页表过大时需要很大的连续空间。</li> <li>在一段时间内并非所有页面都用得到，因此没必要让整个页表常驻内存。</li> </ul> </li> <li>什么是两级页表 <ul> <li>将长长的页表再分页。</li> <li> <p>逻辑地址结构：一级页号，二级页号，页内偏移量。 <strong>注意</strong>：要能根据逻辑地址位数、页面大小、页表项大小确定多级页表的逻辑地址结构。</p> </li> <li>页目录表</li> <li>外层页表</li> <li>顶级页表。</li> </ul> </li> <li>如何实现地址变换？ <ul> <li>按照地址结构将逻辑地址拆分成三部分</li> <li>从 PCB 中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置</li> <li>根据二级页号查表，找到最终想访问的内存块号</li> <li>结合页内偏移量得到物理地址</li> </ul> </li> <li>trivial <ul> <li>多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级</li> <li>多级页表的访存次数(假设没有快表机构) 级页表访问一个辑地址需要 N+1 次访存</li> </ul> </li> </ul> <p>将程序的逻辑地址空间划分为 <strong>固定大小的页 Page</strong>。也就是我们讲的虚拟内存划分。而物理内存也划分为 <strong>同样大小的页框(Page frame)</strong>。程序加载时，可将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分配。(这就区别了分区)。该方法 <strong>需要 CPU 的硬件支持，来实现逻辑地址和物理地址之间的映射</strong>。 在分页式存储管理方式中地址结构由两部分构成，前一部分是页号，后一部分是页内地址(位偏移量)</p> <p><img src="./img/virtual_addr_page.jpeg" alt="虚拟地址的构成" title="虚拟地址的构成"></p> <p>这个分页的方法解决了</p> <ul> <li>空间浪费碎片化问题: 由于虚拟内存空间和物理内存空间按照某种规定的大小进行分配(页 📃)，然后按照页进行内存分配，这就克服了外部碎片问题</li> <li>解决程序大小受限问题: 程序增长有限是因为一个程序需要全部加载到内存才能运行，因此解决的办法是使得一个程序无须全部加载就可以运行。使用分页也可以解决这个问题，只需将当前需要的页面放在内存里，其他暂时不用的页面放在磁盘上，这样一个程序同时占用内存和磁盘，其增长空间就大大增加了。而且，分页之后，如果一个程序需要更多的空间，给其分配一个新页就可以了(无须将程序倒出倒进，从而提高了空间的增长效率)</li> </ul> <p>⚠️ 但是这里有一个缺点: 要求程序全部装入内存，没有足够的内存，程序就不能执行<br></p> <p>虚拟地址的构成，对于 32 位寻址系统，如果页面大小是 4KB，则页面号占 20 位，页内偏移值占 12 位<br></p> <p><strong>分页系统的核心是页面的翻译，即从虚拟页面到物理页面的映射(Mapping)</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="err">虚拟页面非法、不在内存中或被保护</span><span class="p">)</span>
<span class="p">{</span>
    <span class="err">陷入到操作系统错误服务程序</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="err">将虚拟页面号转换为物理页面号</span>
    <span class="err">根据物理页面号产生最终物理地址</span>
<span class="p">}</span>
</code></pre></div></div> <p>这个翻译过程就是由内存管理单元(MMU)完成，MMU 接收 CPU 发出的虚拟地址，将其翻译为物理地址后发送给内存。内存管理单元按照该物理地址进行相应访问后读出或写入相关数据<br></p> <p><img src="./img/virtual_translate_addr.jpeg" alt="虚拟地址翻译过程" title="虚拟地址翻译过程"></p> <p>那么这个翻译是怎么实现的？查页表，对于每个程序，内存管理单元 MMU 都为其保存一个页表，该页表中存放的是虚拟页面到物理页面的映射。每当为一个虚拟页面 📃 寻找到一个物理页面之后，就在页表里增加一条记录来保留该映射关系。当然，随着虚拟页面进出物理内存，页表的内容也会不断更新变化。(逻辑页号，页内偏移地址-&gt;查进程页表，得物理页号-&gt;物理地址)。这个过程通常由处理器的硬件直接完成，不需要软件参与。通常，操作系统只需在进程切换时，把进程页表的首地址装入处理器特定的寄存器中即可。一般来说，页表存储在主存之中。这样处理器每访问一个在内存中的操作数，就要访问两次内存 <strong>1.用来查找页表将操作数的逻辑地址变换为物理地址；2.完成真正的读写操作</strong><br> 这样做时间上耗费严重。为缩短查找时间，可以将页表从内存装入 CPU 内部的 <strong>关联存储器</strong>中，实现按内容查找(hash 表的方法)。(任务都在 CPU 中完成，缩短时间)<br></p> <p><img src="./img/page_storage.jpeg" alt="页表" title="页表存储"></p> <p><strong>页表的根本功能是提供从虚拟页面到物理页面的映射</strong>。 因此，页表的记录 📝 条数与虚拟页面数相同，此外，内存管理单元(MMU)依赖于页表来进行一切与页面有关的管理活动，这些活动包括判断某一页面号是否在内存中，页面是否受到保护，页面是否非法空间等等。<br></p> <p>页表的一个记录所包括的内容</p> <p><img src="./img/record_page.jpeg" alt="页表记录内容举例" title="页表记录内容举例"></p> <ul> <li><strong>分页系统地址映射</strong></li> </ul> <p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p> <p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p> <p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p> <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" width="500"> </div> <p><br></p> <table> <thead> <tr> <th> </th> <th>算法规则</th> <th>优缺点</th> </tr> </thead> <tbody> <tr> <td>OPT</td> <td>优先淘汰最长时间内不会被访问的页面</td> <td>性能最好:缺页率最小，但无法实现</td> </tr> <tr> <td>FIFO</td> <td>优先淘汰最先进入内存的页面</td> <td>实现简单:但性能很差，可能出现 Belady 异常</td> </tr> <tr> <td>LRU</td> <td>优先淘汰最近最久没访问的页面</td> <td>性能很好:但需要硬件支持，算法开销大</td> </tr> <tr> <td>CLOCK (NRU)</td> <td>循环扫描各页面第一轮淘汰访问位=0 的，并将扫描过的页面访问位改为 1.若第一轮没选中，则进行第二轮扫描</td> <td>实现简单，算法开销小:但未考虑页面是否被修改过。</td> </tr> <tr> <td>改进型 CLOCK(改进型 NRU)</td> <td>若用(访问位，修改位)的形式表述，则第一轮:淘汰 (0，0)第二轮:淘汰 (0，1)，并将扫描过的页面访问位都置为 0 第三轮:淘汰 (0，0)第四轮:淘汰 (0，1)</td> <td>算法开销较小，性能也不错</td> </tr> </tbody> </table> <p><img src="imgs/image-20.png" alt="Alt text"></p> <p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p> <p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p> <p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p> <ul> <li>为提高内存利用率，解决内存供不应求的问题，更加合理的使用内存，人们创造了<strong>分页式内存抽象</strong>。同时有一个<strong>虚拟内存</strong>的概念，是指将内存中暂时不需要的部分写入硬盘，看上去硬盘扩展了内存的容量，所以叫做“虚拟”内存。使用虚拟内存，应用程序可以使用比实际物理内存更大的内存空间。可以认为这个更大的内存空间就在硬盘上，只有将某一部分需要被用到时，才被写入真实内存；当它暂时不再被用到时，又被写回硬盘。分页式内存管理将物理内存分为等大的小块，每块大小通常为1K、2K、4K等，称为<strong>页帧；</strong>逻辑内存（使用虚拟内存技术扩大的内存，可认为其位于硬盘上）也被分为等大的小块，称为<strong>页</strong>；且<strong>页和页帧</strong>的大小一定是一样的，它是写入真实内存和写回硬盘最小单位</li> <li>重要概念： <ul> <li>使用位：每个页帧都有一个使用位，记录此页帧是否被使用</li> <li>修改位（脏位）：每个页帧都有一个脏位，记录此页帧是否被更改。调出真实内存时，被更改过的页帧要写回硬盘，未被更改过的页帧直接扔掉即可，因为硬盘上此页帧的副本仍然有效</li> <li>逻辑地址：使用虚拟内存技术扩大后的内存的地址</li> <li>物理地址：真实内存的地址</li> </ul> </li> <li>当然，进程载入到真实内存才可以运行，而进程代码使用的是逻辑地址，所以牵扯到一个<strong>地址转换</strong>的问题，将逻辑地址转换为物理地址。逻辑地址可分为两段，前半段代表页号，后半段代表页内偏移，物理地址也可分为两段，前半段代表页帧号，后半段代表页内偏移。地址转换的方法即，将逻辑地址的页号对应为物理地址的页帧号（对应关系记录在一张表中，比如页号为5，对应到真实内存中页帧号为3），页内偏移不同变化（页和页帧的大小是一样的）</li> </ul> <p>假设某一时刻内存页帧已经被写满了，但这时又需要将一个页写到物理内存中，就需要将原本在物理内存中的某一页换出来。如果置换不当，就会导致刚刚被换出到硬盘的页又要被写回内存，减慢系统运行的速度。页面置换算法就是考虑将哪一页换出来以获得优良性能的方法。</p> <ul> <li><strong>页面置换算法 如果缺页中断</strong></li> </ul> <p>如果发生了缺页中断，就需要从磁盘上将需要的页面调入内存。如果内存没有多余的空间，就需要在现有的页面中选择一个页面进行替换。使用不同的页面置换算法，页面更换的顺序也会各不相同。如果挑选的页面是之后很快又要被访问的页面，那么系统将很快再次产生缺页中断，因为磁盘访问速度远远低于内存当问速度，缺页中断的代价是非常大的。因此，挑选哪个页面进行置换不是随随便便的事情，而是有要求的。<br></p> <ul> <li><strong>页面置换时挑选页面的目标主要在于降低随后发生缺页中断的次数或频率</strong></li> </ul> <p>挑选的页面应当时随后相当长时间内不会被访问的页面，最好是再也不会被访问的页面。如果可能，最好选择一个没有修改过的页面，这样替换时就无须将被替换页面的内容写回磁盘，从而进一步加快缺页中断的响应速度。<br></p> <ul> <li>页面置换算法 <h6 id="1-最佳">1. 最佳</h6> </li> </ul> <blockquote> <p>OPT, Optimal replacement algorithm</p> </blockquote> <p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p> <p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p> <p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
</code></pre></div></div> <p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p> <p>　　首先介绍最优算法，它需要知道以后要被用到的页，然后将不会被用到的页换出内存；如果所有页都会被用到，就把需要使用时间离现在最长的页换出，以尽量使不好的情况晚发生。这种方法能使系统获得最佳性能，但是，它是不可能实现的……因为当前无法获知以后哪些页要被用到。不过最优算法还是能够作为其他算法优秀程度的衡量</p> <h6 id="2-最近最久未使用">2. 最近最久未使用</h6> <blockquote> <p>LRU, Least Recently Used</p> </blockquote> <p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p> <p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p> <p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>4，7，0，7，1，0，1，2，1，2，6
</code></pre></div></div> <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/eb859228-c0f2-4bce-910d-d9f76929352b.png"> </div> <p><br></p> <p>基于过去的数据预测未来，如果一个页面被访问的频率低，那么以后很可能也用不到<br> LRU 算法的实现必须以某种方式记录每个页面被访问的次数，这是个相当大的工作量。最简单的方式就是在页表的记录项里增加一个计数域，一个页面被访问一次，这个计数器的值就增加 1。于是，当需要更换页面时，只需要找到计数域值最小的页面替换即可，该页面即是最近最少使用的页面。另一种简单实现方式就是用一个链表将所有页面链接起来，最近被使用的页面在链表头，最近未被使用的放在链表尾。在每次页面访问时对这个链表进行更新，使其保持最近被使用的页面在链表头。<a href="../Algorithm/singleLinkOper/singleLinkOper.cpp">LRU 缓存策略算法实现</a><br></p> <p>LRU 考虑 💭 周到，但是实现成本高(需要分辨出不同页面中哪个页面最近最少使用)，时间代价大，每次页面访问都需要更新记录。<br></p> <p>　　为获得对最优算法的模拟，提出了LRU算法。由于当前时间之后需要用到哪些页无法提前获知，于是记录当前时间之前页面的使用情况，认为之前使用过的页面以后还会被用到。在置换时，将最近使用最少的页面换出内存。此种方法的开销比较大</p> <h6 id="3-最近未使用">3. 最近未使用</h6> <blockquote> <p>NRU, Not Recently Used</p> </blockquote> <p>　　前面提到修改位和使用位，NRU算法利用这两个标志位将所有页帧分为4组：</p> <p>　　 第0组：修改位和使用位都为0；</p> <p>　　 第1组：修改位为0，使用位为1；</p> <p>　　 第2组：修改位为1，使用位为0；</p> <p>　　 第3组：修改位和使用位都为1。</p> <p>　　NRU算法从组数最小的一组中随机选择一个页面将其移出内存。可能有人会发现第2组这种情况根本不会出现，如果一个页帧被修改，其修改位会被置1，同时它也被使用了，其使用位也会被置1；即不会出现被修改但是没有被使用的情况。真实情况是，页帧的使用位会被定时清零，这样第3组经过一次清零就会变成第2组。这也符合“最近”未使用，即很久以前被使用的页帧被清零了，不在统计范围内，只要“最近”没有被使用，就很有可能被移出。</p> <p>　　NRU算法不是最好的，但是它使用起来开销很小，用较小的代价就得到了不错的效果，不失为一种不错的算法</p> <p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p> <ul> <li>R=0，M=0</li> <li>R=0，M=1</li> <li>R=1，M=0</li> <li>R=1，M=1</li> </ul> <p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p> <p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p> <p>基于程序访问的时空局域性。因为根据时空局域性原理，一个最近没有被访问的页面在随后的时间里也不太可能被访问，而 NRU 的实现方式就是利用页面的访问和修改位<br> 每个页面都有一个访问位和一个修改位，凡是对页面进行读写操作时，访问位被设置为 1。当进程对页面进行读写操作时，修改位设置为 1.根据这两个位的状态来对页面进行分类的话，可以分成以下四种页面类型</p> <p><img src="./img/amend_page.jpeg" alt="访问位与修改位" title="访问位与修改位的取值将页面分为4类"></p> <p>有了这个分类，NRU 算法就按照这四类页面的顺序依次寻找可以替换的页面 📃。如果所有页面皆被访问和修改过，那也只能从中替换掉一个页面，因此 NRU 算法总是会终结的。<br></p> <p>这种分类很笼统，带有随机性，所以可能替换的并不是最近没有被使用的页面</p> <h6 id="4-先进先出">4. 先进先出</h6> <blockquote> <p>FIFO, First In First Out</p> </blockquote> <p>选择换出的页面是最先进入的页面。</p> <p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p> <p>更换最早进入内存的页面，其实现机制是使用链表将所有在内存中的页面按照进入时间的早晚链接起来，然后每次置换链表头上的页面就行了，而新加进来的页面则挂在链表的末端<br></p> <p><img src="./img/page_link_algri.jpeg" alt="先进先出算法" title="先进先出置换"></p> <p>优点简单容易，缺点是如果最先加载进来的页面是经常被访问的页面，那么就可能造成被访问的页面 📃 替换到磁盘上，导致很快就需要再次发生缺页中断，从而降低效率。<br></p> <p>　　FIFO算法的思想很简单，就是置换出当前已经待在内存里时间最长的那个页。FIFO算法的运行速度很快，不需要考虑其他的因素，需要的开销很少。但是正是由于没有考虑页面的重要性的问题，FIFO算法很容易将重要的页换出内存</p> <h6 id="5-第二次机会算法">5. 第二次机会算法</h6> <p>　　为了避免FIFO算法将重要的页换出内存，Second Chance算法提供了一些改进。Second Chance算法在<strong>将页面换出内存前检查其使用位（使用位前文有介绍），如果其使用位为1，证明此页最近有被使用，猜测它还可能被使用，于是不把它置换出内存，但是把其使用位置为0，随后检查下一个页面，直到发现某页的使用位为0，将此页置换出内存</strong></p> <p>FIFO 只考虑 💭 进入内存的时间，不关心一个页面被访问的频率，从而有可能造成替换掉一个被经常访问的页面而造成效率低下。那么可以对 FIFO 进行改进。<br> <strong>在使用 FIFO 更换一个页面时，需要看一下该页面是否在最近被访问过，如果没有被访问过，则替换该页面。反之，如果最近被访问过(通过检查其访问位的取值)，则不替换该页面，而是将该页面挂到链表末端，并将该页面进入内存的时间设置为当前时间，并将其访问位清零。</strong> 这样，对于最近被访问的页面来说，相当于重生！<br></p> <p><img src="./img/second_chance.jpeg" alt="第二次机会算法" title="第二次机会"></p> <p>优点公平简单，容易实现。但是每次移动到链表末端需要耗费时间。此外，页面的访问位只在页面替换进行扫描时才可能清零，所以其时间局域性体现不好，访问位为 1 的页面可能很久以前被访问过了，时间分辨粒度太粗，从而影响页面替换的效果<br></p> <p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p> <p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p> <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"> </div> <p><br></p> <h6 id="6-时钟">6. 时钟</h6> <p>　　为了节约Second Chance算法一个接着一个检查使用位的开销，时钟轮转法又提出了改进。<strong>时钟轮转法将所有的页组成一个圆</strong>，圆心的指针指向下一个要被置换的页面，<strong>置换前同样检查使用位，如果使用位为1，同样将其使用位置为0，随后将顺指针旋转，检查下一个页面，直到发现某页的使用位为0，将此页置换出内存</strong>。很容易理解此算法为什么叫“时钟”轮转法</p> <p>时钟 ⏲️ 算法: 将页面排成一个时钟的形状，该时钟有一个针臂，每次需要更换页面时，我们从针臂所指的页面开始检查。如果当前页面的访问位为 0，即从上次检查到这次，该页面没有被访问过，将该页面替换。反之，将其访问位清 0⃣️，并顺时针移动指针到下一个页面。重复这个步骤，知道找到下一个访问位为 0⃣️ 的页面。<br></p> <p>例如下图所示的一个时钟，指针指向的页面是 F，因此第一个被考虑替换的页面是 F。如果页面 F 的访问位为 0，F 将被替换。如果 F 的访问位为 1，则 F 的访问位清零，指针移动到页面 G。</p> <p><img src="./img/access_time_clock.jpeg" alt="时钟算法" title="时钟转动"></p> <p><strong>时钟 ⏲️ 算法使用的是索引(整数指针)。</strong> 可以直接使用页表，使用页表的好处就是无需额外空间，更大的好处是页面的访问位会定期自动清零，这样将使得时钟算法的时间分辨力度较第二次机会算法高，从而取得更好的页面替换效果<br></p> <p>缺点(怎么还有缺点？！)，过于公平，没有考虑 💭 到不同页面调用频率的不同，有可能换出不应该或不能换出的页面，还可能造成无限循环 ♻️。<br></p> <blockquote> <p>Clock</p> </blockquote> <p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p> <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"> </div> <p><br></p> <h6 id="7-工作集">7. 工作集</h6> <p>工作集算法 由于不阔能精确地确定哪个页面最近最少使用，那就干脆不花这个力气，只维持少量的信息使得我们选出的替换页面不太可能是马上又会使用的页面即可 就是一个容器</p> <p>工作集信息就是少量的信息。什么意思呢？工作集概念来源于程序访问的时空局限性，即在一段时间内，程序访问的页面将局限在一组页面集合上。例如，最近 K 次访问均发生在某 m 个页面上，那么 m 就是参数为 k 时的工作集。我们用 w(k,t)来表示在时间 t 时 k 次访问所涉及的页面数量<br></p> <p><img src="./img/work_set.jpeg" alt="工作集与最近访问次数的关系" title="工作集与最近访问次数的关系"></p> <p>随着 K 的增长，w(k,t)的值也随之增长，但是当 K 增长到某个数值之后，w(k,t)的值将增长极其缓慢甚至接近停滞，并维持一段时间的稳定。<br></p> <p>如图，如果一个程序在内存里面的页面数与其工作集大小相等或者超过工作集，则该程序可在一段时间内不会发生缺页中断。如果其在内存的页面数小于工作集，则发生缺页中断的频率将增加，甚至发生内存抖动<br></p> <p>因此， <strong>工作集的算法目标是维持当前的工作集的页面在物理内存里面。每次页面更换时，寻找一个不属于当前工作集的页面替换即可。</strong><br> 这样我们再寻找页面时只需要将页面分离为两大类即可；当前工作集内页面和当前工作集外页面。如此，只需要找到一个非当前工作集的页面，将其替换即可。<br> 优点: 实现简单，只需要在页表的每个记录增加一个虚拟时间域即可。而且，这个时间域不是每次发生访问都需要更新，而是在需要更换页面时，页面更换算法对其进行修改，因此时间成本也不大。<br> 缺点: 每次扫描页面进行替换时，有可能需要扫描整个页表。然而并不是所有页面都在内存中，因此扫描过程中的一大部分时间将是无用功。另外，由于其数据结构是线性的，会造成每次都按同样的顺序进行扫描(不公平)</p> <p>工作集时钟算法 结合工作集和时钟算法 商业系统采用</p> <p>使用工作集算法的原理，但是将页面的扫描顺序按照时钟的形式组织起来。这样每次需要替换页面时，从指针指向的页面开始扫描，从而达到更加公平的状态。而且，按时钟组织得到页面只是在内存里面的页面，而在内存外的页面不会放在时钟圈(就减少无用功)，从而提高实现效率<br></p> <h4 id="22-分段存储">2.2 分段存储</h4> <h5 id="221-基本分段管理">2.2.1 基本分段管理</h5> <h5 id="222-段的共享与保护">2.2.2 段的共享与保护</h5> <p><img src="./img/segment_addr_transfer.png" alt="段式管理的地址变换" title="段式管理的地址变换"></p> <p>在段式管理系统中，整个进程的地址空间是二维的，即其逻辑地址由段号和段哪地址两部分组成。为了完成进程逻辑地址到物理地址的映射，处理器会查找内存中的段表，由段号得到段的首地址，加上段内地址，得到实际的物理地址。这个过程也是由处理器的硬件直接完成的，OS 只需在进程切换时，将进程段表的首地址装入处理器的特定寄存器当中。这个寄存器一般被称作 <strong>段表地址寄存器。</strong><br></p> <p>这样做的优点: 可以分别编写和编译源程序的一个文件，并且可以针对不同类型的段采取不同的保护，也可以按段为单位来进行共享。<br> 总的来说，段式存储管理的优点是: <strong>没有内部碎片，外部碎片可以通过内存紧缩来消除；</strong> 便于实现内存共享<br> 缺点与页式存储管理的缺点相同，进程必须全部装入内存。<br> 那有什么解决方法？分页呗，这问题不又回去了吗？不，这次的分页不是前面提到的直接程序进程进行分页，而是对程序里面的段进行分页，于是就形成了所谓的段页式内存管理模式。<br></p> <ul> <li><strong>分段式内存管理 分页系统无法解决的缺点:一个进程只能占有一个虚拟地址空间</strong></li> </ul> <p>在此种限制下，一个程序的大小至多只能和虚拟空间一样大，其所有内容都必须从这个共同的虚拟空间内分配。<br></p> <p>分段内存管理就是 <strong>将一个程序按照逻辑单元分成多个程序段，每一个段使用自己单独的虚拟地址空间。</strong> 对于编译器来说，我们可以给其 5 个段，占用 5 个虚拟地址空间</p> <p><img src="./img/segment_memory.jpeg" alt="分段设计" title="按逻辑单元分段"></p> <p>如此，一个段占用一个虚拟地址空间，不会发生空间增长时碰撞到另一个段的问题，从而避免因空间不够而造成编译失败的情况。如果某个数据结构对空间的需求超过整个虚拟空间所能提供的空间，则编译失败。不过这种概率非常非常低。<br></p> <p>就像每个进程拥有一个二维的地址空间。每个进程的每一段都可以不连续地存放在内存的不同分区中。所以因为直接是一个二维的地址空间，所以这些段根本不需要连续。而这个又能回到根本，动态分区管理方法<br></p> <ul> <li>为某个段分配物理内存时，可以采用首先适配方法，下次适配方法以及最佳适配法等</li> <li>在回收某个段所占用的空间时，要注意将回收的空间与其相邻的空间合并</li> <li>程序通过分段划分多个模块，如代码段、数据段、共享段</li> </ul> <blockquote> <p>如图，这样的段可以分别编写与编译 可以针对不同类型的段采取不同的保护 可以按段为单位来进行共享，包括通过动态链接进行代码共享</p> </blockquote> <ul> <li>** 段式管理的数据结构**</li> </ul> <p>为了实现段式管理，操作系统需要如下数据结构来实现进程的地址空间到物理内存空间的映射，并跟踪物理内存的使用情况，以便在装入新的段的时候，合理地分配内存空间。<br></p> <ul> <li>进程段表: 描述组成进程地址空间的各段，可以是指向系统段表中表项的索引。每段都有段基址(段内地址)</li> </ul> <p><img src="./img/segment_addr.png" alt="映射表" title="段映射表"></p> <ul> <li>系统段表:系统所有占用段(已经分配的段)</li> <li> <p>空闲段表:内存中多有空闲段，可以结合到系统段表中</p> </li> <li>什么分段存储 <ul> <li>将地址空间按程序自身的逻辑关系划分为若干个段，每段从 0 开始指址</li> <li>每个段在内存中占据连续空间，但各段之间可以不相邻</li> <li>逻辑地址结构: (段号，段内地址)</li> </ul> </li> <li>段表 <ul> <li>记录逻辑段到实际存储地址的映射关系</li> <li>梅个段对应一个段表项。各段表项长度相同，由段号&lt;隐含) /段长/基址组成</li> </ul> </li> <li>地址变换 <ul> <li> <ol> <li>由逻辑地址得到段号/段内地址</li> </ol> </li> <li> <ol> <li>段号与段表寄存器中的段长度比较，检查是否越界</li> </ol> </li> <li> <ol> <li>由段表始址/段号找到对应段表项</li> </ol> </li> <li> <ol> <li>根抓段表中记录的段长，检查段内地址是否越界</li> </ol> </li> <li> <ol> <li>由段表中的”基址+段内地址”得到最终的物理地划</li> </ol> </li> <li> <ol> <li>访问目标单元</li> </ol> </li> </ul> </li> <li> <p>分段 VS 分页</p> <ul> <li>分页对用户不可见，分段对用户可见</li> <li>分页的地址空间是一维的，分段的地址空间是二维的</li> <li>分段更容易实现信息的共享和保护 &lt;纯代码/可重入代码可以共享)</li> <li>分页(单级页表)/分段访问一个逻辑地址都需要两次访存，分段存储中也可以引入快表机构</li> </ul> </li> <li> <strong>分段和分页的优缺点</strong> <img src="imgs/image-2.png" alt="Alt text"> 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</li> </ul> <p>段是信息的逻辑单位。分页的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</p> <p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p> <p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。</p> <p>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</p> <p>分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码(不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的</p> <ul> <li> <p>访问一个逻辑地址需要几次访存？ 分页(单级页表):第一次访存<strong>查内存中的页表，第二次访存</strong>访问目标内存单元。总共两次访存 分段:第一次访存<strong>查内存中的段表，第二次访存</strong>访问目标内存单元。总共两次访存 与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。</p> </li> <li> <p><strong>分段</strong></p> </li> </ul> <p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p> <p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p> <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/22de0538-7c6e-4365-bd3b-8ce3c5900216.png"> </div> <p><br></p> <p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p> <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png"> </div> <p><br></p> <h5 id="214-缺页中断">2.1.4 缺页中断</h5> <ul> <li>在请求分页系统中，可以<strong>通过查询页表中的状态位来确定所要访问的页面是否存在于内存中</strong>。每当所要访问的页面不在内存时(缓存不命中)，会产生一次缺页中断，此时<strong>操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存</strong> </li> <li>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤 <ul> <li>保护CPU现场</li> <li>分析中断原因</li> <li>转入缺页中断处理程序进行处理</li> <li>恢复CPU现场，继续执行</li> </ul> </li> <li>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，<strong>与一般的中断存在区别</strong> <ul> <li><strong>在指令执行期间产生和处理缺页中断信号</strong></li> <li><strong>一条指令在执行期间，可能产生多次缺页中断</strong></li> <li><strong>缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令</strong></li> </ul> </li> <li>缺页中断就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问 当进程执行过程中发生缺页中断时，需要进行页面换入，步骤如下： <ol> <li>首先<strong>硬件会陷入内核，在堆栈中保存程序计数器。大多数机器将当前指令的各种状态信息保存在CPU中特殊的寄存器中</strong> </li> <li>启动一个汇编代码例程保存通用寄存器及其它易失性信息，以免被操作系统破坏。这个例程将操作系统作为一个函数来调用。（在页面换入换出的过程中可能会发生上下文换行，<strong>导致破坏当前程序计数器及通用寄存器中本进程的信息</strong>）</li> <li>当操作系统发现是一个页面中断时，查找出来发生页面中断的虚拟页面（进程地址空间中的页面）。这个虚拟页面的信息通常会保存在一个硬件寄存器中，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析该指令，通过分析找出发生页面中断的虚拟页面</li> <li><strong>检查虚拟地址的有效性及安全保护位。如果发生保护错误，则杀死该进程</strong></li> <li>操作系统查找一个<strong>空闲的页框</strong>(物理内存中的页面)，如果<strong>没有空闲页框则需要通过页面置换算法找到一个需要换出的页框</strong> </li> <li> <strong>如果找的页框中的内容被修改了，则需要将修改的内容保存到磁盘上</strong>，此时会引起一个写磁盘调用，发生上下文切换（在等待磁盘写的过程中让其它进程运行）（注：此时需要将页框置为忙状态，以防页框被其它进程抢占掉）</li> <li>页框干净后，操作系统根据虚拟地址对应磁盘上的位置，将保持在磁盘上的页面内容复制到“干净”的页框中，此时会引起一个读磁盘调用，发生上下文切换</li> <li>当磁盘中的页面内容全部装入页框后，向操作系统发送一个中断。操作系统更新内存中的页表项，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态</li> <li>恢复缺页中断发生前的状态，将程序指令器重新指向引起缺页中断的指令</li> <li>调度引起页面中断的进程，操作系统返回汇编代码例程</li> <li>汇编代码例程恢复现场，<strong>将之前保存在通用寄存器中的信息恢复</strong> </li> </ol> </li> <li>缺页中断的过程涉及了<strong>用户态和内核态之间的切换</strong>，<strong>虚拟地址和物理之间的转换</strong>（这个转换过程需要使用MMU和TLB）</li> </ul> <h4 id="23-段页式管理">2.3 段页式管理</h4> <h5 id="231-基本段页管理">2.3.1 基本段页管理</h5> <h5 id="232-地址变换过程">2.3.2 地址变换过程</h5> <p>为了解决直接操作内存带来的各种问题，引入了地址空间(Address Space)(其实就是让每个进程能够自己干自己的事情，不受干扰)，允许每个进程拥有自己的地址。所以同时在硬件上引入了两个寄存器，基址寄存器(base register)和界址寄存器(limit register)， <strong>第一个寄存器保存进程的开始地址，第二个寄存器保存上界，防止内存溢出。</strong></p> <p><img src="imgs/image-15.png" alt="Alt text"> <img src="imgs/image-16.png" alt="Alt text"> <img src="imgs/image-17.png" alt="Alt text"></p> <ul> <li>分段 + 分页 <ul> <li>将地址空间按照程序自身的逻辑关系划分为若干个段，在将各段分为大小相等的页面</li> <li>将内存空间分为与页面大小相等的一个个内存块，系统以块为单位为进程分配内存</li> <li>逻辑地址结构: (段号，页号，页内偏移量)</li> </ul> </li> <li>段表/页表 <ul> <li>每个段对应一个段表项。各段表项长度相同，由段号(隐含) /页表长度/页表存放地址 组成</li> <li>每个页对应一个页表项。各页表项长度相同，由页号(隐含) /页面存放的内存块号 组成</li> </ul> </li> <li>地址变换 <ul> <li>1.由逻辑地址得到段号/页号/页内偏移量</li> <li>2.段号与段表寄存器中的段长度比较，检查是否越界</li> <li>3.由段表始址/段号找到对应段表项</li> <li>4.根据段表中记录的页表长度，检查页号是否越界</li> <li>5.由段表中的页表地址/页号得到查询页表，找到相应页表项</li> <li>6 由页面存放的内存块号/页内偏移量得到最终的物理地址</li> <li>7.访问目标单元</li> </ul> </li> <li>访问一个逻辑地址所需访存次数 <ul> <li>第一次一一查段表/第二次一一查页表/第三次一一访问目标单元</li> <li>可引入快表机构，以段号和页号为关键字查询快表，即可直接找到最终的目标页面存放位置。引入快表后仅需一次访存</li> </ul> </li> <li><strong>段页式</strong></li> </ul> <p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p> <ul> <li> <p><strong>分页与分段的比较</strong></p> </li> <li> <p>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</p> </li> <li> <p>地址空间的维度：分页是一维地址空间，分段是二维的。</p> </li> <li> <p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p> </li> <li> <p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p> </li> </ul> <p>段页式管理就是将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组 🈴️ 起来使用。这样做的目的就是想同时获得分段和分页的好处，但又避免了单独分段和单独分页的缺陷。<br></p> <p>如果我们将每个段看做一个单独的程序，则逻辑分段就相当于同时加载多个程序。<br></p> <p><img src="./img/page_table_menory.jpeg" alt="段页式内存管理的实现" title="段页式内存管理的实现"></p> <p>二维数组即视感。<br> 如果需要，次级页表又可以再分为两个或者多个层次，形成层次更为丰富的段页式层次结构。<br> 最后来看看这个计算机内存管理发展历史<br></p> <p><img src="./img/process_of_memory_storage.jpeg" alt="内存管理发展"></p> <p>虚拟内存只是如何映射到物理内存的?了解分页内存管理吗?</p> <h3 id="3-内存紧凑">3. 内存紧凑</h3> <p>将各个占用分区向内存一端移动，然后将各个空闲分区合并成为一个空闲分区</p> <p>一种方案是通过 <strong>紧凑技术(Memory Compaction)</strong>解决，通过移动进程在内存中的地址，使得这些外部碎片空间被填满。还有一些讨巧的方案，比如内存整理软件，原理就是申请一块超大的内存，将所有进程置换出内存，然后再释放这块内存，从而使得重新加载进程，使得外部碎片被消除。这也是为什么运行完内存整理回狂读硬盘的原因。另外，使用紧凑技术回非常消耗 CPU 资源，一个 2G 的 CPU 每 10ns 可以处理 4bytes，因此多一个 2G 的内存进行一次紧凑可能需要好几秒的 CPU 时间。<br></p> <ul> <li>程序大小受限: 1. 指空间增长效率低下(由于磁盘操作耗时，交换出去再找一片更大的空间来增长程序空间的做法效率非常低) 2. 空间增长存在天花板限制(单一程序不能超过物理内存空间)</li> </ul> <p>上面的理论都是基于进程所占的内存空间是固定的这个假设，但实际情况下， <strong>进程往往回动态增长</strong>，因此创建进程时分配的内存就是这个问题了，如果分配多了，就会产生内部碎片，浪费了内存，而分配少了会造成内存溢出。那么怎么解决呢？ <br></p> <h5 id="动态分区-动态增长按程序初始要求分配或在执行过程中通过系统调用进行分配或改变分区大小">动态分区 动态增长，按程序初始要求分配或在执行过程中通过系统调用进行分配或改变分区大小</h5> <p>一个解决方案是在进程创建的时候，比进程实际需要的多分配一点内存空间用于进程的增长。</p> <ul> <li>一种是<strong>直接多分配一点内存空间用于进程在内存中的增长</strong> </li> <li>一种是直接分配多一点内存空间用于进程在内存中的增长</li> <li>一种是将增长区分为数据段和栈(用于存放返回地址和局部变量)</li> </ul> <p>当预留空间不够满足增长时，OS 首先会看相邻的内存是否空闲，如果空闲则自动分配， <strong>如果不空闲，就将整个进程移到足够容纳增长的空间内存中</strong>，如果不存在这样的内存空间，则会将闲置的进程置换出去(也就是交出资源)<br></p> <p>当允许进程动态增长时，OS 必须对内存进行更有效的管理，OS 使用如下两种方法之一得知内存的使用情况 1. 位图 2. 链表<br></p> <ul> <li>位图，将内存划分为多个大小相等的块，比如一个 32K 的内存 1K 一块就可以划分为 32 块，则需要 32 位(4 字节)来表示其使用情况，使用位图将已经使用的块标为 1，未使用的标为 0。</li> <li>链表，将内存按使用和未使用分为多个段进行链接 🔗<br> </li> </ul> <p><img src="./img/bitmap_memory.jpeg" alt="位图内存的使用情况" title="位图内存的使用情况"></p> <p><img src="./img/link_memory.jpeg" alt="链表表示内存的使用情况" title="链表表示内存的使用情况"></p> <p>使用链表中的 P 表示进程，从 0-2 是进程，H 表示空闲，3-4 表示是空闲<br></p> <p>位图表示内存简单明了，但 <strong>一个问题是当分配内存时必须在内存中搜索 🔍 大量的连续 0 的空间，这就十分消耗资源的操作</strong> 。相比之下，使用链表进行此操作将会更胜一筹。为什么呢？直接查链表这个段就可以了，而不用连续的 0。 更有一些 OS 会使用双向链表，因为当进程销毁时，邻接的往往是空内存或是另外的进程。使用双向链表使得链表之间的融合变得更加容易。<br></p> <p>利用链表管理内存的情况下，创建进程时分配什么样的空闲空间也是一个问题。当然，操作系统会有如下几个算法来对进程创建时的空间进行分配</p> <ul> <li>临近适应算法(Next fit) – 从当前位置开始，搜索第一个能满足进程要求的内存空间</li> <li>最佳适应算法(Best fit) – 搜索 🔍 整个链表，找到能满足进程要求最小内存的内存空间</li> <li>最大适应算法(Worst Fit) – 找到当前内存中最大的空闲空间</li> <li>首次适应算法(First fit) – 从链表的第一个开始，找到第一个能满足进程要求的内存空间</li> </ul> <h5 id="页式管理的数据结构-os-为进程中所有的页分配页框">页式管理的数据结构 OS 为进程中所有的页分配页框</h5> <p>在页式系统中进程建立时，OS 为进程中所有的页分配页框。当进程撤销时，收回所有分配给它的页框。在程序的运行期间，如果允许进程动态地申请空间，操作系统还要为进程申请的空间分配物理页框。OS 为了完成这些功能必须记录系统内存中实际的页框使用情况。操作系统还要在进程切换时，正确地切换两个不同的进程地址空间到物理内存空间的映射。 <strong>(保留进程的状态)</strong>。这就要求操作系统要记录每个进程页表的相关信息。为了上述功能的完成，一个页式系统中，一般要采用如下的数据结构<br></p> <p><strong>进程页表:</strong> 完成逻辑页号(本进程的地址空间)到物理页面号(实际内存空间，也叫块号)的映射(每个进程都有一个页表，描述该进程占用的物理页面以及逻辑排列顺序)</p> <p><img src="./img/process_page_table.png" alt="进程页面表" title="进程页面表"></p> <p><strong>物理页面表:</strong> 整个系统有一个物理页面表，描述物理内存空间的分配使用状况，其数据结构可以采用位图和空闲页链表</p> <p><img src="./img/bitmap_page.png" alt="物理页面表" title="物理页面表"></p> <p>如果该页面已经被分配，则对应比特位置为 1，否置为 0<br></p> <p><strong>请求表:</strong> 整个系统有一个请求表，描述系统内各个进程页表的位置和大小，用于地址转换也可以结合到各个进程 PCB(进程控制块)</p> <p><img src="./img/request_table.png" alt="请求表" title="请求表"></p> <h5 id="分页式内存管理的优缺点">分页式内存管理的优缺点</h5> <p>优点:</p> <ol> <li>分页系统不会产生外部碎片，一个进程占用的内存空间可以不是连续的，并且一个进程的虚拟页面在不需要的时候可以放在磁盘中。<br> </li> <li>分页系统可以共享小的地址，即页面共享。只需要在对应给定页面的页表项里做一个相关的记录即可<br> </li> </ol> <p>缺点:</p> <ol> <li>页表超大，占用了大量的内存空间<br> </li> </ol> <h5 id="缺页中断处理-cpu-发出的虚拟地址对应的页面不在物理内存就将产生一个缺页中断而缺页中断服务程序负责将需要的虚拟页面找到并加载到内存">缺页中断处理 CPU 发出的虚拟地址对应的页面不在物理内存，就将产生一个缺页中断，而缺页中断服务程序负责将需要的虚拟页面找到并加载到内存</h5> <p><img src="./img/short_page.jpeg" alt="缺页中断处理程序" title="缺页中断处理"></p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_%E6%80%BB%E7%BA%BF.md/">总线</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_coroutine.md/">coroutine了解</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_process.md/">进程</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_io.md/">磁盘结构</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/1_threads.md/">c++的多线程</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>