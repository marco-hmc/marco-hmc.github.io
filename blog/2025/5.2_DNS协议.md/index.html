<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> L5-DNS | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/5.2_DNS%E5%8D%8F%E8%AE%AE.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">L5-DNS</h1> <p class="post-meta"> Created on May 03, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/category/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"> <i class="fa-solid fa-tag fa-sm"></i> 计算机网络</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="l5-dns">L5-DNS</h2> <p>这引出了域名系统 (DNS)，它是一个分层和分散的命名系统，用于将人类可读的域名转换为 IP 地址。</p> <h2 id="dns-的工作原理">DNS 的工作原理</h2> <p><img src="https://raw.githubusercontent.com/karanpratapsingh/portfolio/master/public/static/courses/system-design/chapter-I/domain-name-system/how-dns-works.png" alt="how-dns-works"></p> <p>DNS 查询涉及以下八个步骤：</p> <ol> <li>客户端在浏览器中输入 <a href="http://example.com" rel="external nofollow noopener" target="_blank">example.com</a>，查询发送到互联网并由 DNS 解析器接收。</li> <li>解析器递归地查询 DNS 根名称服务器。</li> <li>根服务器响应解析器，提供顶级域 (TLD) 的地址。</li> <li>解析器然后向 <code class="language-plaintext highlighter-rouge">.com</code> TLD 发送请求。</li> <li>TLD 服务器响应域名的名称服务器 <a href="http://example.com" rel="external nofollow noopener" target="_blank">example.com</a> 的 IP 地址。</li> <li>最后，递归解析器向域名的名称服务器发送查询。</li> <li>域名的名称服务器将 <a href="http://example.com" rel="external nofollow noopener" target="_blank">example.com</a> 的 IP 地址返回给解析器。</li> <li>DNS 解析器然后将请求的域名的 IP 地址响应给浏览器。</li> </ol> <p>一旦 IP 地址被解析，客户端就可以向解析的 IP 地址请求内容。例如，解析的 IP 地址可能返回一个网页，在浏览器中呈现。</p> <h2 id="服务器类型">服务器类型</h2> <p>现在，让我们看看构成 DNS 基础设施的四个关键服务器组。</p> <h3 id="dns-解析器">DNS 解析器</h3> <p>DNS 解析器（也称为 DNS 递归解析器）是 DNS 查询的第一站。递归解析器充当客户端和 DNS 名称服务器之间的中介。在接收到来自 Web 客户端的 DNS 查询后，递归解析器将响应缓存数据，或者向根名称服务器发送请求，然后向 TLD 名称服务器发送请求，最后向权威名称服务器发送请求。在接收到包含请求的 IP 地址的权威名称服务器的响应后，递归解析器将响应发送给客户端。</p> <h3 id="dns-根服务器">DNS 根服务器</h3> <p>根服务器接受递归解析器的查询，该查询包含一个域名，根名称服务器通过根据该域名的扩展名（如 <code class="language-plaintext highlighter-rouge">.com</code>、<code class="language-plaintext highlighter-rouge">.net</code>、<code class="language-plaintext highlighter-rouge">.org</code> 等）将递归解析器指向 TLD 名称服务器来响应。根名称服务器由一个名为 <a href="https://www.icann.org" rel="external nofollow noopener" target="_blank">互联网名称与数字地址分配机构 (ICANN)</a> 的非营利组织监督。</p> <p>每个递归解析器都知道 13 个 DNS 根名称服务器。请注意，虽然有 13 个根名称服务器，但这并不意味着根名称服务器系统中只有 13 台机器。实际上有 13 种类型的根名称服务器，但每种类型在世界各地都有多个副本，这些副本使用 <a href="https://en.wikipedia.org/wiki/Anycast" rel="external nofollow noopener" target="_blank">Anycast 路由</a> 提供快速响应。</p> <h3 id="tld-名称服务器">TLD 名称服务器</h3> <p>TLD 名称服务器维护共享公共域扩展名（如 <code class="language-plaintext highlighter-rouge">.com</code>、<code class="language-plaintext highlighter-rouge">.net</code> 或 URL 中最后一个点之后的任何内容）的所有域名的信息。</p> <p>TLD 名称服务器的管理由 <a href="https://www.iana.org" rel="external nofollow noopener" target="_blank">互联网号码分配局 (IANA)</a> 处理，IANA 是 <a href="https://www.icann.org" rel="external nofollow noopener" target="_blank">ICANN</a> 的一个分支。IANA 将 TLD 服务器分为两大类：</p> <ul> <li> <strong>通用顶级域 (gTLD)</strong>：这些域包括 <code class="language-plaintext highlighter-rouge">.com</code>、<code class="language-plaintext highlighter-rouge">.org</code>、<code class="language-plaintext highlighter-rouge">.net</code>、<code class="language-plaintext highlighter-rouge">.edu</code> 和 <code class="language-plaintext highlighter-rouge">.gov</code>。</li> <li> <strong>国家代码顶级域 (ccTLD)</strong>：这些域特定于某个国家或州。例如 <code class="language-plaintext highlighter-rouge">.uk</code>、<code class="language-plaintext highlighter-rouge">.us</code>、<code class="language-plaintext highlighter-rouge">.ru</code> 和 <code class="language-plaintext highlighter-rouge">.jp</code>。</li> </ul> <h3 id="权威-dns-服务器">权威 DNS 服务器</h3> <p>权威名称服务器通常是解析器获取 IP 地址的最后一步。权威名称服务器包含其服务的域名（例如 <a href="http://google.com" rel="external nofollow noopener" target="_blank">google.com</a>）的特定信息，它可以向递归解析器提供 DNS A 记录中找到的服务器的 IP 地址，或者如果域名有 CNAME 记录（别名），它将向递归解析器提供别名域名，此时递归解析器将必须执行一个全新的 DNS 查询以从权威名称服务器获取记录（通常是包含 IP 地址的 A 记录）。如果找不到域名，则返回 NXDOMAIN 消息。</p> <h2 id="查询类型">查询类型</h2> <p>在 DNS 系统中有三种类型的查询：</p> <h3 id="递归查询">递归查询</h3> <p>在递归查询中，DNS 客户端要求 DNS 服务器（通常是 DNS 递归解析器）响应客户端请求的资源记录，或者如果解析器找不到记录，则返回错误消息。</p> <h3 id="迭代查询">迭代查询</h3> <p>在迭代查询中，DNS 客户端提供一个主机名，DNS 解析器返回它能找到的最佳答案。如果 DNS 解析器在其缓存中有相关的 DNS 记录，它将返回这些记录。如果没有，它将 DNS 客户端指向根服务器或另一个最接近所需 DNS 区域的权威名称服务器。然后 DNS 客户端必须直接对其被指向的 DNS 服务器重复查询。</p> <h3 id="非递归查询">非递归查询</h3> <p>非递归查询是 DNS 解析器已经知道答案的查询。它要么立即返回 DNS 记录，因为它已经将其存储在本地缓存中，要么查询权威名称服务器，该服务器对记录具有权威性，这意味着它肯定持有该主机名的正确 IP。在这两种情况下，都不需要额外的查询轮次（如递归或迭代查询）。相反，立即向客户端返回响应。</p> <h2 id="记录类型">记录类型</h2> <p>DNS 记录（也称为区域文件）是存储在权威 DNS 服务器中的指令，提供有关域的信息，包括与该域关联的 IP 地址以及如何处理该域的请求。</p> <p>这些记录由一系列用称为 <em>DNS 语法</em> 的文本文件组成。DNS 语法只是用作命令的一串字符，告诉 DNS 服务器该做什么。所有 DNS 记录也有一个 <em>“TTL”</em>，表示生存时间，指示 DNS 服务器将多频繁刷新该记录。</p> <p>有更多的记录类型，但现在让我们看看一些最常用的类型：</p> <ul> <li> <strong>A（地址记录）</strong>：这是保存域名 IP 地址的记录。</li> <li> <strong>AAAA（IP 版本 6 地址记录）</strong>：包含域名的 IPv6 地址的记录（与保存 IPv4 地址的 A 记录相对）。</li> <li> <strong>CNAME（规范名称记录）</strong>：将一个域或子域转发到另一个域，不提供 IP 地址。</li> <li> <strong>MX（邮件交换记录）</strong>：将邮件定向到邮件服务器。</li> <li> <strong>TXT（文本记录）</strong>：此记录允许管理员在记录中存储文本注释。这些记录通常用于电子邮件安全。</li> <li> <strong>NS（名称服务器记录）</strong>：存储 DNS 条目的名称服务器。</li> <li> <strong>SOA（起始授权机构）</strong>：存储有关域的管理员信息。</li> <li> <strong>SRV（服务位置记录）</strong>：指定特定服务的端口。</li> <li> <strong>PTR（反向查找指针记录）</strong>：在反向查找中提供域名。</li> <li> <strong>CERT（证书记录）</strong>：存储公钥证书。</li> </ul> <h2 id="子域">子域</h2> <p>子域是主域名的附加部分。它通常用于逻辑上将网站分成部分。我们可以在主域上创建多个子域或子域。</p> <p>例如，<code class="language-plaintext highlighter-rouge">blog.example.com</code> 中，<a href="command:_github.copilot.openSymbolFromReferences?%5B%22%22%2C%5B%7B%22uri%22%3A%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fhome%2Fmarco%2FgitRepo%2FcodeRepo%2F1_notes%2F1_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Fdns.md%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%22pos%22%3A%7B%22line%22%3A87%2C%22character%22%3A14%7D%7D%5D%2C%2271b86899-7f23-4392-9303-dc0f20f76080%22%5D" title="Go to definition"><code class="language-plaintext highlighter-rouge">blog</code></a> 是子域，<a href="command:_github.copilot.openSymbolFromReferences?%5B%22%22%2C%5B%7B%22uri%22%3A%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fhome%2Fmarco%2FgitRepo%2FcodeRepo%2F1_notes%2F1_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Fdns.md%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%22pos%22%3A%7B%22line%22%3A10%2C%22character%22%3A19%7D%7D%5D%2C%2271b86899-7f23-4392-9303-dc0f20f76080%22%5D" title="Go to definition"><code class="language-plaintext highlighter-rouge">example</code></a> 是主域，<code class="language-plaintext highlighter-rouge">.com</code> 是顶级域 (TLD)。类似的例子有 <code class="language-plaintext highlighter-rouge">support.example.com</code> 或 <code class="language-plaintext highlighter-rouge">careers.example.com</code>。</p> <h2 id="dns-区域">DNS 区域</h2> <p>DNS 区域是域名空间的一个独立部分，委托给一个法律实体，如个人、组织或公司，负责维护 DNS 区域。DNS 区域也是一个管理功能，允许对 DNS 组件进行细粒度控制，如权威名称服务器。</p> <h2 id="dns-缓存">DNS 缓存</h2> <p>DNS 缓存（有时称为 DNS 解析器缓存）是由计算机操作系统维护的一个临时数据库，包含所有最近访问和尝试访问的网站和其他互联网域的记录。换句话说，DNS 缓存只是我们计算机最近 DNS 查询的记忆，当它试图加载网站时可以快速参考。</p> <p>域名系统在每个 DNS 记录上实现了生存时间 (TTL)。TTL 指定记录可以被 DNS 客户端或服务器缓存的秒数。当记录存储在缓存中时，任何 TTL 值也会被存储。服务器继续更新缓存中存储的记录的 TTL，每秒倒计时。当它达到零时，记录将从缓存中删除或清除。此时，如果收到该记录的查询，DNS 服务器必须开始解析过程。</p> <h2 id="反向-dns">反向 DNS</h2> <p>反向 DNS 查找是一个 DNS 查询，用于查找与给定 IP 地址关联的域名。这实现了与更常用的正向 DNS 查找相反的功能，其中查询 DNS 系统以返回 IP 地址。反向解析 IP 地址的过程使用 PTR 记录。如果服务器没有 PTR 记录，它无法解析反向查找。</p> <p>反向查找通常由电子邮件服务器使用。电子邮件服务器检查电子邮件消息是否来自有效服务器，然后再将其带入网络。许多电子邮件服务器会拒绝来自不支持反向查找的服务器或来自极不可能合法的服务器的消息。</p> <p><em>注意：反向 DNS 查找并不是普遍采用的，因为它们对互联网的正常功能并不是至关重要的。</em></p> <h2 id="示例">示例</h2> <p>以下是一些广泛使用的托管 DNS 解决方案：</p> <ul> <li><a href="https://aws.amazon.com/route53" rel="external nofollow noopener" target="_blank">Route53</a></li> <li><a href="https://www.cloudflare.com/dns" rel="external nofollow noopener" target="_blank">Cloudflare DNS</a></li> <li><a href="https://cloud.google.com/dns" rel="external nofollow noopener" target="_blank">Google Cloud DNS</a></li> <li><a href="https://azure.microsoft.com/en-in/services/dns" rel="external nofollow noopener" target="_blank">Azure DNS</a></li> <li><a href="https://ns1.com/products/managed-dns" rel="external nofollow noopener" target="_blank">NS1</a></li> </ul> <h2 id="53dns">（5.3）DNS</h2> <p>到 HTTPDNS 一步一步优化 DNS 到 HTTPDNS，从静态的缓存策略，到动态缓存策略。<br></p> <p>DNS 解析有两种方式:递归查询和迭代查询</p> <ul> <li>递归查询 用户先向本地域名服务器查询,如果本地域名服务器的缓存没有 IP 地址映射记录,就向根域名服务器查询,根域名服务器就会向顶级域名服务器查询,顶级域名服务器向权限域名服务器查询,查到结果后依次返回.</li> <li>迭代查询 用户向本地域名服务器查询,如果没有缓存,本地域名服务器会向根域名服务器查询,根域名服务器返回顶级域名服务器的地址,本地域名服务器再向顶级域名服务器查询,得到权限域名服务器的地址,本地域名服务器再向权限域名服务器查询得到结果</li> </ul> <h3 id="dns-网络世界的地址薄-它是一个黄页">DNS 网络世界的地址薄 它是一个黄页</h3> <p>DNS(Domain Name System)，使用 dig 命令，重现 DNS 查询的过程</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>transCheungdeMacBook-Pro:Desktop transcheung$ dig baidu.com

; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; baidu.com
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 8291
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 5, ADDITIONAL: 5

;; QUESTION SECTION:
;baidu.com.			IN	A

;; ANSWER SECTION:
baidu.com.		193	IN	A	123.125.115.110
baidu.com.		193	IN	A	220.181.57.216

;; AUTHORITY SECTION:
baidu.com.		6764	IN	NS	ns3.baidu.com.
baidu.com.		6764	IN	NS	ns7.baidu.com.
baidu.com.		6764	IN	NS	ns4.baidu.com.
baidu.com.		6764	IN	NS	ns2.baidu.com.
baidu.com.		6764	IN	NS	dns.baidu.com.

;; ADDITIONAL SECTION:
dns.baidu.com.		45730	IN	A	202.108.22.220
ns2.baidu.com.		45574	IN	A	220.181.37.10
ns3.baidu.com.		45810	IN	A	112.80.248.64
ns4.baidu.com.		46217	IN	A	14.215.178.80
ns7.baidu.com.		46309	IN	A	180.76.76.92

;; Query time: 15 msec
;; SERVER: 211.162.66.66#53(211.162.66.66)
;; WHEN: Fri Mar 01 23:16:44 CST 2019
;; MSG SIZE  rcvd: 229
</code></pre></div></div> <p>使用<code class="language-plaintext highlighter-rouge">+short</code>参数能够省略过程，直接检索出结果</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dig +short baidu.com
220.181.57.216
123.125.115.110
</code></pre></div></div> <h4 id="dns-服务器-对应的-ip-地址-对应域名">DNS 服务器 对应的 IP 地址-&gt;对应域名</h4> <p>DNS 在日常的生活中，每个人上网都要访问，但是同时，它出了故障，整个互联网都将瘫痪。另外，上网的人分布在世界各地，如果大家都去同一个地方访问同一台服务器，时延就会非常大。因而 <strong>DNS 服务器，一定要设置成高可用、高并发和分布式的</strong><br> 于是就有了这样的树状层次结构<br> <img src="./img/dns_tree.jpg" alt="dns_tree" title="DNS树状层次结构"></p> <ul> <li>根 DNS 服务器(.root): 返回顶级域 DNS 服务器的 IP 地址</li> <li>顶级域 DNS 服务器(.com,.net,.cn,.edu):返回权威 DNS 服务器的 IP 地址</li> <li>权威 DNS 服务器(.baidu,.alibaba,.taobao,.163.com,.google.cn,.csdn.net):返回相应主机的 IP 地址</li> <li>主机名一般为子域名称，例如https://map.baidu.com中的map,https://image.baidu.com中的image</li> </ul> <h4 id="dns-解析流程">DNS 解析流程</h4> <p>为了提高 DNS 的解析性能，很多网络都会就近部署 DNS 缓存服务器。<br></p> <p><img src="./img/DNS_decode.jpg" alt="DNS_decode" title="DNS解析流程"></p> <p>查找过程:本地 DNS 服务器 ➡️ 根域名服务器 ➡️ 顶级域名服务器 ➡️ 权威 DNS 服务器(我的域名我做主)➡️ 权威 DNS 服务器将对应的 IP 告诉本地 DNS➡️ 本地 DNS 将 IP 返回客户端 🔙<br></p> <h4 id="负载均衡">负载均衡</h4> <p><strong>DNS 递归查询过程</strong>。DNS 除了可以通过名称映射为 IP 地址，还可以做 <strong>负载均衡</strong>。为什么呢？以找 🚾 为例，他可能有很多地址，因为在全世界都有，如果一个人要去 🚾，可以就近找一家，如果大家都就近找一家 🚾，那么这就是负载均衡，如果都去同一家，就爆满 🚽<br> DNS 可以做 <strong>内部负载均衡</strong>，通过解析策略，如果一个应用访问一数据库，数据库部署多份，通过配置 DNS 解析，每次返回的 IP 不同，对应不同的数据库，就可以做到负载均衡。<br> DNS 可以做 <strong>外部负载均衡</strong>，为了保证高可用，往往部署多个机房，每个机房都有自己的 IP 地址，当用户访问某个域名的时候，IP 地址可以轮询访问多个数据中心，如果一个数据中心挂了，就删掉这个 IP 地址。</p> <h4 id="-dns-访问数据中心中对象存储上的静态资源">🌰 DNS 访问数据中心中对象存储上的静态资源</h4> <p><img src="./img/DNS_static_resource.jpg" alt="DNS静态资源访问" title="DNS访问数据中心静态资源"></p> <p>假设全国有多个数据中心，托管多个运营商，每个数据中心三个可用区(Available Zone)。对象存储通过跨可用区部署，实现高可用性。在每个数据中心中，都至少部署两个内部负载均衡器，内部负载均衡器后面对接多个对象存储的前置服务器(Proxy-server)。<br></p> <p>客户端访问一网址 ➡️ 访问本地 DNS 解析器 ➡️ 访问本地缓存(有就直接用)➡️(没有)请求本地 DNS 服务器 ➡️ 本地 DNS 缓存(有就返回，没有就访问根 DNS 服务器)➡️ 查找过程继续(上述)<br></p> <p>对于不需要做全局负载均衡的简单应用来讲，权威 DNS 服务器可以直接将域名解析为一个或多个 IP 地址，客户端通过简单的轮询，实现简单的负载均衡。<br></p> <p>而对于复杂的应用，尤其是跨地域跨运营商的大型应用，就需要更加复杂的 <strong>全局负载均衡机制</strong>，因而需要专门的设备或者服务器来做，这就是 <strong>全局负载均衡器(GSLB,Global Server Load Balance)</strong><br></p> <p>例如在 acompany.com 的 DNS 服务器中，一般是 <strong>通过配置 CNAME 的方式</strong>，给 object.acompany.com 起一个别名，例如 object.vip.acompany.com，然后告诉本地 DNS 服务器，让她请求 GSLB 解析域名，GSLB 就可以在解析这个域名的过程中，通过自己的策略实现负载均衡。<br></p> <p>图中有两层 GSLB，是因为分运营商和地域。希望不同的运营商的客户，可以访问相同运营商机房中的资源， <strong>这样不跨运营商访问，有利于提高吞吐量，减少时延</strong><br></p> <p>第一层 GSLB，通过查看请求它的本地 DNS 服务器所在的运营商，就知道用户所在的运营商。假设是移动，通过 CNAME 的方式，通过另一个别名 object.yd.acompany.com，告诉本地 DNS 服务器去请求第二层 GSLB。<br></p> <p>第二层 GSLB，通过查看请求它本地 DNS 服务器所在地址，就知道用户所在的地理位置，然后将距离用户位置比较近的 Region 里面，六个 <strong>内部负载均衡(SLB Server Load Balancer)</strong>的地址，返回给本地 DNS 服务器。<br></p> <p>本地 DNS 服务器将结果返回给本地 DNS 解析器 ➡️ 本地解析器将结果缓存后，返回给客户端 ➡️ 客户端开始访问属于相同运营商的距离较近的 Region1 中的对象存储。(客户端得到 6 个 IP 地址，可以通过负载均衡的方式，随机或者轮询选择一个可用区进行访问。)对象存储一般会有三个备份，从而可以实现对存储读写的负载均衡。<br></p> <h3 id="问题-question-域名越多越好吗">问题 question 域名越多越好吗？</h3> <p>并不是，域名多不一定能缓存方便，域名解析器更多才能让你的缓存散播更广。什么意思？缓存不一定是缓存在本地，要是在域名解析器中，解析出来的主机里的缓存，这样的缓存就更广，访问就更方便。<br></p> <h3 id="httpdns-更新-dns通过-http-协议">HTTPDNS 更新 DNS，通过 HTTP 协议</h3> <p>DNS 有两个功能，1⃣️ 根据名称查到具体地址 2⃣️ 针对多个地址做负载均衡<br></p> <ul> <li> <strong>DNS 存在域名缓存问题</strong>，每一次缓存都把结果缓存到自己本地，有人访问，直接返回缓存数据，这样陈年的缓存数据一直存放，要是 IP 地址变了，还是返回这个地址，缓存的数据不一样，这样用户就尴尬了。同时造成全局负载均衡失败，为啥，全局负载均衡是访问最近的地址，但是，因为本地缓存，可能绕远了路呀。</li> <li> <strong>域名转发问题</strong>，DNS 服务器转发给别的营运商，访问速度慢</li> <li> <strong>出口 NAT 问题</strong>，很多机房都会配置 NAT，网络地址转换，使得从这个网关出去的包，都换成新的 IP 地址，当然这个网关再将 IP 地址转换回去，对于访问 🆗，但是一旦做了地址转换，权威 DNS 服务器就没法通过这个地址，来判断客户到底是来自哪个运营商，而且极有可能因为转换过后的地址，误判运营商，导致跨运营商访问。</li> <li> <strong>域名更新问题</strong>，本地 DNS 服务器是由不同地区、不同运营商独立部署的。对域名解析缓存的处理上，实现策略也有区别，有的会偷懒， <strong>忽略域名解析结果的 TTL 时间限制</strong>，在权威 DNS 服务器解析变更的时候，解析结果在全网生效的周期非常漫长。但是有时候，在 DNS 的切换中，场景对生效时间要求比较高。例如双机房部署的时候，跨机房的负载均衡和容灾多使用 DNS 来做。当一个机房出问题之后，需要修改权威 DNS，将域名指向新的 IP 地址，但是如果更新太慢，那很多用户都会出现访问异常。</li> <li> <strong>解析延迟问题</strong>，递归遍历耗时多</li> </ul> <p><strong>HTTPDNS，不走传统路线(DNS 解析)，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，</strong> 分布在多个地点和多个运营商。当客户端需要 DNS 解析的时候， <strong>直接通过 HTTP 协议进行请求这个服务器集群，得到就近的地址。</strong><br></p> <p>这就相当于每家基于 HTTP 协议，自己实现自己的域名解析，自己做一个自己的地址薄，而不使用统一的地址薄。但是默认的域名解析都是走 DNS 的， <strong>因而使用 HTTPDNS 需要绕过默认的 DNS 路径。</strong> 就不能使用默认的客户端。使用 HTTPDNS。往往是手机应用，需要手机端嵌入支持 HTTPDNS 的客户端 SDk。<br></p> <h4 id="httpdns-工作模式">HTTPDNS 工作模式</h4> <p>在客户端 SDK 里动态请求服务端 ➡️ 获取 HTTPDNS 服务器的 IP 列表 ➡️ 缓存到本地。<br> 随着不断地解析域名，SDK 也会在本地缓存 DNS 域名解析的结果。<br></p> <p>当手机应用访问一个地址 ➡️ 本地缓存 ➡️HTTPDNS 服务器。 请求方式</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl http://106.2.xxx.xxx/d?dn=c.m.163.com

{"dns":[{"host":"c.m.163.com","ips":["223.252.199.12"],"ttl":300,"http2":0}],"client":{"ip":"106.2.81.50","line":269692944}}
</code></pre></div></div> <p>手机 📱 客户端自然之道手机是哪个运营商、哪个地址。由于是直接的 HTTP 通信，HTTPDNS 服务器能够准确知道这些信息，因而可以做精准的全局负载均衡<br></p> <p><img src="./img/phone_httpdns.jpg" alt="手机HTTPDNS" title="手机HTTPDNS服务器"></p> <h5 id="httpdns-解析速度和更新速度的平衡缓存设计-只能调度调度设计">HTTPDNS 解析速度和更新速度的平衡(缓存设计) 只能调度(调度设计)</h5> <p>1⃣️HTTPDNS 缓存设计<br> 解析过程通过 HTTP 请求。为了提高解析速度，本地也有缓存，缓存是在客户端 SDK 维护，过期时间以及更新时间，自己控制。<br> HTTPDNS 缓存设计策略，常用缓存设计模式(客户端，缓存，数据源)<br></p> <ul> <li>对于应用架构，应用-&gt;Tomcat，缓存-&gt;Redis，数据库-&gt;MySQL</li> <li>对于 HTTPDNS，手机客户端、DNS 缓存、HTTPDNS 服务器</li> </ul> <p>对于缓存的更新、过期、不一致，根据缓存模式来解决。<br> 例如 DNS 缓存在内存中，也可以持久化到存储上，从而 APP 重启之后，能够尽快从存储中加载上次累计的经常访问的网站解析结果，就不需要每次都全部解析一边，再变成缓存。这就像 Redis 是基于内存的缓存，但是同样提供持久化的能力，使得重启或者主备切换的时候，数据不会完全丢失。<br></p> <p>SDK 中的缓存会严格按照缓存过期时间，如果缓存没命中，或者已经过期，而且客户端不允许使用过期的记录，则会发起一次解析，保障记录是更新的。<br></p> <p>解析可以同步进行，也就是直接调用 HTTPDNS 的接口，返回最新的记录，更新缓存；也可以异步进行，添加一个解析任务到后台，由后台任务调用 HTTPDNS 的接口。<br></p> <p><strong>同步更新的优点是实时性好</strong>，缺点是如果有多个请求都发现过期的时候，同时会请求 HTTPDNS 多次，浪费时间。<br></p> <p>Cache-Aside 机制</p> <p><img src="./img/cache-aside.jpg" alt="cache同步更新" title="同步更新机制"></p> <p><strong>异步更新的优点是合并一次请求，减少 HTTPDNS 压力</strong>，同时可以在即将过期的时候，创建一个任务预加载，防止过期之后再刷新，称为 <strong>预加载</strong>。<br> 缺点是，还没请求，客户端开始用了。没有及时更新。<br> <img src="./img/async_cache.jpg" alt="cache-async" title="异步更新"></p> <p>2⃣️HTTPDNS 调度设计<br> 由于客户端嵌入了 SDK，因为就不会因为本地 DNS 的各种缓存、转发、NAT，让权威 DNS 服务器误会客户端所在的位置和运营商，而可以拿到第一手资料 💾。<br> 客户端 SDK 需要收集网络请求数据如错误率、请求时间等网络请求质量数据，并发送给统计后台，进行分析、聚合，以此查看不同的 IP 的服务质量。<br> 服务端，应用可以通过调用 HTTPDNS 的管理接口，配置不同服务质量的优先级、权重。HTTPDNS 会根据这些策略综合地理位置和路线状况算出一个排序，优先访问当前那些优质的、时延低的 IP 地址。<br> <img src="./img/httpdns_asignment.jpg" alt="httpdns_调度" title="调度设计"></p> <p>HTTPDNS 通过智能调度之后返回的结果，也会缓存在客户端。为了不让缓存使得调度失真，客户端可以根据不同的移动网络运营商 WIFI 的 SSID 来分维度缓存，不同的运营商或者 WIFI 解析出来的结果不同。<br></p> <h1 id="dns">DNS</h1> <ul> <li> <strong>DNS 占用 53 号端口,同时使用 TCP 和 UDP 协议</strong>.那么 DNS 在什么情况下使用这两种协议? <ul> <li>在两种情况下会使用 TCP 进行传输: <ul> <li>如果返回的响应超过的 512 字节(UDP 最大只支持 512 字节的数据)</li> <li>区域传送(区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据)</li> </ul> </li> <li>其他时候使用 UDP 协议.大多数情况下 DNS 使用 UDP 进行传输,这就<strong>要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性</strong> </li> </ul> </li> <li> <strong>DNS 区域传输的时候使用 TCP 协议</strong> <ul> <li>辅域名服务器会定时(一般 3 小时)向主域名服务器进行查询以便了解数据是否有变动.如有变动,会执行一次区域传送,进行数据同步.<strong>区域传送使用 TCP 而不是 UDP,因为数据同步传送的数据量比一个请求应答的数据量要多得多</strong> </li> <li>TCP 是一种可靠连接,保证了数据的准确性</li> </ul> </li> <li> <p><strong>域名解析时使用 UDP 协议:</strong></p> <ul> <li>客户端向 DNS 服务器查询域名,一般返回的内容都不超过 512 字节,用 UDP 传输即可.<strong>不用经过三次握手,这样 DNS 服务器负载更低,响应更快</strong>.理论上说,客户端也可以指定向 DNS 服务器查询时用 TCP,但事实上,很多 DNS 服务器进行配置的时候,仅支持 UDP 查询包</li> </ul> </li> <li> <strong>DNS 劫持</strong> <ul> <li>域名劫持是互联网攻击的一种方式,通过<strong>攻击域名解析服务器</strong>,或<strong>伪造域名解析服务器</strong>的方法,<strong>把目标网站域名解析到错误的 IP 地址</strong>从而实现用户无法访问目标网站的目的或者蓄意或恶意要求用户访问指定 IP 地址(网站)的目的</li> <li>常见三种情况 <ul> <li> <strong>错误域名解析到纠错导航页面</strong>,导航页面存在广告.判断方法:访问的域名是错误的,而且跳转的导航页面也是官方的,如电信的 114,联通移网域名纠错导航页面</li> <li> <strong>错误域名解析到非正常页面</strong>,对错误的域名解析到导航页的基础上,有一定几率解析到一些恶意站点,这些恶意站点通过判断你访问的目标 HOST/URI/ referrer 等来确定是否跳转广告页面,这种情况就有可能导致跳转广告页面(域名输错)或者访问页面被加广告(页面加载时有些元素的域名错误而触发)这种劫持会对用户访问的目标 HOST/URI/ referrer 等会进行判定来确定是否解析恶意站点地址,不易被发现</li> <li> <strong>直接将特点站点解析到恶意或者广告页面</strong>,这种情况比较恶劣,而且出现这种情况未必就是运营商所为,家里路由器被黑,或者系统被入侵,甚至运营商的某些节点被第三方恶意控制都有可能</li> </ul> </li> </ul> </li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_%E6%80%BB%E7%BA%BF.md/">总线</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_coroutine.md/">coroutine了解</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_process.md/">进程</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_io.md/">磁盘结构</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/1_threads.md/">c++的多线程</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>