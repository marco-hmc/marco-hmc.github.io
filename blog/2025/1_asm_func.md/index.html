<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> （二）汇编：C 函数调用方式与栈原理 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/toc-custom.css"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/1_asm_func.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-8"> <div class="post"> <header class="post-header"> <h1 class="post-title">（二）汇编：C 函数调用方式与栈原理</h1> <p class="post-meta"> Created on September 15, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/%E6%B1%87%E7%BC%96"> <i class="fa-solid fa-hashtag fa-sm"></i> 汇编</a>   ·   <a href="/blog/category/%E6%B1%87%E7%BC%96"> <i class="fa-solid fa-tag fa-sm"></i> 汇编</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="c-函数调用方式与栈原理">C 函数调用方式与栈原理</h2> <h3 id="1-函数调用的本质">1. 函数调用的本质</h3> <h4 id="11-cpu-视角下的函数概念">1.1 CPU 视角下的函数概念</h4> <p>从 CPU 的工作机制出发，CPU 的主要工作是从内存读取指令、进行计算，然后将结果写回内存。对于 CPU 而言，并不存在”函数”的抽象概念，它处理的只是一条条机器指令。</p> <p><strong>函数的本质</strong>：函数实际上是多个指令、函数参数以及局部变量的有机集合，是对以下要素的抽象：</p> <ul> <li> <strong>指令序列</strong>：一系列按特定逻辑组织的机器指令</li> <li> <strong>参数数据</strong>：函数执行所需的输入数据</li> <li> <strong>局部状态</strong>：函数内部的临时变量和中间结果</li> <li> <strong>返回机制</strong>：确保函数执行完毕后能返回到调用点</li> </ul> <h4 id="12-函数调用的核心问题">1.2 函数调用的核心问题</h4> <p>当程序执行函数调用时，需要解决以下关键问题：</p> <ol> <li> <strong>控制流转移</strong>：如何从当前执行位置跳转到被调用函数</li> <li> <strong>返回地址保存</strong>：如何记住调用完成后的返回位置</li> <li> <strong>参数传递</strong>：如何将调用者的数据传递给被调用函数</li> <li> <strong>局部状态管理</strong>：如何为函数分配独立的工作空间</li> <li> <strong>上下文保护</strong>：如何保护调用者的执行环境</li> </ol> <h3 id="2-栈帧结构与管理">2. 栈帧结构与管理</h3> <h4 id="21-典型栈帧结构">2.1 典型栈帧结构</h4> <p>栈帧是函数执行时在栈上分配的内存区域，包含函数运行所需的所有数据：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                  高地址
    +------------------------+
    | 调用者的局部变量        |
    +------------------------+
    | ...                   |
    +------------------------+
    | 参数n (最后一个参数)    | ← 参数按从右到左顺序压栈
    | 参数n-1               |
    | ...                   |
    | 参数2                 |
    | 参数1 (第一个参数)     |
    +------------------------+
    | 返回地址               | ← CALL指令自动压入
    +------------------------+
    | 调用者的EBP (old EBP)  | ← 函数序言保存
    +------------------------+ ← EBP指向此处
    | 局部变量1              |
    | 局部变量2              |
    | ...                   |
    | 局部变量n              |
    +------------------------+
    | 保存的寄存器           | ← 被调用者保存寄存器
    +------------------------+
    | 临时数据               | ← 中间计算结果
    +------------------------+ ← ESP指向此处
                  低地址
</code></pre></div></div> <ol> <li> <strong>关键指针与概念</strong> <ul> <li> <strong>函数参数入栈顺序</strong>：通常情况下，函数参数按照从右到左的顺序入栈。这种顺序保证了在函数调用时，参数能以特定的逻辑顺序被压入栈中，便于被调用函数正确获取参数值。</li> <li> <strong>函数局部变量在栈中的布局</strong>：局部变量在栈帧中按照声明顺序依次分配空间。这使得局部变量在栈中的存储位置与它们在代码中的声明顺序相关，有利于编译器准确地为变量分配和管理内存。</li> <li> <strong>栈帧指针（Frame Pointer, FP）</strong>：一般用寄存器（如 EBP）作为栈帧指针，它指向当前栈帧的起始位置。通过栈帧指针，函数可以方便地访问栈帧内的各个部分，如局部变量、保存的寄存器等。</li> <li> <strong>栈顶指针（Stack Pointer, SP）</strong>：栈顶指针始终指向当前栈顶的位置。它用于跟踪栈的使用情况，每当有数据压入栈或从栈弹出时，栈顶指针都会相应地移动。</li> </ul> </li> <li> <strong>栈帧创建与寄存器操作</strong> 通常，用一个名为<code class="language-plaintext highlighter-rouge">栈基址</code>（bp，常对应 EBP 寄存器）的寄存器来保存正在运行函数栈帧的<code class="language-plaintext highlighter-rouge">开始地址</code>。而<code class="language-plaintext highlighter-rouge">栈指针</code>（sp，常对应 ESP 寄存器）始终保存栈顶的地址，也就意味着它指向正在运行函数栈帧的<code class="language-plaintext highlighter-rouge">结束地址</code>。每次发生函数调用时，<code class="language-plaintext highlighter-rouge">栈基址</code>（bp）的值需要被修改为新栈帧的<code class="language-plaintext highlighter-rouge">开始地址</code>，这会导致其原始值被覆盖。为了保存和恢复<code class="language-plaintext highlighter-rouge">栈基址</code>，利用<code class="language-plaintext highlighter-rouge">寄存器的保存与恢复</code>机制，通过栈来实现。在函数调用开始时，<code class="language-plaintext highlighter-rouge">栈基址</code>和<code class="language-plaintext highlighter-rouge">栈指针</code>分别指向调用者栈帧的<code class="language-plaintext highlighter-rouge">开始地址</code>和<code class="language-plaintext highlighter-rouge">结束地址</code>。创建新栈帧时，首先将调用者栈帧的<code class="language-plaintext highlighter-rouge">开始地址</code>（即此时的<code class="language-plaintext highlighter-rouge">栈基址</code>）压入栈中保存。由于<code class="language-plaintext highlighter-rouge">栈基址</code>属于<code class="language-plaintext highlighter-rouge">被调用者保存</code>寄存器，所以它存储在被调用函数的栈帧中。随后，将<code class="language-plaintext highlighter-rouge">栈基址</code>（bp）的值修改为此时<code class="language-plaintext highlighter-rouge">栈指针</code>（sp）的值，使得二者指向同一位置。如果被调用函数还需要栈空间，便可以继续将<code class="language-plaintext highlighter-rouge">栈指针</code>（sp）向低地址方向移动来分配空间。最终，<code class="language-plaintext highlighter-rouge">栈基址</code>和<code class="language-plaintext highlighter-rouge">栈指针</code>又分别指向了<code class="language-plaintext highlighter-rouge">被调用者</code>栈帧的<code class="language-plaintext highlighter-rouge">开始地址</code>和<code class="language-plaintext highlighter-rouge">结束地址</code>。</li> <li> <strong>栈帧各部分详细说明</strong> - <strong>函数参数（arguments）</strong>：在<code class="language-plaintext highlighter-rouge">X64</code>架构中，函数参数的传递方式较为特殊。如果函数参数超过 6 个，前 6 个参数通过寄存器进行传递，其余参数则通过栈来传递。当参数少于等于 6 个或没有参数时，栈帧中的参数部分可以忽略。在需要通过栈传递参数时，<code class="language-plaintext highlighter-rouge">调用函数</code>需要先将参数压入自己的栈帧中，然后<code class="language-plaintext highlighter-rouge">被调用函数</code>从<code class="language-plaintext highlighter-rouge">调用函数</code>的栈帧中访问这些参数。因此，在栈帧结构图中，参数部分位于调用函数的栈帧内。 - <strong>返回地址（ret addr）</strong>：在将函数参数压入栈之后，需要把调用位置处的下一条指令地址压入栈中。这个地址被称为返回地址，其作用是确保被调用函数执行完毕后，程序能够回到原来的位置继续执行后续指令。 - <strong>保存的寄存器（saved regs）</strong>：这部分存放需要<code class="language-plaintext highlighter-rouge">被调用者</code>来保存的寄存器。例如，<code class="language-plaintext highlighter-rouge">旧的栈基址</code>（old bp）就保存在此区域。这样，在函数返回时，能够恢复调用者的寄存器状态，保证程序的连续性和正确性。 - <strong>局部变量（local vars）</strong>：该部分存储的是那些存储在栈中而非寄存器中的局部变量。如果函数没有局部变量，或者局部变量都存储在寄存器中，那么栈帧中的这部分可以忽略。</li> </ol> <p>函数的执行环境主要由以下四个部分构成：</p> <ol> <li> <strong>可执行的二进制代码</strong>：二进制代码由编译器生成，编译完成后，它会被固定存储在二进制文件的 <code class="language-plaintext highlighter-rouge">.text</code> 段中。在程序运行时，这部分代码会被加载到内存的只读代码区。正常情况下，这些代码是不可修改的，但在某些特殊场景下，可通过动态指令修改，不过这部分内容超出了当前讨论的范畴。程序编译后，代码段被加载至内存。在 x86 的 CPU 平台下，由 <strong>EIP 寄存器</strong> 指向下一条待执行指令的内存地址；而在 X64 平台，则是由 <strong>RIP 寄存器</strong> 来承担此功能，RIP 为 64 位，其本质与 EIP 类似。对于 <strong>协程</strong> 而言，需要手动记录并切换与 EIP/RIP 相关的内存地址，具体的实现方法将在后续详细阐述。</li> <li> <strong>运行所需寄存器</strong>：寄存器在汇编代码的学习与编写过程中至关重要。随着 CPU 的不断升级，除了普通寄存器外，还涌现出了各种专用寄存器和指令，例如 SSE 指令集所使用的 XMM 寄存器，以及 ARM 的 NEON 加速指令等。对于协程来说，主要关注以下三类寄存器： <ul> <li> <strong>ESP 和 EBP</strong>：这是与堆栈操作和记录紧密相关的寄存器。ESP（Extended Stack Pointer）指向栈顶，用于栈操作的定位；EBP（Extended Base Pointer）则常作为栈帧的基地址，方便对栈内数据进行访问。</li> <li> <strong>EAX、EBX、ECX 等通用寄存器</strong>：它们广泛应用于指令的具体运算过程，同时也承担着传参、返回值等功能。</li> <li> <strong>EIP</strong>：该寄存器负责控制指令的执行流程，决定下一条要执行的指令地址。在 X64 平台上，情况基本类似，只是寄存器的数量有所增加。协程在离开和恢复函数时，需要正确还原部分寄存器的值。根据 Intel i386 的 ABI 调用约定，像 EAX、ECX、EDX 这些寄存器的值在函数调用过程中允许被改变，而 EBX、ESI、EDI 等寄存器的值则需要调用者自行保存和恢复 。</li> </ul> </li> <li> <strong>运行所需栈内存</strong>：函数的运行依赖于栈内存。栈内存中包含了函数的参数、返回地址、需要保护的寄存器值以及局部变量等信息。函数栈帧的结构在各类资料中较为常见。参数的入栈方式并非都采用压栈操作，其具体方式取决于调用约定。对于协程而言，记录栈内存状态十分关键。例如，当函数局部变量被修改后，下次调用时应确保保持修改后的值。这主要涉及两大模式：<strong>有独立栈协程和无独立栈协程</strong>，其他变种暂不展开讨论。</li> <li> <strong>运行可能所需堆内存</strong>：在函数执行过程中，可能需要动态分配堆内存，比如通过 <code class="language-plaintext highlighter-rouge">new</code> 或 <code class="language-plaintext highlighter-rouge">malloc</code> 函数来实现。对于初步理解协程的概念来说，这部分内容可以暂时不做重点关注。</li> </ol> <h4 id="22-关键寄存器的作用">2.2 关键寄存器的作用</h4> <p><strong>栈指针寄存器（ESP/RSP）</strong>：</p> <ul> <li>始终指向当前栈顶位置</li> <li>随 PUSH/POP 操作自动调整</li> <li>用于栈空间的动态分配和释放</li> </ul> <p><strong>基址指针寄存器（EBP/RBP）</strong>：</p> <ul> <li>指向当前栈帧的固定基准点</li> <li>提供稳定的参数和局部变量访问基址</li> <li>通过偏移量访问栈帧内的数据</li> </ul> <p><strong>指令指针寄存器（EIP/RIP）</strong>：</p> <ul> <li>指向下一条待执行指令的地址</li> <li>函数调用时保存为返回地址</li> <li>控制程序执行流程</li> </ul> <h4 id="23-栈帧创建过程">2.3 栈帧创建过程</h4> <p><strong>函数调用序列</strong>：</p> <pre><code class="language-assembly">; 调用者操作
push param3          ; 压入参数（从右到左）
push param2
push param1
call function        ; 调用函数（自动压入返回地址）

; 被调用函数序言
push ebp             ; 保存调用者的栈基址
mov ebp, esp         ; 建立新的栈帧基址
sub esp, N           ; 分配局部变量空间
</code></pre> <p><strong>栈帧销毁序列</strong>：</p> <pre><code class="language-assembly">; 被调用函数尾声
mov esp, ebp         ; 释放局部变量空间
pop ebp              ; 恢复调用者的栈基址
ret                  ; 返回（自动弹出返回地址）

; 调用者清理（cdecl约定）
add esp, 12          ; 清理参数空间（3个参数 × 4字节）
</code></pre> <h4 id="24-销毁栈帧">2.4 销毁栈帧</h4> <p>当函数返回时，需要销毁之前为该函数创建的栈帧，以释放其所占用的空间。</p> <p>销毁栈帧时，首先将栈指针（sp）移动到当前栈基址（bp）的位置，此时栈指针和栈基址指向相同位置。</p> <ul> <li> <p><strong>栈变化过程</strong> 在这一步操作后，栈顶位置存放的正是创建栈帧时保存的调用者栈帧的栈基址。接下来，将该值从栈中弹出到栈基址（bp）寄存器中，此时栈结构发生相应变化，被调用者的栈帧空间已被释放，但函数返回的步骤尚未完成。</p> </li> <li> <p><strong>返回地址处理</strong> 此时，调用者的栈帧中仍保存着返回地址。为了恢复到调用函数前的执行位置，需要将返回地址从栈中弹出到程序计数器（PC）中。至此，函数完成返回，栈帧恢复到调用前的状态。</p> </li> </ul> <p>需要注意的是，在C/C++中，销毁栈帧并不会清空被销毁栈帧中的数据。这些数据在栈空间被重新分配之前，仍然保留在内存中，但从程序逻辑角度，已无法直接访问这些数据。</p> <h3 id="3-参数传递机制">3. 参数传递机制</h3> <h4 id="31-调用约定概览">3.1 调用约定概览</h4> <table> <thead> <tr> <th>调用约定</th> <th>参数传递方式</th> <th>栈清理责任</th> <th>用途场景</th> </tr> </thead> <tbody> <tr> <td><strong>cdecl</strong></td> <td>栈（右到左）</td> <td>调用者</td> <td>C 语言标准，支持可变参数</td> </tr> <tr> <td><strong>stdcall</strong></td> <td>栈（右到左）</td> <td>被调用者</td> <td>Windows API</td> </tr> <tr> <td><strong>fastcall</strong></td> <td>寄存器+栈</td> <td>被调用者</td> <td>高性能场景</td> </tr> <tr> <td><strong>thiscall</strong></td> <td>ECX+栈</td> <td>被调用者</td> <td>C++成员函数</td> </tr> </tbody> </table> <h4 id="32-不同架构的参数传递">3.2 不同架构的参数传递</h4> <p><strong>x86-32 架构（传统方式）</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 函数声明</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">);</span>

<span class="c1">// 调用时的汇编等效代码</span>
<span class="n">push</span> <span class="n">ecx</span>             <span class="c1">// 参数c</span>
<span class="n">push</span> <span class="n">ebx</span>             <span class="c1">// 参数b</span>
<span class="n">push</span> <span class="n">eax</span>             <span class="c1">// 参数a</span>
<span class="n">call</span> <span class="n">add</span>             <span class="c1">// 调用函数</span>
<span class="n">add</span> <span class="n">esp</span><span class="p">,</span> <span class="mi">12</span>          <span class="c1">// 清理栈空间（3×4字节）</span>
</code></pre></div></div> <p><strong>x86-64 架构（寄存器优先）</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 同样的函数调用</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">e</span><span class="p">,</span> <span class="kt">int</span> <span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">);</span>

<span class="c1">// x64参数传递方式</span>
<span class="c1">// 前6个参数：RDI, RSI, RDX, RCX, R8, R9</span>
<span class="c1">// 剩余参数通过栈传递</span>
</code></pre></div></div> <p><strong>ARM64 架构</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ARM64参数传递</span>
<span class="c1">// 前8个参数：X0-X7</span>
<span class="c1">// 剩余参数通过栈传递</span>
<span class="c1">// 返回值：X0</span>
</code></pre></div></div> <h4 id="33-复杂数据类型的传递">3.3 复杂数据类型的传递</h4> <p><strong>结构体传递</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 小结构体（≤8字节）：通过寄存器</span>
<span class="c1">// 大结构体（&gt;8字节）：通过隐藏指针参数</span>
<span class="n">Point</span> <span class="nf">createPoint</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
<span class="c1">// 可能转换为：</span>
<span class="kt">void</span> <span class="nf">createPoint</span><span class="p">(</span><span class="n">Point</span><span class="o">*</span> <span class="n">result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
</code></pre></div></div> <p><strong>浮点数传递</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">calculate</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">);</span>
<span class="c1">// x64：XMM0传递a，XMM1传递b</span>
<span class="c1">// 返回值通过XMM0</span>
</code></pre></div></div> <h3 id="4-控制流转移机制">4. 控制流转移机制</h3> <p>控制转移指的是在函数调用过程中，程序执行流程需从当前位置跳转至被调用函数的起始位置，待被调用函数执行完毕后，再返回到原位置继续执行。</p> <p>以如下C语言代码为例：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Q</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"this is Q."</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">P</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"readying to call Q."</span><span class="p">);</span>
    <span class="n">Q</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>假设代码的<code class="language-plaintext highlighter-rouge">行号</code>等同于<code class="language-plaintext highlighter-rouge">指令地址</code>，初始时，程序计数器（PC）的值为7，即函数<code class="language-plaintext highlighter-rouge">P</code>的起始指令地址。CPU按顺序执行，遇到函数调用时，会将PC修改为被调用函数<code class="language-plaintext highlighter-rouge">Q</code>的起始指令地址2。待<code class="language-plaintext highlighter-rouge">Q</code>函数执行完毕，最后再把PC修改为<code class="language-plaintext highlighter-rouge">P</code>中调用<code class="language-plaintext highlighter-rouge">Q</code>语句的下一条指令地址9，至此本次函数调用过程结束。</p> <p>在此过程中，函数<code class="language-plaintext highlighter-rouge">返回地址</code>的保存是个关键问题。当存在大量函数嵌套调用时，每次调用都会产生一个返回地址，且这些返回地址需与每次调用相关联。为满足这一需求，我们利用<code class="language-plaintext highlighter-rouge">栈</code>来存储函数的<code class="language-plaintext highlighter-rouge">返回地址</code>。每次发生函数调用时，将<code class="language-plaintext highlighter-rouge">返回地址</code>压入栈中，函数执行完毕后，再将其从栈中弹出至<code class="language-plaintext highlighter-rouge">PC</code>中。</p> <p>以下是一个C语言嵌套函数调用的示例，分别对其调用和返回过程进行详细说明：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">Q</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"this is Q.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">P</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"readying to call Q.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">Q</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"readying to call P.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">P</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li> <p>调用过程 依旧假设代码的<code class="language-plaintext highlighter-rouge">行号</code>为每条指令的地址。最初，PC为13，即<code class="language-plaintext highlighter-rouge">main</code>函数的第一行代码处。程序继续执行到14，发现此处调用了函数<code class="language-plaintext highlighter-rouge">P</code>，于是将PC设为<code class="language-plaintext highlighter-rouge">P</code>的起始指令地址7。随后，将调用<code class="language-plaintext highlighter-rouge">P</code>处的下一条指令地址15压入栈中。程序继续执行到<code class="language-plaintext highlighter-rouge">P</code>函数的第8行，又发现调用了函数<code class="language-plaintext highlighter-rouge">Q</code>，同样将PC设为<code class="language-plaintext highlighter-rouge">Q</code>的起始指令地址2，最后把调用<code class="language-plaintext highlighter-rouge">Q</code>处的下一条指令地址9压入栈中。此时，栈中存储了两个<code class="language-plaintext highlighter-rouge">返回地址</code>，分别为9和15。</p> </li> <li> <p>返回过程 函数<code class="language-plaintext highlighter-rouge">Q</code>执行完毕后，开始返回。返回时，会将栈中先前保存的<code class="language-plaintext highlighter-rouge">返回地址</code>弹出到PC中。此时栈顶的指令地址为9，将其从栈中弹出到PC中，函数便成功返回到<code class="language-plaintext highlighter-rouge">P</code>函数中。待<code class="language-plaintext highlighter-rouge">P</code>函数执行完成后，继续将栈顶的指令地址15弹出到PC中，最终函数返回到<code class="language-plaintext highlighter-rouge">main</code>函数，栈也恢复到调用前的状态。</p> </li> </ul> <h4 id="41-call-指令的本质">4.1 CALL 指令的本质</h4> <pre><code class="language-assembly">call target_function
; 等效于：
push eip             ; 保存下一条指令地址
jmp target_function  ; 跳转到目标函数
</code></pre> <h4 id="42-ret-指令的本质">4.2 RET 指令的本质</h4> <pre><code class="language-assembly">ret
; 等效于：
pop eip              ; 恢复返回地址到指令指针
; CPU自动跳转到该地址继续执行
</code></pre> <h4 id="43-嵌套调用的栈管理">4.3 嵌套调用的栈管理</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func_c</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"In function C</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">func_b</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"In function B</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">func_c</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Back to function B</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">func_a</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"In function A</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">func_b</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Back to function A</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">func_a</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>栈状态变化</strong>：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>调用func_a时：   调用func_b时：   调用func_c时：
+----------+    +----------+    +----------+
| main栈帧 |    | main栈帧 |    | main栈帧 |
+----------+    +----------+    +----------+
| ret_addr |    | ret_addr |    | ret_addr |
+----------+    +----------+    +----------+
| func_a帧 |    | func_a帧 |    | func_a帧 |
+----------+    +----------+    +----------+
              | ret_addr |    | ret_addr |
              +----------+    +----------+
              | func_b帧 |    | func_b帧 |
              +----------+    +----------+
                            | ret_addr |
                            +----------+
                            | func_c帧 |
                            +----------+
</code></pre></div></div> <h3 id="5-寄存器管理策略">5. 寄存器管理策略</h3> <h4 id="51-寄存器分类">5.1 寄存器分类</h4> <p>在程序执行过程中，常常需要对寄存器进行保存与恢复操作，以确保函数调用前后寄存器状态的一致性，避免数据丢失或混乱。以下面这段代码为例，展示了如何分别将<code class="language-plaintext highlighter-rouge">ax</code>、<code class="language-plaintext highlighter-rouge">bx</code>这两个寄存器的值保存在栈中：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">push</span><span class="p">(</span><span class="n">ax</span><span class="p">);</span>
<span class="n">push</span><span class="p">(</span><span class="n">bx</span><span class="p">);</span>
</code></pre></div></div> <ul> <li> <strong>保存过程</strong> 上述代码中，<code class="language-plaintext highlighter-rouge">push</code>指令会将寄存器<code class="language-plaintext highlighter-rouge">ax</code>的值压入栈中，栈指针会相应地调整以适应新压入的数据。接着，<code class="language-plaintext highlighter-rouge">bx</code>的值也被压入栈中，栈指针再次调整。此时，<code class="language-plaintext highlighter-rouge">ax</code>的值位于栈底，<code class="language-plaintext highlighter-rouge">bx</code>的值位于栈顶。</li> </ul> <p>当需要恢复寄存器的值时，代码如下：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pop</span><span class="p">(</span><span class="n">bx</span><span class="p">);</span>
<span class="n">pop</span><span class="p">(</span><span class="n">ax</span><span class="p">);</span>
</code></pre></div></div> <ul> <li> <strong>恢复过程</strong> <code class="language-plaintext highlighter-rouge">pop</code>指令的作用是从栈顶弹出数据，并将其赋值给指定的寄存器。这里要特别注意，出栈和入栈的顺序是相反的。因为在保存过程结束后，栈顶存储的是之前<code class="language-plaintext highlighter-rouge">bx</code>的值，所以在恢复时，首先要把栈顶的值弹出到<code class="language-plaintext highlighter-rouge">bx</code>寄存器中，然后再把栈顶此时的值（即之前<code class="language-plaintext highlighter-rouge">ax</code>的值）弹出到<code class="language-plaintext highlighter-rouge">ax</code>寄存器中。通过这样的操作，就能够将保存的值与对应的寄存器正确对应起来，恢复到函数调用前寄存器的状态。</li> </ul> <p>值得注意的是，并不是所有的寄存器都需要进行<code class="language-plaintext highlighter-rouge">保存与恢复</code>操作。根据相关约定，寄存器被划分为<code class="language-plaintext highlighter-rouge">被调用者保存</code>和<code class="language-plaintext highlighter-rouge">调用者保存</code>两类。这一划分有助于明确在函数调用过程中，哪一方（调用函数还是被调用函数）负责保存和恢复特定寄存器的值，从而更有效地管理寄存器资源，提高程序执行的效率和稳定性。具体哪些寄存器属于<code class="language-plaintext highlighter-rouge">被调用者保存</code>，哪些属于<code class="language-plaintext highlighter-rouge">调用者保存</code>，取决于不同的硬件架构和编程规范。例如，在x86架构下，某些通用寄存器（如<code class="language-plaintext highlighter-rouge">ebp</code>、<code class="language-plaintext highlighter-rouge">esi</code>、<code class="language-plaintext highlighter-rouge">edi</code>）通常被视为<code class="language-plaintext highlighter-rouge">被调用者保存</code>寄存器，被调用函数需要在使用前保存这些寄存器的值，并在返回前恢复；而像<code class="language-plaintext highlighter-rouge">eax</code>、<code class="language-plaintext highlighter-rouge">ebx</code>、<code class="language-plaintext highlighter-rouge">ecx</code>、<code class="language-plaintext highlighter-rouge">edx</code>等寄存器，在一些情况下可能被当作<code class="language-plaintext highlighter-rouge">调用者保存</code>寄存器，调用函数在调用其他函数前需自行保存其值，如果被调用函数修改了这些寄存器的值，调用函数需要自行恢复。这种约定在不同的编译器和操作系统中可能会有细微差别，但总体原则是一致的，都是为了保证函数调用过程中寄存器状态的正确维护。</p> <p><strong>调用者保存寄存器（Caller-saved）</strong>：</p> <ul> <li> <strong>EAX, ECX, EDX</strong>：调用函数前需要主动保存</li> <li>被调用函数可以自由修改</li> <li>适用于临时计算和返回值传递</li> </ul> <p><strong>被调用者保存寄存器（Callee-saved）</strong>：</p> <ul> <li> <strong>EBX, ESI, EDI, EBP</strong>：被调用函数必须保护</li> <li>函数返回时必须恢复原值</li> <li>适用于跨函数调用的持久数据</li> </ul> <h4 id="52-寄存器保存示例">5.2 寄存器保存示例</h4> <pre><code class="language-assembly">my_function:
    ; 函数序言 - 保护寄存器
    push ebp             ; 保存帧指针
    push ebx             ; 保存被调用者保存寄存器
    push esi
    push edi

    mov ebp, esp         ; 建立栈帧
    sub esp, 16          ; 分配局部变量空间

    ; 函数体 - 可以自由使用所有寄存器
    mov eax, [ebp+8]     ; 获取参数
    mov ebx, eax         ; 使用EBX进行计算
    ; ...

    ; 函数尾声 - 恢复寄存器
    add esp, 16          ; 释放局部变量空间
    pop edi              ; 恢复寄存器（逆序）
    pop esi
    pop ebx
    pop ebp
    ret                  ; 返回
</code></pre> <h4 id="53-局部变量的存储">5.3 局部变量的存储</h4> <p>在函数执行过程中，寄存器和内存都可用于存放所需数据。寄存器具有极快的存取速度，因此通常优先考虑将数据存入寄存器。然而，寄存器数量有限，当寄存器不足以存放所有数据时，就需要将部分数据存放在栈内存中。</p> <p>我们可通过移动栈指针（sp）向栈顶方向移动，为函数在栈中分配用于存放局部数据的内存空间。</p> <p>以如下C语言代码为例：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="kt">long</span> <span class="n">bar</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>此代码定义了两个<code class="language-plaintext highlighter-rouge">long</code>类型变量<code class="language-plaintext highlighter-rouge">foo</code>和<code class="language-plaintext highlighter-rouge">bar</code>。假设它们都存放在栈中，由于<code class="language-plaintext highlighter-rouge">long</code>类型每个占用8个字节，所以总共需要在栈中分配16个字节的空间。</p> <ul> <li> <p><strong>分配过程（假设一个单元格为8个字节）</strong> 栈指针（sp）向栈顶方向移动16个字节，从而为<code class="language-plaintext highlighter-rouge">foo</code>和<code class="language-plaintext highlighter-rouge">bar</code>在栈中预留出相应的存储空间。</p> </li> <li> <p><strong>存储变量</strong> 移动栈指针完成空间分配后，将变量<code class="language-plaintext highlighter-rouge">foo</code>的值100存入分配好的栈空间起始位置，接着将变量<code class="language-plaintext highlighter-rouge">bar</code>的值200存入紧挨着<code class="language-plaintext highlighter-rouge">foo</code>的栈空间。</p> <h3 id="6-返回值处理机制">6. 返回值处理机制</h3> </li> </ul> <h4 id="61-不同类型返回值的处理">6.1 不同类型返回值的处理</h4> <p><strong>基本数据类型</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">func1</span><span class="p">();</span>         <span class="c1">// 返回值在EAX/RAX</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">func2</span><span class="p">();</span>   <span class="c1">// x86: EDX:EAX, x64: RAX</span>
<span class="kt">float</span> <span class="nf">func3</span><span class="p">();</span>       <span class="c1">// x87 ST(0) 或 XMM0</span>
<span class="kt">double</span> <span class="nf">func4</span><span class="p">();</span>      <span class="c1">// x87 ST(0) 或 XMM0</span>
</code></pre></div></div> <p><strong>结构体返回值</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">SmallStruct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>        <span class="c1">// 8字节，通过RAX返回</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">LargeStruct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>    <span class="c1">// 40字节，通过隐藏参数返回</span>
<span class="p">};</span>

<span class="c1">// 编译器可能将这样的调用：</span>
<span class="n">LargeStruct</span> <span class="nf">func</span><span class="p">();</span>
<span class="c1">// 转换为：</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">LargeStruct</span><span class="o">*</span> <span class="n">result</span><span class="p">);</span>
</code></pre></div></div> <p>函数的返回值一般会使用 <code class="language-plaintext highlighter-rouge">eax</code>（32 位平台）/<code class="language-plaintext highlighter-rouge">rax</code>（64 位平台）/<code class="language-plaintext highlighter-rouge">x0</code>（ARM64 平台）等寄存器作为返回载体，但这并非绝对。在一些特殊情况下，也可借助其他寄存器来返回值，比如 <code class="language-plaintext highlighter-rouge">edx</code>、<code class="language-plaintext highlighter-rouge">xmm0</code> 等。当函数返回值为结构体，一个寄存器无法容纳全部数据时，可能会将返回值的地址作为隐藏参数进行传递，例如 Boost 的协程切换函数就采用了类似的机制。</p> <p>从 C/C++ 层面来看，函数的调用与返回形式较为常规。然而，从汇编层面深入分析，一般函数调用采用 <code class="language-plaintext highlighter-rouge">call functionA</code> 的形式，函数返回则使用 <code class="language-plaintext highlighter-rouge">ret</code> 形式。</p> <h4 id="62-返回值优化rvo">6.2 返回值优化（RVO）</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">MyClass</span> <span class="nf">createObject</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MyClass</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>  <span class="c1">// 可能直接在调用者空间构造</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyClass</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">createObject</span><span class="p">();</span>  <span class="c1">// 可能避免拷贝</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="7-高级主题与优化技术">7. 高级主题与优化技术</h3> <h4 id="71-栈帧优化">7.1 栈帧优化</h4> <p><strong>帧指针消除（Frame Pointer Omission）</strong>：</p> <pre><code class="language-assembly">; 传统方式
push ebp
mov ebp, esp
sub esp, 16
; 使用 [ebp-4], [ebp-8] 访问局部变量

; 优化后（-fomit-frame-pointer）
sub esp, 16
; 直接使用 [esp+12], [esp+8] 访问局部变量
</code></pre> <p><strong>尾调用优化（Tail Call Optimization）</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">acc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">acc</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="n">acc</span><span class="p">);</span>  <span class="c1">// 尾调用，可优化为跳转</span>
<span class="p">}</span>

<span class="p">;</span> <span class="err">优化后可能变成：</span>
<span class="n">factorial_loop</span><span class="o">:</span>
    <span class="n">cmp</span> <span class="n">edi</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">jle</span> <span class="n">end</span>
    <span class="n">imul</span> <span class="n">esi</span><span class="p">,</span> <span class="n">edi</span>
    <span class="n">dec</span> <span class="n">edi</span>
    <span class="n">jmp</span> <span class="n">factorial_loop</span>
<span class="n">end</span><span class="o">:</span>
    <span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">esi</span>
    <span class="n">ret</span>
</code></pre></div></div> <h4 id="72-安全机制">7.2 安全机制</h4> <p><strong>栈金丝雀（Stack Canary）</strong>：</p> <pre><code class="language-assembly">function_with_buffer:
    push ebp
    mov ebp, esp
    mov eax, gs:[0x14]   ; 读取金丝雀值
    push eax             ; 保存到栈上
    sub esp, 256         ; 分配缓冲区

    ; 函数体...

    mov eax, [ebp-4]     ; 读取金丝雀值
    xor eax, gs:[0x14]   ; 检查是否被修改
    jnz stack_overflow   ; 如果修改则跳转到错误处理

    add esp, 260
    pop ebp
    ret

stack_overflow:
    call __stack_chk_fail
</code></pre> <h3 id="8-实际应用示例">8. 实际应用示例</h3> <h4 id="81-完整的函数调用分析">8.1 完整的函数调用分析</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">add_numbers</span><span class="p">(</span><span class="kt">long</span> <span class="n">a</span><span class="p">,</span> <span class="kt">long</span> <span class="n">b</span><span class="p">,</span> <span class="kt">long</span> <span class="n">c</span><span class="p">,</span> <span class="kt">long</span> <span class="n">d</span><span class="p">,</span> <span class="kt">long</span> <span class="n">e</span><span class="p">,</span> <span class="kt">long</span> <span class="n">f</span><span class="p">,</span> <span class="kt">long</span> <span class="n">g</span><span class="p">,</span> <span class="kt">long</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">local_var</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">local_var</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="n">e</span> <span class="o">+</span> <span class="n">f</span> <span class="o">+</span> <span class="n">g</span> <span class="o">+</span> <span class="n">h</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">add_numbers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Result: %ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>编译后的汇编分析（x64）</strong>：</p> <pre><code class="language-assembly">main:
    ; 函数序言
    pushq %rbp
    movq %rsp, %rbp
    subq $16, %rsp           ; 分配局部变量空间

    ; 准备参数（前6个通过寄存器，后2个通过栈）
    pushq $8                 ; 第8个参数
    pushq $7                 ; 第7个参数
    movl $6, %r9d           ; 第6个参数 -&gt; R9
    movl $5, %r8d           ; 第5个参数 -&gt; R8
    movl $4, %ecx           ; 第4个参数 -&gt; RCX
    movl $3, %edx           ; 第3个参数 -&gt; RDX
    movl $2, %esi           ; 第2个参数 -&gt; RSI
    movl $1, %edi           ; 第1个参数 -&gt; RDI

    call add_numbers
    addq $16, %rsp          ; 清理栈参数

    ; 使用返回值（在RAX中）
    movq %rax, %rsi
    movq $.LC0, %rdi        ; "Result: %ld\n"
    call printf

    movl $0, %eax           ; 返回0
    leave                   ; 等价于 movq %rbp, %rsp; popq %rbp
    ret

add_numbers:
    ; 函数序言
    pushq %rbp
    movq %rsp, %rbp

    ; 保存寄存器参数到栈（如果需要）
    movq %rdi, -8(%rbp)     ; a
    movq %rsi, -16(%rbp)    ; b
    ; ... 其他参数

    ; 计算 local_var = a + b
    movq -8(%rbp), %rax
    addq -16(%rbp), %rax
    movq %rax, -56(%rbp)    ; local_var

    ; 计算最终结果
    movq -56(%rbp), %rax    ; local_var
    addq -24(%rbp), %rax    ; + c
    addq -32(%rbp), %rax    ; + d
    addq -40(%rbp), %rax    ; + e
    addq -48(%rbp), %rax    ; + f
    addq 16(%rbp), %rax     ; + g (栈参数)
    addq 24(%rbp), %rax     ; + h (栈参数)

    ; 返回（结果已在RAX中）
    popq %rbp
    ret
</code></pre> <h4 id="82-栈溢出攻击与防护">8.2 栈溢出攻击与防护</h4> <p><strong>栈溢出示例</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">vulnerable_function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
    <span class="n">gets</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>  <span class="c1">// 危险：无边界检查</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>防护措施</strong>：</p> <ol> <li> <strong>栈金丝雀</strong>：检测栈覆盖</li> <li> <strong>ASLR</strong>：地址空间随机化</li> <li> <strong>NX 位</strong>：栈不可执行</li> <li> <strong>安全编程</strong>：使用安全函数</li> </ol> <h4 id="83-调试技巧">8.3 调试技巧</h4> <p><strong>GDB 调试栈帧</strong>：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span>gdb<span class="o">)</span> bt                    <span class="c"># 显示调用栈</span>
<span class="o">(</span>gdb<span class="o">)</span> frame 2              <span class="c"># 切换到第2个栈帧</span>
<span class="o">(</span>gdb<span class="o">)</span> info frame           <span class="c"># 显示当前栈帧信息</span>
<span class="o">(</span>gdb<span class="o">)</span> x/10wx <span class="nv">$esp</span>          <span class="c"># 查看栈内容</span>
<span class="o">(</span>gdb<span class="o">)</span> disas                <span class="c"># 反汇编当前函数</span>
</code></pre></div></div> <h3 id="9-常见问题与解答">9. 常见问题与解答</h3> <h4 id="91-栈相关概念澄清">9.1 栈相关概念澄清</h4> <p><strong>Q: 内存的栈和汇编的栈是同一个概念吗？</strong></p> <p>A: 是的，它们是同一物理结构的不同抽象层次：</p> <ul> <li> <strong>内存栈（高级视角）</strong>：操作系统分配的 LIFO 内存区域，用于函数调用管理</li> <li> <strong>汇编栈（底层视角）</strong>：通过 ESP/RSP 和 EBP/RBP 寄存器操作的具体实现</li> </ul> <h4 id="92-性能相关问题">9.2 性能相关问题</h4> <p><strong>Q: 函数调用的性能开销有多大？</strong></p> <p>A: 典型开销包括：</p> <ul> <li>参数传递：寄存器传递几乎无开销，栈传递有内存访问开销</li> <li>栈帧管理：约 5-10 条指令的开销</li> <li>寄存器保存/恢复：取决于使用的寄存器数量</li> <li>分支预测：现代 CPU 的分支预测器可减少跳转开销</li> </ul> <h4 id="93-获取指令指针的技术">9.3 获取指令指针的技术</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 方法1：编译器内置函数</span>
<span class="kt">uint64_t</span> <span class="nf">get_return_address</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 方法2：内联汇编</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">get_current_address</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">addr</span><span class="p">;</span>
    <span class="k">asm</span><span class="p">(</span><span class="s">"call 1f</span><span class="se">\n</span><span class="s">1: pop %0"</span> <span class="o">:</span> <span class="s">"=r"</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 方法3：利用异常机制</span>
<span class="cp">#include</span> <span class="cpf">&lt;setjmp.h&gt;</span><span class="cp">
</span><span class="kt">jmp_buf</span> <span class="n">env</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">save_context</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">setjmp</span><span class="p">(</span><span class="n">env</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 第一次调用，保存上下文</span>
        <span class="n">longjmp</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 第二次到达，上下文已保存</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="10-总结">10. 总结</h3> <p>函数调用机制是现代计算机系统的基础，涉及多个层面的协调配合：</p> <ol> <li> <strong>硬件层面</strong>：CPU 提供栈操作指令和寄存器支持</li> <li> <strong>指令层面</strong>：CALL/RET 指令实现控制流转移</li> <li> <strong>约定层面</strong>：调用约定确保兼容性</li> <li> <strong>编译器层面</strong>：代码生成和优化</li> <li> <strong>操作系统层面</strong>：栈空间管理和安全保护</li> </ol> <p>现代编译器虽然已经高度优化了函数调用，但深入理解其原理仍然是系统程序员必备的基础知识。随着处理器架构的演进和新技术的出现，函数调用机制也在不断发展，但其核心原理保持相对稳定。</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/6_internet.md/">（七）内核那些事儿：操作系统对网络包的处理</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/5_fileSystem.md/">（六）内核那些事儿：文件系统</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/4_interaction.md/">（五）内核那些事儿：系统和程序的交互</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_device.md/">（四）内核那些事儿：设备管理与驱动开发</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_signal.md/">（三）内核那些事儿：CPU中断和信号</a> </li> </div> </div> <div class="col-sm-4"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <script src="/assets/js/toc-depth.js"></script> </body> </html>