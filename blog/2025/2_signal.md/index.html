<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> （三）内核那些事儿：CPU中断和信号 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/toc-custom.css"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/2_signal.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-8"> <div class="post"> <header class="post-header"> <h1 class="post-title">（三）内核那些事儿：CPU中断和信号</h1> <p class="post-meta"> Created on September 15, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/kernel"> <i class="fa-solid fa-hashtag fa-sm"></i> kernel</a>   ·   <a href="/blog/category/os"> <i class="fa-solid fa-tag fa-sm"></i> OS</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="三内核那些事儿cpu-中断和信号">（三）内核那些事儿：CPU 中断和信号</h2> <h2 id="一设计背景异步事件处理的系统性挑战">一、设计背景：异步事件处理的系统性挑战</h2> <h3 id="11-计算机系统的异步性本质">1.1 计算机系统的异步性本质</h3> <p>现代计算机系统面临的核心挑战：<strong>如何高效处理各种异步事件，保证系统的响应性和稳定性？</strong></p> <p><strong>关键矛盾体现</strong>：</p> <ul> <li> <strong>同步执行 vs 异步事件</strong>：CPU 按顺序执行指令，但需要响应随时可能发生的异步事件</li> <li> <strong>实时响应 vs 处理开销</strong>：系统需要实时响应外部事件，但处理机制本身也有开销</li> <li> <strong>统一抽象 vs 多样事件</strong>：需要用统一的机制处理各种不同类型的异步事件</li> <li> <strong>安全隔离 vs 灵活通信</strong>：保证系统安全的同时，允许灵活的组件间通信</li> </ul> <h3 id="12-操作系统的分层解决方案">1.2 操作系统的分层解决方案</h3> <p>操作系统通过<strong>分层异步处理机制</strong>解决这一挑战：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>应用层事件处理    ←→  信号处理、用户程序逻辑
    ↕ 软件抽象
系统层事件管理    ←→  信号生成、进程调度、资源管理
    ↕ 内核接口
硬件层事件响应    ←→  中断处理、异常处理、上下文切换
    ↕ 硬件抽象
物理层事件源      ←→  外设、CPU异常、定时器
</code></pre></div></div> <p><strong>核心设计理念</strong>：</p> <ol> <li> <strong>分层抽象</strong>：不同层次处理不同粒度的异步事件</li> <li> <strong>统一接口</strong>：提供一致的异步事件处理编程模型</li> <li> <strong>优先级管理</strong>：根据事件重要性合理分配处理资源</li> <li> <strong>状态保护</strong>：确保异步处理不破坏系统一致性</li> </ol> <h2 id="二中断机制硬件与内核的异步桥梁">二、中断机制：硬件与内核的异步桥梁</h2> <h3 id="21-中断产生的根本动机">2.1 中断产生的根本动机</h3> <h4 id="为什么需要中断机制">为什么需要中断机制？</h4> <p><strong>传统轮询方式的局限性</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 低效的轮询方式</span>
<span class="kt">void</span> <span class="nf">inefficient_polling</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">keyboard_has_data</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">process_keyboard_input</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">network_has_packet</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">process_network_packet</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">timer_expired</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">handle_timer_event</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="c1">// CPU 大量时间浪费在轮询上</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>中断机制的优势</strong>：</p> <ul> <li> <strong>按需响应</strong>：只在事件发生时才处理，避免无谓的 CPU 占用</li> <li> <strong>实时性保证</strong>：硬件可以立即通知 CPU，实现快速响应</li> <li> <strong>多任务支持</strong>：CPU 可以专心执行当前任务，直到被中断</li> </ul> <h3 id="22-中断的层次化分类体系">2.2 中断的层次化分类体系</h3> <h4 id="按产生源分类">按产生源分类</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 中断分类的系统性定义</span>
<span class="k">enum</span> <span class="n">interrupt_source</span> <span class="p">{</span>
    <span class="c1">// 外部硬件中断</span>
    <span class="n">EXTERNAL_HARDWARE</span><span class="p">,</span>    <span class="c1">// 键盘、鼠标、网卡等外设</span>

    <span class="c1">// 内部硬件中断</span>
    <span class="n">INTERNAL_HARDWARE</span><span class="p">,</span>    <span class="c1">// CPU内部定时器、性能计数器</span>

    <span class="c1">// 软件中断</span>
    <span class="n">SOFTWARE_INTERRUPT</span><span class="p">,</span>   <span class="c1">// 系统调用、软件模拟的中断</span>

    <span class="c1">// CPU异常</span>
    <span class="n">CPU_EXCEPTION</span>        <span class="c1">// 除零、缺页、保护违例等</span>
<span class="p">};</span>

<span class="c1">// 中断描述符的完整结构</span>
<span class="k">struct</span> <span class="n">interrupt_descriptor</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">interrupt_number</span><span class="p">;</span>     <span class="c1">// 中断号</span>
    <span class="k">enum</span> <span class="n">interrupt_source</span> <span class="n">source</span><span class="p">;</span>  <span class="c1">// 中断源类型</span>
    <span class="kt">uint8_t</span> <span class="n">priority_level</span><span class="p">;</span>        <span class="c1">// 优先级</span>
    <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>               <span class="c1">// 中断属性标志</span>

    <span class="c1">// 处理函数指针</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="k">struct</span> <span class="n">interrupt_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>

    <span class="c1">// 统计信息</span>
    <span class="kt">uint64_t</span> <span class="n">trigger_count</span><span class="p">;</span>       <span class="c1">// 触发次数</span>
    <span class="kt">uint64_t</span> <span class="n">total_time</span><span class="p">;</span>          <span class="c1">// 总处理时间</span>
    <span class="kt">uint64_t</span> <span class="n">max_time</span><span class="p">;</span>            <span class="c1">// 最大处理时间</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="按处理紧急程度分类">按处理紧急程度分类</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 中断优先级系统</span>
<span class="k">enum</span> <span class="n">interrupt_priority</span> <span class="p">{</span>
    <span class="n">IRQ_PRIORITY_NMI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>         <span class="c1">// 不可屏蔽中断(最高)</span>
    <span class="n">IRQ_PRIORITY_MACHINE_CHECK</span><span class="p">,</span>   <span class="c1">// 机器检查异常</span>
    <span class="n">IRQ_PRIORITY_TIMER</span><span class="p">,</span>           <span class="c1">// 系统定时器</span>
    <span class="n">IRQ_PRIORITY_KEYBOARD</span><span class="p">,</span>        <span class="c1">// 键盘输入</span>
    <span class="n">IRQ_PRIORITY_NETWORK</span><span class="p">,</span>         <span class="c1">// 网络中断</span>
    <span class="n">IRQ_PRIORITY_DISK</span><span class="p">,</span>           <span class="c1">// 磁盘I/O</span>
    <span class="n">IRQ_PRIORITY_USER_SIGNAL</span><span class="p">,</span>    <span class="c1">// 用户信号(最低)</span>
    <span class="n">IRQ_PRIORITY_MAX</span>
<span class="p">};</span>

<span class="c1">// 优先级管理结构</span>
<span class="k">struct</span> <span class="n">priority_manager</span> <span class="p">{</span>
    <span class="c1">// 当前中断优先级</span>
    <span class="k">enum</span> <span class="n">interrupt_priority</span> <span class="n">current_level</span><span class="p">;</span>

    <span class="c1">// 各优先级的中断计数</span>
    <span class="n">atomic_t</span> <span class="n">pending_count</span><span class="p">[</span><span class="n">IRQ_PRIORITY_MAX</span><span class="p">];</span>

    <span class="c1">// 优先级掩码</span>
    <span class="kt">uint32_t</span> <span class="n">priority_mask</span><span class="p">;</span>

    <span class="c1">// 嵌套深度控制</span>
    <span class="kt">int</span> <span class="n">nested_depth</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max_nested_depth</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="23-中断处理的完整生命周期">2.3 中断处理的完整生命周期</h3> <h4 id="阶段一中断发生与检测">阶段一：中断发生与检测</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 硬件中断的发生过程</span>
<span class="k">struct</span> <span class="n">hardware_interrupt_process</span> <span class="p">{</span>
    <span class="c1">// 1. 外设事件发生</span>
    <span class="kt">void</span> <span class="n">device_event_occurs</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 设备完成某项操作（如数据接收完成）</span>
        <span class="n">device_status_register</span> <span class="o">|=</span> <span class="n">DEVICE_DATA_READY</span><span class="p">;</span>

        <span class="c1">// 如果中断使能，向中断控制器发送中断请求</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">device_interrupt_enabled</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">interrupt_controller_send_irq</span><span class="p">(</span><span class="n">device_irq_number</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 2. 中断控制器处理</span>
    <span class="kt">void</span> <span class="n">interrupt_controller_process</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 中断控制器接收多个设备的中断请求</span>
        <span class="c1">// 按优先级排序并向CPU发送中断信号</span>
        <span class="kt">int</span> <span class="n">highest_priority_irq</span> <span class="o">=</span> <span class="n">get_highest_priority_pending_irq</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">cpu_interrupt_enabled</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
            <span class="n">irq_priority</span><span class="p">[</span><span class="n">highest_priority_irq</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">current_cpu_priority</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 向CPU发送中断信号</span>
            <span class="n">cpu_interrupt_line_assert</span><span class="p">(</span><span class="n">highest_priority_irq</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 3. CPU响应中断</span>
    <span class="kt">void</span> <span class="n">cpu_interrupt_response</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// CPU在指令边界检查中断信号</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">interrupt_signal_pending</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">interrupts_enabled</span><span class="p">())</span> <span class="p">{</span>
            <span class="c1">// 开始中断处理流程</span>
            <span class="n">handle_interrupt</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="阶段二上下文保存与切换">阶段二：上下文保存与切换</h4> <pre><code class="language-assembly">; x86-64 中断入口的完整汇编实现
interrupt_entry_point:
    ; 1. 硬件自动保存（由CPU完成）
    ; - 压入SS（栈段）
    ; - 压入RSP（栈指针）
    ; - 压入RFLAGS（标志寄存器）
    ; - 压入CS（代码段）
    ; - 压入RIP（指令指针）
    ; - 如果是异常，还会压入错误码

    ; 2. 软件保存通用寄存器
    push %rax
    push %rbx
    push %rcx
    push %rdx
    push %rsi
    push %rdi
    push %rbp
    push %r8
    push %r9
    push %r10
    push %r11
    push %r12
    push %r13
    push %r14
    push %r15

    ; 3. 保存段寄存器
    mov %ds, %ax
    push %rax
    mov %es, %ax
    push %rax
    mov %fs, %ax
    push %rax
    mov %gs, %ax
    push %rax

    ; 4. 切换到内核数据段
    mov $KERNEL_DS, %ax
    mov %ax, %ds
    mov %ax, %es

    ; 5. 调用C语言中断处理函数
    call generic_interrupt_handler

    ; 6. 恢复上下文并返回
    jmp interrupt_exit_point
</code></pre> <h4 id="阶段三中断处理与调度">阶段三：中断处理与调度</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 通用中断处理框架</span>
<span class="kt">void</span> <span class="nf">generic_interrupt_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">interrupt_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">irq_number</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">interrupt_number</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">interrupt_descriptor</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">interrupt_table</span><span class="p">[</span><span class="n">irq_number</span><span class="p">];</span>

    <span class="c1">// 1. 中断统计与监控</span>
    <span class="n">desc</span><span class="o">-&gt;</span><span class="n">trigger_count</span><span class="o">++</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">start_time</span> <span class="o">=</span> <span class="n">get_cycle_count</span><span class="p">();</span>

    <span class="c1">// 2. 关键中断的快速路径</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQ_FLAG_FAST_PATH</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">handle_fast_interrupt</span><span class="p">(</span><span class="n">irq_number</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">interrupt_done</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 3. 常规中断处理</span>
    <span class="c1">// 3.1 确认中断（向中断控制器发送EOI）</span>
    <span class="n">interrupt_controller_ack</span><span class="p">(</span><span class="n">irq_number</span><span class="p">);</span>

    <span class="c1">// 3.2 启用中断嵌套（如果允许）</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQ_FLAG_NESTABLE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">enable_interrupts</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// 3.3 调用具体的中断处理函数</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">desc</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 3.4 处理底半部（延迟工作）</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">IRQ_FLAG_HAS_BOTTOM_HALF</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">schedule_bottom_half</span><span class="p">(</span><span class="n">irq_number</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">interrupt_done:</span>
    <span class="c1">// 4. 更新统计信息</span>
    <span class="kt">uint64_t</span> <span class="n">end_time</span> <span class="o">=</span> <span class="n">get_cycle_count</span><span class="p">();</span>
    <span class="kt">uint64_t</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">;</span>
    <span class="n">desc</span><span class="o">-&gt;</span><span class="n">total_time</span> <span class="o">+=</span> <span class="n">elapsed</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">elapsed</span> <span class="o">&gt;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">max_time</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">desc</span><span class="o">-&gt;</span><span class="n">max_time</span> <span class="o">=</span> <span class="n">elapsed</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 5. 检查是否需要进程调度</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">CTX_FLAG_PREEMPT_NEEDED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">schedule</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="24-软件中断与系统调用">2.4 软件中断与系统调用</h3> <h4 id="系统调用的现代实现">系统调用的现代实现</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 现代x86-64的系统调用机制（SYSCALL/SYSRET）</span>
<span class="k">struct</span> <span class="n">syscall_context</span> <span class="p">{</span>
    <span class="c1">// 保存的用户态寄存器</span>
    <span class="kt">uint64_t</span> <span class="n">user_rax</span><span class="p">,</span> <span class="n">user_rbx</span><span class="p">,</span> <span class="n">user_rcx</span><span class="p">,</span> <span class="n">user_rdx</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">user_rsi</span><span class="p">,</span> <span class="n">user_rdi</span><span class="p">,</span> <span class="n">user_rbp</span><span class="p">,</span> <span class="n">user_rsp</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">user_r8</span><span class="p">,</span> <span class="n">user_r9</span><span class="p">,</span> <span class="n">user_r10</span><span class="p">,</span> <span class="n">user_r11</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">user_r12</span><span class="p">,</span> <span class="n">user_r13</span><span class="p">,</span> <span class="n">user_r14</span><span class="p">,</span> <span class="n">user_r15</span><span class="p">;</span>

    <span class="c1">// 用户态执行状态</span>
    <span class="kt">uint64_t</span> <span class="n">user_rip</span><span class="p">;</span>          <span class="c1">// 用户态返回地址</span>
    <span class="kt">uint64_t</span> <span class="n">user_rflags</span><span class="p">;</span>       <span class="c1">// 用户态标志寄存器</span>
    <span class="kt">uint16_t</span> <span class="n">user_cs</span><span class="p">,</span> <span class="n">user_ss</span><span class="p">;</span>   <span class="c1">// 用户态段寄存器</span>

    <span class="c1">// 系统调用信息</span>
    <span class="kt">uint64_t</span> <span class="n">syscall_number</span><span class="p">;</span>    <span class="c1">// 系统调用号</span>
    <span class="kt">uint64_t</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>     <span class="c1">// 系统调用参数</span>
    <span class="kt">uint64_t</span> <span class="n">return_value</span><span class="p">;</span>      <span class="c1">// 返回值</span>
    <span class="kt">int</span> <span class="n">error_code</span><span class="p">;</span>            <span class="c1">// 错误码</span>
<span class="p">};</span>

<span class="c1">// 系统调用入口点</span>
<span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">system_call_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">syscall_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>

    <span class="c1">// 1. 安全检查</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">syscall_number</span> <span class="o">&gt;=</span> <span class="n">NR_SYSCALLS</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 2. 权限检查</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">syscall_permission_check</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">syscall_number</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 3. 参数验证和复制</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">validate_syscall_parameters</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 4. 调用具体的系统调用实现</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">sys_call_table</span><span class="p">[</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">syscall_number</span><span class="p">])(</span>
        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parameters</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parameters</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parameters</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">parameters</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="p">);</span>

    <span class="c1">// 5. 结果处理</span>
    <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="三信号机制内核与进程的异步通信">三、信号机制：内核与进程的异步通信</h2> <h3 id="31-信号设计的历史背景与演进">3.1 信号设计的历史背景与演进</h3> <h4 id="信号机制的诞生动机">信号机制的诞生动机</h4> <p><strong>早期系统的局限性</strong>：</p> <ul> <li>进程只能通过轮询方式检查外部事件</li> <li>缺乏异步通知机制，无法及时响应紧急情况</li> <li>进程间通信方式有限，难以实现复杂的协作</li> </ul> <p><strong>信号机制的设计目标</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 信号机制要解决的核心问题</span>
<span class="k">struct</span> <span class="n">signal_design_goals</span> <span class="p">{</span>
    <span class="c1">// 1. 异步通知能力</span>
    <span class="n">bool</span> <span class="n">asynchronous_notification</span><span class="p">;</span>

    <span class="c1">// 2. 进程间通信</span>
    <span class="n">bool</span> <span class="n">inter_process_communication</span><span class="p">;</span>

    <span class="c1">// 3. 系统事件传递</span>
    <span class="n">bool</span> <span class="n">system_event_delivery</span><span class="p">;</span>

    <span class="c1">// 4. 用户控制接口</span>
    <span class="n">bool</span> <span class="n">user_control_interface</span><span class="p">;</span>

    <span class="c1">// 5. 简单编程模型</span>
    <span class="n">bool</span> <span class="n">simple_programming_model</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h4 id="信号的演进历程">信号的演进历程</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 信号系统的历史演进</span>
<span class="k">enum</span> <span class="n">signal_evolution</span> <span class="p">{</span>
    <span class="c1">// 第一代：简单信号（Unix V6/V7）</span>
    <span class="n">SIMPLE_SIGNALS</span><span class="p">,</span>           <span class="c1">// 基本的进程终止和停止</span>

    <span class="c1">// 第二代：可靠信号（4.2BSD）</span>
    <span class="n">RELIABLE_SIGNALS</span><span class="p">,</span>         <span class="c1">// 引入信号屏蔽和排队</span>

    <span class="c1">// 第三代：实时信号（POSIX.1b）</span>
    <span class="n">REALTIME_SIGNALS</span><span class="p">,</span>         <span class="c1">// 支持优先级和附加数据</span>

    <span class="c1">// 第四代：现代扩展（Linux/现代Unix）</span>
    <span class="n">MODERN_EXTENSIONS</span>         <span class="c1">// signalfd, eventfd等新机制</span>
<span class="p">};</span>

<span class="c1">// 现代信号系统的特性</span>
<span class="k">struct</span> <span class="n">modern_signal_features</span> <span class="p">{</span>
    <span class="c1">// 标准信号（1-31）</span>
    <span class="kt">int</span> <span class="n">standard_signals</span><span class="p">[</span><span class="mi">31</span><span class="p">];</span>

    <span class="c1">// 实时信号（32-64）</span>
    <span class="kt">int</span> <span class="n">realtime_signals</span><span class="p">[</span><span class="mi">33</span><span class="p">];</span>

    <span class="c1">// 信号排队支持</span>
    <span class="n">bool</span> <span class="n">signal_queuing</span><span class="p">;</span>

    <span class="c1">// 信号信息传递</span>
    <span class="n">bool</span> <span class="n">signal_information</span><span class="p">;</span>

    <span class="c1">// 异步安全保证</span>
    <span class="n">bool</span> <span class="n">async_signal_safety</span><span class="p">;</span>

    <span class="c1">// 现代同步接口</span>
    <span class="n">bool</span> <span class="n">synchronous_interfaces</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="32-信号的生命周期管理">3.2 信号的生命周期管理</h3> <h4 id="信号产生的多种途径">信号产生的多种途径</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 信号产生的完整分类</span>
<span class="k">enum</span> <span class="n">signal_generation</span> <span class="p">{</span>
    <span class="c1">// 1. 硬件异常转换</span>
    <span class="n">HARDWARE_EXCEPTION_SIGNAL</span><span class="p">,</span>   <span class="c1">// 除零、段错误等</span>

    <span class="c1">// 2. 内核事件通知</span>
    <span class="n">KERNEL_EVENT_SIGNAL</span><span class="p">,</span>         <span class="c1">// 子进程退出、定时器到期</span>

    <span class="c1">// 3. 用户显式发送</span>
    <span class="n">USER_EXPLICIT_SIGNAL</span><span class="p">,</span>        <span class="c1">// kill()、raise()等</span>

    <span class="c1">// 4. 终端操作触发</span>
    <span class="n">TERMINAL_SIGNAL</span><span class="p">,</span>             <span class="c1">// Ctrl+C、Ctrl+Z等</span>

    <span class="c1">// 5. 资源限制违反</span>
    <span class="n">RESOURCE_LIMIT_SIGNAL</span>        <span class="c1">// CPU时间、文件大小超限</span>
<span class="p">};</span>

<span class="c1">// 信号生成的内核实现</span>
<span class="k">struct</span> <span class="n">signal_generation_context</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">sender</span><span class="p">;</span>     <span class="c1">// 发送者进程</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span>     <span class="c1">// 目标进程</span>
    <span class="kt">int</span> <span class="n">signal_number</span><span class="p">;</span>              <span class="c1">// 信号编号</span>
    <span class="n">siginfo_t</span> <span class="n">signal_info</span><span class="p">;</span>          <span class="c1">// 信号附加信息</span>
    <span class="k">enum</span> <span class="n">signal_generation</span> <span class="n">source</span><span class="p">;</span>   <span class="c1">// 信号来源</span>

    <span class="c1">// 权限验证</span>
    <span class="n">bool</span> <span class="n">permission_granted</span><span class="p">;</span>

    <span class="c1">// 发送时间戳</span>
    <span class="k">struct</span> <span class="n">timespec</span> <span class="n">send_time</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 信号发送的内核核心函数</span>
<span class="kt">int</span> <span class="nf">send_signal_internal</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
                         <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">pending</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

    <span class="c1">// 1. 权限检查</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_permission_check</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">sig</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 2. 目标进程状态检查</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_DEAD</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ESRCH</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 3. 信号屏蔽检查</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">,</span> <span class="n">sig</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 如果信号被屏蔽，仍然需要排队（除非是SIGKILL/SIGSTOP）</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">!=</span> <span class="n">SIGKILL</span> <span class="o">&amp;&amp;</span> <span class="n">sig</span> <span class="o">!=</span> <span class="n">SIGSTOP</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">goto</span> <span class="n">queue_signal</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 4. 特殊信号处理</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">SIGKILL</span> <span class="o">||</span> <span class="n">sig</span> <span class="o">==</span> <span class="n">SIGSTOP</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 这些信号不能被忽略或捕获</span>
        <span class="k">return</span> <span class="n">force_signal_delivery</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">queue_signal:</span>
    <span class="c1">// 5. 确定信号队列</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pending</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">shared_pending</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">pending</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="c1">// 6. 实时信号特殊处理</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">&gt;=</span> <span class="n">SIGRTMIN</span> <span class="o">&amp;&amp;</span> <span class="n">sig</span> <span class="o">&lt;=</span> <span class="n">SIGRTMAX</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 实时信号需要排队</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">allocate_sigqueue</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pending</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
            <span class="n">copy_siginfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 标准信号只设置位标志</span>
        <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 7. 唤醒目标进程</span>
    <span class="n">signal_wake_up_state</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">sig</span> <span class="o">==</span> <span class="n">SIGKILL</span> <span class="o">?</span> <span class="n">TASK_WAKEKILL</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="信号传递与排队机制">信号传递与排队机制</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 信号队列管理</span>
<span class="k">struct</span> <span class="n">signal_queue_manager</span> <span class="p">{</span>
    <span class="c1">// 标准信号队列（位图方式）</span>
    <span class="n">sigset_t</span> <span class="n">standard_pending</span><span class="p">;</span>

    <span class="c1">// 实时信号队列（链表方式）</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">realtime_queue</span><span class="p">;</span>

    <span class="c1">// 队列统计</span>
    <span class="n">atomic_t</span> <span class="n">queue_depth</span><span class="p">;</span>
    <span class="n">atomic_t</span> <span class="n">max_queue_depth</span><span class="p">;</span>

    <span class="c1">// 内存管理</span>
    <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">sigqueue_cache</span><span class="p">;</span>
    <span class="n">atomic_t</span> <span class="n">allocated_sigqueues</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 信号优先级处理</span>
<span class="kt">int</span> <span class="nf">dequeue_signal</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">mask</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">sigpending</span> <span class="o">*</span><span class="n">pending</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sigqueue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="c1">// 1. 首先检查标准信号（按编号顺序）</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">next_signal</span><span class="p">(</span><span class="n">pending</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">&lt;</span> <span class="n">SIGRTMIN</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 标准信号：清除位标志</span>
            <span class="n">sigdelset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>

            <span class="c1">// 填充基本信号信息</span>
            <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">sig</span><span class="p">;</span>
            <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_code</span> <span class="o">=</span> <span class="n">SI_USER</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 实时信号：从队列中取出</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sigqueue</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
            <span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
            <span class="n">copy_siginfo</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">);</span>
            <span class="n">__sigqueue_free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 2. 检查进程组信号</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">dequeue_group_signal</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">siglock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">sig</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="33-信号处理的三种模式">3.3 信号处理的三种模式</h3> <h4 id="模式一默认处理">模式一：默认处理</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 信号默认动作定义</span>
<span class="k">enum</span> <span class="n">signal_default_action</span> <span class="p">{</span>
    <span class="n">SIGACT_IGNORE</span><span class="p">,</span>     <span class="c1">// 忽略信号</span>
    <span class="n">SIGACT_TERMINATE</span><span class="p">,</span>  <span class="c1">// 终止进程</span>
    <span class="n">SIGACT_COREDUMP</span><span class="p">,</span>   <span class="c1">// 终止进程并生成核心转储</span>
    <span class="n">SIGACT_STOP</span><span class="p">,</span>       <span class="c1">// 停止进程</span>
    <span class="n">SIGACT_CONTINUE</span>    <span class="c1">// 继续进程</span>
<span class="p">};</span>

<span class="c1">// 各信号的默认动作表</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">enum</span> <span class="n">signal_default_action</span> <span class="n">signal_defaults</span><span class="p">[</span><span class="n">_NSIG</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">SIGHUP</span><span class="p">]</span>  <span class="o">=</span> <span class="n">SIGACT_TERMINATE</span><span class="p">,</span>
    <span class="p">[</span><span class="n">SIGINT</span><span class="p">]</span>  <span class="o">=</span> <span class="n">SIGACT_TERMINATE</span><span class="p">,</span>
    <span class="p">[</span><span class="n">SIGQUIT</span><span class="p">]</span> <span class="o">=</span> <span class="n">SIGACT_COREDUMP</span><span class="p">,</span>
    <span class="p">[</span><span class="n">SIGILL</span><span class="p">]</span>  <span class="o">=</span> <span class="n">SIGACT_COREDUMP</span><span class="p">,</span>
    <span class="p">[</span><span class="n">SIGTRAP</span><span class="p">]</span> <span class="o">=</span> <span class="n">SIGACT_COREDUMP</span><span class="p">,</span>
    <span class="p">[</span><span class="n">SIGABRT</span><span class="p">]</span> <span class="o">=</span> <span class="n">SIGACT_COREDUMP</span><span class="p">,</span>
    <span class="p">[</span><span class="n">SIGFPE</span><span class="p">]</span>  <span class="o">=</span> <span class="n">SIGACT_COREDUMP</span><span class="p">,</span>
    <span class="p">[</span><span class="n">SIGKILL</span><span class="p">]</span> <span class="o">=</span> <span class="n">SIGACT_TERMINATE</span><span class="p">,</span>  <span class="c1">// 不可改变</span>
    <span class="p">[</span><span class="n">SIGSEGV</span><span class="p">]</span> <span class="o">=</span> <span class="n">SIGACT_COREDUMP</span><span class="p">,</span>
    <span class="p">[</span><span class="n">SIGPIPE</span><span class="p">]</span> <span class="o">=</span> <span class="n">SIGACT_TERMINATE</span><span class="p">,</span>
    <span class="p">[</span><span class="n">SIGALRM</span><span class="p">]</span> <span class="o">=</span> <span class="n">SIGACT_TERMINATE</span><span class="p">,</span>
    <span class="p">[</span><span class="n">SIGTERM</span><span class="p">]</span> <span class="o">=</span> <span class="n">SIGACT_TERMINATE</span><span class="p">,</span>
    <span class="p">[</span><span class="n">SIGCHLD</span><span class="p">]</span> <span class="o">=</span> <span class="n">SIGACT_IGNORE</span><span class="p">,</span>
    <span class="p">[</span><span class="n">SIGCONT</span><span class="p">]</span> <span class="o">=</span> <span class="n">SIGACT_CONTINUE</span><span class="p">,</span>
    <span class="p">[</span><span class="n">SIGSTOP</span><span class="p">]</span> <span class="o">=</span> <span class="n">SIGACT_STOP</span><span class="p">,</span>       <span class="c1">// 不可改变</span>
    <span class="p">[</span><span class="n">SIGTSTP</span><span class="p">]</span> <span class="o">=</span> <span class="n">SIGACT_STOP</span><span class="p">,</span>
    <span class="c1">// ... 更多信号</span>
<span class="p">};</span>

<span class="c1">// 执行默认动作</span>
<span class="kt">void</span> <span class="nf">do_signal_default_action</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="n">signal_default_action</span> <span class="n">action</span> <span class="o">=</span> <span class="n">signal_defaults</span><span class="p">[</span><span class="n">sig</span><span class="p">];</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">SIGACT_IGNORE</span><span class="p">:</span>
        <span class="c1">// 什么都不做</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">SIGACT_TERMINATE</span><span class="p">:</span>
        <span class="n">do_exit_group</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">SIGACT_COREDUMP</span><span class="p">:</span>
        <span class="n">do_coredump</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
        <span class="n">do_exit_group</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">SIGACT_STOP</span><span class="p">:</span>
        <span class="n">do_signal_stop</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">SIGACT_CONTINUE</span><span class="p">:</span>
        <span class="n">do_signal_continue</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="模式二忽略处理">模式二：忽略处理</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 信号忽略的实现</span>
<span class="kt">void</span> <span class="nf">signal_ignore_setup</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">ignore_action</span><span class="p">;</span>

    <span class="c1">// 设置忽略动作</span>
    <span class="n">ignore_action</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">SIG_IGN</span><span class="p">;</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ignore_action</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
    <span class="n">ignore_action</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 应用到特定信号</span>
    <span class="n">sigaction</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ignore_action</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 内核中的忽略处理</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span> <span class="nf">signal_ignored</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">k_sigaction</span> <span class="o">*</span><span class="n">ka</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">sighand</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">[</span><span class="n">sig</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

    <span class="c1">// 检查是否设置为忽略</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">==</span> <span class="n">SIG_IGN</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 默认忽略的信号</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ka</span><span class="o">-&gt;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">==</span> <span class="n">SIG_DFL</span> <span class="o">&amp;&amp;</span> <span class="n">signal_defaults</span><span class="p">[</span><span class="n">sig</span><span class="p">]</span> <span class="o">==</span> <span class="n">SIGACT_IGNORE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="模式三自定义处理">模式三：自定义处理</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 高级信号处理的完整示例</span>
<span class="k">struct</span> <span class="n">advanced_signal_handler</span> <span class="p">{</span>
    <span class="c1">// 信号处理函数</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

    <span class="c1">// 信号掩码</span>
    <span class="n">sigset_t</span> <span class="n">blocked_signals</span><span class="p">;</span>

    <span class="c1">// 处理标志</span>
    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

    <span class="c1">// 替代栈</span>
    <span class="n">stack_t</span> <span class="n">signal_stack</span><span class="p">;</span>

    <span class="c1">// 统计信息</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">handle_count</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">timespec</span> <span class="n">last_handled</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 现代信号处理注册</span>
<span class="kt">int</span> <span class="nf">setup_advanced_signal_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">sa</span><span class="p">;</span>
    <span class="n">stack_t</span> <span class="n">ss</span><span class="p">;</span>

    <span class="c1">// 1. 设置替代信号栈</span>
    <span class="n">ss</span><span class="p">.</span><span class="n">ss_sp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">SIGSTKSZ</span><span class="p">);</span>
    <span class="n">ss</span><span class="p">.</span><span class="n">ss_size</span> <span class="o">=</span> <span class="n">SIGSTKSZ</span><span class="p">;</span>
    <span class="n">ss</span><span class="p">.</span><span class="n">ss_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sigaltstack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ss</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"sigaltstack"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 2. 配置信号处理</span>
    <span class="n">sa</span><span class="p">.</span><span class="n">sa_sigaction</span> <span class="o">=</span> <span class="n">advanced_signal_handler</span><span class="p">;</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>

    <span class="c1">// 屏蔽其他信号在处理期间</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span>

    <span class="c1">// 设置标志</span>
    <span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">SA_SIGINFO</span> <span class="o">|</span>     <span class="c1">// 使用扩展信息</span>
                  <span class="n">SA_ONSTACK</span> <span class="o">|</span>     <span class="c1">// 使用替代栈</span>
                  <span class="n">SA_RESTART</span><span class="p">;</span>      <span class="c1">// 自动重启被中断的系统调用</span>

    <span class="c1">// 3. 注册处理函数</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"sigaction"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 高级信号处理函数</span>
<span class="kt">void</span> <span class="nf">advanced_signal_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ucontext</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ucontext_t</span> <span class="o">*</span><span class="n">uc</span> <span class="o">=</span> <span class="p">(</span><span class="n">ucontext_t</span> <span class="o">*</span><span class="p">)</span><span class="n">ucontext</span><span class="p">;</span>

    <span class="c1">// 1. 记录信号信息</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"信号 %d 来自进程 %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_pid</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"信号原因: %d, 错误码: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_code</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_errno</span><span class="p">);</span>

    <span class="c1">// 2. 根据信号类型处理</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">SIGSEGV</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"段错误发生在地址: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_addr</span><span class="p">);</span>
        <span class="n">print_stack_trace</span><span class="p">(</span><span class="n">uc</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">SIGFPE</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"浮点异常，错误地址: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">si_addr</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">SIGCHLD</span><span class="p">:</span>
        <span class="n">handle_child_signal</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="nl">default:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"处理通用信号: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 3. 可选：修改上下文后继续执行</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sig</span> <span class="o">==</span> <span class="n">SIGSEGV</span> <span class="o">&amp;&amp;</span> <span class="n">can_recover_from_segv</span><span class="p">(</span><span class="n">info</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 修复错误并继续</span>
        <span class="n">fix_segmentation_fault</span><span class="p">(</span><span class="n">uc</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="34-现代信号处理的高级特性">3.4 现代信号处理的高级特性</h3> <h4 id="信号同步处理signalfd">信号同步处理：signalfd</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 使用signalfd进行同步信号处理</span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/signalfd.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">modern_signal_processor</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">signal_fd</span><span class="p">;</span>                  <span class="c1">// signalfd文件描述符</span>
    <span class="n">sigset_t</span> <span class="n">monitored_signals</span><span class="p">;</span>     <span class="c1">// 监控的信号集</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">events</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>  <span class="c1">// epoll事件数组</span>
    <span class="kt">int</span> <span class="n">epoll_fd</span><span class="p">;</span>                   <span class="c1">// epoll文件描述符</span>
<span class="p">};</span>

<span class="c1">// 初始化现代信号处理</span>
<span class="kt">int</span> <span class="nf">init_modern_signal_handling</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">modern_signal_processor</span> <span class="o">*</span><span class="n">processor</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_processor</span><span class="p">;</span>

    <span class="c1">// 1. 设置要监控的信号</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">monitored_signals</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">monitored_signals</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">monitored_signals</span><span class="p">,</span> <span class="n">SIGTERM</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">monitored_signals</span><span class="p">,</span> <span class="n">SIGCHLD</span><span class="p">);</span>
    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">monitored_signals</span><span class="p">,</span> <span class="n">SIGUSR1</span><span class="p">);</span>

    <span class="c1">// 2. 阻塞这些信号的传统处理</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">monitored_signals</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"sigprocmask"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 3. 创建signalfd</span>
    <span class="n">processor</span><span class="o">-&gt;</span><span class="n">signal_fd</span> <span class="o">=</span> <span class="n">signalfd</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">monitored_signals</span><span class="p">,</span>
                                   <span class="n">SFD_CLOEXEC</span> <span class="o">|</span> <span class="n">SFD_NONBLOCK</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">signal_fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"signalfd"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 4. 创建epoll实例</span>
    <span class="n">processor</span><span class="o">-&gt;</span><span class="n">epoll_fd</span> <span class="o">=</span> <span class="n">epoll_create1</span><span class="p">(</span><span class="n">EPOLL_CLOEXEC</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">epoll_fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_create1"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 5. 将signalfd添加到epoll中</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ev</span><span class="p">;</span>
    <span class="n">ev</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
    <span class="n">ev</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">processor</span><span class="o">-&gt;</span><span class="n">signal_fd</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">epoll_fd</span><span class="p">,</span> <span class="n">EPOLL_CTL_ADD</span><span class="p">,</span>
                  <span class="n">processor</span><span class="o">-&gt;</span><span class="n">signal_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ev</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_ctl"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 同步处理信号</span>
<span class="kt">void</span> <span class="nf">process_signals_synchronously</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">modern_signal_processor</span> <span class="o">*</span><span class="n">processor</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_processor</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 1. 等待信号或其他事件</span>
        <span class="kt">int</span> <span class="n">nfds</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">epoll_fd</span><span class="p">,</span> <span class="n">processor</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">,</span>
                             <span class="mi">16</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nfds</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="n">perror</span><span class="p">(</span><span class="s">"epoll_wait"</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 2. 处理事件</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nfds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">processor</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="n">processor</span><span class="o">-&gt;</span><span class="n">signal_fd</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">handle_signalfd_events</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 处理signalfd事件</span>
<span class="kt">void</span> <span class="nf">handle_signalfd_events</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">signalfd_siginfo</span> <span class="n">si</span><span class="p">;</span>
    <span class="kt">ssize_t</span> <span class="n">s</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">((</span><span class="n">s</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">global_processor</span><span class="p">.</span><span class="n">signal_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">si</span><span class="p">)))</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">si</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"接收到信号: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">si</span><span class="p">.</span><span class="n">ssi_signo</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"发送者PID: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">si</span><span class="p">.</span><span class="n">ssi_pid</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"发送者UID: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">si</span><span class="p">.</span><span class="n">ssi_uid</span><span class="p">);</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">si</span><span class="p">.</span><span class="n">ssi_signo</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">SIGINT</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">SIGTERM</span><span class="p">:</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"收到终止信号，开始清理...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">cleanup_and_exit</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="n">SIGCHLD</span><span class="p">:</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"子进程 %d 退出，状态: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                   <span class="n">si</span><span class="p">.</span><span class="n">ssi_pid</span><span class="p">,</span> <span class="n">si</span><span class="p">.</span><span class="n">ssi_status</span><span class="p">);</span>
            <span class="n">reap_child_processes</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="n">SIGUSR1</span><span class="p">:</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"收到用户定义信号1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">handle_user_request</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="四中断与信号的协作关系">四、中断与信号的协作关系</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>┌─────────────────────────────────────────────────────────────┐
│                        完整的事件处理流                        │
└─────────────────────────────────────────────────────────────┘

硬件层面:
├── CPU异常 ──┐
├── 外设中断 ──┼─→ [中断向量表] ─→ [内核中断处理程序]
└── 软件中断 ──┘                        │
                                        ↓
内核层面:                    ┌─────────────────────┐
                            │   内核处理逻辑        │
                            │ • 保存上下文         │
                            │ • 处理具体事件       │
                            │ • 决定是否发送信号   │
                            └─────────┬───────────┘
                                     ↓
用户层面:                  ┌─────────────────────┐
                          │   信号传递与处理      │
                          │ • 信号入队           │
                          │ • 进程调度时检查     │
                          │ • 执行信号处理函数   │
                          └─────────────────────┘
</code></pre></div></div> <table> <thead> <tr> <th>场景</th> <th>中断</th> <th>异常</th> <th>信号</th> </tr> </thead> <tbody> <tr> <td><strong>键盘输入</strong></td> <td>键盘中断 → 内核</td> <td>-</td> <td>内核 →shell 进程(信号)</td> </tr> <tr> <td><strong>除零错误</strong></td> <td>-</td> <td>CPU 异常 → 内核</td> <td>内核 → 进程(SIGFPE)</td> </tr> <tr> <td><strong>进程终止</strong></td> <td>-</td> <td>-</td> <td>kill 命令 → 目标进程(SIGTERM)</td> </tr> <tr> <td><strong>网络数据到达</strong></td> <td>网卡中断 → 内核</td> <td>-</td> <td>内核 → 网络进程(SIGIO)</td> </tr> <tr> <td><strong>定时任务</strong></td> <td>定时器中断 → 内核</td> <td>-</td> <td>内核 → 进程(SIGALRM)</td> </tr> <tr> <td><strong>内存访问违规</strong></td> <td>-</td> <td>页面错误异常 → 内核</td> <td>内核 → 进程(SIGSEGV)</td> </tr> </tbody> </table> <h3 id="41-完整的事件处理流水线">4.1 完整的事件处理流水线</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 从硬件事件到应用响应的完整流程</span>
<span class="k">struct</span> <span class="n">event_processing_pipeline</span> <span class="p">{</span>
    <span class="c1">// 阶段1：硬件事件检测</span>
    <span class="k">struct</span> <span class="n">hardware_stage</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">detect_event</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>        <span class="c1">// 事件检测</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">generate_interrupt</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>   <span class="c1">// 产生中断</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">notify_controller</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>    <span class="c1">// 通知中断控制器</span>
    <span class="p">}</span> <span class="n">hardware</span><span class="p">;</span>

    <span class="c1">// 阶段2：中断处理</span>
    <span class="k">struct</span> <span class="n">interrupt_stage</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">save_context</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>        <span class="c1">// 保存上下文</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handle_interrupt</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>     <span class="c1">// 处理中断</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">decide_signal</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>        <span class="c1">// 决定是否产生信号</span>
    <span class="p">}</span> <span class="n">interrupt</span><span class="p">;</span>

    <span class="c1">// 阶段3：信号生成</span>
    <span class="k">struct</span> <span class="n">signal_stage</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">generate_signal</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 生成信号</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">queue_signal</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>    <span class="c1">// 信号排队</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">wake_process</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>         <span class="c1">// 唤醒进程</span>
    <span class="p">}</span> <span class="n">signal</span><span class="p">;</span>

    <span class="c1">// 阶段4：用户处理</span>
    <span class="k">struct</span> <span class="n">user_stage</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">check_signals</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>       <span class="c1">// 检查信号</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handle_signal</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>        <span class="c1">// 处理信号</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">resume_execution</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>    <span class="c1">// 恢复执行</span>
    <span class="p">}</span> <span class="n">user</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 事件处理流程的具体实现</span>
<span class="kt">void</span> <span class="nf">complete_event_processing_example</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 场景：键盘按键导致进程接收SIGINT信号</span>

    <span class="c1">// 1. 硬件阶段：键盘控制器检测到按键</span>
    <span class="n">keyboard_hardware_detect_keypress</span><span class="p">();</span>

    <span class="c1">// 2. 硬件阶段：产生键盘中断</span>
    <span class="n">keyboard_generate_interrupt</span><span class="p">(</span><span class="n">IRQ_KEYBOARD</span><span class="p">);</span>

    <span class="c1">// 3. 中断阶段：CPU响应中断</span>
    <span class="n">cpu_interrupt_handler</span><span class="p">(</span><span class="n">IRQ_KEYBOARD</span><span class="p">);</span>

    <span class="c1">// 4. 中断阶段：键盘中断处理程序</span>
    <span class="n">keyboard_interrupt_handler</span><span class="p">();</span>

    <span class="c1">// 5. 信号阶段：检测到Ctrl+C组合键</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">detect_ctrl_c_combination</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// 6. 信号阶段：向前台进程发送SIGINT</span>
        <span class="n">send_signal_to_foreground_process</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 7. 用户阶段：进程在下次调度时检查信号</span>
    <span class="n">process_check_pending_signals</span><span class="p">();</span>

    <span class="c1">// 8. 用户阶段：执行信号处理函数</span>
    <span class="n">execute_sigint_handler</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="42-性能与响应时间分析">4.2 性能与响应时间分析</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 事件处理性能监控</span>
<span class="k">struct</span> <span class="n">event_performance_monitor</span> <span class="p">{</span>
    <span class="c1">// 各阶段耗时统计</span>
    <span class="k">struct</span> <span class="n">stage_timing</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">hardware_detection_time</span><span class="p">;</span>   <span class="c1">// 硬件检测时间</span>
        <span class="kt">uint64_t</span> <span class="n">interrupt_latency</span><span class="p">;</span>         <span class="c1">// 中断延迟</span>
        <span class="kt">uint64_t</span> <span class="n">interrupt_handling_time</span><span class="p">;</span>   <span class="c1">// 中断处理时间</span>
        <span class="kt">uint64_t</span> <span class="n">signal_generation_time</span><span class="p">;</span>    <span class="c1">// 信号生成时间</span>
        <span class="kt">uint64_t</span> <span class="n">signal_delivery_time</span><span class="p">;</span>      <span class="c1">// 信号传递时间</span>
        <span class="kt">uint64_t</span> <span class="n">user_handling_time</span><span class="p">;</span>        <span class="c1">// 用户处理时间</span>
        <span class="kt">uint64_t</span> <span class="n">total_response_time</span><span class="p">;</span>       <span class="c1">// 总响应时间</span>
    <span class="p">}</span> <span class="n">timing</span><span class="p">;</span>

    <span class="c1">// 性能计数器</span>
    <span class="n">atomic64_t</span> <span class="n">total_events</span><span class="p">;</span>
    <span class="n">atomic64_t</span> <span class="n">fast_path_events</span><span class="p">;</span>
    <span class="n">atomic64_t</span> <span class="n">slow_path_events</span><span class="p">;</span>
    <span class="n">atomic64_t</span> <span class="n">dropped_events</span><span class="p">;</span>

    <span class="c1">// 响应时间分布</span>
    <span class="kt">uint64_t</span> <span class="n">response_histogram</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>  <span class="c1">// 0-9个时间段</span>
<span class="p">};</span>

<span class="c1">// 性能优化策略</span>
<span class="k">struct</span> <span class="n">optimization_strategies</span> <span class="p">{</span>
    <span class="c1">// 中断优化</span>
    <span class="n">bool</span> <span class="n">interrupt_coalescing</span><span class="p">;</span>      <span class="c1">// 中断合并</span>
    <span class="n">bool</span> <span class="n">interrupt_threading</span><span class="p">;</span>       <span class="c1">// 中断线程化</span>
    <span class="n">bool</span> <span class="n">fast_interrupt_path</span><span class="p">;</span>       <span class="c1">// 快速中断路径</span>

    <span class="c1">// 信号优化</span>
    <span class="n">bool</span> <span class="n">signal_batching</span><span class="p">;</span>          <span class="c1">// 信号批处理</span>
    <span class="n">bool</span> <span class="n">realtime_signal_priority</span><span class="p">;</span> <span class="c1">// 实时信号优先级</span>
    <span class="n">bool</span> <span class="n">signal_compression</span><span class="p">;</span>       <span class="c1">// 信号压缩</span>

    <span class="c1">// 缓存优化</span>
    <span class="n">bool</span> <span class="n">hot_path_optimization</span><span class="p">;</span>    <span class="c1">// 热路径优化</span>
    <span class="n">bool</span> <span class="n">cache_line_alignment</span><span class="p">;</span>     <span class="c1">// 缓存行对齐</span>
    <span class="n">bool</span> <span class="n">prefetch_optimization</span><span class="p">;</span>    <span class="c1">// 预取优化</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="43-错误处理与恢复机制">4.3 错误处理与恢复机制</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 异常情况的处理策略</span>
<span class="k">struct</span> <span class="n">error_handling_framework</span> <span class="p">{</span>
    <span class="c1">// 中断错误处理</span>
    <span class="k">struct</span> <span class="n">interrupt_error_handling</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">spurious_interrupt</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>    <span class="c1">// 虚假中断</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">interrupt_storm</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>       <span class="c1">// 中断风暴</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler_timeout</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>       <span class="c1">// 处理超时</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">nested_overflow</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>      <span class="c1">// 嵌套溢出</span>
    <span class="p">}</span> <span class="n">interrupt_errors</span><span class="p">;</span>

    <span class="c1">// 信号错误处理</span>
    <span class="k">struct</span> <span class="n">signal_error_handling</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">queue_overflow</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>        <span class="c1">// 队列溢出</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">delivery_failure</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">// 传递失败</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler_crash</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>         <span class="c1">// 处理程序崩溃</span>
        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">infinite_loop</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>         <span class="c1">// 无限循环</span>
    <span class="p">}</span> <span class="n">signal_errors</span><span class="p">;</span>

    <span class="c1">// 恢复机制</span>
    <span class="k">struct</span> <span class="n">recovery_mechanisms</span> <span class="p">{</span>
        <span class="n">bool</span> <span class="n">automatic_retry</span><span class="p">;</span>               <span class="c1">// 自动重试</span>
        <span class="n">bool</span> <span class="n">graceful_degradation</span><span class="p">;</span>          <span class="c1">// 优雅降级</span>
        <span class="n">bool</span> <span class="n">emergency_shutdown</span><span class="p">;</span>            <span class="c1">// 紧急关闭</span>
        <span class="n">bool</span> <span class="n">checkpoint_recovery</span><span class="p">;</span>           <span class="c1">// 检查点恢复</span>
    <span class="p">}</span> <span class="n">recovery</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 错误恢复的实现示例</span>
<span class="kt">void</span> <span class="nf">implement_error_recovery</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 1. 中断风暴检测与处理</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">detect_interrupt_storm</span><span class="p">(</span><span class="n">IRQ_NETWORK</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 临时禁用中断</span>
        <span class="n">disable_irq</span><span class="p">(</span><span class="n">IRQ_NETWORK</span><span class="p">);</span>

        <span class="c1">// 启动恢复定时器</span>
        <span class="n">setup_recovery_timer</span><span class="p">(</span><span class="n">IRQ_NETWORK</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span> <span class="c1">// 1秒后重新启用</span>
    <span class="p">}</span>

    <span class="c1">// 2. 信号队列溢出处理</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal_queue_overflow_detected</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// 清理低优先级信号</span>
        <span class="n">cleanup_low_priority_signals</span><span class="p">();</span>

        <span class="c1">// 通知应用程序</span>
        <span class="n">send_signal</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">SIGUSR2</span><span class="p">);</span> <span class="c1">// 自定义溢出信号</span>
    <span class="p">}</span>

    <span class="c1">// 3. 信号处理程序崩溃恢复</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">signal_handler_crashed</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 重置为默认处理</span>
        <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">SIG_DFL</span><span class="p">);</span>

        <span class="c1">// 记录错误</span>
        <span class="n">log_signal_handler_crash</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="五实际应用场景与最佳实践">五、实际应用场景与最佳实践</h2> <h3 id="51-高性能服务器的事件处理">5.1 高性能服务器的事件处理</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 高性能Web服务器的事件处理架构</span>
<span class="k">struct</span> <span class="n">high_performance_server</span> <span class="p">{</span>
    <span class="c1">// 网络中断优化</span>
    <span class="k">struct</span> <span class="n">network_optimization</span> <span class="p">{</span>
        <span class="n">bool</span> <span class="n">napi_polling</span><span class="p">;</span>          <span class="c1">// NAPI轮询模式</span>
        <span class="n">bool</span> <span class="n">interrupt_coalescing</span><span class="p">;</span>  <span class="c1">// 中断合并</span>
        <span class="n">bool</span> <span class="n">rss_support</span><span class="p">;</span>          <span class="c1">// RSS多队列支持</span>
        <span class="kt">int</span> <span class="n">irq_affinity</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>      <span class="c1">// 中断亲和性设置</span>
    <span class="p">}</span> <span class="n">network</span><span class="p">;</span>

    <span class="c1">// 信号处理优化</span>
    <span class="k">struct</span> <span class="n">signal_optimization</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">signalfd</span><span class="p">;</span>              <span class="c1">// 使用signalfd</span>
        <span class="n">bool</span> <span class="n">self_pipe_trick</span><span class="p">;</span>      <span class="c1">// 自管道技巧</span>
        <span class="n">bool</span> <span class="n">signal_masking</span><span class="p">;</span>       <span class="c1">// 信号屏蔽</span>
        <span class="n">sigset_t</span> <span class="n">worker_mask</span><span class="p">;</span>      <span class="c1">// 工作线程信号掩码</span>
    <span class="p">}</span> <span class="n">signals</span><span class="p">;</span>

    <span class="c1">// 事件循环优化</span>
    <span class="k">struct</span> <span class="n">event_loop_optimization</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">epoll_fd</span><span class="p">;</span>              <span class="c1">// epoll文件描述符</span>
        <span class="n">bool</span> <span class="n">edge_triggered</span><span class="p">;</span>       <span class="c1">// 边缘触发模式</span>
        <span class="kt">int</span> <span class="n">max_events</span><span class="p">;</span>           <span class="c1">// 最大事件数</span>
        <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">;</span> <span class="c1">// 事件数组</span>
    <span class="p">}</span> <span class="n">event_loop</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 服务器事件处理主循环</span>
<span class="kt">void</span> <span class="nf">server_event_loop</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">high_performance_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_server</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">shutdown_requested</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 1. 等待事件（网络I/O、信号等）</span>
        <span class="kt">int</span> <span class="n">nfds</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">event_loop</span><span class="p">.</span><span class="n">epoll_fd</span><span class="p">,</span>
                             <span class="n">server</span><span class="o">-&gt;</span><span class="n">event_loop</span><span class="p">.</span><span class="n">events</span><span class="p">,</span>
                             <span class="n">server</span><span class="o">-&gt;</span><span class="n">event_loop</span><span class="p">.</span><span class="n">max_events</span><span class="p">,</span>
                             <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nfds</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 被信号中断，继续</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">handle_epoll_error</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 2. 处理所有就绪事件</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nfds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">ev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">event_loop</span><span class="p">.</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">==</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">signals</span><span class="p">.</span><span class="n">signalfd</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 处理信号事件</span>
                <span class="n">handle_signal_events</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 处理网络读事件</span>
                <span class="n">handle_network_read</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLOUT</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 处理网络写事件</span>
                <span class="n">handle_network_write</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">EPOLLERR</span> <span class="o">|</span> <span class="n">EPOLLHUP</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// 处理错误事件</span>
                <span class="n">handle_connection_error</span><span class="p">(</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 3. 处理延迟任务</span>
        <span class="n">process_deferred_tasks</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="52-实时系统的中断与信号管理">5.2 实时系统的中断与信号管理</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 实时系统的优先级管理</span>
<span class="k">struct</span> <span class="n">realtime_priority_manager</span> <span class="p">{</span>
    <span class="c1">// 中断优先级配置</span>
    <span class="k">struct</span> <span class="n">interrupt_priority_config</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">critical_irqs</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>       <span class="c1">// 关键中断列表</span>
        <span class="kt">int</span> <span class="n">rt_irqs</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>           <span class="c1">// 实时中断列表</span>
        <span class="kt">int</span> <span class="n">normal_irqs</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>       <span class="c1">// 普通中断列表</span>

        <span class="kt">uint64_t</span> <span class="n">max_interrupt_latency</span><span class="p">;</span> <span class="c1">// 最大中断延迟</span>
        <span class="kt">uint64_t</span> <span class="n">max_handling_time</span><span class="p">;</span>     <span class="c1">// 最大处理时间</span>
    <span class="p">}</span> <span class="n">interrupt_config</span><span class="p">;</span>

    <span class="c1">// 信号优先级配置</span>
    <span class="k">struct</span> <span class="n">signal_priority_config</span> <span class="p">{</span>
        <span class="n">sigset_t</span> <span class="n">rt_signals</span><span class="p">;</span>        <span class="c1">// 实时信号集</span>
        <span class="n">sigset_t</span> <span class="n">critical_signals</span><span class="p">;</span>  <span class="c1">// 关键信号集</span>

        <span class="kt">int</span> <span class="n">rt_signal_priority</span><span class="p">[</span><span class="mi">33</span><span class="p">];</span> <span class="c1">// 实时信号优先级</span>
        <span class="kt">uint64_t</span> <span class="n">max_signal_latency</span><span class="p">;</span> <span class="c1">// 最大信号延迟</span>
    <span class="p">}</span> <span class="n">signal_config</span><span class="p">;</span>

    <span class="c1">// 调度策略</span>
    <span class="k">struct</span> <span class="n">scheduling_policy</span> <span class="p">{</span>
        <span class="n">bool</span> <span class="n">preempt_disable</span><span class="p">;</span>       <span class="c1">// 禁用抢占</span>
        <span class="n">bool</span> <span class="n">interrupt_disable</span><span class="p">;</span>     <span class="c1">// 禁用中断</span>
        <span class="kt">int</span> <span class="n">cpu_isolation</span><span class="p">;</span>         <span class="c1">// CPU隔离</span>
        <span class="kt">int</span> <span class="n">rt_throttling</span><span class="p">;</span>         <span class="c1">// 实时节流</span>
    <span class="p">}</span> <span class="n">scheduling</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 实时系统的信号处理</span>
<span class="kt">void</span> <span class="nf">setup_realtime_signal_handling</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">sched_param</span> <span class="n">param</span><span class="p">;</span>
    <span class="n">sigset_t</span> <span class="n">rt_set</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">sa</span><span class="p">;</span>

    <span class="c1">// 1. 设置实时调度策略</span>
    <span class="n">param</span><span class="p">.</span><span class="n">sched_priority</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span> <span class="c1">// 最高优先级</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sched_setscheduler</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SCHED_FIFO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"sched_setscheduler"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 2. 设置实时信号</span>
    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_set</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">SIGRTMIN</span><span class="p">;</span> <span class="n">sig</span> <span class="o">&lt;=</span> <span class="n">SIGRTMAX</span><span class="p">;</span> <span class="n">sig</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rt_set</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 3. 配置实时信号处理</span>
    <span class="n">sa</span><span class="p">.</span><span class="n">sa_sigaction</span> <span class="o">=</span> <span class="n">realtime_signal_handler</span><span class="p">;</span>
    <span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span> <span class="o">=</span> <span class="n">rt_set</span><span class="p">;</span>
    <span class="n">sa</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">SA_SIGINFO</span> <span class="o">|</span> <span class="n">SA_RESTART</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">sig</span> <span class="o">=</span> <span class="n">SIGRTMIN</span><span class="p">;</span> <span class="n">sig</span> <span class="o">&lt;=</span> <span class="n">SIGRTMAX</span><span class="p">;</span> <span class="n">sig</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sigaction</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 4. 锁定内存防止页面交换</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mlockall</span><span class="p">(</span><span class="n">MCL_CURRENT</span> <span class="o">|</span> <span class="n">MCL_FUTURE</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"mlockall"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 实时信号处理函数</span>
<span class="kt">void</span> <span class="nf">realtime_signal_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">context</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 记录处理开始时间</span>
    <span class="k">struct</span> <span class="n">timespec</span> <span class="n">start_time</span><span class="p">;</span>
    <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_time</span><span class="p">);</span>

    <span class="c1">// 根据信号优先级处理</span>
    <span class="kt">int</span> <span class="n">priority</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">-</span> <span class="n">SIGRTMIN</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">priority</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">// 最高优先级</span>
        <span class="n">handle_critical_realtime_event</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">handle_high_priority_event</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
        <span class="n">handle_normal_realtime_event</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 检查处理时间</span>
    <span class="k">struct</span> <span class="n">timespec</span> <span class="n">end_time</span><span class="p">;</span>
    <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end_time</span><span class="p">);</span>

    <span class="kt">uint64_t</span> <span class="n">elapsed_ns</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_time</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000000</span> <span class="o">+</span>
                         <span class="p">(</span><span class="n">end_time</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">elapsed_ns</span> <span class="o">&gt;</span> <span class="n">MAX_RT_SIGNAL_HANDLING_TIME</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">log_rt_violation</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">elapsed_ns</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="53-调试和性能分析工具">5.3 调试和性能分析工具</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 中断与信号的调试框架</span>
<span class="k">struct</span> <span class="n">debug_framework</span> <span class="p">{</span>
    <span class="c1">// 跟踪功能</span>
    <span class="k">struct</span> <span class="n">tracing_capabilities</span> <span class="p">{</span>
        <span class="n">bool</span> <span class="n">interrupt_tracing</span><span class="p">;</span>     <span class="c1">// 中断跟踪</span>
        <span class="n">bool</span> <span class="n">signal_tracing</span><span class="p">;</span>       <span class="c1">// 信号跟踪</span>
        <span class="n">bool</span> <span class="n">latency_tracing</span><span class="p">;</span>      <span class="c1">// 延迟跟踪</span>
        <span class="n">bool</span> <span class="n">call_stack_tracing</span><span class="p">;</span>   <span class="c1">// 调用栈跟踪</span>
    <span class="p">}</span> <span class="n">tracing</span><span class="p">;</span>

    <span class="c1">// 统计信息</span>
    <span class="k">struct</span> <span class="n">statistics</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">interrupt_counts</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>    <span class="c1">// 中断计数</span>
        <span class="kt">uint64_t</span> <span class="n">signal_counts</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>        <span class="c1">// 信号计数</span>
        <span class="kt">uint64_t</span> <span class="n">latency_histogram</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>   <span class="c1">// 延迟直方图</span>
        <span class="kt">uint64_t</span> <span class="n">error_counts</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>         <span class="c1">// 错误计数</span>
    <span class="p">}</span> <span class="n">stats</span><span class="p">;</span>

    <span class="c1">// 调试接口</span>
    <span class="k">struct</span> <span class="n">debug_interfaces</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">debugfs_root</span><span class="p">;</span>          <span class="c1">// debugfs根目录</span>
        <span class="kt">int</span> <span class="n">proc_entries</span><span class="p">;</span>          <span class="c1">// proc条目</span>
        <span class="kt">int</span> <span class="n">sysfs_attributes</span><span class="p">;</span>      <span class="c1">// sysfs属性</span>
        <span class="kt">int</span> <span class="n">trace_events</span><span class="p">;</span>          <span class="c1">// trace事件</span>
    <span class="p">}</span> <span class="n">interfaces</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 性能分析工具实现</span>
<span class="kt">void</span> <span class="nf">implement_performance_analysis</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 1. 创建debugfs接口</span>
    <span class="n">create_debugfs_entries</span><span class="p">();</span>

    <span class="c1">// 2. 注册trace事件</span>
    <span class="n">register_trace_events</span><span class="p">();</span>

    <span class="c1">// 3. 启动性能监控</span>
    <span class="n">start_performance_monitoring</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// debugfs接口示例</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">interrupt_stats_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
                                   <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">4096</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">tmp</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">-</span> <span class="n">len</span><span class="p">,</span>
                   <span class="s">"Interrupt Statistics:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">interrupt_stats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">tmp</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="o">-</span> <span class="n">len</span><span class="p">,</span>
                           <span class="s">"IRQ %d: %llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">interrupt_stats</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">simple_read_from_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// trace事件定义</span>
<span class="n">TRACE_EVENT</span><span class="p">(</span><span class="n">interrupt_entry</span><span class="p">,</span>
    <span class="n">TP_PROTO</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">),</span>
    <span class="n">TP_ARGS</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span>
    <span class="n">TP_STRUCT__entry</span><span class="p">(</span>
        <span class="n">__field</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">irq</span><span class="p">)</span>
        <span class="n">__string</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">__field</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="n">TP_fast_assign</span><span class="p">(</span>
        <span class="n">__entry</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
        <span class="n">__assign_str</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
        <span class="n">__entry</span><span class="o">-&gt;</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">local_clock</span><span class="p">();</span>
    <span class="p">),</span>
    <span class="n">TP_printk</span><span class="p">(</span><span class="s">"irq=%d name=%s timestamp=%llu"</span><span class="p">,</span>
              <span class="n">__entry</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">__get_str</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">__entry</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div> <h2 id="六知识体系总结构建完整的认知框架">六、知识体系总结：构建完整的认知框架</h2> <h3 id="61-核心概念的层次关系">6.1 核心概念的层次关系</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                    异步事件处理知识体系
                           |
    ┌─────────────────────┼─────────────────────┐
    |                     |                     |
硬件事件层              系统处理层              应用响应层
    |                     |                     |
┌───┴───┐           ┌─────┴─────┐         ┌─────┴─────┐
|       |           |           |         |           |
设备    CPU        中断        信号      用户        应用
中断    异常       处理        生成      处理        逻辑
|       |           |           |         |           |
└───┬───┘           └─────┬─────┘         └─────┬─────┘
    |                     |                     |
    └─────────────────────┼─────────────────────┘
                          |
                    性能与可靠性保证
                          |
                ┌─────────┼─────────┐
                |         |         |
            响应时间    错误处理    资源管理
            优化       与恢复      与调度
</code></pre></div></div> <h3 id="62-技术演进的历史脉络">6.2 技术演进的历史脉络</h3> <ol> <li> <p><strong>第一阶段：基础机制建立（1960s-1970s）</strong></p> <ul> <li>中断机制的引入，解决 CPU 与 I/O 设备的协调问题</li> <li>简单信号机制，提供基本的进程间通知能力</li> <li>异常处理，保证系统对错误情况的基本应对</li> </ul> </li> <li> <p><strong>第二阶段：机制完善与标准化（1980s-1990s）</strong></p> <ul> <li>POSIX 信号标准化，统一不同 Unix 系统的信号接口</li> <li>中断优先级和嵌套机制，提高系统响应能力</li> <li>信号掩码和可靠信号，解决信号丢失问题</li> </ul> </li> <li> <p><strong>第三阶段：性能优化与扩展（2000s-2010s）</strong></p> <ul> <li>实时信号引入，支持更复杂的应用需求</li> <li>中断线程化，改善实时性能</li> <li>新型同步接口（signalfd、eventfd 等）</li> </ul> </li> <li> <p><strong>第四阶段：现代化与融合（2010s-现在）</strong></p> <ul> <li>统一的事件通知机制（epoll、kqueue 等）</li> <li>用户态中断处理技术</li> <li>容器化环境下的信号和中断处理</li> </ul> </li> </ol> <h3 id="63-关键设计原则的权衡">6.3 关键设计原则的权衡</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 设计权衡的核心考量</span>
<span class="k">struct</span> <span class="n">design_tradeoffs</span> <span class="p">{</span>
    <span class="c1">// 性能 vs 复杂度</span>
    <span class="k">struct</span> <span class="n">performance_complexity</span> <span class="p">{</span>
        <span class="n">bool</span> <span class="n">fast_path_optimization</span><span class="p">;</span>    <span class="c1">// 快路径优化</span>
        <span class="n">bool</span> <span class="n">feature_completeness</span><span class="p">;</span>      <span class="c1">// 功能完整性</span>
        <span class="kt">int</span> <span class="n">code_maintainability</span><span class="p">;</span>       <span class="c1">// 代码可维护性</span>
    <span class="p">}</span> <span class="n">perf_complex</span><span class="p">;</span>

    <span class="c1">// 实时性 vs 吞吐量</span>
    <span class="k">struct</span> <span class="n">realtime_throughput</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">max_interrupt_latency</span><span class="p">;</span>  <span class="c1">// 最大中断延迟</span>
        <span class="kt">uint64_t</span> <span class="n">system_throughput</span><span class="p">;</span>      <span class="c1">// 系统吞吐量</span>
        <span class="n">bool</span> <span class="n">preemption_control</span><span class="p">;</span>         <span class="c1">// 抢占控制</span>
    <span class="p">}</span> <span class="n">rt_throughput</span><span class="p">;</span>

    <span class="c1">// 安全性 vs 灵活性</span>
    <span class="k">struct</span> <span class="n">security_flexibility</span> <span class="p">{</span>
        <span class="n">bool</span> <span class="n">strict_permission_check</span><span class="p">;</span>    <span class="c1">// 严格权限检查</span>
        <span class="n">bool</span> <span class="n">signal_spoofing_protection</span><span class="p">;</span> <span class="c1">// 信号欺骗保护</span>
        <span class="kt">int</span> <span class="n">user_customization_level</span><span class="p">;</span>    <span class="c1">// 用户定制化程度</span>
    <span class="p">}</span> <span class="n">sec_flex</span><span class="p">;</span>

    <span class="c1">// 向后兼容 vs 创新发展</span>
    <span class="k">struct</span> <span class="n">compatibility_innovation</span> <span class="p">{</span>
        <span class="n">bool</span> <span class="n">legacy_api_support</span><span class="p">;</span>         <span class="c1">// 传统API支持</span>
        <span class="n">bool</span> <span class="n">modern_interface_adoption</span><span class="p">;</span>  <span class="c1">// 现代接口采用</span>
        <span class="kt">int</span> <span class="n">migration_complexity</span><span class="p">;</span>        <span class="c1">// 迁移复杂度</span>
    <span class="p">}</span> <span class="n">compat_innov</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="64-未来发展趋势">6.4 未来发展趋势</h3> <ol> <li> <p><strong>硬件辅助的信号处理</strong></p> <ul> <li>硬件支持的用户态中断</li> <li>智能中断控制器</li> <li>基于 AI 的中断预测和调度</li> </ul> </li> <li> <p><strong>容器和微服务环境适配</strong></p> <ul> <li>容器间信号隔离</li> <li>微服务中断聚合</li> <li>云原生的信号处理模式</li> </ul> </li> <li> <p><strong>新兴计算模式的支持</strong></p> <ul> <li>边缘计算的实时信号处理</li> <li>量子计算中的错误信号</li> <li>神经形态计算的事件驱动模型</li> </ul> </li> </ol> <h3 id="65-学习建议与实践路径">6.5 学习建议与实践路径</h3> <ol> <li> <p><strong>基础理论掌握</strong></p> <ul> <li>深入理解硬件中断机制</li> <li>掌握信号的 POSIX 标准</li> <li>学习操作系统内核实现</li> </ul> </li> <li> <p><strong>编程实践经验</strong></p> <ul> <li>编写信号处理程序</li> <li>实现高性能事件循环</li> <li>调试中断和信号问题</li> </ul> </li> <li> <p><strong>系统级优化能力</strong></p> <ul> <li>性能分析和调优</li> <li>实时系统设计</li> <li>故障诊断和恢复</li> </ul> </li> <li> <p><strong>持续学习方向</strong></p> <ul> <li>关注新硬件特性</li> <li>跟踪内核发展动态</li> <li>参与开源项目贡献</li> </ul> </li> </ol> <p>这个知识体系展现了从硬件中断到用户信号处理的完整技术栈，理解这些机制及其相互关系，有助于构建高性能、高可靠性的系统级应用程序。</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/6_internet.md/">（七）内核那些事儿：操作系统对网络包的处理</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/5_fileSystem.md/">（六）内核那些事儿：文件系统</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/4_interaction.md/">（五）内核那些事儿：系统和程序的交互</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_device.md/">（四）内核那些事儿：设备管理与驱动开发</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/1_program.md/">（二）内核那些事儿：程序启动到运行的完整过程</a> </li> </div> </div> <div class="col-sm-4"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <script src="/assets/js/toc-depth.js"></script> </body> </html>