<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 指针那些事儿 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A blog for documenting my own study notes. "> <meta name="keywords" content="blog, cpp, programmer"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="stylesheet" href="/assets/css/toc-custom.css"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/0_pointer.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-8"> <div class="post"> <header class="post-header"> <h1 class="post-title">指针那些事儿</h1> <p class="post-meta"> Created on September 15, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/pointer"> <i class="fa-solid fa-hashtag fa-sm"></i> Pointer</a>   ·   <a href="/blog/category/c"> <i class="fa-solid fa-tag fa-sm"></i> C++</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="指针那些事儿">指针那些事儿</h2> <h3 id="1-指针的本质与内存模型">1. 指针的本质与内存模型</h3> <h4 id="11-指针的核心概念">1.1 指针的核心概念</h4> <p>指针的主要目的在于表示内存中的数据。在此，我们先简要回顾内存存储数据的机制。</p> <p>内存由众多单元格组成，每个单元格都被赋予一个唯一的地址。每个单元格的存储容量为一个字节，这恰好与 <code class="language-plaintext highlighter-rouge">char</code> 类型所占的空间大小一致。从硬件层面而言，系统提供了依据地址获取存储数据的方法。一份数据在内存中存储时，可能占用一个单元格，也可能由若干连续的单元格共同存储。</p> <p>那么，若要表示内存中的一份数据，可行的方式有哪些呢？</p> <ol> <li> <strong>记录所有单元格地址</strong>：记录该数据所有单元格对应的地址</li> <li> <strong>记录首地址+长度</strong>：基于数据连续存储的特性，仅需记录首地址和数据长度</li> </ol> <p>显然，第二种方式更为高效。而指针，本质上就是基于第二种方式的一种表达方式。</p> <p>进一步来讲，数据总长度信息与数据类型信息在本质上是等价的。因为一种数据类型实际上就明确了存储该数据所需占用的单元格数量。然而，使用数据总长度来描述数据的存储需求，在表达上可能会引发歧义。因此，在编程中，人们更倾向于使用数据类型来表示数据长度这一概念。</p> <p>再进一步分析，数据类型对于编译器而言，决定了其对首地址数据的解读方式。编译器的主要功能是将 C/C++ 等高级语言转换为汇编语言，而在汇编语言层面，并不存在自定义类型长度的概念。当程序中使用自定义类型时，编译器会对该类型进行解析，明确表示该数据所需的单元格数量。在编译器生成汇编语言代码的过程中，会直接指定按照相应数量的单元格去读取数据。所以，也有人认为，数据类型的重要意义在于告知编译器应采用何种格式去读取特定地址处的数据。</p> <h4 id="12-指针的组成要素">1.2 指针的组成要素</h4> <p><strong>指针 = 类型信息（数据长度） + 内存地址</strong></p> <p>数据类型对于编译器而言，决定了其对首地址数据的解读方式：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">demonstratePointerEssence</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>

    <span class="c1">// 同一块内存，不同类型指针的解释</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">int_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">char_ptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
    <span class="kt">short</span><span class="o">*</span> <span class="n">short_ptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"内存地址: "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"int指针解释: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">int_ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"char指针解释: "</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">char_ptr</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"short指针解释: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">short_ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 指针算术：类型决定步长</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">指针算术演示:"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"int_ptr: "</span> <span class="o">&lt;&lt;</span> <span class="n">int_ptr</span> <span class="o">&lt;&lt;</span> <span class="s">" -&gt; "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">int_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"char_ptr: "</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">char_ptr</span><span class="p">)</span>
              <span class="o">&lt;&lt;</span> <span class="s">" -&gt; "</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">char_ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="13-内存对齐与硬件亲和性">1.3 内存对齐与硬件亲和性</h4> <p>内存访问并非逐字节进行，而是按”行”（缓存行）操作：</p> <h4 id="14-指针的大小">1.4 指针的大小</h4> <p>在特定的系统架构中，各类指针在内存中所占据的空间大小通常是一致的。这背后的原因在于，指针的核心功能是存储内存地址，而地址空间的规模是由硬件与操作系统共同确定的，并非取决于指针所指向的数据类型。</p> <p>在常见的 32 位系统里，不管指针指向的是<code class="language-plaintext highlighter-rouge">int</code>类型数据（如<code class="language-plaintext highlighter-rouge">int*</code>）、<code class="language-plaintext highlighter-rouge">char</code>类型数据（如<code class="language-plaintext highlighter-rouge">char*</code>），还是<code class="language-plaintext highlighter-rouge">double</code>类型数据（如<code class="language-plaintext highlighter-rouge">double*</code>）等，指针自身的大小一般为 4 字节，换算成二进制位即 32 位。这是因为 32 位系统的地址总线宽度为 32 位，它所能表示的地址范围决定了指针需占用 4 字节来存储完整的内存地址。</p> <p>而在 64 位系统环境下，情况类似，几乎所有类型的指针，无论其指向何种数据类型，通常大小为 8 字节，也就是 64 位。64 位系统的地址总线更宽，能够处理更大的地址空间，因此需要 8 字节来存储一个内存地址。</p> <p>需要留意的是，尽管上述情况是普遍现象，但在使用特殊编译器选项，或者处于某些特定的虚拟化环境时，即便在 32 位系统中，也存在将指针配置为 64 位的可能性。不过，这种情形相对罕见，在常规的 32 位系统应用开发中，指针大小基本遵循 4 字节的标准。</p> <h4 id="15-指针的种类有哪些">1.5 指针的种类有哪些</h4> <p>在 C 和 C++编程中，指针是一种强大而灵活的工具，具有多种类型，每种类型都有其特定的用途和特点。以下详细介绍各类指针：</p> <ol> <li> <code class="language-plaintext highlighter-rouge">基本对象指针</code>：这类指针指向基本数据类型。例如，<code class="language-plaintext highlighter-rouge">int* p;</code> 这条语句定义了一个指针 <code class="language-plaintext highlighter-rouge">p</code>，它专门用于指向整型数据。通过这个指针，程序可以直接访问和操作内存中存储的整型值。</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">demonstrateBasicPointers</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 1. 基本对象指针</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">int_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"基本指针: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">int_ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 2. void指针：通用但需要转换</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">void_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">;</span>
    <span class="c1">// std::cout &lt;&lt; *void_ptr;  // 错误：无法解引用void*</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">converted</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">void_ptr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"void指针转换后: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">converted</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 3. 空指针：现代C++推荐nullptr</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">null_ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  <span class="c1">// C++11推荐</span>
    <span class="c1">// int* old_null = NULL;  // 不推荐，可能是0</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">null_ptr</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"安全的空指针检查"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <ol> <li> <p>``void<code class="language-plaintext highlighter-rouge">指针</code>：<code class="language-plaintext highlighter-rouge">void*</code>是一种特殊的指针类型，它具有通用性，可以指向任何类型的数据。通常在需要存储任意类型地址的场景中使用，比如在编写通用函数时，其参数可能接受不同类型的数据地址，这时就可以使用<code class="language-plaintext highlighter-rouge">void*</code>指针。但需要注意的是，由于<code class="language-plaintext highlighter-rouge">void</code> 指针没有明确的数据类型，在使用它访问所指向的数据时，通常需要进行类型转换，将其转换为具体的数据类型指针，以便编译器能够正确解析和处理数据。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">常量指针与指向常量的指针</code>：这是两个容易混淆但概念截然不同的指针类型，同时还有指向常量的常量指针。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">指向常量的指针</code>：以 <code class="language-plaintext highlighter-rouge">const int* p;</code> 为例，这里定义的指针 <code class="language-plaintext highlighter-rouge">p</code> 可以指向一个整型常量。这种指针的特点是，不能通过它来修改所指向的值，这为数据提供了一定的保护机制，防止意外的修改。但指针本身可以指向其他的整型常量或变量。</li> <li> <code class="language-plaintext highlighter-rouge">常量指针</code>：如 <code class="language-plaintext highlighter-rouge">int* const p;</code>，此指针 <code class="language-plaintext highlighter-rouge">p</code> 本身是一个常量。一旦初始化后，它所指向的地址就不能再改变，但通过这个指针可以修改其所指向的值。这在一些需要固定指向某个特定内存位置的场景中很有用。</li> <li> <code class="language-plaintext highlighter-rouge">指向常量的常量指针</code>：<code class="language-plaintext highlighter-rouge">const int* const p;</code> 定义的指针既不能改变它所指向的地址，也不能通过它修改所指向的值，为数据和指针本身都提供了最高级别的保护。</li> </ul> </li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">demonstrateConstPointers</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">value2</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">const_value</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>

    <span class="c1">// 1. 指向常量的指针（可重新指向，不可修改值）</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">ptr_to_const</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">value1</span><span class="p">;</span>
    <span class="c1">// *ptr_to_const = 15;  // 错误：不能修改指向的值</span>
    <span class="n">ptr_to_const</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">value2</span><span class="p">;</span>  <span class="c1">// 正确：可以重新指向</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"指向常量的指针: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr_to_const</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 2. 常量指针（不可重新指向，可修改值）</span>
    <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">const_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">value1</span><span class="p">;</span>
    <span class="o">*</span><span class="n">const_ptr</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>         <span class="c1">// 正确：可以修改指向的值</span>
    <span class="c1">// const_ptr = &amp;value2;  // 错误：不能重新指向</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"常量指针: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">const_ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 3. 指向常量的常量指针（都不可改变）</span>
    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">const_ptr_to_const</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">const_value</span><span class="p">;</span>
    <span class="c1">// *const_ptr_to_const = 35;     // 错误：不能修改值</span>
    <span class="c1">// const_ptr_to_const = &amp;value1; // 错误：不能重新指向</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"常量指针指向常量: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">const_ptr_to_const</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ol> <li> <code class="language-plaintext highlighter-rouge">函数指针</code>：函数指针用于指向函数，它存储的是函数在内存中的地址。通过函数指针，可以像调用普通函数一样调用其所指向的函数。例如，<code class="language-plaintext highlighter-rouge">void (*func_ptr)(int);</code> 定义了一个名为 <code class="language-plaintext highlighter-rouge">func_ptr</code> 的指针，它指向一个接受一个整型参数且无返回值的函数。这种机制使得程序在运行时能够根据不同的条件动态选择要执行的函数，增加了程序的灵活性和可扩展性。</li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span>
<span class="c1">// 目标函数</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">multiply</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">void</span> <span class="nf">demonstrateFunctionPointers</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 传统函数指针语法</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">operation</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"函数指针结果: "</span> <span class="o">&lt;&lt;</span> <span class="n">operation</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 切换函数</span>
    <span class="n">operation</span> <span class="o">=</span> <span class="n">multiply</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"切换后结果: "</span> <span class="o">&lt;&lt;</span> <span class="n">operation</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 现代C++：std::function（更类型安全）</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">modern_op</span> <span class="o">=</span> <span class="n">add</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"std::function结果: "</span> <span class="o">&lt;&lt;</span> <span class="n">modern_op</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 函数指针数组</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">operations</span><span class="p">[])(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span><span class="n">add</span><span class="p">,</span> <span class="n">multiply</span><span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"操作 "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">": "</span> <span class="o">&lt;&lt;</span> <span class="n">operations</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Lambda表达式</span>
    <span class="k">auto</span> <span class="n">lambda_op</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">func_lambda</span> <span class="o">=</span> <span class="n">lambda_op</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Lambda结果: "</span> <span class="o">&lt;&lt;</span> <span class="n">func_lambda</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ol> <li> <p><code class="language-plaintext highlighter-rouge">数组指针与指向数组的指针</code>：在数组与指针的关系中，存在数组指针和指向数组的指针这两种概念，需要清晰区分。</p> <ul> <li> <code class="language-plaintext highlighter-rouge">数组名与指针的关系</code>：在 C 和 C++中，数组名在很多情况下可以视为指向其首元素的指针。例如，定义 <code class="language-plaintext highlighter-rouge">int arr[10];</code> 后，<code class="language-plaintext highlighter-rouge">int* ptr = arr;</code> 这种赋值是合法的，此时 <code class="language-plaintext highlighter-rouge">ptr</code> 就指向了数组 <code class="language-plaintext highlighter-rouge">arr</code> 的第一个元素。</li> <li> <code class="language-plaintext highlighter-rouge">指向数组的指针</code>：可以声明专门指向整个数组的指针，例如 <code class="language-plaintext highlighter-rouge">int (*ptr_to_array)[10];</code>。这里 <code class="language-plaintext highlighter-rouge">ptr_to_array</code> 是一个指针，它指向一个包含 10 个整型元素的数组。与指向数组首元素的指针不同，这种指针在移动时，每次移动的步长是整个数组的大小，而不是单个元素的大小。</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">多级指针</code>：多级指针是指针的指针，例如 <code class="language-plaintext highlighter-rouge">int **ptr;</code> 定义了一个二级指针 <code class="language-plaintext highlighter-rouge">ptr</code>。它指向的是一个指针，而这个指针又指向一个整型数据。通过多级指针，可以构建更复杂的数据结构，并且在处理动态分配的多维数组等场景中非常有用。多级指针的概念可以扩展到更多级别，如三级指针 <code class="language-plaintext highlighter-rouge">int ***ptr;</code> 等，每增加一级，指针所指向的对象就是下一级的指针。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">成员指针</code>：成员指针专门用于指向类的非静态成员变量。例如，<code class="language-plaintext highlighter-rouge">int MyClass::*ptr;</code> 定义了一个指针 <code class="language-plaintext highlighter-rouge">ptr</code>，它可以指向 <code class="language-plaintext highlighter-rouge">MyClass</code> 类中的某个整型成员。使用成员指针可以在运行时动态地访问类的不同成员变量，这在一些需要灵活操作类成员的场景中非常实用，比如在实现反射机制或某些通用的类操作算法时。</p> </li> </ol> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">static_data</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">display</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"MyClass数据: "</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">setData</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">static_data</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">demonstrateMemberPointers</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyClass</span> <span class="n">obj</span><span class="p">;</span>

    <span class="c1">// 成员变量指针</span>
    <span class="kt">int</span> <span class="n">MyClass</span><span class="o">::*</span><span class="n">member_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">data</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"通过成员指针访问: "</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="o">*</span><span class="n">member_ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 修改成员变量</span>
    <span class="n">obj</span><span class="p">.</span><span class="o">*</span><span class="n">member_ptr</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"修改后: "</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="o">*</span><span class="n">member_ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 成员函数指针</span>
    <span class="kt">void</span> <span class="p">(</span><span class="n">MyClass</span><span class="o">::*</span><span class="n">func_ptr</span><span class="p">)()</span> <span class="k">const</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">display</span><span class="p">;</span>
    <span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="o">*</span><span class="n">func_ptr</span><span class="p">)();</span>

    <span class="kt">void</span> <span class="p">(</span><span class="n">MyClass</span><span class="o">::*</span><span class="n">setter_ptr</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">setData</span><span class="p">;</span>
    <span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="o">*</span><span class="n">setter_ptr</span><span class="p">)(</span><span class="mi">77</span><span class="p">);</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>

    <span class="c1">// 静态成员不需要成员指针</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">static_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">MyClass</span><span class="o">::</span><span class="n">static_data</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"静态成员: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">static_ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="16-总结">1.6 总结</h4> <p>综上所述，指针的本质可归结为类型（与数据长度等价）和地址两个关键要素。</p> <p>在现代计算机系统中，无论指针指向何种数据类型，其自身占用的内存大小通常是固定的，且与计算机的位数相关。以常见情况为例，在 64 位计算机系统中，指针一般占用 8 字节的内存空间。</p> <p>指针类型具有重要作用，它指导编译器如何解读特定地址中的内存内容以及确定该内容的大小。例如，<code class="language-plaintext highlighter-rouge">int*</code> 类型的指针会使编译器按照 <code class="language-plaintext highlighter-rouge">int</code> 类型的长度和格式去解释所指向地址处的内存数据。</p> <p><code class="language-plaintext highlighter-rouge">void*</code> 指针较为特殊，它能够存储一个地址，但由于其未明确所指对象的数据类型，因此无法直接通过它对所指对象进行操作，因为此时无法确定其覆盖的地址空间范围及数据格式。</p> <p>在使用指针进行内存操作时，硬件亲和性是一个不容忽视的重要因素。内存访问并非简单地逐个地址获取数据，实际上，它通常遵循一定的模式，按 “行” 进行操作。例如，当通过指针访问 <code class="language-plaintext highlighter-rouge">int</code> 类型（4 字节数据）的数据时，并非分四次分别访问对应的四个字节地址，而是一次性访问包含这四个字节的一行内存空间。字节对齐机制正是基于这种内存访问模式而产生的。字节对齐能够确保数据在内存中的存储方式符合硬件高效访问的要求，从而显著提升内存访问效率，使基于指针的内存操作更为顺畅和高效。</p> <p>进一步深入分析，内存访问过程通常是先查询高速缓存，若未命中再查询内存。这里提到的 “行” 的大小，实际上由高速缓存决定。综合各种因素考量，目前常见的缓存行大小一般为 64 字节，这相当于 8 个地址长度，或者说能够容纳 16 个 <code class="language-plaintext highlighter-rouge">int</code> 型数据。</p> <p>值得注意的是，当读取非内存对齐的数据时，可能会出现数据读取的原子性问题。例如，若一个数据需要读取两行才能完整获取，在读完第一行后，第二行的数据有可能在读取前被修改。不过，随着计算机硬件技术的不断发展，部分硬件已能够保证此类数据读取的原子性。</p> <p>基于上述内存访问机制与指针操作原理，当面临存储同一类型数据多次且要求连续存储的需求时，应如何实现呢？</p> <h3 id="2-数组与指针的深度关系">2. 数组与指针的深度关系</h3> <p>在处理连续存储同一类型数据多次的需求时，常见的思路有以下两种：</p> <ol> <li> <strong>记录每个数据的指针</strong>：在实际应用场景中，该方式的管理成本相对较高。因为需要维护多个指针，这不仅会增加内存开销，还会提升操作的复杂度。</li> <li> <strong>利用数据连续存储特性</strong>：鉴于同一类型的数据通常是连续存储的，所以只需掌握首数据的地址以及连续数据的数量即可。</li> </ol> <p>显然，第二种方式更为简洁高效。数组本质上就是基于这种方式的数据结构表达。</p> <p>以 C 语言代码为例：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
</code></pre></div></div> <p>在此数组定义中：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">arr</code>本质上代表首数据的地址。</li> <li>数组长度为 4，表示连续存储了 4 个<code class="language-plaintext highlighter-rouge">int</code>类型的数据。</li> </ul> <p>具体到数组元素的地址计算，<code class="language-plaintext highlighter-rouge">arr</code>作为数组名，指向数组的首元素，即首数据地址。对于数组中的其他元素，其地址遵循如下计算规则：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">arr[0]</code>是数组的首元素，值为 1 。假设<code class="language-plaintext highlighter-rouge">arr</code>所代表的首数据地址为<code class="language-plaintext highlighter-rouge">0x0001</code>（仅为示例）。</li> <li> <code class="language-plaintext highlighter-rouge">arr[1]</code>的地址为<code class="language-plaintext highlighter-rouge">首数据地址 + 类型长度 * 序数</code>。由于<code class="language-plaintext highlighter-rouge">int</code>类型通常占 4 字节，所以<code class="language-plaintext highlighter-rouge">arr[1]</code>的地址为<code class="language-plaintext highlighter-rouge">0x0001 + 4 * 1 = 0x0005</code>。</li> <li>同理，<code class="language-plaintext highlighter-rouge">arr[2]</code>的地址为<code class="language-plaintext highlighter-rouge">0x0001 + 4 * 2 = 0x0009</code>。</li> <li> <code class="language-plaintext highlighter-rouge">arr[3]</code>的地址为<code class="language-plaintext highlighter-rouge">0x0001 + 4 * 3 = 0x000D</code>。</li> </ul> <p>由此可见，数组可看作由首数据指针和数组长度构成。进一步来讲，数组是对指针概念的一种封装和抽象。它凭借简洁的语法和特定的内存布局，为开发者提供了便于管理和操作连续存储的同类型数据集合的方式。例如，数组隐藏了指针运算的细节，使数据访问更加直观。但需要注意的是，C 语言数组本身并不提供边界检查机制，开发者需自行确保访问在合法范围内。相较于直接使用指针，数组虽在一定程度上减少了因指针操作不当导致的错误，但边界问题仍需开发者谨慎对待。</p> <h4 id="21-数组的本质">2.1 数组的本质</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">demonstrateArrayEssence</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"=== 数组本质分析 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"数组名: "</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"首元素地址: "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"数组地址: "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">arr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 数组名在不同上下文中的含义</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== 数组名的不同含义 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sizeof(arr): "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" 字节"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sizeof(&amp;arr[0]): "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="s">" 字节"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 数组到指针的隐式转换</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span>  <span class="c1">// 数组名隐式转换为指针</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"转换后的指针: "</span> <span class="o">&lt;&lt;</span> <span class="n">ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 指针算术</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== 指针算术 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"arr["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"] = "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">arr</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
                  <span class="o">&lt;&lt;</span> <span class="s">" (地址: "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">arr</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 数组类型推导</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== 类型推导 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"arr是数组: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_array_v</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ptr是指针: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_pointer_v</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="22-数组退化详解">2.2 数组退化详解</h4> <p>数组退化为指针是指在某些情况下，数组名会被编译器自动转换为指向数组第一个元素的指针。这种情况通常发生在数组作为函数参数传递时。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">printArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
    <span class="n">printArray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>  <span class="c1">// array 退化为指针</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在这个例子中，<code class="language-plaintext highlighter-rouge">array</code> 作为参数传递给 <code class="language-plaintext highlighter-rouge">printArray</code> 函数时，退化为指向 <code class="language-plaintext highlighter-rouge">array</code> 第一个元素的指针。正如前面说的，数组的本质是是首元素指针+数组长度。当数组名传递给函数时，在被调函数中无法获取数组的长度信息。这是因为数组本质上由长度和指针构成，而长度在 C 语言设计理念中被认为应在编译期确定（即便有了变长数组，其长度确定方式也存在一定编译器相关的“取巧”成分），无法传递到被调函数中。同时，被调函数缺乏足够的上下文来推测数组长度。因此，当传递数组名时，<code class="language-plaintext highlighter-rouge">void func(int a[]);</code>与<code class="language-plaintext highlighter-rouge">void func(int a*);</code>是等价的。尽管前者看似传递数组名，但实际上数组长度信息已经丢失。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="c1">// 函数重载展示数组退化</span>
<span class="kt">void</span> <span class="nf">processArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[])</span> <span class="p">{</span>  <span class="c1">// 等价于 int* arr</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"函数内sizeof(arr): "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" 字节"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"这实际上是指针大小"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">processArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{</span>  <span class="c1">// 仍然等价于 int* arr</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"指定大小也无效，仍是指针"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 阻止数组退化的方法</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">processArrayTemplate</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"模板函数保持数组类型，大小: "</span> <span class="o">&lt;&lt;</span> <span class="n">N</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sizeof(arr): "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" 字节"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// C++17 std::array 替代方案</span>
<span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">processStdArray</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"std::array大小: "</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"类型安全且不退化"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">demonstrateArrayDecay</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"=== 数组退化演示 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"原数组sizeof: "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" 字节"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">processArray</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>  <span class="c1">// 数组退化为指针</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== 阻止数组退化 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">processArrayTemplate</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>  <span class="c1">// 保持数组类型</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== 现代C++解决方案 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">modern_arr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
    <span class="n">processStdArray</span><span class="p">(</span><span class="n">modern_arr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="23-变长数组vla">2.3 变长数组（VLA）</h4> <p>在 C99 标准之前，变长数组（VLA）并非标准 C 语言的特性，即类似<code class="language-plaintext highlighter-rouge">int n = 10; int a[n];</code>这种写法，在严格遵循 C 标准的编译器中无法通过编译。不过，一些编译器可能会将其作为扩展特性支持。按照 C 语言最初的设计理念，数组的长度被视为编译期信息，无需在运行时存储长度信息。然而，这种限制在实际使用中显得不够灵活。</p> <p>C99 标准引入了变长数组的支持。变长数组的实现涉及较为复杂的栈动态管理机制，不仅仅是简单地从汇编语言层面读取一个变量值并动态调整栈顶指针。在变长数组中，<code class="language-plaintext highlighter-rouge">sizeof</code>操作符在运行时对数组求值，而非编译期。例如，对于变长数组<code class="language-plaintext highlighter-rouge">int n = 10; int a[n];</code>，<code class="language-plaintext highlighter-rouge">sizeof(a)</code>会在运行时返回<code class="language-plaintext highlighter-rouge">n</code>乘以数组元素类型大小的值。</p> <p>好玩的是，C99标准是支持变长数组标准的，而C++23才正式支持变长数组标准，也就是说之前的C++标准，是不能认为<code class="language-plaintext highlighter-rouge">int n = 10; int a[n];</code>这个是可以通过编译的，只是主流的编译器都作为一种扩展特性支持了而已。</p> <h3 id="3-多维数组与内存布局">3. 多维数组与内存布局</h3> <p>首先明确高维数组的定义。数组用于存储多个同一类型的数据，如果这个“同一类型”本身就是一个数组，那么就构成了高维数组。以二维数组为例，如以下 C 语言代码：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>在这个例子中，<code class="language-plaintext highlighter-rouge">arr</code> 是一个二维数组，它可以看作是由两个元素组成的数组，而每个元素又是一个包含两个 <code class="language-plaintext highlighter-rouge">int</code> 类型数据的数组。</p> <p>为了更深入理解高维数组的结构，我们需要引入“降维”的概念。对于 <code class="language-plaintext highlighter-rouge">int arr[2][2]</code>，可以借助类型定义来辅助理解，例如：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 其实typedef int[2] type可能更好理解，但parse解析规则不是这样的</span>
<span class="c1">// 但理解是一个意思即可</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">TYPE</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">TYPE</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>这里将 <code class="language-plaintext highlighter-rouge">int[2]</code> 定义为 <code class="language-plaintext highlighter-rouge">TYPE</code> 类型，<code class="language-plaintext highlighter-rouge">arr</code> 就是一个由两个 <code class="language-plaintext highlighter-rouge">TYPE</code> 类型元素组成的数组，这样从结构上更清晰地展示了二维数组的构成。</p> <p>再通过一个具体的内存空间示例进一步说明：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">tab</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>从内存空间角度来看，计算机内存是按顺序线性排列的，假设起始地址为 <code class="language-plaintext highlighter-rouge">0x7ffc5c78b530</code>，每个 <code class="language-plaintext highlighter-rouge">int</code> 类型数据占 4 字节（在 32 位系统下），则内存布局如下：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| Address        | type   | length | Value          | Interpretation                   |
| -------------- | ------ | ------ | -------------- | -------------------------------- |
| 0x7ffc5c78b530 | int[2] | 8      | 0x7ffc5c78b530 | `tab` 的地址，即 `tab[0]` 的地址 |
| 0x7ffc5c78b538 | int[2] | 8      | 0x7ffc5c78b538 | `tab[1]` 的地址                  |
| 0x7ffc5c78b530 | int    | 4      | 1              | `tab[0][0]` 的值                 |
| 0x7ffc5c78b534 | int    | 4      | 2              | `tab[0][1]` 的值                 |
| 0x7ffc5c78b538 | int    | 4      | 3              | `tab[1][0]` 的值                 |
| 0x7ffc5c78b53c | int    | 4      | 4              | `tab[1][1]` 的值                 |
</code></pre></div></div> <p>在这个布局中，<code class="language-plaintext highlighter-rouge">tab</code> 作为二维数组名，代表数组首地址，即 <code class="language-plaintext highlighter-rouge">tab[0]</code> 的地址 <code class="language-plaintext highlighter-rouge">0x7ffc5c78b530</code>。<code class="language-plaintext highlighter-rouge">tab[0]</code> 又指向第一行的首元素 <code class="language-plaintext highlighter-rouge">tab[0][0]</code>，其值为 1。<code class="language-plaintext highlighter-rouge">tab + 1</code> 则指向第二行的首地址 <code class="language-plaintext highlighter-rouge">tab[1]</code>，即 <code class="language-plaintext highlighter-rouge">0x7ffc5c78b538</code>，<code class="language-plaintext highlighter-rouge">tab[1]</code> 指向第二行首元素 <code class="language-plaintext highlighter-rouge">tab[1][0]</code>，其值为 3。</p> <p>从二维数组的逻辑角度理解，它可以看作是一个表格，有行和列的概念：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|        | col: 0 | col: 1 |
| ------ | ------ | ------ |
| row: 0 | 1      | 2      |
| row: 1 | 3      | 4      |
</code></pre></div></div> <p>本质上，高维数组在内存中也是按顺序一个单元挨着一个单元存储的，和一维数组并无区别。例如 <code class="language-plaintext highlighter-rouge">int tab[2][2]</code> 与 <code class="language-plaintext highlighter-rouge">int row[4]</code> 在物理存储上是类似的，都是连续存储 4 个 <code class="language-plaintext highlighter-rouge">int</code> 类型的数据。然而，<code class="language-plaintext highlighter-rouge">int tab[2][2]</code> 这种高维数组的表示形式提供了更为便捷的访问方式。比如，要访问第二行的所有数据，可以通过 <code class="language-plaintext highlighter-rouge">tab[1]</code> 获取第二行的首地址，进而遍历该行数据；要访问第二行第一列的数据，即第三个数据，可以表示为 <code class="language-plaintext highlighter-rouge">tab[1][0]</code>。这种按行和列的逻辑访问方式，使得处理具有行列结构的数据（如矩阵等）更加直观和高效。</p> <ul> <li>高维数组指针退化 特别要补充的是，高维数组作为函数参数传递时，其指针只会退化一级。例如，对于二维数组<code class="language-plaintext highlighter-rouge">int arr[3][4];</code>，当传递给函数<code class="language-plaintext highlighter-rouge">void func(int arr[][4]);</code>时，<code class="language-plaintext highlighter-rouge">arr</code>退化为指向一维数组<code class="language-plaintext highlighter-rouge">int [4]</code>的指针，而非直接退化为<code class="language-plaintext highlighter-rouge">int *</code>类型的指针。</li> </ul> <p>需注意，这只是 C 语言的设计选择，并非只能如此设计。比如说，如果由我自行设计，可能不会让数组退化为指针，同时保留数组长度为编译期信息的概念。对于<code class="language-plaintext highlighter-rouge">void func(int a[])</code>，可以将其隐式转化为<code class="language-plaintext highlighter-rouge">void func(int* a, int len)</code>来处理。当出现<code class="language-plaintext highlighter-rouge">int a[10]; func(a);</code>时，实际上在编译期就能确定长度为 10，进而处理为<code class="language-plaintext highlighter-rouge">func(a, 10);</code>。</p> <p>高维数组也是同样的道理，C 语言设计仅让其退化一级，主要是因为若完全看成纯指针，高维数组使用起来会过于麻烦。</p> <h4 id="31-多维数组的内存模型">3.1 多维数组的内存模型</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">demonstrateMultiDimensionalArrays</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 二维数组定义</span>
    <span class="kt">int</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"=== 二维数组内存布局 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"数组地址: "</span> <span class="o">&lt;&lt;</span> <span class="n">matrix</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"第一行地址: "</span> <span class="o">&lt;&lt;</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"第二行地址: "</span> <span class="o">&lt;&lt;</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 逐个元素的地址分析</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== 元素地址分析 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"matrix["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"]["</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="s">"] = "</span>
                      <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                      <span class="o">&lt;&lt;</span> <span class="s">" (地址: "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// 内存连续性验证</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== 内存连续性验证 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">flat_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"flat_ptr["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"] = "</span> <span class="o">&lt;&lt;</span> <span class="n">flat_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 行主序存储</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== 行主序存储计算 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">linear_index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"matrix["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"]["</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="s">"] = "</span>
                      <span class="o">&lt;&lt;</span> <span class="s">"flat["</span> <span class="o">&lt;&lt;</span> <span class="n">linear_index</span> <span class="o">&lt;&lt;</span> <span class="s">"] = "</span>
                      <span class="o">&lt;&lt;</span> <span class="n">flat_ptr</span><span class="p">[</span><span class="n">linear_index</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="4-多级指针与动态内存">4. 多级指针与动态内存</h3> <h4 id="41-多级指针在参数传递中的应用">4.1 多级指针在参数传递中的应用</h4> <p>首先明确在函数参数传递场景中多级指针的作用。当我们需要在函数中传递一个指针进来或者出去时，多级指针就能发挥重要作用。例如，假设我们有一个函数需要返回一个动态分配的数组，同时返回数组的长度，并且用一个状态值表示操作是否成功。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="c1">// 假设ID是一个自定义类型，这里简单用int代替</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">ID</span><span class="p">;</span>

<span class="c1">// 函数声明</span>
<span class="n">bool</span> <span class="nf">getArr</span><span class="p">(</span><span class="n">ID</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">cnt</span><span class="p">,</span> <span class="kt">int</span><span class="o">**</span> <span class="n">arr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ID</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">isSuccess</span> <span class="o">=</span> <span class="n">getArr</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">free</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">getArr</span><span class="p">(</span><span class="n">ID</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">cnt</span><span class="p">,</span> <span class="kt">int</span><span class="o">**</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 这里简单模拟获取数组的逻辑</span>
    <span class="o">*</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="o">*</span><span class="n">cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">arr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上述代码中，<code class="language-plaintext highlighter-rouge">getArr</code> 函数接受一个 <code class="language-plaintext highlighter-rouge">ID</code> 类型的参数 <code class="language-plaintext highlighter-rouge">id</code>，以及两个指针参数 <code class="language-plaintext highlighter-rouge">cnt</code> 和 <code class="language-plaintext highlighter-rouge">arr</code>。<code class="language-plaintext highlighter-rouge">cnt</code> 是一个 <code class="language-plaintext highlighter-rouge">int*</code> 类型的指针，用于传出数组的长度；<code class="language-plaintext highlighter-rouge">arr</code> 是一个 <code class="language-plaintext highlighter-rouge">int**</code> 类型的指针，用于传出动态分配的数组的地址。通过这种方式，函数可以返回多个值。</p> <p>从内存空间角度来看，在 <code class="language-plaintext highlighter-rouge">main</code> 函数中，<code class="language-plaintext highlighter-rouge">arr</code> 最初是一个空指针，<code class="language-plaintext highlighter-rouge">&amp;arr</code> 传递给 <code class="language-plaintext highlighter-rouge">getArr</code> 函数。在 <code class="language-plaintext highlighter-rouge">getArr</code> 函数内部，<code class="language-plaintext highlighter-rouge">*arr</code> 被分配内存并填充数据。这里的二级指针 <code class="language-plaintext highlighter-rouge">arr</code> 就像是一个“桥梁”，连接了函数内外，使得函数可以修改外部指针变量的值，从而达到传递指针出去的目的。</p> <p>简单来说，如果需要传指针到函数进去修改，就会多一级指针。如果本身是二级指针，就会变成三级指针。</p> <h4 id="42-多级指针等价于高维数组">4.2 多级指针等价于高维数组</h4> <p>在 C 语言中，多级指针和高维数组在某些方面存在等价关系，这种等价关系源于它们对内存布局和数据访问方式的相似性。</p> <p>以二维数组为例，假设有如下二维数组定义：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">twoDArray</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span>
</code></pre></div></div> <p>从本质上讲，二维数组可以看作是由多个一维数组组成的数组。<code class="language-plaintext highlighter-rouge">twoDArray</code> 可以理解为一个包含 3 个元素的数组，每个元素又是一个包含 4 个 <code class="language-plaintext highlighter-rouge">int</code> 类型元素的一维数组。</p> <p>此时，<code class="language-plaintext highlighter-rouge">twoDArray</code> 可以看作是一个指向包含 4 个 <code class="language-plaintext highlighter-rouge">int</code> 元素的一维数组的指针，即 <code class="language-plaintext highlighter-rouge">int (*)[4]</code> 类型。如果用多级指针来模拟这个二维数组，可以这样做：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">**</span><span class="n">multiPtr</span><span class="p">;</span>
<span class="n">multiPtr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">));</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">multiPtr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p>这里，<code class="language-plaintext highlighter-rouge">multiPtr</code> 是一个二级指针，它首先指向一个包含 3 个 <code class="language-plaintext highlighter-rouge">int*</code> 类型元素的数组，而每个 <code class="language-plaintext highlighter-rouge">int*</code> 类型的元素又指向一个包含 4 个 <code class="language-plaintext highlighter-rouge">int</code> 类型元素的数组，从而模拟出了与二维数组 <code class="language-plaintext highlighter-rouge">twoDArray</code> 类似的结构。</p> <p>在数据访问上，对于二维数组 <code class="language-plaintext highlighter-rouge">twoDArray[i][j]</code>，访问方式是基于数组的内存连续性，通过计算偏移量来获取特定位置的元素。对于多级指针模拟的结构 <code class="language-plaintext highlighter-rouge">multiPtr[i][j]</code>，也是通过指针的偏移来访问相应位置的元素。只不过在多级指针中，需要先通过外层指针找到内层数组的起始地址，再通过内层指针找到具体元素。</p> <p>对于更高维度的数组，同样可以用多级指针来模拟。例如三维数组 <code class="language-plaintext highlighter-rouge">int threeDArray[2][3][4]</code>，可以用三级指针来模拟：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">***</span><span class="n">triplePtr</span><span class="p">;</span>
<span class="n">triplePtr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">***</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">));</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">triplePtr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">triplePtr</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>虽然多级指针可以模拟高维数组的结构和数据访问方式，但在实际使用中，高维数组的语法更加简洁直观，并且编译器对数组的边界检查等方面有更好的支持。而多级指针则更加灵活，在需要动态分配内存来模拟多维结构时更为适用。这种等价关系为开发者在不同场景下选择合适的数据结构提供了依据。</p> <h4 id="43-多级指针的应用场景">4.3 多级指针的应用场景</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="c1">// 场景1：函数需要修改指针本身</span>
<span class="kt">bool</span> <span class="nf">allocateArray</span><span class="p">(</span><span class="kt">int</span><span class="o">**</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nothrow</span><span class="p">)</span> <span class="kt">int</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">arr</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 初始化数组</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 场景2：动态二维数组</span>
<span class="kt">int</span><span class="o">**</span> <span class="nf">create2DArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">**</span> <span class="n">matrix</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">*</span><span class="p">[</span><span class="n">rows</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">cols</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">matrix</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">destroy2DArray</span><span class="p">(</span><span class="kt">int</span><span class="o">**</span> <span class="n">matrix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rows</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">matrix</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 现代C++替代方案</span>
<span class="k">class</span> <span class="nc">Matrix</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">Matrix</span><span class="p">(</span><span class="kt">int</span> <span class="n">rows</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cols</span><span class="p">)</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cols</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">row</span> <span class="o">:</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">:</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">demonstrateMultiLevelPointers</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"=== 多级指针应用演示 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 场景1：函数修改指针</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">array</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">allocateArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"动态分配成功: "</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">array</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 场景2：动态二维数组</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== 传统动态二维数组 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">**</span> <span class="n">matrix</span> <span class="o">=</span> <span class="n">create2DArray</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">destroy2DArray</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

    <span class="c1">// 现代C++方案</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== 现代C++矩阵类 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">Matrix</span> <span class="nf">modern_matrix</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">modern_matrix</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="44-内存管理最佳实践">4.4 内存管理最佳实践</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="c1">// 错误的内存管理示例</span>
<span class="kt">void</span> <span class="nf">badMemoryManagement</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"=== 错误的内存管理 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="c1">// 忘记 delete ptr;  // 内存泄漏</span>

    <span class="kt">int</span><span class="o">*</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="c1">// delete arr;  // 错误：应该是 delete[]</span>

    <span class="kt">int</span><span class="o">**</span> <span class="n">matrix</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">*</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="c1">// 忘记释放内部数组</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">matrix</span><span class="p">;</span>  <span class="c1">// 只释放了指针数组，内存泄漏</span>
<span class="p">}</span>

<span class="c1">// 正确的内存管理</span>
<span class="kt">void</span> <span class="nf">goodMemoryManagement</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"=== 正确的内存管理 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 1. 使用智能指针</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"智能指针自动管理: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="c1">// 自动释放，无需手动delete</span>
    <span class="p">}</span>

    <span class="c1">// 2. 使用智能指针数组</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"智能指针数组: "</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="c1">// 自动释放</span>
    <span class="p">}</span>

    <span class="c1">// 3. 使用容器代替原始指针</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"vector容器: "</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">val</span> <span class="o">:</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="c1">// 自动管理内存</span>
    <span class="p">}</span>

    <span class="c1">// 4. 二维数据使用vector&lt;vector&lt;&gt;&gt;或一维数组模拟</span>
    <span class="p">{</span>
        <span class="c1">// 方案一：vector&lt;vector&lt;&gt;&gt;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">matrix2d</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>

        <span class="c1">// 方案二：一维数组模拟二维（更高效）</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">matrix1d</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">access</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">matrix1d</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">col</span><span class="p">];</span>
        <span class="p">};</span>

        <span class="n">access</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"一维模拟二维: "</span> <span class="o">&lt;&lt;</span> <span class="n">access</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// RAII包装器示例</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">AutoArray</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">AutoArray</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">size</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]();</span>  <span class="c1">// 零初始化</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">AutoArray</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 禁用拷贝，启用移动</span>
    <span class="n">AutoArray</span><span class="p">(</span><span class="k">const</span> <span class="n">AutoArray</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">AutoArray</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">AutoArray</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="n">AutoArray</span><span class="p">(</span><span class="n">AutoArray</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="n">size</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">other</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
        <span class="n">other</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">AutoArray</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">AutoArray</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
            <span class="n">other</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
            <span class="n">other</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">size_t</span> <span class="n">getSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">size</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">demonstrateRAII</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">=== RAII包装器演示 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">AutoArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">.</span><span class="n">getSize</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"RAII数组: "</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">.</span><span class="n">getSize</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// 自动释放</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="5-指针安全与现代-c实践">5. 指针安全与现代 C++实践</h3> <h4 id="61-常见指针错误及预防">6.1 常见指针错误及预防</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">demonstrateCommonPointerErrors</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"=== 常见指针错误及预防 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 1. 悬挂指针</span>
    <span class="p">{</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">dangling_ptr</span><span class="p">;</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">local_var</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
            <span class="n">dangling_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">local_var</span><span class="p">;</span>
        <span class="p">}</span>  <span class="c1">// local_var 生命周期结束</span>
        <span class="c1">// std::cout &lt;&lt; *dangling_ptr;  // 未定义行为</span>

        <span class="c1">// 预防：使用智能指针或确保生命周期</span>
        <span class="k">auto</span> <span class="n">safe_ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
        <span class="c1">// safe_ptr 自动管理生命周期</span>
    <span class="p">}</span>

    <span class="c1">// 2. 双重释放</span>
    <span class="p">{</span>
        <span class="c1">// int* ptr = new int(42);</span>
        <span class="c1">// delete ptr;</span>
        <span class="c1">// delete ptr;  // 错误：双重释放</span>

        <span class="c1">// 预防：使用智能指针或手动置nullptr</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>  <span class="c1">// 防止误用</span>
        <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>     <span class="c1">// 对nullptr执行delete是安全的</span>
    <span class="p">}</span>

    <span class="c1">// 3. 内存泄漏</span>
    <span class="p">{</span>
        <span class="c1">// 错误示例</span>
        <span class="c1">// int* ptr = new int(42);</span>
        <span class="c1">// if (some_condition) return;  // 忘记delete，内存泄漏</span>

        <span class="c1">// 正确做法：使用RAII</span>
        <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
        <span class="c1">// 即使提前返回，也会自动释放</span>
    <span class="p">}</span>

    <span class="c1">// 4. 缓冲区溢出</span>
    <span class="p">{</span>
        <span class="c1">// 错误示例</span>
        <span class="c1">// int arr[5];</span>
        <span class="c1">// arr[10] = 100;  // 缓冲区溢出</span>

        <span class="c1">// 预防：使用std::array或std::vector</span>
        <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">safe_arr</span><span class="p">{};</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">safe_arr</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">// 抛出异常而不是未定义行为</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"捕获越界访问: "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="62-现代-c指针管理">6.2 现代 C++指针管理</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="c1">// 智能指针的正确使用</span>
<span class="kt">void</span> <span class="nf">demonstrateSmartPointers</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"=== 智能指针最佳实践 ==="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 1. unique_ptr：独占所有权</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"unique_ptr: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="c1">// 转移所有权</span>
        <span class="k">auto</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
        <span class="c1">// ptr 现在为空，ptr2 拥有资源</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"转移后: "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">?</span> <span class="s">"有效"</span> <span class="o">:</span> <span class="s">"空"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"新指针: "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 2. shared_ptr：共享所有权</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"引用计数: "</span> <span class="o">&lt;&lt;</span> <span class="n">ptr1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="n">ptr1</span><span class="p">;</span>  <span class="c1">// 拷贝，增加引用计数</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"共享后引用计数: "</span> <span class="o">&lt;&lt;</span> <span class="n">ptr1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>  <span class="c1">// ptr2 销毁，引用计数减少</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"减少后引用计数: "</span> <span class="o">&lt;&lt;</span> <span class="n">ptr1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 3. weak_ptr：解决循环引用</span>
    <span class="p">{</span>
        <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>  <span class="c1">// 使用weak_ptr避免循环引用</span>
            <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

            <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
            <span class="o">~</span><span class="n">Node</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Node "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">" 析构"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">};</span>

        <span class="k">auto</span> <span class="n">node1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">node2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

        <span class="n">node1</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node2</span><span class="p">;</span>
        <span class="n">node2</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">node1</span><span class="p">;</span>  <span class="c1">// weak_ptr，不增加引用计数</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"node1引用计数: "</span> <span class="o">&lt;&lt;</span> <span class="n">node1</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"node2引用计数: "</span> <span class="o">&lt;&lt;</span> <span class="n">node2</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>  <span class="c1">// 正确析构，无内存泄漏</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="6-总结">6. 总结</h3> <h4 id="61-指针使用原则">6.1 指针使用原则</h4> <ol> <li> <strong>优先使用智能指针</strong>：<code class="language-plaintext highlighter-rouge">unique_ptr</code> &gt; <code class="language-plaintext highlighter-rouge">shared_ptr</code> &gt; 原始指针</li> <li> <strong>避免悬挂指针</strong>：注意对象生命周期，使用 RAII</li> <li> <strong>防止内存泄漏</strong>：成对使用 new/delete，优先使用容器</li> <li> <strong>类型安全</strong>：避免 void*，使用模板或强类型转换</li> <li> <strong>边界检查</strong>：使用 at()方法或范围 for 循环</li> </ol> <h4 id="62-现代-c替代方案">6.2 现代 C++替代方案</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 传统C风格 -&gt; 现代C++风格</span>
<span class="c1">// int* arr = new int[size];              -&gt; std::vector&lt;int&gt; arr(size);</span>
<span class="c1">// int** matrix = new int*[rows];         -&gt; std::vector&lt;std::vector&lt;int&gt;&gt; matrix;</span>
<span class="c1">// char* str = new char[100];             -&gt; std::string str;</span>
<span class="c1">// void* generic_ptr;                     -&gt; std::any 或模板</span>
<span class="c1">// function_ptr();                        -&gt; std::function&lt;&gt; 或lambda</span>
</code></pre></div></div> <h4 id="63-性能考虑">6.3 性能考虑</h4> <ol> <li> <strong>内存局部性</strong>：优先使用连续内存布局</li> <li> <strong>缓存友好</strong>：行主序访问，避免随机访问模式</li> <li> <strong>对齐优化</strong>：合理排列结构体成员</li> <li> <strong>智能指针开销</strong>：在性能关键路径考虑原始指针</li> <li> <strong>编译器优化</strong>：相信现代编译器的优化能力</li> </ol> <p>通过深入理解指针的本质和现代 C++的最佳实践，你将能够编写更安全、更高效的代码，并避免常见的内存管理错误。</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/6_internet.md/">（七）内核那些事儿：操作系统对网络包的处理</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/5_fileSystem.md/">（六）内核那些事儿：文件系统</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/4_interaction.md/">（五）内核那些事儿：系统和程序的交互</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_device.md/">（四）内核那些事儿：设备管理与驱动开发</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_signal.md/">（三）内核那些事儿：CPU中断和信号</a> </li> </div> </div> <div class="col-sm-4"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <script src="/assets/js/toc-depth.js"></script> </body> </html>