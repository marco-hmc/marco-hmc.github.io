<!DOCTYPE html> <html lang="cn"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> coroutine了解 | Marco's blog </title> <meta name="author" content="Marco Huang"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, blog"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="/assets/img/mc_logo.ico?cf243b61f6c6d75747808b3ae8298c5b"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marco-hmc.github.io/blog/2025/3_coroutine.md/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Marco's blog </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">coroutine了解</h1> <p class="post-meta"> Created on May 06, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/cpp"> <i class="fa-solid fa-hashtag fa-sm"></i> cpp</a>   <a href="/blog/tag/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"> <i class="fa-solid fa-hashtag fa-sm"></i> 并发编程</a>   <a href="/blog/tag/coroutine"> <i class="fa-solid fa-hashtag fa-sm"></i> coroutine</a>   ·   <a href="/blog/category/language"> <i class="fa-solid fa-tag fa-sm"></i> language</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="coroutine了解">coroutine了解</h2> <h3 id="1-基础概念">1. 基础概念</h3> <ul> <li>函数怎么提前返回？</li> <li>怎么手动模拟函数调用？</li> <li>函数参数到底怎么传？</li> <li>函数如何能跨调用层次返回？</li> <li>怎么能获取 EIP/RIP？</li> <li>函数怎么跳转到特定地址执行？</li> <li>函数怎么保存上下文？</li> <li>汇编中为什么要保存寄存器？</li> <li>汇编中怎么恢复栈？</li> <li>汇编怎么平衡栈？</li> <li>什么是 <code class="language-plaintext highlighter-rouge">__stdcall</code> 和 <code class="language-plaintext highlighter-rouge">__cdecl</code>？</li> </ul> <h4 id="01-什么是协程什么是纤程">0.1 什么是协程？什么是纤程？</h4> <ul> <li> <strong>什么是协程：</strong> 协程(Coroutine)是一种用户态的轻量级线程,协程的调度完全由用户控制.协程有点类似于线程,但协程避免了无意义的调度,而且提供了方便的协作式多任务处理能力.协程在某些场景下,如IO密集型任务,可以提高程序的执行效率.</li> </ul> <p>协程和纤程都是一种比线程更加轻量级的并发单元。两者的调度都不是由操作系统决定，而是由用户决定。两者都允许在一个函数执行过程中暂停执行，并在稍后恢复执行，从而实现非阻塞的并发操作。</p> <p>两者的实现原理也是相同的，本质上都是以下几点：</p> <ol> <li> <strong>记住上下文信息</strong>：无论是纤程还是协程，都需要记住当前的执行上下文，包括寄存器状态、栈指针等。</li> <li> <strong>切换执行位置</strong>：在需要时，切换到另一个执行位置，继续执行其他任务。</li> <li> <strong>还原上下文信息</strong>：在切换回原来的执行位置时，还原之前保存的上下文信息，继续执行。</li> </ol> <table> <thead> <tr> <th>特性</th> <th>纤程（Fiber）</th> <th>协程（Coroutine）</th> </tr> </thead> <tbody> <tr> <td>平台依赖</td> <td>Windows 特定实现</td> <td>跨平台</td> </tr> <tr> <td>内存共享</td> <td>共享线程栈</td> <td>共享进程内存空间</td> </tr> <tr> <td>实现复杂度</td> <td>依赖操作系统 API</td> <td>可以通过库或语言特性实现</td> </tr> </tbody> </table> <h4 id="02-协程的原理是什么">0.2 协程的原理是什么？</h4> <p>协程实现的基础：C/C++ 函数调用过程，执行过程，返回过程。</p> <ul> <li> <strong>记住离开的位置</strong>：一个函数离开时能记住离开的位置。在 Windows 平台下，这意味着要能记住 EIP/RIP 寄存器的值，因为 EIP/RIP 指示了下一条指令要执行的地址。</li> <li> <strong>恢复现场</strong>：再次进入时能恢复现场。这要求能够保存当时函数栈内存和寄存器的值，并在恢复时恢复栈内存和寄存器的值。后面我们会详细说明并手动完成这个过程，这要求我们对函数调用有深入的理解。</li> </ul> <h4 id="11-协程是什么">1.1 协程是什么？</h4> <p>协程（Coroutine）是一种比线程更轻量级的并发单元。与线程不同，协程不依赖于操作系统的线程调度，而是由程序自身控制的。协程可以在一个线程内实现多任务的切换，避免了线程上下文切换的开销。协程的主要特点是可以在执行过程中暂停，并在稍后恢复执行。</p> <h4 id="12-协程有什么用">1.2 协程有什么用？</h4> <p>协程主要用于实现并发编程，特别是在 I/O 密集型任务中。以下是协程的一些主要用途：</p> <ol> <li> <strong>异步编程</strong>：协程可以在等待 I/O 操作（如网络请求、文件读写）时暂停执行，释放 CPU 资源给其他任务，从而提高程序的并发性能。</li> <li> <strong>生成器</strong>：协程可以用作生成器，逐步生成数据，而不是一次性生成所有数据。这对于处理大数据集或流式数据非常有用。</li> <li> <strong>协作多任务</strong>：协程可以在多个任务之间切换，模拟多任务处理，而不需要多线程或多进程的开销。</li> <li> <strong>简化代码</strong>：协程可以使异步代码看起来像同步代码，简化了编写和维护异步代码的复杂性。</li> </ol> <p>通过这些用途，协程在现代编程中变得越来越重要，特别是在需要高并发和高性能的应用程序中。</p> <p>生成器的恢复执行由用户显式调用来决定。 异步函数的恢复执行由后台线程来决定。</p> <h4 id="13-协程的优缺点是什么">1.3 协程的优缺点是什么？</h4> <p>优点</p> <ul> <li>轻量级：协程比线程更轻量级，创建和切换的开销更小。</li> <li>无锁并发：协程可以避免多线程编程中的锁和竞态条件问题。</li> <li>简化异步编程：协程可以使异步代码看起来像同步代码，简化了编写和维护异步代码的复杂性。 缺点</li> <li>不适用于多核并行：协程在单个线程内运行，不能利用多核 CPU 的并行计算能力。</li> <li>手动调度：协程的调度需要手动管理，增加了编程复杂性。</li> <li>栈大小限制：协程的栈大小通常是固定的，可能会限制递归深度和局部变量的使用。</li> </ul> <h4 id="14-协程的应用场景">1.4 协程的应用场景</h4> <p>网络编程（当成异步使用，提高可读性）：协程可以简化异步网络编程，使代码更易读。 数据处理（生成器，逐步处理数据）：协程可以用于处理大数据集，逐步生成和处理数据。 用户界面（ui协程和业务协程切换）：协程可以用于实现响应式用户界面，避免界面卡顿。</p> <h4 id="15-协程实现的基本原理是什么">1.5 协程实现的基本原理是什么？</h4> <p>协程的实现的关键在于上下文切换。 而上下文切换涉及到三个过程：保存状态、切换上下文、恢复状态。</p> <p>保存状态主要涉及保存当前协程的执行上下文，包括以下内容：</p> <ul> <li>程序计数器（PC）：指示当前执行的指令地址。</li> <li>栈指针（SP）：指示当前栈顶的位置。</li> <li>寄存器：保存当前协程的寄存器状态，包括通用寄存器和特殊寄存器。</li> </ul> <p>恢复状态是指将之前保存的执行上下文恢复到当前协程中，使其能够继续执行。恢复状态的过程包括：</p> <ul> <li>恢复程序计数器：将程序计数器恢复到保存时的值。</li> <li>恢复栈指针：将栈指针恢复到保存时的值。</li> <li>恢复寄存器：将寄存器恢复到保存时的状态。</li> </ul> <p>而切换上下文就是保存当前协程状态，恢复到目标协程状态。</p> <h3 id="2-协程使用的一般例子">2. 协程使用的一般例子</h3> <h4 id="21-协程的切换">2.1 协程的切换</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;boost/coroutine/coroutine.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">coroutine_function</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">coroutines</span><span class="o">::</span><span class="n">coroutine</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">push_type</span> <span class="o">&amp;</span><span class="n">yield</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from coroutine!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">yield</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Back in coroutine!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">coroutines</span><span class="o">::</span><span class="n">coroutine</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">pull_type</span> <span class="n">source</span><span class="p">(</span><span class="n">coroutine_function</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from main!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">source</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Back in main!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
Hello from coroutine!
Hello from main!
Back in coroutine!
Back in main!
*/</span>
</code></pre></div></div> <ul> <li>push_type和pull_type怎么理解？ <ul> <li>push_type 定义：push_type 是一个类型，用于将控制权推送到协程中。 作用：在协程函数中，push_type 对象用于暂停协程的执行并返回到调用者。它通常作为协程函数的参数传递。 使用场景：当协程需要暂停执行并返回到主程序或其他协程时，使用 push_type 对象的 operator() 来实现这一点。</li> <li>pull_type 定义：pull_type 是一个类型，用于从协程中拉取控制权。 作用：在主程序或调用者中，pull_type 对象用于启动和恢复协程的执行。它通常在主程序中创建，并与协程函数关联。 使用场景：当主程序或其他协程需要启动或恢复协程的执行时，使用 pull_type 对象的 operator() 来实现这一点。</li> </ul> </li> </ul> <h4 id="22-带返回值的协程">2.2 带返回值的协程</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;boost/coroutine2/all.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">coroutine_function</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">coroutines2</span><span class="o">::</span><span class="n">coroutine</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">push_type</span> <span class="o">&amp;</span><span class="n">yield</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Coroutine yields: "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">yield</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">coroutines2</span><span class="o">::</span><span class="n">coroutine</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">pull_type</span> <span class="n">source</span><span class="p">(</span><span class="n">coroutine_function</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Main received: "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">source</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="98-习题">98. 习题</h3> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;boost/coroutine2/all.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">coroutines2</span><span class="o">::</span><span class="n">coroutine</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">pull_type</span> <span class="n">source</span><span class="p">(</span>
      <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">boost</span><span class="o">::</span><span class="n">coroutines2</span><span class="o">::</span><span class="n">coroutine</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">push_type</span> <span class="o">&amp;</span><span class="n">sink</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">sink</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">sink</span><span class="p">(</span><span class="n">second</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="kt">int</span> <span class="n">third</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">second</span><span class="p">;</span>
          <span class="n">first</span> <span class="o">=</span> <span class="n">second</span><span class="p">;</span>
          <span class="n">second</span> <span class="o">=</span> <span class="n">third</span><span class="p">;</span>
          <span class="n">sink</span><span class="p">(</span><span class="n">third</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">});</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">source</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-yield_type和call_type是什么和push_type还有pull_type的联系是什么">1. yield_type和call_type是什么？和push_type还有pull_type的联系是什么？</h4> <p>yield_type 和 call_type 是旧版本 Boost.Coroutine 库中的类型，而 push_type 和 pull_type 是新的 Boost.Coroutine2 库中的类型。 它们在功能和目的上有相似之处，都是用于在协程中暂停执行并返回到调用者，但它们的内部实现和对外使用方式有所不同。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;boost/coroutine/coroutine.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">coroutine_function</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">coroutines</span><span class="o">::</span><span class="n">yield_type</span> <span class="o">&amp;</span><span class="n">yield</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from coroutine!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">yield</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Back in coroutine!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">coroutines</span><span class="o">::</span><span class="n">call_type</span> <span class="n">coroutine</span><span class="p">(</span><span class="n">coroutine_function</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from main!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">coroutine</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Back in main!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="2-什么是对称协程什么是非对称协程">2. 什么是对称协程？什么是非对称协程？</h4> <p>非对称协程：</p> <ul> <li>使用 boost::coroutines2::asymmetric_coroutine 实现。</li> <li>非对称协程只能从主程序或调度器中启动和恢复，而不能直接相互调用。</li> <li>非对称协程能知道其调用方，调用一些方法能让出当前的控制回到调用方手上。</li> </ul> <p>对称协程：</p> <ul> <li>使用 boost::coroutines2::coroutine 实现。</li> <li>对称协程允许协程之间相互切换，而不需要返回到主调度器。</li> <li>对程协程都是平等的，一个对程协程能把控制让给任意一个协程，因此，当对称协程让出控制的时候，必须指定被让出的协程是哪一个。</li> </ul> <p>对称协程可以当成非对称协程使用。对称协程提供了更灵活的控制流，可以在协程之间相互切换，但也可以像非对称协程一样，从主程序中启动和恢复协程。 具体什么时候建议使用非对称协程欢迎补充。</p> <h4 id="3-有栈协程和无栈协程的实现是什么">3. 有栈协程和无栈协程的实现是什么？</h4> <p>协程的实现的关键在于上下文切换。 而上下文切换涉及到三个过程：保存状态、切换上下文、恢复状态。 而有栈协程实现和无栈协程的实现区别就在于状态保存在哪里。 有栈实现：每一个协程有一个独立的栈空间。受到栈空间大小约束，有空间损耗 无栈实现：将协程的状态存储在堆（Heap）空间中，通过状态机的方式去管理。不受栈空间大小约束，没有空间损耗。实现麻烦。</p> <p>而协程的状态包含以下三个方面</p> <ul> <li>程序计数器（PC）：指示当前执行的指令地址。</li> <li>栈指针（SP）：指示当前栈顶的位置。</li> <li> <p>寄存器：保存当前协程的寄存器状态，包括通用寄存器和特殊寄存器。</p> </li> <li>boost的是有栈协程</li> <li>c++20的是无栈协程</li> </ul> <p>协程的实现涉及到底层的上下文切换和状态保存，这些操作通常需要使用汇编语言来直接操作寄存器和栈指针。高级语言通常不直接提供这些底层接口，因此实现协程通常依赖于库（调用一些其他类似接口去模拟）或语言特性（编译器层面直接操作）。</p> <h4 id="4-堆空间和栈空间概念">4. 堆空间和栈空间概念</h4> <p>不同线程：</p> <ul> <li>栈空间：每个线程都有自己的栈空间，用于存储该线程的局部变量、函数调用的参数、返回地址等。这意味着栈空间是线程私有的。</li> <li>堆空间：同一进程内的所有线程共享同一个堆空间。这意味着线程之间可以通过指针或引用共享堆上分配的数据。</li> </ul> <p>不同进程：</p> <ul> <li>栈空间：每个进程都有自己的虚拟地址空间，其中包括独立的栈空间。进程间的栈空间是完全隔离的。</li> <li>堆空间：每个进程也有自己独立的堆空间。进程间的堆空间不共享，因此进程之间不能直接访问对方的堆数据。</li> </ul> <h3 id="3-ques">3. ques</h3> <h4 id="31-c的协程的实现原理是什么">3.1 C++的协程的实现原理是什么?</h4> <p>C++的协程是一种特殊的函数,它可以在执行过程中暂停和恢复.协程的实现原理涉及到两个关键概念:生成器和状态机.</p> <p>生成器是协程的基础,它是一个可以产生多个值的函数.在C++中,生成器使用<code class="language-plaintext highlighter-rouge">yield</code>语句来暂停执行并返回一个值,然后可以通过调用生成器来恢复执行并继续生成下一个值.生成器的实现通常使用状态机来跟踪函数的执行状态.</p> <p>状态机是一个用于管理协程执行状态的机制.它可以记录协程的当前状态,并根据不同的状态执行相应的操作.在C++中,状态机通常使用有限状态机(FSM)来实现.FSM由一组状态和状态之间的转换组成.每个状态都对应着协程的不同执行阶段,而状态之间的转换则由协程的控制流决定.</p> <p>在C++中,协程的实现依赖于协程支持库,如Boost.Coroutine或C++20中引入的标准库中的协程.这些库提供了协程的底层实现,包括生成器和状态机的机制.通过使用这些库,我们可以更方便地编写和管理协程.</p> <p>总结一下,C++的协程实现原理涉及生成器和状态机的概念.生成器用于产生多个值并支持暂停和恢复执行,而状态机用于管理协程的执行状态和控制流.通过使用协程支持库,我们可以更轻松地编写和管理协程.</p> <h4 id="32">3.2</h4> <p>我的理解是协程只有两个主要功能，一个是保存上下文信息，一个是灵活的控制流。 协程是用来代替传统的异步编程的. 通过保存上下文和灵活的控制流操作，允许开发者以同步的方式编写代码，同时在执行阻塞操作时让出CPU，从而实现类似异步的非阻塞行为。这种方式简化了异步编程的复杂性，使得代码更易于理解和维护。</p> <p>协程就是为了代替异步用的. 比如说你说在后端异步加载信息的时候，不想用异步，异步编程比较麻烦. 开了异步也要切换线程，也有消耗， 想用同步的方式去写，而且不阻塞的话. 这个时候的选择就是开协程.</p> <p>去执行其他任务，从而提高程序的并发效率。 但它本质上是在单线程内通过协作式的调度来实现异步，适合处理大量 I/O 密集型任务场景。 然而，对于那些需要真正并行执行的计算密集型任务，比如复杂的数学计算等，仅靠 async 并不能充分利用多核 CPU 的优势来实现真正的并行加速。</p> <h2 id="协程">协程</h2> <ul> <li> <p>基本概念：<strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程</p> <p><img src="imgs/os/corotines.png" alt="corotines" style="zoom:60%;"></p> </li> <li> <p>进程，线程，协程的上下文切换</p> <ul> <li>进程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户是无感知的。进程的切换内容包括<strong>页全局目录、内核栈、硬件上下文，切换内容保存在内存</strong>中。进程切换过程是由“<strong>用户态到内核态到用户态</strong>”的方式，<strong>切换效率低</strong> </li> <li>线程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户无感知。线程的切换内容<strong>包括内核栈和硬件上下文</strong>。线程切换内容保存在内核栈中。线程切换过程是由“用户态到内核态到用户态”， <strong>切换效率中等</strong> </li> <li>协程的切换者是用户（编程者或应用程序），<strong>切换时机是用户自己的程序所决定的</strong>。协程的<strong>切换内容是硬件上下文</strong>，<strong>切换内存保存在用户自己的变量</strong>（用户栈或堆）中。<strong>协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高</strong> </li> <li> <strong>协程是轻量级线程，拥有自己的寄存器上下文和栈</strong>。<strong>协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈</strong> </li> <li>协程能保留上一次调用时的状态，即所有局部状态的一个特定组合，每次过程重入时，就相当于进入上一次调用的状态</li> </ul> </li> <li> <p>协程相比进程和线程的优势</p> <ul> <li>协程拥有极高的执行效率。因为<strong>子程序切换不是线程切换，协程不是被操作系统内核所管理，而是由程序自身完全控制(完全运行在用户态)，因此，没有线程切换的开销</strong>，和多线程比，线程数量越多，协程的性能优势就越明显</li> <li>不需要多线程的锁机制，因为<strong>只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多</strong> </li> </ul> </li> <li> <p>协程分类：</p> <ul> <li> <p><strong>按照控制传递机制</strong></p> <ul> <li> <p><strong>非对称式协程</strong>：通过yield, 将控制权返回给调用方, 如达夫设备 就是一种非对称式协程，这种协程更像是一个可以返回多次的子例程(函数)，因此代码可读性会较高</p> </li> <li> <p><strong>对称式协程</strong>：通过resum, 将控制权交给任意协程, 这种协程更像goto 可以任意的跳转 返回，如果滥用会导致代码可读性较低</p> </li> </ul> </li> <li> <p><strong>按调实现分类</strong></p> <ul> <li> <p><strong>stackfull 有栈协程</strong>：<strong>每个协程都拥有自己的栈，协程上下文保存在自己的栈中</strong>，切换协程就是切换栈然后恢复栈中的上下文，这种方法实现的协程更像是用户态的线程</p> </li> <li> <p><strong>stackcopy 共享栈协程</strong>：stackfull 的缺点显而易见，<strong>十分浪费内存，当协程数量过多时会导致内存开销过大</strong>。stackcopy 就是用来解决此问题的，<strong>所有协程公用一个运行栈，当协程发生切换的时候，将协程数据copy到自身的独立栈中，独立栈可以进行动态的扩充</strong></p> </li> <li> <p><strong>stackless 无栈协程</strong>：stackless 协程公用一个栈，但是与stackcopy 不同，<strong>协程切换的时候仅会将所需的上下文保存在堆中</strong>, 可以将部分无用局部变量提前释放，通常这需要编译器的支持。stackless 协程通常只有顶层例程可以被挂起</p> </li> </ul> </li> </ul> </li> <li> <p><strong>应用场景</strong></p> <ul> <li>I/O 密集型任务 <ul> <li>这一点与多线程有些类似，<strong>但协程调用是在一个线程内进行的，是单线程，切换的开销小，因此效率上略高于多线程</strong> </li> <li>当程序在执行 I/O 时操作时，CPU 是空闲的，此时可以充分利用 CPU 的时间片来处理其他任务。在单线程中，一个函数调用，一般是从函数的第一行代码开始执行，结束于 return 语句、异常或者函数执行（也可以认为是隐式地返回了 None ）</li> <li><strong>有了协程，我们在函数的执行过程中，如果遇到了耗时的 I/O 操作，函数可以临时让出控制权，让 CPU 执行其他函数，等 I/O 操作执行完毕以后再收回控制权</strong></li> </ul> </li> <li>当今无数的 Web 服务和互联网服务，<strong>本质上大部分都是 IO 密集型服务</strong>，什么是 IO 密集型服务？意思是处理的任务大多是和<strong>网络连接或读写相关的高耗时任务</strong>，高耗时是相对 CPU 计算逻辑处理型任务来说，两者的处理时间差距不是一个数量级的 <ul> <li><strong>IO 密集型服务的瓶颈不在 CPU 处理速度，而在于尽可能快速的完成高并发、多连接下的数据读写</strong></li> </ul> </li> <li> <strong>以前有两种解决方案：</strong> <ul> <li>如果用多线程，<strong>高并发场景的大量 IO 等待会导致多线程被频繁挂起和切换</strong>，非常消耗系统资源，同时多线程访问共享资源存在竞争问题</li> <li>如果用多进程，不仅存在频繁调度切换问题，同时还会存在每个进程资源不共享的问题，需要<strong>额外引入进程间通信机制来解决</strong> </li> </ul> </li> <li> <strong>协程出现给高并发和 IO 密集型服务开发提供了另一种选择。</strong>当然，世界上没有技术银弹，在这里我想把协程这把钥匙交到你手中，但是它也不是万能钥匙，最好的解决方案是贴合自身业务类型做出最优选择，不一定就选择一种模型，有时候是几种模型的组合，比如<strong>多线程搭配协程是常见的组合</strong> </li> </ul> </li> <li> <p>因为协程是在一个线程执行，那怎么利用多核CPU呢？最简单的方法是<strong>多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能</strong></p> </li> <li> <p>python协程完成生产者-消费者问题例子（Python对协程的支持还非常有限，用在generator中的<strong>yield</strong>可以一定程度上实现协程）</p> <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">time</span>


<span class="k">def</span> <span class="nf">consumer</span><span class="p">():</span>
    <span class="n">r</span> <span class="o">=</span> <span class="sh">""</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">r</span>  <span class="c1"># 使用 yield 接收生产者发送的数据并返回结果
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">[CONSUMER] Consuming %s...</span><span class="sh">"</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sh">"</span><span class="s">200 OK</span><span class="sh">"</span>


<span class="k">def</span> <span class="nf">produce</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
    <span class="n">c</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>  <span class="c1"># 启动 consumer 协程
</span>    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">[PRODUCER] Producing %s...</span><span class="sh">"</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># 发送数据给 consumer 并接收结果
</span>        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">[PRODUCER] Consumer return: %s</span><span class="sh">"</span> <span class="o">%</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">c</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="nf">consumer</span><span class="p">()</span>
    <span class="nf">produce</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

</code></pre></div> </div> <p>注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：</p> <ol> <li>首先调用c.next()启动生成器；</li> <li>然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</li> <li>consumer通过yield拿到消息，处理，又通过yield把结果传回；</li> <li>produce拿到consumer处理的结果，继续生产下一条消息；</li> <li>produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</li> </ol> <p>整个流程<strong>无锁</strong>，由一个线程执行，produce和consumer<strong>协作完成任务</strong>，所以称为“协程”，而非线程的抢占式多任务</p> </li> <li> <p>支持协程的编程语言</p> <ul> <li><strong>Lua语言</strong></li> <li><strong>Python语言</strong></li> <li><strong>Go语言</strong></li> <li><strong>Java语言(Kilim框架)</strong></li> </ul> </li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/3_%E6%80%BB%E7%BA%BF.md/">总线</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_process.md/">进程</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2_io.md/">磁盘结构</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/1_threads.md/">c++的多线程</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/0_pointer.md/">指针</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Marco Huang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>