---
layout: post
title: 结构型模式
categories: 程序设计
related_posts: True
tags: 设计模式
toc:
  sidebar: left
---

## 结构型模式

结构型模式是设计模式的一种，用于描述如何将类和对象组合在一起形成更大的结构。它们主要关注类和对象的组合方式，以获得更大的灵活性和复用性。或者换句话说，实体如何相互使用。

### 1. **适配器模式（Adapter Pattern）**：

- **目的**：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。
  适配器模式允许你将一个不兼容的对象包装在一个适配器中，使其与另一个类兼容。
- **使用场景**：当你想使用一个已经存在的类，但它的接口不符合你的需求时。
- **示例**：将一个旧的接口适配到一个新的接口上，使得旧代码可以与新代码一起工作。
  - 假设你有一些照片在你的存储卡中，你需要将它们传输到你的电脑。为了传输它们，你需要某种适配器，该适配器与电脑端口兼容，以便你可以将存储卡连接到电脑。在这种情况下，读卡器就是一个适配器。
  - 另一个例子是著名的电源适配器；一个三脚插头不能连接到一个两孔插座，它需要使用一个电源适配器使其与两孔插座兼容。还有一个例子是翻译人员将一个人说的话翻译给另一个人。
  - 适配器模式允许你将一个不兼容的对象包装在一个适配器中，使其与另一个类兼容。通过这种方式，可以在不修改现有类的情况下，使其与其他类一起工作。
  - 一般是当前工程使用某一个库的接口，后面这个库升级了，性能得到了很大提升。因此也想升级这个库的时候，可能会出现库的接口发生了很大的变化，导致接口不匹配的。如果当前工程出于进度，或者出于工作量和人手，没办法很好完成接口调整，一般则是通过接口层去调整这次接口变化，使得新的api和原来一样。

### 2. **桥接模式（Bridge Pattern）**：

- **桥接模式**：分离抽象和实现，使它们可以独立变化。
- **目的**：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
- **使用场景**：当一个类存在多个独立变化的维度时，通过组合而不是继承来扩展类的功能。
- **优点**：分离抽象和实现，使它们可以独立变化，提高了系统的扩展性。
- **缺点**：增加了系统的复杂性。
- **示例**：将图形的形状和颜色分离，使得形状和颜色可以独立变化。
  - 简单来说，就是组合的一种形式。比如说一个页面有主题的概念，存在深色主题，浅色主题等等多个主题。
    页面只需要以成员变量方式去组合主题变量。页面setBackGroundColour(){bg.color = theme->colour()}即可

### 3. **组合模式（Composite Pattern）**：

- **组合模式**：统一处理单个对象和组合对象。
- **目的**：将对象组合成树形结构以表示“部分-整体”的层次结构，使得客户对单个对象和组合对象的使用具有一致性。
- **使用场景**：当你希望客户端可以忽略组合对象与单个对象的差异时。
- **优点**：统一处理单个对象和组合对象，使得客户端代码更简单。
- **缺点**：可能会使设计变得过于抽象。
- **示例**：文件系统中的文件和文件夹，文件夹可以包含文件和其他文件夹。
  - 简单来说，就是希望单个对象和组合对象的使用具有一致性。一般需要依赖多态特性处理，单个对象和组合对象都有一个共同父类。然后组合对象一般以容器方式存储单个对象这样子。
  - 比如说打开/删除/移动/复制/重命名等等操作，对于文件（单个对象）和文件夹（文件的组合对象）来说应该是一致的。使单个对象和组合对象对外呈现一致的模式叫组合。

### 4. **装饰模式（Decorator Pattern）**：

- **装饰模式**：动态添加对象职责。
- **目的**：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。
- **使用场景**：当你需要在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责时。
- **优点**：动态添加对象职责，提供了比继承更灵活的扩展方式。
- **缺点**：增加了许多小对象，可能会影响性能。
- **示例**：在不修改原始类的情况下，为对象添加新的功能，如为图形对象添加边框或阴影。
  - 简单来说，就是需要调整一个类，但是又不能直接修改，就通过一种装饰的方式得到一个装饰类，有类的功能，同时这个装饰类也能够调整和修改。
  - 至于为什么不能直接修改，可能因为这个类的是库提供的，但是当前工程使用这个类的时候有一些统一要求需要调整，因此当前工程需要修改这个类，但又改不了，就通过装饰的方式得到一个装饰类，对装饰类进行调整。
  - 装饰的方式一般在C++来说则是通过继承自原有类型。

### 5. **外观模式（Facade Pattern）**：

- **外观模式**：简化子系统接口。
- **目的**：为子系统中的一组接口提供一个一致的界面，使得子系统更容易使用。
- **使用场景**：当你希望为复杂子系统提供一个简单接口时。
- **优点**：简化子系统接口，使得子系统更容易使用。
- **缺点**：增加了额外的接口层，可能会影响性能。
- **示例**：为一个复杂的图形库提供一个简单的绘图接口，使得用户可以更容易地使用图形库。
  - 简单来说，一个类的接口太复杂了，使用外观类简化内部类的调用。
  - 外观模式是一种结构型设计模式，它为子系统中的一组接口提供一个一致的界面，使得子系统更容易使用。通过引入一个外观类，简化了复杂子系统的使用。
  - 外观模式通过引入一个外观类，为子系统中的一组接口提供一个一致的界面，使得子系统更容易使用。通过这种方式，可以简化复杂子系统的使用，提高代码的可读性和可维护性。这个示例展示了如何使用外观模式简化计算机的启动和关闭操作。

### 6. **享元模式（Flyweight Pattern）**：

- **享元模式**：共享细粒度对象，减少内存消耗。
- **目的**：运用共享技术有效地支持大量细粒度的对象。享元模式用于通过尽可能多地共享相似对象来最小化内存使用或计算开销。
- **使用场景**：当你需要大量细粒度对象时，通过共享减少内存消耗。
- **优点**：通过共享减少内存消耗，提高系统性能。
- **缺点**：增加了系统的复杂性，需要维护共享对象的状态。
- **示例**：在文字处理器中共享字符对象，以减少内存消耗。
  - 内存池就是享元模式的一种体现。每次通过系统调用开辟内存空间开销比较大，不如只通过一次系统调用开辟大量内存空间。然后由内存池分配，减少多次系统调用开销。可以理解为是共享了系统调用开销。除此，比如说泡茶，泡一壶和泡一桶茶其实开销差不了多少。但是每次要喝茶才去泡茶，开销就很大。泡好一桶，下一次有需要就不需要重新泡茶。

### 7. **代理模式（Proxy Pattern）**：

- **代理模式**：控制对象访问。
- **目的**：为其他对象提供一种代理以控制对这个对象的访问。代理模式是一种结构型设计模式，它为其他对象提供一种代理以控制对这个对象的访问。代理模式可以用于延迟加载、安全控制、日志记录等场景。
- **使用场景**：当你需要为某个对象提供一个替代者以控制对它的访问时。
- **优点**：控制对象访问，提供了额外的功能，如延迟加载、安全控制等。
- **缺点**：增加了系统的复杂性，可能会影响性能。
- **示例**：在远程代理中，代理对象控制对远程对象的访问；在虚拟代理中，代理对象在需要时才创建实际对象。
  - 代理模式通过为其他对象提供一种代理，以控制对这个对象的访问。通过这种方式，可以在不修改现有类的情况下，为对象添加新的功能，例如延迟加载、安全控制、日志记录等。
  - 和装饰器相比，装饰器一般是增加对外能力。而代理一般是不会调整对外的方式，而是修改实现。比如说直接上网和通过代理模式上网。对外的接口是一样的，但代理模式可以在不改变接口的情况下，添加一些额外的处理逻辑。
  - 比如说有门这个类了，要整一个防盗门，就可以通过代理模式实现。
