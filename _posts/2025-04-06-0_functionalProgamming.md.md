---
layout: post
title: 函数对象和函数式编程
categories: language
related_posts: True
tags: cpp functional
toc:
  sidebar: left
---

## 函数对象和函数式编程

> todo: 要补充柯里化，偏函数内容、mapReduce内容
> 狭义地函数式编程还是比较强调纯函数，这里对纯函数那种函数式编程讲解不够深入。

### 1. 什么是函数对象

在 C++ 中，函数对象（也称为仿函数）是一个行为类似函数的对象。任何类如果重载了 `operator()`，那么该类的对象就可以作为函数来使用，这样的对象就被称为函数对象。

函数对象的优点包括：

1. **内联优化**：由于函数对象是类的对象，其操作符重载函数通常会被编译器内联，这可以消除函数调用的开销，提高性能。
2. **状态保持**：函数对象可以有自己的成员变量，这意味着它们可以保持状态。这对于需要在多次调用之间保持状态的操作非常有用。
3. **灵活性**：函数对象可以被参数化。例如，你可以在构造函数中传入参数来改变函数对象的行为。这种灵活性使得函数对象可以很容易地适应不同的需求。

以下是一个简单的函数对象的例子：

```cpp
class Add {
public:
    Add(int x) : x_(x) {}

    int operator()(int y) const {
        return x_ + y;
    }

private:
    int x_;
};

int main() {
    Add add_five(5);
    std::cout << add_five(6);  // 输出：11
    return 0;
}
```

在这个例子中，`Add` 是一个函数对象，它接受一个参数 `x`，然后返回 `x + y`。我们可以像调用函数一样调用 `add_five(6)`，并得到结果 `11`。

#### 1.1 stl中的函数对象有哪些？

STL（Standard Template Library，标准模板库）中包含了一些预定义的函数对象，这些函数对象主要分为两类：算术运算函数对象和关系运算函数对象。

**算术运算函数对象**：

- `std::plus`：加法函数对象
- `std::minus`：减法函数对象
- `std::multiplies`：乘法函数对象
- `std::divides`：除法函数对象
- `std::modulus`：取模函数对象
- `std::negate`：取反函数对象

**关系运算函数对象**：

- `std::equal_to`：等于函数对象
- `std::not_equal_to`：不等于函数对象
- `std::greater`：大于函数对象
- `std::less`：小于函数对象
- `std::greater_equal`：大于等于函数对象
- `std::less_equal`：小于等于函数对象

这些函数对象都是模板，可以用于任何类型，只要该类型支持对应的运算符。例如，`std::less<int>` 是一个可以比较两个整数大小的函数对象。

#### 1.2 stl的函数对象怎么用？

`std::less` 是一个函数对象，它提供了一种方式来比较两个对象。它的行为类似于 `<` 运算符。以下是一个 `std::less` 的使用例子：

```cpp
#include <iostream>
#include <functional>

int main() {
    std::less<int> less;

    std::cout << std::boolalpha;  // 输出 bool 值为 true 或 false 而不是 1 或 0
    std::cout << "less(10, 20): " << less(10, 20) << std::endl;  // 输出：true
    std::cout << "less(20, 10): " << less(20, 10) << std::endl;  // 输出：false
    std::cout << "less(10, 10): " << less(10, 10) << std::endl;  // 输出：false

    return 0;
}
```

在这个例子中，我们创建了一个 `std::less<int>` 的对象 `less`，然后使用它来比较两个整数的大小。`less(10, 20)` 返回 `true`，因为 10 小于 20；`less(20, 10)` 返回 `false`，因为 20 不小于 10；`less(10, 10)` 返回 `false`，因为 10 不小于 10。

### 2. 函数式编程

#### 2.1 什么是函数式编程？

函数式编程最本质的是将函数作为一等公民处理，即函数可以作为变量传递。一个函数的输入和输出也可以是另一个函数。
基于此，函数式编程有两种主要的实践方式：

第一种：强调纯函数和不可变数据

- 特点
  - 以 lambda 演算为理论基础，指导编译器理解函数式编程。
  - 函数不带状态，也不可变。非常利于并行计算，也利于测试。因为只需要关注输入和输出就好了。
  - 可能不容易写好，但是写好之后比较少 bug。
  - 纯函数：不依赖外部状态，也不修改外部状态。对于相同的输入，总是返回相同的输出。
  - 不可变数据：数据一旦创建就不能修改，所有的操作都返回新的数据。
- 好处
  **易于测试和调试**：
  - 纯函数不依赖外部状态，也不修改外部状态，因此测试和调试变得更加简单。你只需要关注输入和输出，而不需要担心外部环境的影响。
    **并行计算友好**：
  - 由于纯函数没有副作用，可以安全地在多个线程中并行执行，而不需要担心数据竞争和同步问题。这使得并行计算变得更加容易和高效。
    **代码可预测性高**：
  - 纯函数对于相同的输入总是返回相同的输出，这使得代码行为更加可预测，减少了意外情况的发生。

第二种：高阶函数和条件式编程

- 特点
  - 高阶函数：可以接受一个或多个函数作为参数，或返回一个函数。
  - 条件式编程：例如用于回调函数/异步函数，将一个函数传入到某个时机去执行。
  - 条件查询：方便传入一个函数进行过滤操作。
  - 例如，`map`、`filter` 和 `reduce` 等高阶函数在处理数据时非常有用。
- 好处
  **代码简洁和可读性高**：
  - 高阶函数和条件式编程使得代码更加简洁和易读。通过将函数作为参数传递，可以减少重复代码，提高代码的可读性。
    **提高代码复用性**：
  - 高阶函数允许你编写通用的函数逻辑，并通过传递不同的函数来实现不同的功能。这提高了代码的复用性，减少了重复代码。
    **灵活性和扩展性**：
  - 条件式编程使得代码更加灵活，可以根据不同的条件执行不同的操作。通过传递不同的回调函数，可以轻松扩展代码的功能。
    **简化异步编程**：
  - 条件式编程特别适用于异步编程，通过传递回调函数，可以简化异步操作的实现，使代码更加直观和易于理解。
    **方便数据处理**：
  - 高阶函数如 `map`、`filter` 和 `reduce` 在处理数据时非常有用。它们提供了简洁的语法来进行数据转换、过滤和聚合操作，提高了代码的效率和可读性。

#### 2.2 纯粹的函数式编程

对于一些教条主义者来说，这是简单把函数作为参数，是不能够算函数式变成的。
函数式变成，必须是纯函数，即没有状态变量，或者说不会修改状态变量。
因此`[&]()[xxx]`就不会是函数式编程。

更加严格的教条主义还会要求函数是单参数的，使用柯里化方式将函数调整成单参数的，并且会使用一些函数算子。
这里在附录形式给出。不另外说明。

### 97. 例子

#### 1. 基本例子

```c++
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> data{1, 2, 3, 4, 5};

    // lambda函数是纯函数，没有状态。方便搭配std::execution::par完成并行。
    std::transform(std::execution::par, data.begin(), data.end(), data.begin(),
                   [](int x) { return x * 2; });

    for (const auto &val : data) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

```c++
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> data{1, 2, 3, 4, 5};
    auto printDoubleValue = [](int x){
        std::cout << x * 2 << " ";
    };

    // 相较于传统的 `for` 循环写法，loop执行的意图可以通过函数命名表达
    // 使得不需要阅读整个循环体就能理解代码的意图。
    std::for_each(data.begin(), data.end(), printDoubleValue);
    std::cout << std::endl;

    return 0;
}
```

#### 2. 函数式编程

```c++
// 严格-函数式编程
// 1. 无状态变量，或者不修改状态变量。
// 2. 单参数
// 3. 使用函数算子
auto Y = [](auto f) {
  return [f](auto x) -> std::function<int(int)> {
    return f([x](auto v) { return x(x)(v); });
  }([f](auto x) -> std::function<int(int)> {
           return f([x](auto v) { return x(x)(v); });
         });
};

auto factorial = Y(
    [](auto f) { return [f](int n) { return (n == 0) ? 1 : n * f(n - 1); }; });

void test_y_combinator() {
  std::cout << "Factorial of 5: " << factorial(5) << '\n';
}
```

```c++
// 柯里化的调用两次的算子
auto callTwice = [](auto func) {
    return [func](auto value) {
        return func(func(value));
    };
};

// 示例函数：将整数加倍
auto doubleValue = [](int x) {
    return x * 2;
};

```

#### 3. 其他的函数式编程用法

```c++
template <typename T, typename ...Ts>
auto concat(T t, Ts ...ts) {
    if constexpr (sizeof...(ts) > 0) {
        return [=](auto ...parameters) {
            return t(concat(ts...)(parameters...));
            };
    }
    else {
        return [=](auto ...parameters) {
            return t(parameters...);
            };
    }
}

void test_concat() {
    auto twice = [](int i) { return i * 2; };
    auto thrice = [](int i) { return i * 3; };
    auto combined = concat(twice, thrice, std::plus<int>{});

    std::cout << combined(2, 3) << '\n';
}
```

### 98. 总结

- 并行
  函数式编程强调不可变性，因此不应将 `std::for_each` 视为一个传统的循环体。传统的循环体是一个迭代器接一个迭代器地顺序运行，而函数式编程则可以看作是对所有迭代器同时执行一个操作。这个操作可以是串行的，也可以是并行的，这取决于具体的执行策略。

在 C++17 中，引入了 `std::execution::par`，使得这些操作可以方便地并行执行。编译器可以根据执行策略优化代码，从而提高性能。

如果操作中存在线程安全问题，可以在操作中使用加锁等方式来确保线程安全。例如，可以使用 `std::mutex` 来保护共享数据。

- 可读
  相较于传统的 `for` 循环实现，函数式编程明确了操作的目的，提升了代码的可读性。

在 `for` 循环中，操作可能会包含 `break` 语句、对集合进行变形操作，或者在集合中查找符合条件的元素。而函数式编程则通过使用特定的高阶函数明确了操作的意图。例如：

- **变形操作**：使用 `std::transform`。
- **查找操作**：使用 `std::any_of`、`std::all_of` 或 `std::find_if`。

此外，对于复杂的操作，通常会对 lambda 表达式进行命名，通过函数命名来解释操作的目的。这使得代码更加自解释，减少了对注释的依赖。

在传统的 `for` 循环中，开发者往往需要依赖注释来解释操作的目的。然而，注释通常容易被忽略或遗忘，导致代码难以阅读和理解。

### 99. quiz

#### 1. 函数对象和lambda有什么本质不同吗？两者都可以保存状态变量

函数对象和 lambda 表达式在 C++ 中都可以用来封装行为，并且都可以保存状态。但是，它们在使用方式和适用场景上有一些不同：

1. **定义方式**：函数对象是通过定义一个类并重载 `operator()` 来创建的，而 lambda 表达式是通过一个简洁的语法直接在代码中创建的。

2. **状态保存**：函数对象可以通过成员变量来保存状态，而 lambda 表达式则通过捕获列表来保存状态。函数对象的状态保存更为直观和灵活，而 lambda 表达式的状态保存更为简洁和方便。

3. **复用性**：函数对象可以在定义后在多处复用，而 lambda 表达式通常在定义后立即使用，并不易于复用。

4. **复杂性**：对于复杂的行为，使用函数对象可能更为合适，因为你可以利用类的所有特性（如私有成员、成员函数等）来组织你的代码。而对于简单的行为，使用 lambda 表达式可能更为合适，因为它的语法更为简洁。

总的来说，函数对象和 lambda 表达式在某些方面是相似的，但是它们在使用方式和适用场景上有一些不同。你应该根据你的具体需求来选择使用哪一种。

#### 2. 函数对象、lambda、普通函数，性能上有什么不同吗？编译器行为有什么区别？

在大多数情况下，函数对象、lambda 表达式和普通函数的性能是相似的。这是因为现代编译器通常会对这些构造进行优化，例如内联函数调用，以减少函数调用的开销。

以下是这三种构造在编译器行为上的一些区别：

1. **函数对象**：函数对象是类的对象，其操作符重载函数通常会被编译器内联，这可以消除函数调用的开销，提高性能。此外，函数对象可以有自己的成员变量，这意味着它们可以保持状态。

2. **lambda 表达式**：lambda 表达式在编译时会被转换为函数对象，因此它们的性能特性和函数对象相似。lambda 表达式的一个优点是它们可以捕获周围的环境，这使得它们在编写闭包时非常有用。

3. **普通函数**：普通函数在编译时会被转换为机器代码，它们不能保持状态（除非使用静态变量），也不能捕获周围的环境。但是，普通函数可以被声明为内联函数，提示编译器进行内联优化。

总的来说，函数对象、lambda 表达式和普通函数在性能上的差异通常可以忽略不计。你应该根据你的具体需求和编程风格来选择使用哪一种。在考虑性能时，你应该首先关注算法的复杂性，然后再考虑这些低级的优化。

#### 3. 什么是柯里化？柯里化的目的和意义是什么？

柯里化（Currying）是函数式编程中的一种技术，它将一个接受多个参数的函数转换为一系列接受单一参数的函数。换句话说，柯里化将一个多参数函数转换为多个嵌套的一元函数（即每个函数只接受一个参数）。

假设有一个普通的多参数函数：

```cpp
int add(int a, int b) {
    return a + b;
}
```

通过柯里化，这个函数可以转换为：

```cpp
auto curriedAdd = [](int a) {
    return [a](int b) {
        return a + b;
    };
};

// 使用柯里化函数
int result = curriedAdd(2)(3); // result = 5
```

- **柯里化的目的和意义**

1. **提高函数的复用性**：

   - 柯里化使得函数可以部分应用（Partial Application），即你可以固定函数的一部分参数，生成一个新的函数。这提高了代码的复用性和灵活性。

2. **简化函数组合**：

   - 柯里化使得函数组合更加简单和直观。你可以将多个小函数组合成一个复杂的函数，而不需要显式地传递所有参数。

3. **增强代码的可读性和可维护性**：

   - 柯里化使得代码更加模块化，每个函数只处理一个参数，逻辑更加清晰。这提高了代码的可读性和可维护性。

4. **支持函数式编程范式**：
   - 柯里化是函数式编程的重要特性之一，它使得函数式编程中的高阶函数、函数组合等技术更加容易实现。

计算机是一个工程发展远远领先学科发展的领域，很多概念定义出来之后，工程会基于原始概念不停发展，甚至会和原来初衷不太一样。
lambda演算是函数式编程的理论基础。
首先lambda演算是一种计算形式，定义了三种基本元素：定义函数，变量，函数计算。
这三种基本元素
lambda演算

https://www.lumin.tech/articles/lambda-calculus/

https://yhj.me/posts/introduction-to-lambda-calculus

https://blog.csdn.net/sinat_35576477/article/details/122031649

https://www.shuzhiduo.com/A/Vx5MOX07zN/

https://site.douban.com/145723/widget/notes/192785890/note/611560272/

https://openhome.cc/Gossip/CodeData/JavaLambdaTutorial/LambdaCalculus.html

https://zhuanlan.zhihu.com/p/30510749

https://learnxinyminutes.com/zh-cn/lambda-calculus/

https://cgnail.github.io/academic/lambda-2/

https://cgnail.github.io/academic/lambda-2/

函数式编程，和面向过程式编程以及面向对象编程一样，都是一种范式。在实际编程中，使用哪一种范式，其实还是相当依赖于语言自身提供的能力的。
比如说C语言，封装了struct，强行按照面向对象的感觉来写，可以吗？也是可以的，在相当多的大型C项目是有面向对象影子的。但是，多少会有一些蹩脚。
而函数式编程则是在haskell，lisp以及js等语言更流行。特别是随着js影响力的提升，其他编程语言也逐步吸收了函数式编程的概念。
比如说c++中的lambda函数，自然是可以理解为是一种函数声明的语法糖；但更恰当地理解应该是引入函数式编程的一个起点，这是函数式编程的基本概念。

函数式编程发展的理论基础源于lambda演算，这是一种记号系统。

> 什么是记号系统，类似于中小学做过的自定义运算符号题目把。给一些记号定义一些规则，基于若干规则进行演化。
> 那是怎么样的记号系统呢？是用于研究函数的。函数在一般认知里面，就是一种给定输入，给出输出的过程。但是这里进一步，把函数看成一种变量，看成一种输入，即给定函数，我的输出也还是函数。

这种把函数视为一个变量，对函数进行操作，组合的特性，在某些数据处理对象的场景下会更好用。下面给出一个从面向过程逐步转向函数式编程的写法。

函数式编程有什么好处呢？易于测试，修改方便，利于并行。
