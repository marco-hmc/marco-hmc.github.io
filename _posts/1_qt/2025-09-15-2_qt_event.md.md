---
layout: post
title: ï¼ˆäºŒï¼‰Qt é‚£äº›äº‹å„¿ï¼šäº‹ä»¶å¾ªç¯æœºåˆ¶
categories: C++
related_posts: True
tags: Qt
toc:
  sidebar: right
---

## ï¼ˆäºŒï¼‰Qt é‚£äº›äº‹å„¿ï¼šäº‹ä»¶å¾ªç¯æœºåˆ¶

### 1. concepts

#### 1.1 ä»€ä¹ˆæ˜¯äº‹ä»¶å¾ªç¯ï¼Ÿ

Qt äº‹ä»¶å¾ªç¯ï¼ˆEvent Loopï¼‰æ˜¯æ•´ä¸ªæ¡†æ¶çš„æ ¸å¿ƒï¼Œå®ƒåŸºäº**ç”Ÿäº§è€…-æ¶ˆè´¹è€…**æ¨¡å¼è¿ä½œï¼š

```
æ“ä½œç³»ç»Ÿ â†’ äº‹ä»¶é˜Ÿåˆ— â†’ Qtäº‹ä»¶å¾ªç¯ â†’ æ§ä»¶å¤„ç†
   â†‘          â†‘          â†‘         â†‘
ç”Ÿäº§äº‹ä»¶    ç¼“å­˜äº‹ä»¶    æ¶ˆè´¹äº‹ä»¶   å“åº”äº‹ä»¶
```

**æ ¸å¿ƒæœºåˆ¶ï¼š**

- **äº‹ä»¶ç”Ÿäº§**ï¼šæ“ä½œç³»ç»Ÿæ•è·ç”¨æˆ·æ“ä½œï¼ˆé¼ æ ‡ã€é”®ç›˜ç­‰ï¼‰
- **äº‹ä»¶ç¼“å­˜**ï¼šäº‹ä»¶è¢«æ”¾å…¥é˜Ÿåˆ—ç­‰å¾…å¤„ç†
- **äº‹ä»¶æ¶ˆè´¹**ï¼šQt ä»é˜Ÿåˆ—å–å‡ºäº‹ä»¶å¹¶åˆ†å‘
- **äº‹ä»¶å“åº”**ï¼šç›®æ ‡æ§ä»¶å¤„ç†äº‹ä»¶

åœ¨ Qt æ¡†æ¶ä¸­ï¼Œäº‹ä»¶å¾ªç¯ï¼ˆEvent Loopï¼‰å¤„äºæ ¸å¿ƒåœ°ä½ï¼Œè´Ÿè´£ç®¡ç†å’Œå¤„ç†åº”ç”¨ç¨‹åºä¸­å„ç±»äº‹ä»¶ã€‚æ— è®ºæ˜¯ç”¨æˆ·åœ¨ç•Œé¢ä¸Šçš„ç‚¹å‡»ã€è¾“å…¥ç­‰æ“ä½œï¼Œè¿˜æ˜¯ç³»ç»Ÿäº§ç”Ÿçš„å®šæ—¶å™¨äº‹ä»¶ã€çŠ¶æ€å˜åŒ–é€šçŸ¥ç­‰ï¼Œéƒ½éœ€ç”±ç¨‹åºæ•æ‰å¹¶åšå‡ºå“åº”ã€‚

æ“ä½œç³»ç»Ÿä¼šæ•è·è¿™äº›äº‹ä»¶ï¼Œå‘é€åˆ°ç¨‹åºå’Œ os ä¹‹é—´çš„ä¸€ä¸ªç¼“å­˜åŒºï¼Œä¹Ÿå«äº‹ä»¶é˜Ÿåˆ—ã€‚ç¨‹åºä¼šä¸å®šæœŸä»è¿™ä¸ªäº‹ä»¶é˜Ÿåˆ—å–å‡ºäº‹ä»¶æ¶ˆè´¹ï¼Œæ‰€è°“çš„ç¨‹åºæœªå“åº”å…¶å®å°±æ˜¯è¿™ä¸ªäº‹ä»¶é˜Ÿåˆ—å·²æ»¡ï¼Œæ— æ³•ç»§ç»­æ·»åŠ äº‹ä»¶ï¼Œå› æ­¤å½“å‰å‡ºäºæ— æ³•å“åº”çš„çŠ¶æ€ã€‚è€Œ Qt ä½œä¸ºä¸€ä¸ªæ¡†æ¶ï¼Œåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­å±è”½äº†ä¸åŒå¹³å°äº§ç”Ÿçš„äº‹ä»¶ç±»å‹ï¼Œä¸åŒå¹³å°çš„äº‹ä»¶è·å–æ–¹å¼ï¼Œå¹¶ç»™å‡ºäº†ç»Ÿä¸€çš„äº‹ä»¶æ¶ˆè´¹ã€äº‹ä»¶åˆ†å‘æœºåˆ¶ã€‚

åˆå› ä¸ºäº‹ä»¶çš„å¤„ç†ï¼ˆåˆ†å‘ã€æ¶ˆè´¹ï¼‰å’Œäº‹ä»¶çš„ç”Ÿæˆä¸æ˜¯åŒä¸€ä¸ªä¸»ä½“ï¼Œå‰è€…æ˜¯ç¨‹åºè‡ªèº«ï¼Œè€Œåè€…æ˜¯ os çš„äº‹æƒ…ï¼Œå› æ­¤å³ä½¿äº‹ä»¶åœ¨å¤„ç†çš„è¿‡ç¨‹ä¸­ï¼Œäº‹ä»¶ä¹Ÿå¯ä»¥ä¸åœç”Ÿäº§å¹¶æ·»åŠ åˆ°äº‹ä»¶é˜Ÿåˆ—ä¸­ã€‚

äº‹ä»¶å¾ªç¯åŸºäºé˜Ÿåˆ—æœºåˆ¶å¾ªç¯å¤„ç†äº‹ä»¶ã€‚å½“äº‹ä»¶é˜Ÿåˆ—ä¸­æœ‰ç­‰å¾…å¤„ç†çš„äº‹ä»¶æ—¶ï¼Œäº‹ä»¶å¾ªç¯è¢«æ¿€æ´»å¹¶å¤„ç†è¿™äº›äº‹ä»¶ï¼›è‹¥é˜Ÿåˆ—ä¸ºç©ºï¼Œäº‹ä»¶å¾ªç¯åˆ™è¿›å…¥é˜»å¡çŠ¶æ€ï¼Œç­‰å¾…æ–°äº‹ä»¶å‘ç”Ÿã€‚

å€ŸåŠ©äº‹ä»¶å¾ªç¯ï¼ŒQt åº”ç”¨èƒ½å¤Ÿä»¥éé˜»å¡æ–¹å¼å“åº”ç”¨æˆ·äº¤äº’ï¼Œä½¿ç•Œé¢ä¿æŒå“åº”çŠ¶æ€ï¼ŒåŒæ—¶å¤„ç†å…¶ä»–å¼‚æ­¥äº‹ä»¶ã€‚è¿™ç§æ¨¡å‹è®©ç¨‹åºåœ¨ç­‰å¾…äº‹ä»¶å‘ç”Ÿæ—¶ä¿æŒä½åŠŸè€—ï¼Œä»…åœ¨å¿…è¦æ—¶å”¤é†’æ‰§è¡Œç›¸å…³æ“ä½œï¼Œé«˜æ•ˆåˆ©ç”¨ç³»ç»Ÿèµ„æºã€‚

#### 1.2 Qt ç¨‹åºå¯¹äº‹ä»¶çš„å…·ä½“å¤„ç†æœºåˆ¶

ç¨‹åºæ¥æ”¶æ“ä½œç³»ç»Ÿåˆ†å‘çš„äº‹ä»¶ï¼ˆå¦‚é¼ æ ‡ç‚¹å‡»ã€é”®ç›˜è¾“å…¥ã€çª—å£å¤§å°å˜åŒ–ç­‰ï¼‰åï¼Œå€ŸåŠ©äº‹ä»¶å¾ªç¯å¤„ç†å¹¶ä¼ é€’ç»™ç›¸åº”æ§ä»¶ã€‚ä»¥ Qt ä¸ºä¾‹ï¼Œè¯¦ç»†è¿‡ç¨‹å¦‚ä¸‹ï¼š

1. **äº‹ä»¶çš„æ¶ˆè´¹å’ŒåŠ å·¥**

   æ“ä½œç³»ç»Ÿå°†äº‹ä»¶æ¶ˆæ¯å‘é€è‡³å‰å°çª—å£ã€‚ä»¥Windowsä¸ºä¾‹ï¼ŒQtå†…éƒ¨ä½¿ç”¨`QWindowsEventDispatcher`æ¥æ”¶`WM_MOUSEMOVE`ã€`WM_LBUTTONDOWN`ç­‰æ¶ˆæ¯ï¼Œéšåå°è£…ä¸ºQtè‡ªå·±çš„äº‹ä»¶å¯¹è±¡ï¼ˆå¦‚`QMouseEvent`ï¼‰ã€‚

   Qtå°†å¹³å°äº‹ä»¶ç»Ÿä¸€åŠ å·¥æˆQtäº‹ä»¶ï¼Œå±è”½å¹³å°å·®å¼‚ï¼š

   ```cpp
   // Windows: WM_MOUSEMOVE, WM_LBUTTONDOWN
   // Linux: X11 events
   // macOS: Cocoa events
   // â†“ Qtå†…éƒ¨è½¬æ¢
   // QMouseEvent, QKeyEvent, QPaintEvent
   ```

   Qtç¨‹åºå¯åŠ¨æ—¶æ‰§è¡Œ`QApplication::exec()`ï¼Œè¿™æ˜¯ä¸€ä¸ªæŒç»­è¿è¡Œçš„å¾ªç¯å‡½æ•°ï¼Œä¸æ–­ä»äº‹ä»¶é˜Ÿåˆ—æ¶ˆè´¹äº‹ä»¶ï¼š

   ```cpp
   int main(int argc, char *argv[]) {
       QApplication app(argc, argv);
       MainWindow w;
       w.show();
       return app.exec();  // å¯åŠ¨äº‹ä»¶å¾ªç¯
   }
   ```

   äº‹ä»¶å¾ªç¯åŸºäºæ“ä½œç³»ç»Ÿæ¶ˆæ¯æœºåˆ¶ï¼Œå°è£…åœ¨`QEventLoop`ç±»ä¸­ã€‚Qtå°†å¹³å°æ¶ˆæ¯è½¬æ¢ä¸º`QEvent`å¯¹è±¡å¹¶æ”¾å…¥äº‹ä»¶é˜Ÿåˆ—ï¼ˆç”±`QCoreApplication`ç®¡ç†ï¼‰ã€‚æ‰§è¡Œ`app.exec()`æ—¶å¯åŠ¨äº‹ä»¶å¾ªç¯æœºåˆ¶ï¼Œé€šè¿‡`QEventLoop::exec()`è¿›è¡Œwhileå¾ªç¯ï¼Œä¸æ–­å–å‡ºå¹¶å¤„ç†äº‹ä»¶ã€‚

2. **Qt å¯¹äº‹ä»¶çš„åˆ†å‘**

   å–å‡ºäº‹ä»¶åï¼Œé€šè¿‡`QCoreApplication::notify(QObject *receiver, QEvent *event)`ç¡®å®šæ¥æ”¶äº‹ä»¶çš„æ§ä»¶å¹¶åˆ†å‘ã€‚è¯¥å‡½æ•°è´Ÿè´£å°†äº‹ä»¶åˆ†å‘ç»™æ¥æ”¶è€…ï¼Œå¹¶è°ƒç”¨`receiver->event(event)`å‡½æ•°ã€‚

   ä¸åŒäº‹ä»¶çš„åˆ†å‘æ–¹å¼ï¼š

   - **é¼ æ ‡äº‹ä»¶**ï¼šé€šè¿‡åæ ‡æ˜ å°„ç¡®å®šå¯¹åº”æ§ä»¶æ¥æ”¶
   - **é”®ç›˜äº‹ä»¶**ï¼šç”±è·å¾—ç„¦ç‚¹çš„æ§ä»¶æ¥æ”¶
   - **å®šæ—¶å™¨äº‹ä»¶**ï¼šç”±è®¾ç½®äº†`QTimer`çš„æ§ä»¶æˆ–å¯¹è±¡æ¥æ”¶
   - **è‡ªå®šä¹‰äº‹ä»¶**ï¼šæ‰‹åŠ¨æŠ•é€’æˆ–å‘é€

   ä»¥é¼ æ ‡äº‹ä»¶ä¸ºä¾‹ï¼š

   ```cpp
   // åœ¨ QApplication::notify ä¸­
   // Qtç›´æ¥å®šä½ç›®æ ‡æ§ä»¶ï¼Œä¸é€å±‚ä¼ é€’
   QWidget *target = QWidget::find(widgetAt(mousePos));
   QMouseEvent event(...);
   QCoreApplication::sendEvent(target, &event);
   ```

   Qtçš„äº‹ä»¶åˆ†å‘æ˜¯ç›´æ¥ä¼ å…¥ç›®æ ‡æ§ä»¶ï¼Œè€Œéçˆ¶å¯¹è±¡é€å±‚ä¼ é€’ã€‚å½“é¼ æ ‡ç‚¹å‡»å‘ç”Ÿæ—¶ï¼ŒQtç²¾å‡†å®šä½æœ€ç»ˆç›®æ ‡æ§ä»¶ï¼ˆå¦‚`QPushButton`ï¼‰ï¼Œç›´æ¥å‘é€äº‹ä»¶ç»™å®ƒã€‚è¿™ç§å®šä½åœ¨`QApplication::notify()`ä¸­å®Œæˆï¼Œå€ŸåŠ©`QWidget::find()`ç­‰æœºåˆ¶ç¡®å®šæ¥æ”¶äº‹ä»¶çš„å…·ä½“æ§ä»¶ã€‚

   å‡è®¾æ§ä»¶ç»“æ„å¦‚ä¸‹ï¼š

   ```
   MainWindow
   â””â”€â”€ QWidget (parent)
       â””â”€â”€ QPushButton (child, åæ ‡åŒºåŸŸè¦†ç›–é¼ æ ‡)
   ```

   äº‹ä»¶åˆ†å‘æµç¨‹ï¼š

   1. Qtè·å–é¼ æ ‡åæ ‡ï¼ˆç›¸å¯¹äºå±å¹•æˆ–ä¸»çª—å£ï¼‰
   2. è°ƒç”¨`QWidget::childAt()`æ‰¾åˆ°è¯¥åæ ‡ä¸‹æœ€æ·±å±‚çš„æ§ä»¶ï¼ˆ`QPushButton`ï¼‰
   3. ç›´æ¥å°†äº‹ä»¶å‘é€ç»™`QPushButton`
   4. `QPushButton`æ¥æ”¶äº‹ä»¶åè°ƒç”¨è‡ªèº«çš„`event()`å‡½æ•°ï¼Œè¿›è€Œåˆ†å‘ç»™`mousePressEvent()`å¤„ç†

   ä¸åŒç±»å‹äº‹ä»¶çš„åˆ†å‘æ–¹å¼ï¼š

   | ç±»å‹                | åˆ†å‘æ–¹å¼                                   |
   | ------------------- | ------------------------------------------ |
   | é¼ æ ‡/é”®ç›˜/è§¦æ‘¸äº‹ä»¶  | ğŸš€ ç›´æ¥åˆ†å‘ç»™ç›®æ ‡æ§ä»¶                      |
   | ç»˜åˆ¶äº‹ä»¶ PaintEvent | ğŸ§± ç”±å¤–å±‚æ§ä»¶é€’å½’å‘å­æ§ä»¶è°ƒç”¨              |
   | è‡ªå®šä¹‰äº‹ä»¶          | ğŸš€ ä½¿ç”¨`postEvent`/`sendEvent`æ‰‹åŠ¨æŒ‡å®šç›®æ ‡ |
   | æ‹¦æˆªæœºåˆ¶            | ğŸ›‘ `installEventFilter()`å…ˆäºæ­£å¸¸åˆ†å‘      |

   **æ³¨æ„**ï¼šæ™®é€šè¾“å…¥äº‹ä»¶ç›´æ¥å‘é€è‡³ç›®æ ‡æ§ä»¶ï¼Œä½†ç»˜åˆ¶äº‹ä»¶ï¼ˆ`QPaintEvent`ï¼‰ä¸åŒã€‚ç»˜åˆ¶äº‹ä»¶ç”±æ¡†æ¶è‡ªåŠ¨äº§ç”Ÿï¼Œåˆ†å‘é¡ºåºæŒ‰æ§ä»¶å±‚çº§ä»å¤–åˆ°å†…è°ƒç”¨ï¼Œå¦‚`MainWindow::paintEvent() â†’ QWidget::paintEvent() â†’ QPushButton::paintEvent()`ã€‚

3. **æ§ä»¶å¯¹äº‹ä»¶çš„æ¶ˆè´¹**

   äº‹ä»¶åˆ°è¾¾æ§ä»¶ï¼ˆQObjectæ´¾ç”Ÿç±»ï¼‰åï¼Œå…ˆè°ƒç”¨`event()`å‡½æ•°ï¼Œå†åˆ†å‘ç»™å…·ä½“å¤„ç†å‡½æ•°ï¼š

   ```cpp
   bool QWidget::event(QEvent *e) {
       switch (e->type()) {
           case QEvent::MouseButtonPress:
               return mousePressEvent(static_cast<QMouseEvent *>(e));
           case QEvent::KeyPress:
               return keyPressEvent(static_cast<QKeyEvent *>(e));
           ...
       }
       return false;
   }
   ```

   `event()`æ˜¯æ§ä»¶å¤„ç†æ‰€æœ‰äº‹ä»¶çš„ç»Ÿä¸€å…¥å£ï¼ŒQtæ ¹æ®äº‹ä»¶ç±»å‹è°ƒç”¨ä¸“é—¨çš„å‡½æ•°ã€‚å¼€å‘è€…å¯é‡å†™è¿™äº›å¤„ç†å‡½æ•°å®ç°è‡ªå®šä¹‰è¡Œä¸ºã€‚

   **äº‹ä»¶å¤„ç†è¿”å›å€¼çš„æ„ä¹‰ï¼š**

   - **è¿”å›`true`**ï¼šäº‹ä»¶å·²å¤„ç†å®Œæ¯•ï¼ŒQtäº‹ä»¶ç³»ç»Ÿè®¤ä¸ºä¸éœ€è¦å†ä¼ é€’ç»™å…¶ä»–å¯¹è±¡ï¼ˆåŒ…æ‹¬çˆ¶æ§ä»¶ï¼‰
   - **è¿”å›`false`**ï¼šå½“å‰æ§ä»¶æœªå¤„ç†è¯¥äº‹ä»¶ï¼ŒQtäº‹ä»¶ç³»ç»Ÿå°†ç»§ç»­åˆ†å‘ç»™å…¶ä»–å¯¹è±¡

   è¿”å›å€¼å†³å®šäº‹ä»¶æ˜¯å¦"ç»ˆæ­¢ä¼ æ’­"ï¼š`true`ç»ˆæ­¢ä¼ æ’­ï¼Œ`false`å…è®¸äº‹ä»¶ç»§ç»­ä¼ é€’ã€‚

#### 1.3 å¦‚ä½•ä»‹å…¥äº‹ä»¶å¤„ç†æµç¨‹çš„æ—¶æœºä¸æ–¹å¼

ä½¿ç”¨äº‹ä»¶è¿‡æ»¤å™¨ï¼ˆäº‹ä»¶æ‹¦æˆªæœºåˆ¶ï¼‰å¯åœ¨äº‹ä»¶åˆ°è¾¾ç›®æ ‡æ§ä»¶**ä¹‹å‰**è¿›è¡Œæ‹¦æˆªå¤„ç†ï¼š

```cpp
// äº‹ä»¶è¿‡æ»¤å™¨ç±» MyFilter
bool MyFilter::eventFilter(QObject *watched, QEvent *event) {
    if (event->type() == QEvent::KeyPress) {
        qDebug() << "Key pressed!";
        return true; // è¿”å› true è¡¨ç¤ºæ‹¦æˆªè¯¥äº‹ä»¶
    }
    return false; // è¿”å› false è¡¨ç¤ºä¸å¤„ç†ï¼Œå°†äº‹ä»¶äº¤ç»™ç›®æ ‡å¯¹è±¡
}

// åœ¨ä¸»ä»£ç ä¸­å®‰è£…äº‹ä»¶è¿‡æ»¤å™¨
targetWidget->installEventFilter(myFilter);
// æ³¨æ„ï¼šæ­¤è¡Œä¸ºä¸ä¼šå¯¹å­å¯¹è±¡ç”Ÿæ•ˆï¼Œå¦‚éœ€å¯¹å­å¯¹è±¡å®‰è£…eventFilterï¼Œéœ€è¦æ‰¾åˆ°å­å¯¹è±¡è°ƒç”¨æ­¤æ–¹æ³•
```

`eventFilter()`æ˜¯`QObject`ç±»çš„æˆå‘˜å‡½æ•°ï¼Œé€šå¸¸åœ¨`QObject`æˆ–å…¶å­ç±»ä¸­é‡å†™ï¼Œç”¨äºè¿‡æ»¤å…¶ä»–å¯¹è±¡çš„äº‹ä»¶ã€‚å®‰è£…äº‹ä»¶è¿‡æ»¤å™¨åï¼Œå½“ç›®æ ‡å¯¹è±¡æ¥æ”¶äº‹ä»¶æ—¶ï¼Œ`eventFilter()`å‡½æ•°ä¼˜å…ˆè¢«è°ƒç”¨ï¼Œå¯ä»¥å†³å®šæ˜¯å¦æ‹¦æˆªäº‹ä»¶æˆ–è¿›è¡Œç‰¹æ®Šå¤„ç†ã€‚

#### 1.4 æŒ‚èµ·äº‹ä»¶çš„æå‰æ¶ˆè´¹ - `processEvents`

`processEvents()`æ˜¯åœ¨é˜»å¡ä»£ç ä¸­ä¿ƒä½¿Qtå¯¹å·²æ’é˜Ÿäº‹ä»¶è¿›è¡Œ"æŠ¢å…ˆå¤„ç†"ï¼Œç»´æŒç•Œé¢å“åº”æ€§çš„å…³é”®æ‰‹æ®µï¼š

```cpp
void MainWindow::onLoadClicked() {
    // UIæ˜¾ç¤º"æ­£åœ¨åŠ è½½"
    ui->label->setText("Loading...");

    // è¿™é‡Œä¸è°ƒç”¨ processEventsï¼ŒUI å¯èƒ½ä¸ä¼šç«‹å³åˆ·æ–°
    // å¼€å§‹åŠ è½½ä¸€ä¸ªå¤§æ–‡ä»¶ï¼ˆé˜»å¡ä¸»çº¿ç¨‹ï¼‰
    loadBigFile();

    // åŠ è½½å®Œå†åˆ·æ–° UI
    ui->label->setText("Load done");
}
```

åœ¨æ­¤å®ç°ä¸­ï¼Œç”±äºè®¾ç½®`label`æ–‡æœ¬åæœªè°ƒç”¨`processEvents()`ï¼Œæ‰§è¡Œ`loadBigFile()`è¿™ä¸€é˜»å¡æ“ä½œæ—¶ï¼ŒUIå¯èƒ½æ— æ³•åŠæ—¶åˆ·æ–°æ˜¾ç¤º"Loading..."ã€‚

æ”¹è¿›åçš„å®ç°ï¼š

```cpp
void MainWindow::onLoadClicked() {
    ui->label->setText("Loading...");
    qApp->processEvents();  // ç«‹å³å¤„ç†äº‹ä»¶ï¼Œåˆ·æ–°ç•Œé¢

    loadBigFile(); // é˜»å¡æ“ä½œ

    ui->label->setText("Load done");
}
```

`processEvents()`æ–¹æ³•å¤„ç†äº‹ä»¶é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰æŒ‚èµ·äº‹ä»¶ï¼ŒåŒ…æ‹¬ç”¨æˆ·è¾“å…¥ã€çª—å£æ›´æ–°ã€å®šæ—¶å™¨äº‹ä»¶ç­‰ã€‚é€šè¿‡è°ƒç”¨`qApp->processEvents()`ï¼Œåœ¨è®¾ç½®æ–‡æœ¬åç«‹å³å¤„ç†äº‹ä»¶ï¼Œç¡®ä¿UIåŠæ—¶åˆ·æ–°ã€‚

**ä½¿ç”¨æ³¨æ„äº‹é¡¹ï¼š**

1. **æ€§èƒ½é—®é¢˜**ï¼šé¢‘ç¹è°ƒç”¨å¯èƒ½å¼•å‘æ€§èƒ½ä¸‹é™ï¼Œæ¯æ¬¡è°ƒç”¨éƒ½ä¼šå¤„ç†æ‰€æœ‰æŒ‚èµ·äº‹ä»¶
2. **é¿å…é€’å½’äº‹ä»¶**ï¼šåœ¨äº‹ä»¶å¤„ç†è¿‡ç¨‹ä¸­å†æ¬¡è°ƒç”¨å¯èƒ½å¯¼è‡´é€’å½’ï¼Œä½¿é€»è¾‘å¤æ‚
3. **æ›¿ä»£æ–¹æ¡ˆ**ï¼šä¼˜å…ˆé‡‡ç”¨å¼‚æ­¥æ“ä½œï¼ˆå¦‚`QThread`æˆ–`QtConcurrent`ï¼‰é˜²æ­¢é˜»å¡äº‹ä»¶å¾ªç¯

#### 1.5 ä¸»åŠ¨ç”Ÿæˆäº‹ä»¶

åœ¨Qtä¸­ï¼Œäº‹ä»¶ï¼ˆ`QEvent`ï¼‰æ˜¯å¯¹è±¡é—´ä¼ é€’ä¿¡æ¯çš„æœºåˆ¶ã€‚é™¤äº†å¤–éƒ¨äº‹ä»¶ï¼ˆé¼ æ ‡ã€é”®ç›˜ã€çª—å£é‡ç»˜ç­‰ï¼‰ï¼Œè¿˜æœ‰ç³»ç»Ÿå†…éƒ¨äº‹ä»¶ï¼ˆå®šæ—¶å™¨æ¶ˆæ¯ã€è¿›ç¨‹é—´æ¶ˆæ¯ç­‰ï¼‰ã€‚

äº‹ä»¶çš„æ„é€ å‡½æ•°ä¸æ˜¯ç§æœ‰çš„ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥æ„é€ äº‹ä»¶ã€‚å¯¹äºæ–°æ„é€ çš„äº‹ä»¶ï¼Œæœ‰ä¸¤ç§æ¶ˆè´¹æ–¹å¼ï¼š

**(1) `sendEvent(QObject *receiver, QEvent *event)`**

- **åŒæ­¥è°ƒç”¨**ï¼šäº‹ä»¶ç«‹å³å‘é€åˆ°ç›®æ ‡å¯¹è±¡ï¼Œè°ƒç”¨é“¾ç«‹åˆ»è¿›å…¥`receiver->event()`
- äº‹ä»¶å¤„ç†å®Œæˆåæ‰è¿”å›è°ƒç”¨è€…
- ä¸è¿›å…¥Qtäº‹ä»¶é˜Ÿåˆ—ï¼Œä¸ç­‰å¾…äº‹ä»¶å¾ªç¯
- é€‚åˆ**éœ€è¦ç«‹å³æ‰§è¡Œçš„åœºæ™¯**
- å› ä¸ºç«‹å³æ‰§è¡Œï¼Œè‹¥åœ¨éUIçº¿ç¨‹è°ƒç”¨ï¼Œä¼šè¿åçº¿ç¨‹äº²å’Œæ€§ï¼Œå¯èƒ½å¯¼è‡´å´©æºƒ
- ä¼šé˜»å¡å½“å‰çº¿ç¨‹ç›´åˆ°äº‹ä»¶å¤„ç†å®Œæˆ

```cpp
QMouseEvent event(QEvent::MouseButtonPress, QPointF(10, 10), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier);
QCoreApplication::sendEvent(widget, &event);  // ç«‹å³è°ƒç”¨ widget->event(&event)
```

**(2) `postEvent(QObject *receiver, QEvent *event)`**

- **å¼‚æ­¥è°ƒç”¨**ï¼šå°†äº‹ä»¶æ”¾å…¥Qtäº‹ä»¶é˜Ÿåˆ—ï¼Œç­‰åˆ°äº‹ä»¶å¾ªç¯å¤„ç†æ—¶æ‰è°ƒç”¨`receiver->event()`
- ä¸ä¼šç«‹å³å¤„ç†ï¼Œè¿”å›æ—¶äº‹ä»¶è¿˜æœªå¤„ç†
- é€‚åˆè·¨çº¿ç¨‹é€šä¿¡ã€å»¶è¿Ÿå¤„ç†ã€é¿å…é˜»å¡
- `postEvent`ä¼šè‡ªåŠ¨æ¥ç®¡`event`çš„å†…å­˜ï¼ˆQtäº‹ä»¶é˜Ÿåˆ—è´Ÿè´£deleteï¼‰
- ç›®æ ‡å¯¹è±¡é”€æ¯æ—¶ï¼Œæœªå¤„ç†çš„äº‹ä»¶ä¼šè¢«è‡ªåŠ¨ä¸¢å¼ƒå¹¶é‡Šæ”¾
- æ›´å®‰å…¨åœ°è·¨çº¿ç¨‹å‘é€äº‹ä»¶ï¼ŒQtä¼šæŠŠäº‹ä»¶æ´¾å‘åˆ°ç›®æ ‡å¯¹è±¡æ‰€åœ¨çº¿ç¨‹çš„äº‹ä»¶å¾ªç¯

```cpp
QMouseEvent *event = new QMouseEvent(QEvent::MouseButtonPress, QPointF(10, 10), Qt::LeftButton, Qt::LeftButton, Qt::NoModifier);
QCoreApplication::postEvent(widget, event);  // æ”¾å…¥äº‹ä»¶é˜Ÿåˆ—ï¼Œç¨åæ‰§è¡Œ
```

### 2. å­äº‹ä»¶å¾ªç¯

#### 2.1 ä»€ä¹ˆæ˜¯å­äº‹ä»¶å¾ªç¯

å­äº‹ä»¶å¾ªç¯æ˜¯ä¸€ç§ä¸´æ—¶æ„å»ºçš„äº‹ä»¶å¤„ç†æœºåˆ¶ã€‚é™¤äº†ç”±`QApplication::exec()`å¯åŠ¨çš„ä¸»äº‹ä»¶å¾ªç¯å¤–ï¼Œå¼€å‘è€…å¯ä»¥åœ¨å‡½æ•°ä¸­ä¸´æ—¶åˆ›å»º`QEventLoop`å¯¹è±¡ï¼Œé€šè¿‡æ‰§è¡Œ`loop.exec()`æ¥å¤„ç†äº‹ä»¶ã€‚

ä¸»è¦åŠŸèƒ½ï¼š

1. **æš‚åœå½“å‰å‡½æ•°æ‰§è¡Œä»¥æ˜¾ç¤ºæ¨¡æ€å¯¹è¯æ¡†**ï¼šå¦‚`QDialog::exec()`åˆ©ç”¨å­äº‹ä»¶å¾ªç¯æš‚åœå½“å‰æ“ä½œæµç¨‹ï¼Œç­‰å¾…ç”¨æˆ·è¾“å…¥

2. **ç­‰å¾…å¼‚æ­¥äº‹ä»¶å®Œæˆ**ï¼š

   ```cpp
   QEventLoop loop;
   connect(task, &AsyncTask::done, &loop, &QEventLoop::quit);
   loop.exec();  // ç­‰å¾…å¼‚æ­¥ä¿¡å·è§¦å‘
   ```

3. **åœ¨ä¸ä¸­æ–­ä¸»äº‹ä»¶å¾ªç¯çš„å‰æä¸‹ç»´æŒUIå“åº”æ€§**ï¼š
   ```cpp
   QEventLoop loop;
   while (!operationFinished) {
       doOneStepOfLongTask();
       loop.processEvents();  // å¤„ç†ç”¨æˆ·è¾“å…¥å’Œç•Œé¢åˆ·æ–°
       if (shouldCancelOperation) break;
   }
   ```

`QEventLoop`ä¸»è¦æ¥å£ï¼š

| æ¥å£å                                                            | è¯´æ˜                                         |
| ----------------------------------------------------------------- | -------------------------------------------- |
| `exec(QEventLoop::ProcessEventsFlags flags = AllEvents)`          | å¯åŠ¨äº‹ä»¶å¾ªç¯                                 |
| `exit(int returnCode = 0)`                                        | åœæ­¢äº‹ä»¶å¾ªç¯ï¼Œå¹¶è¿”å›çŠ¶æ€ç                    |
| `quit()`                                                          | ä¿¡å·ï¼šç”¨äºé€€å‡ºäº‹ä»¶å¾ªç¯                       |
| `isRunning()`                                                     | åˆ¤æ–­äº‹ä»¶å¾ªç¯æ˜¯å¦æ­£åœ¨è¿è¡Œ                     |
| `processEvents(QEventLoop::ProcessEventsFlags flags = AllEvents)` | ç«‹å³å¤„ç†æ‰€æœ‰å¾…å¤„ç†äº‹ä»¶                       |
| `wakeUp()`                                                        | å”¤é†’å¤„äºé˜»å¡çŠ¶æ€çš„äº‹ä»¶å¾ªç¯ï¼Œå¸¸ç”¨äºçº¿ç¨‹é—´é€šä¿¡ |

- **`wakeUp()`**ï¼šä¸»è¦ç”¨äºå”¤é†’å› äº‹ä»¶é˜Ÿåˆ—æ— äº‹ä»¶è€Œé˜»å¡çš„äº‹ä»¶å¾ªç¯ï¼Œé€šå¸¸åœ¨å¤šçº¿ç¨‹åœºæ™¯ä¸‹ç”¨äºçº¿ç¨‹é—´é€šä¿¡
- **`isRunning()`**ï¼šåˆ¤æ–­å½“å‰æ˜¯å¦æ­£åœ¨è¿è¡Œäº‹ä»¶å¾ªç¯ï¼Œé¿å…é‡å¤è°ƒç”¨`exec()`é˜²æ­¢åµŒå¥—è¿‡æ·±æˆ–æ­»é”

```cpp
QEventLoop loop;
if (!loop.isRunning()) {
    loop.exec();
}
```

#### 2.2 å¤šä¸ª QEventLoop åŒæ—¶å­˜åœ¨çš„æƒ…å†µ

Qtåº”ç”¨ç¨‹åºæ‹¥æœ‰ä¸€ä¸ªç”±`QApplication::exec()`å¯åŠ¨çš„ä¸»äº‹ä»¶å¾ªç¯ã€‚å½“å¯åŠ¨å­äº‹ä»¶å¾ªç¯æ—¶ï¼Œä¸»äº‹ä»¶å¾ªç¯æš‚æ—¶æš‚åœï¼Œå­äº‹ä»¶å¾ªç¯æˆä¸ºå½“å‰æ´»åŠ¨çš„äº‹ä»¶å¾ªç¯ã€‚

**äº‹ä»¶å¤„ç†ç‰¹ç‚¹ï¼š**

- å­äº‹ä»¶å¾ªç¯æ´»åŠ¨æ—¶è´Ÿè´£å¤„ç†äº‹ä»¶é˜Ÿåˆ—ä¸­çš„äº‹ä»¶
- çˆ¶äº‹ä»¶å¾ªç¯ï¼ˆä¸»äº‹ä»¶å¾ªç¯ï¼‰æš‚åœï¼Œæ— æ³•ä¸»åŠ¨æ¶ˆè´¹äº‹ä»¶
- æ–°äº‹ä»¶ä»å¯æ·»åŠ åˆ°äº‹ä»¶é˜Ÿåˆ—ä¸­
- æ–°äº‹ä»¶ä¼šåœ¨å½“å‰æ´»åŠ¨çš„å­å¾ªç¯ä¸­å¤„ç†ï¼ˆè‹¥é€‚ç”¨ï¼‰ï¼Œæˆ–ç­‰å¾…å­å¾ªç¯é€€å‡ºåç”±çˆ¶å¾ªç¯å¤„ç†

å­äº‹ä»¶å¾ªç¯é€€å‡ºåï¼Œçˆ¶äº‹ä»¶å¾ªç¯æ¢å¤è¿è¡Œç»§ç»­å¤„ç†å‰©ä½™äº‹ä»¶ã€‚ä»»ä¸€æ—¶åˆ»ä»…æœ‰ä¸€ä¸ªäº‹ä»¶å¾ªç¯å¤„äºæ´»åŠ¨çŠ¶æ€ï¼Œä½†äº‹ä»¶é˜Ÿåˆ—æ˜¯å…±äº«çš„ã€‚

**åµŒå¥—äº‹ä»¶å¾ªç¯ç¤ºä¾‹ï¼š**

```cpp
#include <QCoreApplication>
#include <QEventLoop>
#include <QTimer>
#include <QDebug>

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    // å¤–å±‚äº‹ä»¶å¾ªç¯
    QEventLoop outerLoop;
    // å†…å±‚äº‹ä»¶å¾ªç¯
    QEventLoop innerLoop;

    // å®šæ—¶å™¨ï¼Œç”¨äºé€€å‡ºå†…å±‚äº‹ä»¶å¾ªç¯
    QTimer innerTimer;
    QObject::connect(&innerTimer, &QTimer::timeout, &innerLoop, &QEventLoop::quit);
    innerTimer.start(1000); // 1ç§’åè¶…æ—¶

    // å®šæ—¶å™¨ï¼Œç”¨äºé€€å‡ºå¤–å±‚äº‹ä»¶å¾ªç¯
    QTimer outerTimer;
    QObject::connect(&outerTimer, &QTimer::timeout, &outerLoop, &QEventLoop::quit);
    outerTimer.start(3000); // 3ç§’åè¶…æ—¶

    qDebug() << "è¿›å…¥å¤–å±‚äº‹ä»¶å¾ªç¯";
    outerLoop.exec();
    qDebug() << "å¤–å±‚äº‹ä»¶å¾ªç¯ç»“æŸ";

    return a.exec();
}
```

**æ³¨æ„**ï¼šè¿‡å¤šçš„åµŒå¥—äº‹ä»¶å¾ªç¯ä¼šä½¿ä»£ç é€»è¾‘å¤æ‚ï¼Œå¯èƒ½å¼•å‘æ­»é”ç­‰é—®é¢˜ã€‚åœ¨åµŒå¥—äº‹ä»¶å¾ªç¯ä¸­ï¼Œæ‰€æœ‰äº‹ä»¶ä¾æ—§åœ¨ä¸»äº‹ä»¶å¾ªç¯ä¸­å¤„ç†ï¼ŒåµŒå¥—äº‹ä»¶å¾ªç¯ä»…æš‚åœå½“å‰ä»£ç æ‰§è¡Œï¼Œä¸å½±å“äº‹ä»¶åˆ†å‘å’Œå¤„ç†ã€‚

### 3. åŒæ­¥æ–¹å¼å®ç°çš„ UI äº¤äº’

åœ¨UIäº¤äº’ä¸­ï¼Œå¸¸è§ä¸€ç§"é¡ºåºå¼"çš„é€»è¾‘ï¼š

```cpp
StartLineCommand();
GetPoint("è¯·é€‰æ‹©èµ·ç‚¹");  // ç­‰å¾…ç”¨æˆ·ç‚¹å‡»
GetPoint("è¯·é€‰æ‹©ç»ˆç‚¹");  // å†ç­‰å¾…ç”¨æˆ·ç‚¹å‡»
```

è¿™ç§åŒæ­¥æ‰§è¡Œæµç¨‹ç›´è§‚æ¸…æ™°ï¼šä¸€è¡Œä¸€è¡Œæ‰§è¡Œï¼Œ`GetPoint()`ä¼š"åœä¸‹æ¥ç­‰å¾…"ç”¨æˆ·ç‚¹å‡»ï¼Œç”¨æˆ·ç‚¹å‡»åå‡½æ•°è¿”å›å†ç»§ç»­æ‰§è¡Œä¸‹ä¸€è¡Œã€‚è¿™ç§å†™æ³•å°±åƒæ§åˆ¶å°ç¨‹åºæˆ–è„šæœ¬é‚£æ ·ï¼Œè‡ªç„¶æ¸…æ™°ï¼Œä¹Ÿä¾¿äºç»´æŠ¤ã€‚

ä½†è¿™åœ¨Qtä¸­è¡Œä¸é€šï¼Œå› ä¸ºQtæ˜¯**äº‹ä»¶é©±åŠ¨çš„GUIæ¡†æ¶**ï¼š

1. ç¨‹åºå¯åŠ¨åï¼ŒQtå¯åŠ¨ä¸€ä¸ª**äº‹ä»¶å¾ªç¯ï¼ˆevent loopï¼‰**
2. é¼ æ ‡ç‚¹å‡»ã€é”®ç›˜è¾“å…¥ã€çª—å£é‡ç»˜ç­‰éƒ½ä¼šç”Ÿæˆ"äº‹ä»¶"
3. QtæŠŠäº‹ä»¶æŠ•é€’ç»™å“åº”çš„å¯¹è±¡ï¼ˆæŒ‰é’®ã€çª—å£ç­‰ï¼‰
4. æˆ‘ä»¬é€šè¿‡ä¿¡å·æ§½ã€äº‹ä»¶å¤„ç†å‡½æ•°æ¥å“åº”è¿™äº›äº‹ä»¶

**å…³é”®åŒºåˆ«**ï¼šäº‹ä»¶ä¸æ˜¯ä½ ä»£ç è°ƒç”¨è§¦å‘çš„ï¼Œè€Œæ˜¯ç”¨æˆ·æ“ä½œåQtè°ƒç”¨ä½ çš„å›è°ƒå‡½æ•°ã€‚æ‰€ä»¥æ— æ³•å†™å‡ºåƒ`GetPoint()`è¿™æ ·çš„é˜»å¡å‡½æ•°ï¼Œé™¤é**äººä¸ºæ„é€ ä¸€ä¸ª"åŒæ­¥ç­‰å¾…"çš„æœºåˆ¶**ã€‚

#### 3.1 Qt åŸç”Ÿæ–¹å¼ â€”â€” å¼‚æ­¥+çŠ¶æ€æœº

åœ¨ Qt ä¸­ï¼Œæ¨èçš„å†™æ³•æ˜¯é€šè¿‡äº‹ä»¶é©±åŠ¨çš„å›è°ƒè¿›è¡Œå¤„ç†ã€‚ä¾‹å¦‚ç›‘å¬ç‚¹å‡»äº‹ä»¶ï¼Œé€šè¿‡çŠ¶æ€è®°å½•å½“å‰æ˜¯ç¬¬å‡ æ¬¡ç‚¹å‡»ï¼š

```cpp
// å‡è®¾ currentState æ˜¯ä¸€ä¸ªæˆå‘˜å˜é‡ï¼Œè®°å½•å½“å‰çŠ¶æ€ï¼ˆ0=ç­‰å¾…èµ·ç‚¹ï¼Œ1=ç­‰å¾…ç»ˆç‚¹ï¼‰
void onUserClicked(QPoint p) {
    if (currentState == 0) {
        startPoint = p;
        currentState = 1;
        showHint("è¯·é€‰æ‹©ç»ˆç‚¹");
    } else if (currentState == 1) {
        endPoint = p;
        finishLine(startPoint, endPoint);
        currentState = 0;
        showHint("è¯·é€‰æ‹©èµ·ç‚¹");
    }
}
```

è¿™æ˜¯æ ‡å‡†çš„äº‹ä»¶é©±åŠ¨å†™æ³•ï¼Œä½†å®ƒæœ‰ä¸¤ä¸ªé—®é¢˜ï¼šï¼ˆ1ï¼‰å†™èµ·æ¥ä¸åƒâ€œæµç¨‹ä»£ç â€ï¼Œè€Œæ˜¯æ‹†æˆå¤šä¸ªå›è°ƒï¼›ï¼ˆ2ï¼‰æ— æ³•æ¸…æ™°è¡¨è¾¾â€œé˜»å¡ç­‰å¾…ç”¨æˆ·è¾“å…¥â€çš„è¯­ä¹‰ã€‚

#### 3.2 ä¸ºä»€ä¹ˆä¸èƒ½ç”¨ `while()` ç­‰å¾…ç”¨æˆ·ç‚¹å‡»ï¼Ÿ

```cpp
QPoint p;
while (!gotUserClick) {
    // ç­‰å¾…ç‚¹å‡»
}
```

å¾ˆå¤šäººç¬¬ä¸€ååº”ä¹Ÿè¿˜æ˜¯ä¸Šé¢è¿™ç§å†™æ³•ï¼Œè¿™ç§å†™æ³•ä¼šè®©ç¨‹åºç›´æ¥â€œå¡æ­»â€ï¼Œå› ä¸ºä½ é˜»å¡äº†ä¸»çº¿ç¨‹ï¼ŒQt æ— æ³•å¤„ç† UI äº‹ä»¶ â€”â€” é¼ æ ‡ã€é”®ç›˜ã€é‡ç»˜ç­‰å…¨éƒ¨åœæ‘†ï¼Œç•Œé¢æ— å“åº”ï¼Œæ•´ä¸ªç¨‹åºé™·å…¥æ­»é”çŠ¶æ€ã€‚

#### 3.3 ä½¿ç”¨ QEventLoop å¯åŠ¨â€œå­äº‹ä»¶å¾ªç¯â€

Qt æä¾›ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„ç±» `QEventLoop`ï¼Œå®ƒå¯ä»¥ä¸´æ—¶å¼€å¯ä¸€ä¸ªæ–°çš„äº‹ä»¶å¾ªç¯ï¼Œè®© UI ä¸ä¼šå¡æ­»ï¼ŒåŒæ—¶ä¸»æµç¨‹â€œåœä¸‹æ¥ç­‰ç»“æœâ€ï¼Œæ¨¡æ‹ŸåŒæ­¥è¡Œä¸ºã€‚

ç¤ºæ„ä»£ç å¦‚ä¸‹ï¼š

```cpp
QEventLoop loop;

connect(viewport, &MyCanvas::clicked, [&loop](QPoint pt){
    point = pt;
    loop.quit();  // é€€å‡ºå­äº‹ä»¶å¾ªç¯
});

showHint("è¯·é€‰æ‹©ä¸€ä¸ªç‚¹");
loop.exec();       // å¯åŠ¨å­äº‹ä»¶å¾ªç¯ï¼Œç­‰å¾… quit è¢«è°ƒç”¨
```

ä½ å¯ä»¥ç†è§£ä¸ºï¼šä¸»æµç¨‹æš‚æ—¶â€œæŒ‚èµ·â€ï¼Œè¿›å…¥ä¸€ä¸ªæ–°çš„äº‹ä»¶å¤„ç†é˜¶æ®µï¼›ç”¨æˆ·ç‚¹å‡»åè§¦å‘å›è°ƒï¼Œé€€å‡ºå¾ªç¯ï¼Œä¸»æµç¨‹æ¢å¤ç»§ç»­æ‰§è¡Œã€‚è¿™å°±å®ç°äº†çœ‹èµ·æ¥æ˜¯åŒæ­¥çš„ç­‰å¾…ï¼Œä½†å®é™…ä¸Š Qt ä»ç„¶åœ¨æ­£å¸¸å¤„ç†äº‹ä»¶ï¼Œä¸ä¼šå¡ UIã€‚

åº•å±‚ç”±äº‹ä»¶é©±åŠ¨ + å­äº‹ä»¶å¾ªç¯æœºåˆ¶æ”¯æ’‘ï¼Œè¡¨é¢ä¸Šæ˜¯â€œåŒæ­¥æµç¨‹â€ï¼Œå®é™…ä¸Šæ˜¯å¼‚æ­¥äº‹ä»¶å“åº”ã€‚

ä½†æ˜¯ä¸€ä¸ªå®é™…çš„ç³»ç»Ÿï¼Œå¯èƒ½è¿˜ä¼šé¢ä¸´å¦‚ä¸‹éœ€æ±‚ï¼š

- æ¨¡æ€äº¤äº’ï¼ˆå¦‚ç‚¹é€‰å¯¹è±¡ã€é€‰æ‹©åŒºåŸŸï¼‰ï¼›
- å–æ¶ˆæœºåˆ¶ï¼ˆæŒ‰ Esc æˆ–å³é”®å–æ¶ˆå½“å‰å‘½ä»¤ï¼‰ï¼›
- å¤šé‡åµŒå¥—ï¼ˆä¸»å‘½ä»¤ä¸­è°ƒç”¨å­å‘½ä»¤æˆ–å¯¹è¯æ¡†ï¼‰ï¼›
- è·¨æ¨¡å—çš„ç»Ÿä¸€äº¤äº’é€»è¾‘è°ƒåº¦ã€‚

æ‰€ä»¥ä¸€èˆ¬éƒ½éœ€è¦å†å¯¹`loop`å»å°è£…ä¸€ä¸‹

| ç›®æ ‡                     | æ˜¯å¦è¾¾æˆ                            |
| ------------------------ | ----------------------------------- |
| çœ‹èµ·æ¥æ˜¯åŒæ­¥çš„äº¤äº’ç­‰å¾…   | âœ… ä½¿ç”¨ `exec()` + `quit()` å®ç°    |
| UI ä¿æŒå“åº”æ€§            | âœ… å­äº‹ä»¶å¾ªç¯ä¸é˜»å¡ UI              |
| æ”¯æŒå¤šçº§åµŒå¥—å’Œå¼¹çª—è°ƒç”¨   | âœ… ç”¨ `_loops` æ ˆç»Ÿä¸€ç®¡ç†           |
| æ”¯æŒä¸­æ–­é€€å‡ºã€çŠ¶æ€æ¢å¤   | âœ… `earlyExit` / `interrupt()` æ§åˆ¶ |
| æä¾›ç»Ÿä¸€æŒ‡ä»¤äº¤äº’è°ƒåº¦æ¡†æ¶ | âœ… æ‰€æœ‰å‘½ä»¤é€»è¾‘éƒ½èµ°ç»Ÿä¸€äº‹ä»¶å¾ªç¯å°è£… |

**æ€»ç»“**ï¼šQtæ˜¯å¼‚æ­¥äº‹ä»¶é©±åŠ¨æ¨¡å‹ï¼Œæ— æ³•åƒæ§åˆ¶å°ç¨‹åºé‚£æ ·"ç­‰è¾“å…¥"ã€‚å¦‚æœæƒ³åœ¨ç•Œé¢ç¨‹åºä¸­"ç­‰ç”¨æˆ·ç‚¹ä¸€ä¸‹"ï¼Œè¦ä¹ˆå†™å¼‚æ­¥çŠ¶æ€æœºé€»è¾‘ï¼Œè¦ä¹ˆç”¨`QEventLoop`å¼€ä¸ªå­äº‹ä»¶å¾ªç¯ï¼Œæ¨¡æ‹ŸåŒæ­¥æµç¨‹è€Œä¸é˜»å¡UIã€‚

è¿™ç§åšæ³•åœ¨Qtçš„æœºåˆ¶ä¸Šæ„å»ºäº†ä¸€å¥—ç»Ÿä¸€çš„æŒ‡ä»¤è°ƒåº¦å’Œäº¤äº’ç³»ç»Ÿï¼Œæ—¢ä¿ç•™å¼‚æ­¥é©±åŠ¨çš„ä¼˜åŠ¿ï¼Œåˆæä¾›å¯æ§ã€æ¸…æ™°çš„"åŒæ­¥å¼"äº¤äº’ä½“éªŒã€‚

#### 3.4 åç¨‹æ–¹å¼å®ç°åŒæ­¥çš„ ui äº¤äº’

éšç€C++20å¼•å…¥åç¨‹æ”¯æŒï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ›´ç°ä»£çš„æ–¹å¼æ¥å®ç°çœ‹ä¼¼åŒæ­¥çš„UIäº¤äº’ï¼Œé¿å…å¤æ‚çš„çŠ¶æ€æœºé€»è¾‘å’Œäº‹ä»¶å¾ªç¯åµŒå¥—ã€‚

##### 3.4.1 åç¨‹çš„åŸºæœ¬æ¦‚å¿µä¸ä¼˜åŠ¿

åç¨‹ï¼ˆCoroutineï¼‰æ˜¯ä¸€ç§å¯ä»¥è¢«æš‚åœå’Œæ¢å¤çš„å‡½æ•°ï¼Œå®ƒå…è®¸æˆ‘ä»¬åœ¨å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­"è®©å‡ºæ§åˆ¶æƒ"ï¼Œç¨åå†ä»æš‚åœçš„åœ°æ–¹ç»§ç»­æ‰§è¡Œã€‚è¿™éå¸¸é€‚åˆå®ç°å¼‚æ­¥ç­‰å¾…ç”¨æˆ·è¾“å…¥çš„åœºæ™¯ã€‚

**æ ¸å¿ƒä¼˜åŠ¿å¯¹æ¯”ï¼š**

| æ–¹å¼           | ä»£ç ç»“æ„      | å¼‚å¸¸å¤„ç† | ç»´æŠ¤æ€§    | åµŒå¥—æ”¯æŒ    |
| -------------- | ------------- | -------- | --------- | ----------- |
| çŠ¶æ€æœºæ–¹å¼     | ğŸ”´ åˆ†æ•£çš„å›è°ƒ | ğŸ”´ å¤æ‚  | ğŸ”´ éš¾ç»´æŠ¤ | ğŸ”´ å›°éš¾     |
| QEventLoopæ–¹å¼ | ğŸŸ¡ è¾ƒæ¸…æ™°     | ğŸŸ¡ ä¸€èˆ¬  | ğŸŸ¡ ä¸­ç­‰   | ğŸŸ¡ éœ€è¦ç®¡ç† |
| åç¨‹æ–¹å¼       | ğŸŸ¢ çº¿æ€§åŒæ­¥å¼ | ğŸŸ¢ è‡ªç„¶  | ğŸŸ¢ æ˜“ç»´æŠ¤ | ğŸŸ¢ å¤©ç„¶æ”¯æŒ |

##### 3.4.2 Qtåç¨‹UIäº¤äº’æ¡†æ¶å®ç°

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€ä¸ªåç¨‹æ¡†æ¶æ¥å¤„ç†UIäº¤äº’ï¼š

```cpp
#include <coroutine>
#include <optional>
#include <QEventLoop>
#include <QTimer>
#include <QMouseEvent>
#include <QWidget>
#include <QApplication>

// åç¨‹ä»»åŠ¡ç±»å‹
template<typename T>
struct Task {
    struct promise_type {
        T value{};
        std::exception_ptr exception = nullptr;

        Task get_return_object() {
            return Task{std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_never initial_suspend() noexcept { return {}; }
        std::suspend_never final_suspend() noexcept { return {}; }

        void return_value(T val) { value = std::move(val); }

        void unhandled_exception() {
            exception = std::current_exception();
        }
    };

    std::coroutine_handle<promise_type> coro;

    Task(std::coroutine_handle<promise_type> h) : coro(h) {}

    ~Task() {
        if (coro) coro.destroy();
    }

    // ç§»åŠ¨è¯­ä¹‰
    Task(Task&& other) noexcept : coro(std::exchange(other.coro, {})) {}
    Task& operator=(Task&& other) noexcept {
        if (this != &other) {
            if (coro) coro.destroy();
            coro = std::exchange(other.coro, {});
        }
        return *this;
    }

    // ç¦æ­¢æ‹·è´
    Task(const Task&) = delete;
    Task& operator=(const Task&) = delete;

    T get_result() {
        if (coro.promise().exception) {
            std::rethrow_exception(coro.promise().exception);
        }
        return coro.promise().value;
    }
};

// ç­‰å¾…ç”¨æˆ·ç‚¹å‡»çš„ awaiter
class PointAwaiter : public QObject {
    Q_OBJECT

public:
    PointAwaiter(QWidget* widget, const QString& hint)
        : widget_(widget), hint_(hint) {}

    bool await_ready() const noexcept { return false; }

    void await_suspend(std::coroutine_handle<> handle) {
        handle_ = handle;
        showHint(hint_);
        installEventFilter();
    }

    QPoint await_resume() {
        removeEventFilter();
        return result_point_;
    }

private slots:
    void onTimeout() {
        removeEventFilter();
        cancelled_ = true;
        if (handle_) {
            handle_.resume();
        }
    }

private:
    QWidget* widget_;
    QString hint_;
    QPoint result_point_;
    std::coroutine_handle<> handle_;
    bool cancelled_ = false;
    QTimer* timeout_timer_ = nullptr;

    void showHint(const QString& text) {
        if (widget_) {
            widget_->setToolTip(text);
            widget_->setStatusTip(text);
        }
    }

    void installEventFilter() {
        if (widget_) {
            widget_->installEventFilter(this);

            // è®¾ç½®è¶…æ—¶æœºåˆ¶
            timeout_timer_ = new QTimer(this);
            timeout_timer_->setSingleShot(true);
            connect(timeout_timer_, &QTimer::timeout, this, &PointAwaiter::onTimeout);
            timeout_timer_->start(30000); // 30ç§’è¶…æ—¶
        }
    }

    void removeEventFilter() {
        if (widget_) {
            widget_->removeEventFilter(this);
        }
        if (timeout_timer_) {
            timeout_timer_->stop();
            timeout_timer_->deleteLater();
            timeout_timer_ = nullptr;
        }
    }

    bool eventFilter(QObject* obj, QEvent* event) override {
        if (event->type() == QEvent::MouseButtonPress) {
            QMouseEvent* mouseEvent = static_cast<QMouseEvent*>(event);
            if (mouseEvent->button() == Qt::LeftButton) {
                result_point_ = mouseEvent->pos();
                removeEventFilter();
                if (handle_) {
                    handle_.resume();
                }
                return true; // äº‹ä»¶å·²å¤„ç†
            }
        } else if (event->type() == QEvent::KeyPress) {
            QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
            if (keyEvent->key() == Qt::Key_Escape) {
                cancelled_ = true;
                removeEventFilter();
                if (handle_) {
                    handle_.resume();
                }
                return true;
            }
        }
        return QObject::eventFilter(obj, event);
    }
};

// ç­‰å¾…æŒ‰é”®çš„ awaiter
class KeyAwaiter : public QObject {
    Q_OBJECT

public:
    KeyAwaiter(QWidget* widget, const QString& hint)
        : widget_(widget), hint_(hint) {}

    bool await_ready() const noexcept { return false; }

    void await_suspend(std::coroutine_handle<> handle) {
        handle_ = handle;
        showHint(hint_);
        installEventFilter();
    }

    int await_resume() {
        removeEventFilter();
        if (cancelled_) {
            throw std::runtime_error("ç”¨æˆ·å–æ¶ˆæ“ä½œ");
        }
        return result_key_;
    }

private:
    QWidget* widget_;
    QString hint_;
    int result_key_;
    std::coroutine_handle<> handle_;
    bool cancelled_ = false;

    void showHint(const QString& text) {
        if (widget_) {
            widget_->setStatusTip(text);
        }
    }

    void installEventFilter() {
        if (widget_) {
            widget_->installEventFilter(this);
        }
    }

    void removeEventFilter() {
        if (widget_) {
            widget_->removeEventFilter(this);
        }
    }

    bool eventFilter(QObject* obj, QEvent* event) override {
        if (event->type() == QEvent::KeyPress) {
            QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
            result_key_ = keyEvent->key();
            removeEventFilter();
            if (handle_) {
                handle_.resume();
            }
            return true;
        }
        return QObject::eventFilter(obj, event);
    }
};
```

##### 3.4.3 åç¨‹UIäº¤äº’çš„å®é™…åº”ç”¨

ä½¿ç”¨ä¸Šè¿°æ¡†æ¶ï¼Œæˆ‘ä»¬å¯ä»¥å®ç°éå¸¸è‡ªç„¶çš„UIäº¤äº’é€»è¾‘ï¼š

```cpp
// ç»˜åˆ¶çº¿æ¡çš„åç¨‹å‡½æ•° - ä»£ç çœ‹èµ·æ¥æ˜¯åŒæ­¥çš„ï¼
Task<bool> drawLineCommand(QWidget* canvas) {
    try {
        // è·å–èµ·ç‚¹
        QPoint startPoint = co_await PointAwaiter(canvas, "è¯·é€‰æ‹©èµ·ç‚¹");

        // æ˜¾ç¤ºä¸´æ—¶æ ‡è®°
        showTemporaryMarker(startPoint);

        // è·å–ç»ˆç‚¹
        QPoint endPoint = co_await PointAwaiter(canvas, "è¯·é€‰æ‹©ç»ˆç‚¹");

        // ç»˜åˆ¶çº¿æ¡
        drawLine(startPoint, endPoint);

        co_return true;

    } catch (const std::exception& e) {
        qDebug() << "ç»˜åˆ¶çº¿æ¡è¢«å–æ¶ˆ:" << e.what();
        co_return false;
    }
}

// å¤æ‚çš„å¤šæ­¥éª¤äº¤äº’
Task<bool> drawRectangleCommand(QWidget* canvas) {
    try {
        // ç¬¬ä¸€ä¸ªè§’ç‚¹
        QPoint corner1 = co_await PointAwaiter(canvas, "é€‰æ‹©çŸ©å½¢ç¬¬ä¸€ä¸ªè§’ç‚¹");

        // å¯¹è§’ç‚¹
        QPoint corner2 = co_await PointAwaiter(canvas, "é€‰æ‹©çŸ©å½¢å¯¹è§’ç‚¹");

        // è®©ç”¨æˆ·ç¡®è®¤
        int key = co_await KeyAwaiter(canvas, "æŒ‰å›è½¦ç¡®è®¤ï¼ŒæŒ‰ESCå–æ¶ˆ");

        if (key == Qt::Key_Return) {
            drawRectangle(corner1, corner2);
            co_return true;
        } else {
            co_return false; // ç”¨æˆ·å–æ¶ˆ
        }

    } catch (const std::exception& e) {
        qDebug() << "ç»˜åˆ¶çŸ©å½¢è¢«å–æ¶ˆ:" << e.what();
        co_return false;
    }
}

// åµŒå¥—å‘½ä»¤çš„ä¾‹å­ - ç»„åˆå¤šä¸ªåç¨‹
Task<bool> complexDrawingCommand(QWidget* canvas) {
    // å…ˆç”»ä¸€æ¡çº¿
    bool lineResult = co_await drawLineCommand(canvas);
    if (!lineResult) {
        co_return false;
    }

    // å†ç”»ä¸€ä¸ªçŸ©å½¢
    bool rectResult = co_await drawRectangleCommand(canvas);

    co_return lineResult && rectResult;
}
```

##### 3.4.4 åç¨‹ä»»åŠ¡çš„å¯åŠ¨å’Œç®¡ç†

ä¸ºäº†åœ¨Qtåº”ç”¨ä¸­ä½¿ç”¨åç¨‹ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªä»»åŠ¡è°ƒåº¦å™¨ï¼š

```cpp
class CoroutineScheduler : public QObject {
    Q_OBJECT

public:
    template<typename T>
    void schedule(Task<T> task) {
        // ä½¿ç”¨QTimerè®©åç¨‹åœ¨äº‹ä»¶å¾ªç¯ä¸­æ‰§è¡Œ
        QTimer::singleShot(0, this, [this, task = std::move(task)]() mutable {
            try {
                // åç¨‹ä¼šåœ¨éœ€è¦ç­‰å¾…æ—¶è‡ªåŠ¨æš‚åœ
                // å½“ç”¨æˆ·æ“ä½œå®Œæˆæ—¶ä¼šè‡ªåŠ¨æ¢å¤
                T result = task.get_result();
                emit taskCompleted(QVariant::fromValue(result));
            } catch (const std::exception& e) {
                qDebug() << "åç¨‹æ‰§è¡Œå¼‚å¸¸:" << e.what();
                emit taskFailed(QString::fromStdString(e.what()));
            }
        });
    }

signals:
    void taskCompleted(const QVariant& result);
    void taskFailed(const QString& error);

private:
    std::vector<std::unique_ptr<QObject>> activeTasks_;
};

// åœ¨ä¸»çª—å£ä¸­ä½¿ç”¨
class MainWindow : public QMainWindow {
    Q_OBJECT

public:
    MainWindow(QWidget* parent = nullptr) : QMainWindow(parent) {
        setupUI();

        connect(&scheduler_, &CoroutineScheduler::taskCompleted,
                this, &MainWindow::onTaskCompleted);
        connect(&scheduler_, &CoroutineScheduler::taskFailed,
                this, &MainWindow::onTaskFailed);
    }

private slots:
    void onDrawLineClicked() {
        scheduler_.schedule(drawLineCommand(ui->canvas));
    }

    void onDrawRectClicked() {
        scheduler_.schedule(drawRectangleCommand(ui->canvas));
    }

    void onComplexDrawClicked() {
        scheduler_.schedule(complexDrawingCommand(ui->canvas));
    }

    void onTaskCompleted(const QVariant& result) {
        statusBar()->showMessage("æ“ä½œå®Œæˆ", 2000);
    }

    void onTaskFailed(const QString& error) {
        statusBar()->showMessage(QString("æ“ä½œå¤±è´¥: %1").arg(error), 5000);
    }

private:
    CoroutineScheduler scheduler_;
    // UI ç»„ä»¶...
};
```

##### 3.4.5 ä¸ä¼ ç»Ÿæ–¹å¼çš„è¯¦ç»†å¯¹æ¯”

**1. ä»£ç å¤æ‚åº¦å¯¹æ¯”ï¼š**

```cpp
// ä¼ ç»ŸçŠ¶æ€æœºæ–¹å¼ - åˆ†æ•£çš„é€»è¾‘
class TraditionalLineDrawer {
    enum State { WaitingStart, WaitingEnd };
    State state_ = WaitingStart;
    QPoint startPoint_;

    void onMouseClick(QPoint p) {
        switch(state_) {
            case WaitingStart:
                startPoint_ = p;
                state_ = WaitingEnd;
                showHint("é€‰æ‹©ç»ˆç‚¹");
                break;
            case WaitingEnd:
                drawLine(startPoint_, p);
                state_ = WaitingStart;
                showHint("é€‰æ‹©èµ·ç‚¹");
                break;
        }
    }

    void onKeyPress(int key) {
        if (key == Qt::Key_Escape) {
            state_ = WaitingStart;
            showHint("æ“ä½œå·²å–æ¶ˆ");
        }
    }
};

// QEventLoopæ–¹å¼ - éœ€è¦æ‰‹åŠ¨ç®¡ç†å¾ªç¯
class EventLoopLineDrawer {
    QPoint getPoint(const QString& hint) {
        QEventLoop loop;
        QPoint result;
        bool got_point = false;

        auto connection = connect(canvas, &Canvas::clicked,
                                [&](QPoint p) {
                                    result = p;
                                    got_point = true;
                                    loop.quit();
                                });

        showHint(hint);
        loop.exec();

        disconnect(connection);
        return result;
    }

    void drawLine() {
        QPoint start = getPoint("é€‰æ‹©èµ·ç‚¹");
        QPoint end = getPoint("é€‰æ‹©ç»ˆç‚¹");
        drawLine(start, end);
    }
};

// åç¨‹æ–¹å¼ - è‡ªç„¶çš„çº¿æ€§é€»è¾‘
Task<void> coroutineLineDrawer(QWidget* canvas) {
    QPoint start = co_await PointAwaiter(canvas, "é€‰æ‹©èµ·ç‚¹");
    QPoint end = co_await PointAwaiter(canvas, "é€‰æ‹©ç»ˆç‚¹");
    drawLine(start, end);
}
```

**2. é”™è¯¯å¤„ç†å¯¹æ¯”ï¼š**

```cpp
// åç¨‹æ–¹å¼çš„å¼‚å¸¸å¤„ç†æ›´è‡ªç„¶
Task<bool> robustDrawCommand(QWidget* canvas) {
    try {
        QPoint p1 = co_await PointAwaiter(canvas, "é€‰æ‹©èµ·ç‚¹");
        QPoint p2 = co_await PointAwaiter(canvas, "é€‰æ‹©ç»ˆç‚¹");

        if (isValidLine(p1, p2)) {
            drawLine(p1, p2);
            co_return true;
        } else {
            throw std::invalid_argument("æ— æ•ˆçš„çº¿æ¡å‚æ•°");
        }

    } catch (const std::runtime_error& e) {
        showError(QString("æ“ä½œå¤±è´¥: %1").arg(e.what()));
        co_return false;
    } catch (const std::invalid_argument& e) {
        showWarning(QString("å‚æ•°é”™è¯¯: %1").arg(e.what()));
        co_return false;
    }
}
```

##### 3.4.6 æ³¨æ„äº‹é¡¹å’Œæœ€ä½³å®è·µ

**1. å†…å­˜ç®¡ç†ï¼š**

```cpp
// ç¡®ä¿åç¨‹å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
class SafeCoroutineScheduler {
    struct TaskWrapper {
        virtual ~TaskWrapper() = default;
        virtual void execute() = 0;
    };

    template<typename T>
    struct TypedTaskWrapper : TaskWrapper {
        Task<T> task;
        TypedTaskWrapper(Task<T> t) : task(std::move(t)) {}
        void execute() override { /* æ‰§è¡Œé€»è¾‘ */ }
    };

    std::vector<std::unique_ptr<TaskWrapper>> activeTasks_;

public:
    template<typename T>
    void schedule(Task<T> task) {
        auto wrapper = std::make_unique<TypedTaskWrapper<T>>(std::move(task));
        activeTasks_.push_back(std::move(wrapper));
        // ä»»åŠ¡å®Œæˆåè‡ªåŠ¨æ¸…ç†
    }
};
```

**2. çº¿ç¨‹å®‰å…¨ï¼š**

```cpp
// ç¡®ä¿åç¨‹æ¢å¤åœ¨æ­£ç¡®çš„çº¿ç¨‹ä¸­æ‰§è¡Œ
void await_suspend(std::coroutine_handle<> handle) {
    handle_ = handle;

    // ä½¿ç”¨ QMetaObject::invokeMethod ç¡®ä¿åœ¨ä¸»çº¿ç¨‹æ¢å¤
    QMetaObject::invokeMethod(qApp, [this, handle]() {
        // è®¾ç½®äº‹ä»¶è¿‡æ»¤å™¨ç­‰æ“ä½œ
        installEventFilter();
    }, Qt::QueuedConnection);
}
```

**3. å–æ¶ˆæœºåˆ¶ï¼š**

```cpp
// æ”¯æŒå–æ¶ˆçš„åç¨‹æ¡†æ¶
class CancellableTask {
    std::atomic<bool> cancelled_{false};

public:
    void cancel() { cancelled_ = true; }
    bool isCancelled() const { return cancelled_; }

    template<typename Awaiter>
    auto operator co_await(Awaiter awaiter) {
        struct CancellableAwaiter {
            Awaiter inner;
            CancellableTask* task;

            bool await_ready() {
                return task->isCancelled() || inner.await_ready();
            }

            void await_suspend(std::coroutine_handle<> h) {
                if (!task->isCancelled()) {
                    inner.await_suspend(h);
                }
            }

            auto await_resume() {
                if (task->isCancelled()) {
                    throw std::runtime_error("æ“ä½œè¢«å–æ¶ˆ");
                }
                return inner.await_resume();
            }
        };

        return CancellableAwaiter{std::move(awaiter), this};
    }
};
```

##### 3.4.7 æ€§èƒ½å’Œå…¼å®¹æ€§è€ƒè™‘

**ç¼–è¯‘è¦æ±‚ï¼š**

- éœ€è¦C++20æ”¯æŒçš„ç¼–è¯‘å™¨ï¼ˆGCC 10+, Clang 11+, MSVC 2019 16.8+ï¼‰
- CMakeä¸­éœ€è¦è®¾ç½®ï¼š`set(CMAKE_CXX_STANDARD 20)`

**æ€§èƒ½ç‰¹ç‚¹ï¼š**

- åç¨‹çš„å†…å­˜å¼€é”€é€šå¸¸æ¯”çº¿ç¨‹å°å¾—å¤š
- åˆ‡æ¢å¼€é”€æ¯”çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ä½
- ä½†æ¯”ç›´æ¥çš„çŠ¶æ€æœºç•¥æœ‰å¼€é”€

**é€‚ç”¨åœºæ™¯ï¼š**

```
âœ… å¤æ‚çš„å¤šæ­¥éª¤ç”¨æˆ·äº¤äº’
âœ… éœ€è¦é¢‘ç¹åµŒå¥—çš„æ“ä½œæµç¨‹
âœ… å¯¹ä»£ç å¯è¯»æ€§è¦æ±‚é«˜çš„é¡¹ç›®
âœ… å›¢é˜Ÿç†Ÿæ‚‰ç°ä»£C++ç‰¹æ€§

âŒ ç®€å•çš„å•æ­¥äº¤äº’ï¼ˆè¿‡åº¦è®¾è®¡ï¼‰
âŒ å¯¹C++20æ”¯æŒæœ‰é™åˆ¶çš„é¡¹ç›®
âŒ æ€§èƒ½è¦æ±‚æå…¶è‹›åˆ»çš„åœºæ™¯
```

åç¨‹æ–¹å¼ä¸ºQt UIäº¤äº’æä¾›äº†ä¸€ç§ç°ä»£åŒ–ã€é«˜æ•ˆä¸”æ˜“äºç»´æŠ¤çš„è§£å†³æ–¹æ¡ˆï¼Œç‰¹åˆ«é€‚åˆéœ€è¦å¤æ‚ç”¨æˆ·è¾“å…¥æµç¨‹çš„åº”ç”¨åœºæ™¯ã€‚é€šè¿‡åˆç†çš„è®¾è®¡å’Œå®ç°ï¼Œå¯ä»¥æ˜¾è‘—æé«˜ä»£ç çš„å¯è¯»æ€§ã€å¯ç»´æŠ¤æ€§å’Œå¼€å‘æ•ˆç‡ã€‚

#include "ui_interaction.moc" // åŒ…å«MOCç”Ÿæˆçš„æ–‡ä»¶

### 4. Qt äº‹ä»¶å¾ªç¯æºç åˆ†æ

ä¸‹é¢æ·±å…¥å‰–æ Qt äº‹ä»¶å¾ªç¯çš„æºç ã€‚åœ¨äº‹ä»¶å¾ªç¯å¤„ç†äº‹ä»¶å‰ï¼Œäº‹ä»¶é€šè¿‡ `sendEvent` æˆ– `postEvent` è¿›è¡Œæ´¾å‘ï¼Œå‰è€…ä½¿äº‹ä»¶ç«‹å³æ‰§è¡Œï¼Œåè€…å°†äº‹ä»¶å…ˆæ’å…¥é˜Ÿåˆ—ï¼Œå†ç”±äº‹ä»¶å¾ªç¯å–å‡ºæ‰§è¡Œï¼Œæ¥ä¸‹æ¥ç€é‡é˜è¿°äº‹ä»¶å¾ªç¯è·å–å¹¶å‘é€é˜Ÿåˆ—ä¸­äº‹ä»¶çš„è¿è½¬è¿‡ç¨‹ã€‚

åœ¨ Qt GUI åº”ç”¨ç¨‹åºå…¥å£ `main` å‡½æ•°ä¸­ï¼Œèƒ½çœ‹åˆ°åº”ç”¨å¯åŠ¨ä¸äº‹ä»¶å¾ªç¯å¼•å…¥è¿‡ç¨‹ï¼š

```c++
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    MainWindow w;
    w.show();
    return a.exec();
}
```

å®ä¾‹åŒ– `QApplication` ä¸ºç¨‹åºè®¾ç½®åŸºæœ¬ç¯å¢ƒä¸å‚æ•°ï¼Œåˆ›å»ºå¹¶æ˜¾ç¤ºä¸»çª—å£åï¼Œè°ƒç”¨ `a.exec()` å¯åŠ¨äº‹ä»¶å¾ªç¯ï¼Œä½¿ç¨‹åºèƒ½å“åº”é¼ æ ‡ç‚¹å‡»ã€æŒ‰é”®ç­‰äº‹ä»¶ã€‚

1. **`QCoreApplication::exec` å‡½æ•°**ï¼š

```c++
int QCoreApplication::exec()
{
   ...
    threadData->quitNow = false;
    QEventLoop eventLoop;
    self->d_func()->in_exec = true;
    self->d_func()->aboutToQuitEmitted = false;
    int returnCode = eventLoop.exec();
   ...
}
```

æ­¤å‡½æ•°åˆ›å»ºå¹¶å¯åŠ¨ `QEventLoop` å¯¹è±¡ï¼Œé€šè¿‡è°ƒç”¨å…¶ `exec` æ–¹æ³•è¿è¡Œäº‹ä»¶å¾ªç¯ï¼Œè¯¥å¾ªç¯è´Ÿè´£ç®¡ç†äº‹ä»¶é˜Ÿåˆ—ä¸å¤„ç†äº‹ä»¶ã€‚

2. **`QEventLoop::exec` å‡½æ•°**ï¼š

```c++
int QEventLoop::exec(ProcessEventsFlags flags)
{
    //...
    while (!d->exit.loadAcquire())
        processEvents(flags | WaitForMoreEvents | EventLoopExec);
    ref.exceptionCaught = false;
    return d->returnCode.loadRelaxed();
}
```

`QEventLoop::exec` åŒ…å«å¾ªç¯ï¼ŒæŒç»­è°ƒç”¨ `processEvents` å¤„ç†äº‹ä»¶ã€‚`WaitForMoreEvents` æ ‡å¿—è¡¨æ˜æ— æ–°äº‹ä»¶æ—¶ï¼Œå¾ªç¯å°†é˜»å¡ç­‰å¾…ã€‚

3. **`QCoreApplication::processEvents` å‡½æ•°**ï¼š

```c++
void QCoreApplication::processEvents(QEventLoop::ProcessEventsFlags flags, int ms)
{
    QThreadData *data = QThreadData::current();
    if (!data->hasEventDispatcher())
        return;
    QElapsedTimer start;
    start.start();
    while (data->eventDispatcher.loadRelaxed()->processEvents(flags & ~QEventLoop::WaitForMoreEvents)) {
        if (start.elapsed() > ms)
            break;
    }
}
```

`processEvents` æ–¹æ³•è°ƒç”¨å½“å‰çº¿ç¨‹çš„äº‹ä»¶è°ƒåº¦å™¨ `QAbstractEventDispatcher`ï¼Œä¸åŒç³»ç»Ÿå¹³å°æœ‰ä¸åŒå®ç°ï¼Œä»¥ Windows å¹³å°çš„ `QEventDispatcherWin32` ä¸ºä¾‹åˆ†æã€‚åœ¨é•¿æ—¶é—´å¾ªç¯ä¸­å‘¨æœŸæ€§è°ƒç”¨ `processEvents()`ï¼Œå¯é¿å…ç•Œé¢å¡æ­»ï¼Œä¸”èƒ½åœ¨ä¸ä¸­æ–­æ“ä½œæµç¨‹æ—¶å¤„ç†ç”¨æˆ·è¾“å…¥ã€åŠ¨ç”»åˆ·æ–°ç­‰ã€‚

4. **`QEventDispatcherWin32` çš„äº‹ä»¶å¤„ç†**ï¼š

```c++
bool QEventDispatcherWin32::processEvents(QEventLoop::ProcessEventsFlags flags)
{
    Q_D(QEventDispatcherWin32);
   ...
    // é˜²æ­¢æ­»é”ï¼Œæ¯æ¬¡è¿­ä»£å‘é€å·²å‘å¸ƒäº‹ä»¶
    sendPostedEvents();
   ...
}
```

5. **`QEventDispatcherWin32::sendPostedEvents`**ï¼š

```c++
void QEventDispatcherWin32::sendPostedEvents()
{
    Q_D(QEventDispatcherWin32);
    if (d->sendPostedEventsTimerId != 0)
        KillTimer(d->internalHwnd, d->sendPostedEventsTimerId);
    d->sendPostedEventsTimerId = 0;

    d->wakeUps.storeRelaxed(0);

    QCoreApplicationPrivate::sendPostedEvents(0, 0, d->threadData.loadRelaxed());
}
```

è¯¥éƒ¨åˆ†å±•ç¤ºäº‹ä»¶è°ƒåº¦å™¨å¤„ç†äº‹ä»¶é˜Ÿåˆ—ï¼Œæœ€ç»ˆè°ƒç”¨ `QCoreApplication` çš„ `sendPostEvents` æ–¹æ³•ã€‚

6. **`QCoreApplicationPrivate::sendPostedEvents`ï¼šäº‹ä»¶å‘é€é€»è¾‘**ï¼š

```c++
void QCoreApplicationPrivate::sendPostedEvents(QObject *receiver, int event_type,
                                               QThreadData *data)
{
    //...
    if (receiver && receiver->d_func()->threadData != data) {
        qWarning("QCoreApplication::sendPostedEvents: Cannot send "
                 "posted events for objects in another thread");
        return;
    }
   ...
    while (i < data->postEventList.size()) {
      ...
        QEvent *e = pe.event;
        QObject * r = pe.receiver;
      ...
        QCoreApplication::sendEvent(r, e);
      ...
    }
}
```

ä»£ç å…ˆæ£€æŸ¥çº¿ç¨‹ï¼Œç¡®ä¿äº‹ä»¶åœ¨æ‰€å±çº¿ç¨‹å‘é€ï¼Œç„¶åéå†äº‹ä»¶åˆ—è¡¨ï¼Œè°ƒç”¨ `sendEvent` æ–¹æ³•å°†äº‹ä»¶å‘é€ç»™ç›®æ ‡å¯¹è±¡ã€‚

### 99. quiz

#### 1. ä»€ä¹ˆæ˜¯ `qApp`ï¼Ÿ

åœ¨ Qt åº”ç”¨ä¸­ï¼Œ`qApp` ä½œä¸ºå…¨å±€ â€œäº‹ä»¶ä¸­æ¢â€ï¼Œæ‰®æ¼”ç€ä¸¾è¶³è½»é‡çš„è§’è‰²ã€‚å®ƒè´Ÿè´£æ¥æ”¶æ¥è‡ªæ“ä½œç³»ç»Ÿçš„äº‹ä»¶ï¼Œå¹¶å¯¹ Qt å†…éƒ¨æ‰€æœ‰äº‹ä»¶çš„åˆ†å‘ã€å¾ªç¯ã€é€€å‡ºä»¥åŠä¿¡å·æ§½çš„è¿è¡Œç­‰è¿›è¡Œè°ƒåº¦ç®¡ç†ã€‚`qApp` æ˜¯ Qt æä¾›çš„å®ï¼Œç”¨äºæŒ‡ä»£å½“å‰åº”ç”¨ç¨‹åºçš„å…¨å±€å®ä¾‹ï¼Œå…·ä½“å®šä¹‰ä¸ºï¼š

```cpp
#define qApp (static_cast<QCoreApplication *>(QCoreApplication::instance()))
```

é€šè¿‡ `QCoreApplication::instance()` è·å–å½“å‰æ­£åœ¨è¿è¡Œçš„ `QCoreApplication` å¯¹è±¡å®ä¾‹ï¼Œå†ç» `static_cast<QCoreApplication *>()` è½¬æ¢ä¸º `QCoreApplication` ç±»å‹æŒ‡é’ˆï¼Œä»è€Œä¸ºå¼€å‘è€…æä¾›äº†åœ¨ç¨‹åºå„å¤„ä¾¿æ·è®¿é—®å…¨å±€ `QApplication` æˆ– `QCoreApplication` å¯¹è±¡çš„é€”å¾„ã€‚

`qApp` çŠ¹å¦‚åº”ç”¨ç¨‹åºçš„å¤§è„‘ä¸å¿ƒè„ï¼Œä¸ä»…æ‰¿æ¥æ“ä½œç³»ç»Ÿçš„äº‹ä»¶è¾“å…¥ï¼Œè¿˜ä¸»å®°ç€è°ƒåº¦ã€åˆ†å‘ã€äº‹ä»¶å¾ªç¯ã€å®šæ—¶å™¨ç®¡ç†ã€ä¿¡å·æ§½æœºåˆ¶ç­‰å…¨å±€è¡Œä¸ºã€‚åœ¨å®é™…å¼€å‘ä¸­ï¼Œ`qApp` å…·æœ‰è¯¸å¤šå¸¸è§ä½¿ç”¨åœºæ™¯ï¼š

- **è®¿é—®åº”ç”¨å…¨å±€çŠ¶æ€**ï¼šå¦‚éœ€è®¾ç½®å…¨å±€å­—ä½“ã€è¯­è¨€æˆ–è·¯å¾„ç­‰åº”ç”¨å…¨å±€çŠ¶æ€ä¿¡æ¯ï¼Œå¯å€ŸåŠ© `qApp` å®Œæˆã€‚ä¾‹å¦‚è®¾ç½®å…¨å±€å­—ä½“ä¸ºå®‹ä½“ï¼š

```cpp
QFont font("å®‹ä½“");
qApp->setFont(font);
```

- **æ•è·æ‰€æœ‰æ§ä»¶çš„äº‹ä»¶**ï¼šåœ¨äº‹ä»¶è¿‡æ»¤å™¨ä¸­ï¼Œé€šè¿‡ `qApp` èƒ½å¤Ÿæ•è·æ‰€æœ‰æ§ä»¶çš„äº‹ä»¶ã€‚å‡è®¾å­˜åœ¨å…¨å±€äº‹ä»¶è¿‡æ»¤å™¨ç±» `GlobalEventFilter`ï¼Œæ“ä½œå¦‚ä¸‹ï¼š

```cpp
GlobalEventFilter filter;
qApp->installEventFilter(&filter);
```

å¦‚æ­¤ï¼Œåœ¨ `GlobalEventFilter` ç±»çš„ `eventFilter` å‡½æ•°ä¸­ï¼Œä¾¿å¯å¤„ç†åº”ç”¨ä¸­æ‰€æœ‰æ§ä»¶çš„äº‹ä»¶ã€‚

- **è¿›è¡Œè·¨æ¨¡å—é€šä¿¡**ï¼šä¾‹å¦‚åœ¨å­æ¨¡å—ä¸­ï¼Œè‹¥è¦é€€å‡ºç¨‹åºï¼Œå¯è°ƒç”¨ `qApp->quit()`ã€‚å‡è®¾åœ¨åä¸º `SubModule` çš„å­æ¨¡å—ç±»ä¸­æœ‰å‡½æ•° `exitApp`ï¼š

```cpp
void SubModule::exitApp() {
    qApp->quit();
}
```

éœ€æ³¨æ„ï¼Œåœ¨ä¸»ç¨‹åºä¸­å¿…é¡»åˆ›å»º `QApplication`ï¼ˆé GUI åº”ç”¨åˆ™ä½¿ç”¨ `QCoreApplication`ï¼‰ï¼Œç¤ºä¾‹ä»£ç å¦‚ä¸‹ï¼š

```cpp
int main(int argc, char *argv[]) {
    QApplication app(argc, argv);
    // ä¸»ç¨‹åºå…¶ä»–ä»£ç 
    return app.exec();
}
```

æ­¤ `app` å®ä¾‹å³ `qApp` æ‰€æŒ‡å‘çš„å¯¹è±¡ã€‚

`qApp` çš„èŒè´£å¹¿æ³›ï¼Œå…·ä½“å¯é€šè¿‡ä»¥ä¸‹ç±»æ¯”ä¸å®é™…åŠŸèƒ½ç¤ºä¾‹è¯´æ˜ï¼š

```
| ç±»ä¼¼è§’è‰² | åœ¨ Qt ä¸­çš„åå­— | èŒè´£æè¿° | åŠŸèƒ½ç¤ºä¾‹åŠåº”ç”¨åœºæ™¯ |
| ---- | ---- | ---- | ---- |
| ğŸ§  å¤§è„‘ | `QCoreApplication` | ç®¡ç†äº‹ä»¶ã€çº¿ç¨‹ä»¥åŠåº”ç”¨ç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸï¼Œæ˜¯åº”ç”¨ç¨‹åºè¿è¡Œçš„æ ¸å¿ƒ | `qApp->exec()` å¯åŠ¨åº”ç”¨ç¨‹åºçš„äº‹ä»¶å¾ªç¯ï¼Œä½¿åº”ç”¨å¼€å§‹æ¥æ”¶å’Œå¤„ç†äº‹ä»¶ï¼›`qApp->quit()` ç”¨äºå…³é—­åº”ç”¨ç¨‹åºï¼Œå¯åœ¨ç”¨æˆ·ç‚¹å‡»å…³é—­æŒ‰é’®ç­‰åœºæ™¯ä¸‹è°ƒç”¨ |
| ğŸ’“ å¿ƒè·³ | `QEventLoop` | ç»´æŒäº‹ä»¶å¾ªç¯æŒç»­è¿è¡Œï¼Œç¡®ä¿åº”ç”¨ç¨‹åºèƒ½ä¸æ–­æ¥æ”¶å’Œå¤„ç†äº‹ä»¶ | `qApp->processEvents()` ä¸»åŠ¨å¤„ç†å½“å‰äº‹ä»¶é˜Ÿåˆ—ä¸­çš„äº‹ä»¶ï¼Œé€‚ç”¨äºéœ€ç«‹å³å¤„ç†äº‹ä»¶çš„åœºæ™¯ï¼›`qApp->hasPendingEvents()` æ£€æŸ¥æ˜¯å¦æœ‰æœªå¤„ç†çš„äº‹ä»¶ï¼Œå¯åœ¨å¾ªç¯ä¸­åˆ¤æ–­ |
| ğŸ•¹ï¸ è°ƒåº¦å‘˜ | `notify()` | å†³å®šå°†æ¥æ”¶åˆ°çš„äº‹ä»¶åˆ†å‘ç»™å“ªä¸ªå¯¹è±¡å¤„ç† | `qApp->notify(receiver, event)` å°†äº‹ä»¶ `event` åˆ†å‘ç»™æŒ‡å®šæ¥æ”¶è€… `receiver`ï¼Œè‡ªå®šä¹‰äº‹ä»¶åˆ†å‘é€»è¾‘æ—¶å¯é‡å†™æ­¤å‡½æ•° |
| ğŸ“¬ é‚®å±€ | `postEvent()` | ç®¡ç†äº‹ä»¶é˜Ÿåˆ—ï¼Œå°†äº‹ä»¶æ”¾å…¥é˜Ÿåˆ—ç­‰å¾…å¤„ç† | `qApp->postEvent(obj, event)` å°†äº‹ä»¶ `event` å‘é€åˆ°å¯¹è±¡ `obj` çš„äº‹ä»¶é˜Ÿåˆ—ï¼Œå¸¸ç”¨äºå¼‚æ­¥å¤„ç†äº‹ä»¶åœºæ™¯ï¼Œå¦‚å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ä¸€ä¸ªçº¿ç¨‹å‘å¦ä¸€ä¸ªçº¿ç¨‹çš„å¯¹è±¡å‘é€äº‹ä»¶ |
| ğŸ“… æ—¥å† | `QTimer` | æä¾›ç»Ÿä¸€å®šæ—¶æœºåˆ¶ï¼Œå®šæ—¶è§¦å‘ç‰¹å®šäº‹ä»¶æˆ–ä»»åŠ¡ | å¯é€šè¿‡ `QTimer::singleShot(time, qApp, [](){ /* å®šæ—¶æ‰§è¡Œçš„ä»£ç  */ });` å®ç°å•æ¬¡å®šæ—¶ä»»åŠ¡ï¼Œå¦‚åº”ç”¨å¯åŠ¨åå»¶è¿Ÿæ‰§è¡Œæ“ä½œï¼›ä¹Ÿå¯åˆ›å»º `QTimer` å¯¹è±¡å¹¶è¿æ¥å…¶ `timeout` ä¿¡å·åˆ°ç›¸åº”æ§½å‡½æ•°å®ç°å‘¨æœŸæ€§ä»»åŠ¡ï¼Œå¦‚å®šæ—¶æ›´æ–°ç•Œé¢æ•°æ® |
| ğŸ§­ å¯¼èˆª | - | è·å–å½“å‰è·¯å¾„ã€åº”ç”¨åç§°ç­‰å…¨å±€ä¿¡æ¯ï¼Œæ–¹ä¾¿ç¨‹åºå„å¤„ä½¿ç”¨ | `qApp->applicationDirPath()` è·å–åº”ç”¨ç¨‹åºå®‰è£…ç›®å½•è·¯å¾„ï¼Œé€‚ç”¨äºè¯»å–åº”ç”¨é…ç½®æ–‡ä»¶ç­‰åœºæ™¯ï¼›`qApp->applicationName()` è·å–åº”ç”¨ç¨‹åºåç§°ï¼Œå¯ç”¨äºæ—¥å¿—è®°å½•æˆ–æ˜¾ç¤ºåº”ç”¨æ ‡é¢˜ |
| ğŸ§µ çº¿ç¨‹ç®¡å®¶ | `qApp->thread()` | ä»£è¡¨ GUI çº¿ç¨‹ï¼Œæ–¹ä¾¿ç®¡ç†ä¸ GUI ç›¸å…³çš„çº¿ç¨‹æ“ä½œ | åœ¨éœ€ç¡®ä¿æŸäº›æ“ä½œåœ¨ GUI çº¿ç¨‹æ‰§è¡Œçš„åœºæ™¯ä¸‹ï¼Œå¯é€šè¿‡åˆ¤æ–­å½“å‰çº¿ç¨‹æ˜¯å¦ä¸º `qApp->thread()` å†³å®šï¼Œå¦‚æ›´æ–°ç•Œé¢å…ƒç´ å¿…é¡»åœ¨ GUI çº¿ç¨‹æ‰§è¡Œ |
```

Qt ä¸­æ‰€æœ‰äº‹ä»¶æœ€åˆç”±æ“ä½œç³»ç»Ÿå‘å‡ºï¼Œ`qApp`ï¼ˆå³ `QApplication` å®ä¾‹ï¼‰è´Ÿè´£æ¥æ”¶å¹¶åˆ†å‘ç»™å¯¹åº”çš„ Qt å¯¹è±¡ï¼ˆæ§ä»¶ã€çª—å£ç­‰ï¼‰ã€‚Qt çš„äº‹ä»¶å¾ªç¯æ¯æ¬¡ä»…å¤„ç†ä¸€ä¸ªäº‹ä»¶ï¼Œå¤„ç†å®Œä¸€ä¸ªäº‹ä»¶åæ‰å–ä¸‹ä¸€ä¸ªäº‹ä»¶ã€‚å…·ä½“ç‰¹ç‚¹å¦‚ä¸‹ï¼š âœ”ï¸ æ¯ä¸ªäº‹ä»¶æŒ‰äº‹ä»¶é˜Ÿåˆ—å…ˆè¿›å…ˆå‡ºçš„é¡ºåºå¤„ç†ã€‚ âœ”ï¸ å½“å‰äº‹ä»¶å¿…é¡»å¤„ç†å®Œæ¯•ï¼Œæ‰ä¼šç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªäº‹ä»¶ã€‚ âŒ ä½†å¹¶éâ€œé˜»å¡å¼çš„åŒæ­¥è°ƒç”¨â€é‚£ç§ä¸€ç›´ç­‰å¾…ç»“æœæ‰ç»§ç»­ï¼Œè€Œæ˜¯ç±»ä¼¼ä»»åŠ¡é˜Ÿåˆ—ï¼Œäº‹ä»¶å¤„ç†å‡½æ•°æ­£å¸¸è¿”å›å³å¯ç»§ç»­ï¼Œæ­¤æ—¶äº‹ä»¶è¿›ä¸€æ­¥çš„å¤„ç†å¯å¦èµ·çº¿ç¨‹è¿›è¡Œã€‚

#### 2. å¤šçº¿ç¨‹åœºæ™¯ä¸‹çš„äº‹ä»¶å¤„ç†é—®é¢˜

åœ¨ Qt ä¸­ï¼Œåªæœ‰ä¸»çº¿ç¨‹ï¼ˆå³ GUI çº¿ç¨‹ï¼‰èƒ½å¤Ÿå¯¹ UI æ§ä»¶è¿›è¡Œæ“ä½œï¼ŒåŸå› ä¸»è¦æœ‰ä»¥ä¸‹ä¸¤ç‚¹ï¼š

1. **äº‹ä»¶å¾ªç¯çš„ä¸»çº¿ç¨‹é™åˆ¶**ï¼šå­çº¿ç¨‹ä¸èƒ½ç›´æ¥è°ƒç”¨ UI æ§ä»¶çš„æ–¹æ³•æˆ–è®¿é—® UIï¼Œå¦åˆ™ä¼šäº§ç”Ÿæœªå®šä¹‰è¡Œä¸ºï¼Œç”šè‡³å¯¼è‡´ç¨‹åºå´©æºƒã€‚è¿™æ˜¯å› ä¸º UI ç»„ä»¶çš„åˆ›å»ºä¸ç®¡ç†å‡åœ¨ä¸»çº¿ç¨‹ä¸­å®Œæˆï¼Œå…¶ç”Ÿå‘½å‘¨æœŸä¸ä¸»çº¿ç¨‹ç´§å¯†ç›¸å…³ã€‚è‹¥å­çº¿ç¨‹å¯¹ UI ç»„ä»¶è¿›è¡Œæ“ä½œï¼Œææœ‰å¯èƒ½åœ¨ UI ç»„ä»¶å°šæœªå®Œå…¨åˆ›å»ºæˆ–å·²è¢«é”€æ¯æ—¶è¿›è¡Œè®¿é—®ï¼Œè¿›è€Œå¼•å‘é”™è¯¯ã€‚

2. **UI æ¡†æ¶çš„çº¿ç¨‹å®‰å…¨æ€§**ï¼šQt çš„ UI æ¡†æ¶å¹¶éçº¿ç¨‹å®‰å…¨ã€‚è‹¥å¤šä¸ªçº¿ç¨‹åŒæ—¶å¯¹ UI ç»„ä»¶è¿›è¡Œæ“ä½œï¼Œææ˜“å¼•å‘æ•°æ®ç«äº‰ã€‚ä¾‹å¦‚ï¼Œå½“ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶è¯•å›¾ä¿®æ”¹åŒä¸€ä¸ªæŒ‰é’®çš„æ–‡æœ¬æ—¶ï¼ŒæŒ‰é’®çš„æ–‡æœ¬å†…å®¹å°†å¤„äºä¸å¯é¢„æµ‹çŠ¶æ€ï¼Œä¸¥é‡æ—¶ä¼šè‡´ä½¿ç¨‹åºå´©æºƒã€‚

Qt çš„ UI æ›´æ–°ä¾èµ–äºäº‹ä»¶å¾ªç¯ï¼Œä¸»äº‹ä»¶å¾ªç¯è¿è¡Œåœ¨ä¸»çº¿ç¨‹ï¼Œè´Ÿè´£å¤„ç†å„ç±» UI äº‹ä»¶ï¼Œå¦‚ç»˜åˆ¶ã€é‡ç»˜ã€é¼ æ ‡ç‚¹å‡»ç­‰ã€‚è€Œå­çº¿ç¨‹æ²¡æœ‰è‡ªèº«çš„ä¸»äº‹ä»¶å¾ªç¯ï¼Œæ— æ³•æ­£ç¡®å¤„ç†è¿™äº› UI äº‹ä»¶ã€‚è‹¥åœ¨å­çº¿ç¨‹ä¸­è¿›è¡Œ UI æ“ä½œï¼Œå¾ˆå¯èƒ½å¯¼è‡´ UI ç»„ä»¶æ— æ³•æ­£ç¡®æ›´æ–°æˆ–é‡ç»˜ã€‚

åœ¨ Qt å®¢æˆ·ç«¯ç¨‹åºä¸­ï¼Œå­çº¿ç¨‹ä¸èƒ½æ‰§è¡Œ UI æ“ä½œï¼Œå¯é€šè¿‡ä¿¡å·/æ§½æœºåˆ¶ï¼ˆ`Qt::QueuedConnection`ï¼‰æˆ–ä½¿ç”¨ `QMetaObject::invokeMethod` å®ç°å­çº¿ç¨‹ä¸ä¸»çº¿ç¨‹çš„é€šä¿¡ï¼Œä»è€Œå®‰å…¨åœ°æ›´æ–° UIã€‚ä»¥ä¸‹æ˜¯ç¤ºä¾‹ä»£ç ï¼š

```cpp
#include <QApplication>
#include <QWidget>
#include <QLabel>
#include <QVBoxLayout>
#include <QThread>
#include <QMetaObject>

class WorkerThread : public QThread {
    Q_OBJECT
signals:
    void updateSignal(const QString&);

public:
    void run() override {
        QThread::sleep(2);
        emit updateSignal("Updated from thread");
    }
};

class MainWindow : public QWidget {
    Q_OBJECT

public:
    MainWindow() {
        QLabel* label = new QLabel("Initial text");
        QVBoxLayout* layout = new QVBoxLayout(this);
        layout->addWidget(label);

        WorkerThread* thread = new WorkerThread(this);
        connect(thread, &WorkerThread::updateSignal, [label](const QString& text) {
            label->setText(text);
        });
        thread->start();
    }
};

int main(int argc, char *argv[]) {
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}
```

åœ¨ä¸Šè¿°ç¤ºä¾‹ä¸­ï¼Œ`WorkerThread` å­çº¿ç¨‹é€šè¿‡ `updateSignal` ä¿¡å·å°†æ¶ˆæ¯å‘é€åˆ°ä¸»çº¿ç¨‹ï¼Œä¸»çº¿ç¨‹æ¥æ”¶åˆ°ä¿¡å·åæ›´æ–° `QLabel` çš„æ–‡æœ¬ã€‚è‹¥ç›´æ¥åœ¨å­çº¿ç¨‹ä¸­æ›´æ–° `QLabel` çš„æ–‡æœ¬ï¼Œå°±ä¼šå‡ºç°é—®é¢˜ã€‚

æ€»ä¹‹ï¼Œä¸ºç¡®ä¿ç¨‹åºçš„ç¨³å®šæ€§ä¸æ­£ç¡®æ€§ï¼ŒUI æ“ä½œåº”åœ¨ä¸»çº¿ç¨‹ä¸­è¿›è¡Œï¼Œå­çº¿ç¨‹å¯å€ŸåŠ©ä¿¡å·ä¸æ§½æœºåˆ¶æˆ– `QMetaObject::invokeMethod` ä¸ä¸»çº¿ç¨‹é€šä¿¡ï¼Œç”±ä¸»çº¿ç¨‹å®Œæˆ UI æ›´æ–°ã€‚
