---
layout: post
title: 行为型设计模式
categories: 程序设计
related_posts: True
tags: 设计模式
toc:
  sidebar: left
---

## 行为型设计模式

行为型设计模式关注对象之间职责的分配。与结构型模式不同的是，它们不仅仅指定结构，还概述了对象之间消息传递/通信的模式。换句话说，它们帮助回答“如何在软件组件中运行行为？"。
在软件工程中，行为型设计模式是识别对象之间常见通信模式并实现这些模式的设计模式。通过这样做，这些模式增加了执行这种通信的灵活性。

### 1. **责任链模式**

- **介绍**
  责任链模式通过将请求沿着处理者链传递，直到有一个处理者处理它。每个处理者都有机会处理请求，或者将其传递给下一个处理者。
  由一系列命令对象和一系列处理对象组成。每个处理对象包含定义它可以处理的命令对象类型的逻辑；其余的传递给链中的下一个处理对象。
  - 一种消息链，责任链，实现链的抽象模式。责任链模式就是将请求沿着处理者链进行传递，直到有处理者能够处理该请求为止，很好地实现了请求发送者和处理者之间的解耦。
  - 举个例子来说，比如说支付，选择用了余额宝支付，但是余额不足，剩余金额跳转到银行支付；或者说日志库，选择用了 info 等级，但是出现了 error 等级也还是会记录。这些流程都会抽象成一条处理链，当前处理器能够指向下一级处理器，如果当前处理器完成不了，就传递到下一级。
- **使用场景**
  - 当多个对象可以处理一个请求时，具体处理者在运行时刻自动确定。
  - 当需要动态指定处理某个请求的对象时。
- **优点**
  - 降低耦合度。一个对象无需知道是其他哪一个对象处理其请求。
  - 增强了系统的灵活性，可以动态地添加或删除处理者。
- **缺点**
  - 可能会导致请求处理的延迟，因为请求可能会被多个处理者传递。
  - 如果链条过长，可能会影响性能。
- **例子**
  假设我们有一个日志记录系统，需要根据日志级别（如 INFO、DEBUG、ERROR）来记录日志。
  我们可以使用责任链模式来实现不同级别的日志记录器，每个记录器处理特定级别的日志，并将其他级别的日志传递给下一个记录器。
  责任链（Chain of Responsibility）设计模式的本质是将请求沿着处理链传递，直到有一个处理器处理它。
  每个处理器都包含对下一个处理器的引用，如果当前处理器不能处理请求，它会将请求传递给下一个处理器。

### 2. **命令模式**

- 一种发出命令，传递命令参数，处理命令的抽象模式。命令模式将请求封装成一个对象，使得可以用不同的请求对客户进行参数化，支持命令的撤销和重做等操作。
- 举个例子来说，遥控器会有对电视机的控制。通过遥控器可以向电视机发出命令。电视机的具体能力不可能被遥控器感知，因此只能是遥控器发出命令。
- 那么电视机能不能直接暴露出接口给遥控器调用，为什么还要抽象命令呢？因为命令有时候有一些统一的行为，比如说命令需要有记录，事务，等等能力。不管是增大减少音量，还是调台等等命令本身就应该派生自一个父类。因此有命令类，能够使用命令传递参数，处理命令的模式就叫做命令模式。
- **使用场景**
  - 当需要对操作进行参数化时。
  - 当需要将操作放入队列中执行或记录日志时。
  - 当需要支持撤销和恢复操作时。
- **介绍**
  命令模式将请求封装成对象，使得可以用不同的请求对客户进行参数化。命令模式还支持撤销操作。
  通过这种方式，可以在不修改现有类的情况下，为对象添加新的功能，例如支持撤销操作。
  允许你将动作封装在对象中。这个模式的关键思想是提供一种手段，将客户端与接收者解耦。
- **优点**
  - 将调用操作的对象与实现操作的对象解耦。
  - 容易扩展新的命令。
- **缺点**
  - 可能会导致系统中类的数量增加。
- **例子**
  用户（即 `Client`）使用遥控器（即 `Invoker`）打开（即 `Command`）电视（即 `Receiver`）。

### 3. **迭代器模式**

- 一种对容器提供访问能力的模式。
- 举个例子来说，比如说文件夹需要提供一个显示所有子文件的能力。那么针对这种场景，提供一个遍历的迭代器以供操作则是迭代器模式了。

* **使用场景**
  - 当需要访问一个聚合对象的内容而无需暴露其内部表示时。
  - 当需要为聚合对象提供多种遍历方式时。
* **介绍**
  迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部表示。
  迭代器模式将算法与容器解耦；在某些情况下，算法必然是容器特定的，因此无法解耦。
* **优点**
  - 支持以不同方式遍历一个聚合对象。
  - 迭代器简化了聚合类。
* **缺点**
  - 增加了类的数量。
* **例子**
  或者以 MP3 播放器或电视机为例，你可以按下一个和上一个按钮来浏览连续的频道或歌曲，换句话说，它们都提供了一个接口来迭代相应的频道、歌曲或电台。

### 4. **中介者模式**

- 一种解耦的模式
- 举个例子说，比如说一个聊天软件。用户和聊天室本来就有相互引用的关系，即用户有所属聊天室，聊天室有所属用户。如果要将用户和聊天室解耦开，就需要依赖中介者模式。用户和聊天室的彼此相互引用，就变成了聊天室和中介者的相互引用，用户和中介者的相互引用。
- 如果进一步抽象来说，假设有一个非常复杂的引用关系，进而抽象为一个复杂的图。如果使用中介者模式，那么这个图可以简化成类似的海星模式。这些所有节点都和中心节点，即中介者关联。中介去处理这些复杂的耦合关系，总比原来每个节点既需要处理业务关系，又需要处理引用关系好。
- 如果本来的引用关系比较简单，就不需要了。

* **使用场景**
  - 当对象之间存在复杂的引用关系，导致它们之间的依赖关系结构混乱且难以复用时。
  - 当需要通过一个中介对象来封装多个对象之间的交互时。
* **介绍**
  中介者模式定义一个中介对象来封装一系列对象之间的交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
* **优点**
  - 降低了对象之间的耦合性，使得对象易于独立地被复用。
  - 将对象之间的交互抽象化，使得对象之间的交互更加灵活。
* **缺点**
  - 中介者会膨胀得很大，变得复杂难以维护。

### 5. **备忘录模式**

- 一种类似缓存的机制，也可以理解是一种记录中间状态的模式
- 比如说游戏的读档和存档，在游戏中保存角色的当前状态，以便可以回退到之前的状态，这是典型的备忘录模式应用。

* **使用场景**
  - 当需要保存对象的某个状态，以便在适当的时候恢复时。
  - 当使用命令模式实现撤销操作时。
* **介绍**
  备忘录模式是关于捕获和存储对象的当前状态，以便以后可以以平滑的方式恢复它。
  某种角度来说就是添加一种中间状态变量。
* **优点**
  - 提供了一种恢复状态的机制，使得用户可以方便地恢复到某个历史状态。
  - 实现了信息的封装，使得用户不需要关心状态的保存细节。
* **缺点**
  - 资源消耗较大，如果需要保存的状态过多，可能会占用较多的内存。
* **例子**
  以计算器为例（即发起者），每当你进行一些计算时，最后的计算结果会保存在内存中（即备忘录），以便你可以返回到它并通过一些操作按钮（即看护者）将其恢复。
  word文档的ctrl-s其实也会记录当前文档若干个版本的备份，也是类似备忘录的实现。

### 6. **观察者模式**

- 一种 monitor 机制。
- 举个例子说，下课了，下课需要有一个广播的方式，能够通知到其他对象这个事件；接收到这个事件的，按照自己的业务进行相应处理，比如说老师收到下课铃，就要开始留堂了；学生收到下课铃，就要开始收拾书包了。
- 注意细节是，下课铃不可能认识所有需要关注下课的对象，因此需要下课的对象需要有一种方式去注册、订阅下课消息；下课铃只认识这些对象，通过多态的模式去统一通知。然后这些对象再去完成任务。
- 进一步抽象则是，对象会有成员变量。这些成员变量是所谓的观察者/monitor，观察者需要去注册消息。当被收到消息的时候，再去处理。

* **使用场景**
  - 当一个对象的改变需要同时改变其他对象时。
  - 当一个对象必须通知其他对象，而它又不能假定其他对象是谁时。
* **介绍**
  定义对象之间的一种依赖关系，以便每当一个对象改变状态时，所有依赖于它的对象都会得到通知。
  通过这种方式，可以实现对象之间的松耦合，提高系统的灵活性和可维护性。
  观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象发生变化时，它的所有依赖者（观察者）都会收到通知并更新。
* **优点**
  - 观察者和被观察者之间是抽象耦合的。
  - 建立一套触发机制。
* **缺点**
  - 如果一个被观察者对象有很多的直接和间接观察者，将所有的观察者都通知到会花费很多时间。
  - 如果在观察者和被观察者之间有循环依赖，可能会导致系统崩溃。
* **例子**
  一个很好的例子是求职者，他们订阅了一些招聘网站，每当有匹配的工作机会时，他们会收到通知。
  招聘网站不应该认识具体的求职者，但认识一下订阅消息是可以的。
  因此招聘网站应该会调用到这些订阅信息的方法。这些消息会实际认识和调用求职者接口。

### 7. **访问者模式**

- 一种动态添加对象能力的方法。
- 举个例子来说，酒店只需要有一个入访登记处，各个对象如果需要进入酒店并完成职能，比如说服务员、厨师等等有不同的职能。就只需要去酒店统一登记`accept(args: Visitor)/register(args: Visitor)`，并通过多态形式在`accept()`去调用统一的`action()`。

* **使用场景**
  - 当需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类时。
  - 当对象结构比较稳定，但经常需要在此对象结构上定义新的操作时。
* **介绍**
  访问者模式表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
* **优点**
  - 增加新的操作很容易。
  - 访问者模式将有关行为集中到一个访问者对象中。
* **缺点**
  - 增加新的元素类很困难。
  - 破坏了类的封装性。

### 8. **策略模式**

- 一种动态调整算法和策略的模式。
- 举个例子说，大数据集和小数据集有不同的平均最优算法。根据数据集的大小，动态选择执行哪一个排序算法，这种模式就是策略模式。
- 注意的是，策略模式的动态选择依赖于规则或者说需求，算法的调用也可能依赖于多样的状态变量，没有一个特别通用的常见模式。但针对某一种需要有多种计算策略/算法的时候，知道这是策略模式就够了。

* **使用场景**
  - 当一个系统需要动态地在几种算法中选择一种时。
  - 当一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现时。
* **介绍**
  策略模式定义了一系列算法，并将每一个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。
  策略模式允许你根据情况，在运行时切换算法或策略。
* **优点**
  - 算法可以自由切换。
  - 避免使用多重条件判断。
* **缺点**
  - 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
* **例子**
  考虑排序的例子，我们实现了冒泡排序，但数据开始增长，冒泡排序变得非常慢。为了应对这个问题，我们实现了快速排序。但是，虽然快速排序算法在处理大数据集时表现更好，但在处理小数据集时非常慢。为了处理这个问题，我们实现了一种策略，对于小数据集使用冒泡排序，对于大数据集使用快速排序。

### 9. **状态模式**

- 一种状态机的实现模式。
- 举个例子说，音乐播放器都会有下一首功能，但是这个下一首的功能，依赖于播放模式状态，即单曲循环、顺序循环、随机播放等等。同一个行为，能够根据不同状态执行不同操作，就是状态模式。
- 注意的是，广义地说，状态模式就是状态机。但狭义地说，状态模式更多地指代业务能力下放到 state 中，由 state 的子类去实现具体业务需求。因此音乐播放的能力为`void playNext(){m_state->action()}`。

* **使用场景**
  - 当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时。
  - 当一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。
* **介绍**
  状态模式允许一个对象在其内部状态改变时改变它的行为。对象看起来好像修改了它的类。
* **优点**
  - 将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。
  - 使得状态转换显式化。
* **缺点**
  - 状态模式的使用必然会增加系统类和对象的个数。
  - 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。

### 10. **模板方法模式**

    - 一种定义流程的模式。
    - 举个例子说，炒菜应该有一个固定的流程，我可以给炒菜设定`1.买菜；2.洗菜；3.切菜；4.炒菜；5.上菜`。然后会有一个统一的`make()`方法调用上面 5 个步骤。那不管是辣椒炒肉，还是番茄炒蛋，都会派生自炒菜这一个类，按需重写不同的制作步骤即可。

- **使用场景**
  - 当一个算法的整体结构已经确定，但某些步骤的具体实现可以由子类来完成时。
  - 当多个子类有公有的方法，并且逻辑基本相同时。
- **介绍**
  模板方法模式定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
- **优点**
  - 提高代码复用性。
  - 提高了扩展性。
- **缺点**
  - 每一个不同的实现都需要一个子类来实现，导致类的个数增加。
  - 增加了系统的复杂性。
- **\*例子**
  简单来说就是父类定义算法结构，比如说`step1/step2/step3/step4`等等。
  子类按需重载step1方法。
  如果某一个子类没有step2方法，重载并return即可。
