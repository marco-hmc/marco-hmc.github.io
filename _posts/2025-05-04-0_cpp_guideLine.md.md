---
layout: post
title: c++ guideline
categories: 程序设计
related_posts: True
tags: 开发规范
toc:
  sidebar: left
---

## c++ guideline

**代码的静态检查能力很重要**。
本地支持静态检查时非常重要的，c++推荐用`clang-tidy`。
本文是《effective c++》《more effective c++》作为常规静态代码检查的补充，或者个人觉得常规代码静态检查有可值得额外留意之处，便在这里记录。

### 1. 多线程

- 对于业务开发来说，一般不太需要
- 很多人误认为使用锁会让程序变慢，但实际上影响性能的不是锁本身，而是锁争用（多个线程同时竞争同一个锁）。
- 需要学会在程序的复杂度和性能之间取得平衡，并考虑机器扩容的可能性。

### 2. 内存安全

访问越界数组不一定会导致段错误（segmentation fault），但在某些情况下确实可能会发生。段错误通常发生在程序试图访问未分配或受保护的内存区域时。以下是一些可能导致段错误的情况，以及为什么访问越界数组不一定总是会导致段错误。

什么时候会有段错误？

1. **访问未分配的内存**：
   - 当程序试图访问未分配的内存区域时，操作系统会检测到并触发段错误。例如，访问一个指针指向的内存地址，但该地址未被分配。
2. **访问受保护的内存**：
   - 当程序试图访问受保护的内存区域（如只读内存或内核空间）时，操作系统会触发段错误。
3. **访问已经释放的内存**：
   - 当程序试图访问已经通过 `free` 或 `delete` 释放的内存时，可能会触发段错误。

访问越界数组不一定会有段错误的原因

1. **越界访问在已分配的内存范围内**：
   - 如果越界访问的内存地址仍然在程序已分配的内存范围内，可能不会立即触发段错误。例如，访问数组的越界元素，但该元素在同一个内存块中。
2. **未触发内存保护机制**：
   - 如果越界访问的内存地址未触发操作系统的内存保护机制，可能不会触发段错误。例如，访问堆上的越界元素，但该元素未超出堆的边界。

访问越界数组不一定会导致段错误，具体取决于越界访问的内存地址是否在已分配的内存范围内，以及是否触发了操作系统的内存保护机制。段错误通常发生在程序试图访问未分配或受保护的内存区域时。为了避免段错误和其他未定义行为，建议在访问数组时进行边界检查。

### 3. 原始指针

最好不要用原始指针

1. 指针作为返回的时候

```cpp
Info* foo();
```

- 用户负责指针指向对象的析构
- foo()负责指针指向对象的析构
- 指针是能否为空？是不是外部用之前都得判断一下？
  总是会有歧义。
  因此如果是foo()内部管理声明周期，可以选择返回引用；
  如果是用户负责生命周期，可以选择返回智能指针。
  甚至乎其实不返回指针，返回对象实例的时候，因为rvo的存在。其实性能差不多的。
  但是rvo在多返回路径的时候没办法支持，这个时候可以考虑使用移动语义。

### 4. 考虑使用 op=来取代单独的 op 运算符

operator+ 和 operator+=是不一样的，所以如果想要重载+号，就最好重载+=，那么一个比较好的方法就是把+号用+=来实现，当然如果可以的话，可以使用模板编写：

```c++
    template<class T>
    const T operator+(const T& lhs, const T& rhs)
    {
        return T(lhs) += rhs;
    }
    template<class T>
    const T operator-(const T& lhs, const T& rhs){
        return T(lhs) -= rhs;
    }
```

### 5. release 模式防止变量被优化

    volatile

### 6. 通过引用捕获异常

使用指针方式捕获异常：不需要拷贝对象，是最快的,但是，程序员很容易忘记写 static，如果忘记写 static 的话，会导致异常在抛出后，因为离开了作用域而失效：

    void someFunction(){
        static exception ex;
        throw &ex;
    }
    void doSomething(){
        try{
            someFunction();
        }
        catch(exception *ex){...}
    }

创建堆对象抛出异常：new exception 不会出现异常失效的问题，但是会出现在捕捉以后是否应该删除他们接受的指针，在哪一个层级删除指针的问题
通过值捕获异常：不会出现上述问题，但是会在被抛出时系统将异常对象拷贝两次，而且会出现派生类和基类的 slicing problem，即派生类的异常对象被作为基类异常对象捕获时，会把派生类的一部分切掉，例如：

    class exception{
    public:
        virtual const char *what() throw();
    };
    class runtime_error : public exception{...};
    void someFunction(){
        if(true){
            throw runtime_error();
        }
    }
    void doSomething(){
        try{
            someFunction();
        }
        catch(exception ex){
            cerr << ex.what(); //这个时候调用的就是基类的what而不是runtime_error里面的what了，而这个并不是我们想要的
        }
    }

通过引用捕获异常：可以避免上面所有的问题，异常对象也只会被拷贝一次：

    void someFunction(){...} //和上面一样
    void doSomething(){
        try{...}             //和上面一样
        catch(exception& ex){
            cerr << ex.what(); //这个时候就是调用的runtime_error而不是基类的exception::what()了，其他和上面其实是一样的
        }
    }

这段文字讨论了在 C++ 中抛出异常、传递参数和调用虚函数之间的不同点，特别是它们在处理方式和行为上的差异。以下是对这段文字的详细解释：

### 7. 传递参数和捕获异常的相同点和不同点

- **相同点**

传递参数和捕获异常的方式可以是传值、传引用或者传指针。例如：

- 传递参数的函数：

  ```cpp
  void f1(Widget w);
  ```

- 捕获异常的 [`catch`]子句：
  ```cpp
  catch(Widget w)...
  ```

这两种方式都可以通过传值、传引用或传指针来进行参数传递或异常捕获。

- **不同点**

* **控制权的返回**：
  - 调用函数时，程序的控制权会返回到函数的调用处。
  - 抛出异常时，控制权永远不会回到抛出异常的地方。

- **三种捕获异常的方法**

1. **传值捕获**：

   ```cpp
   catch(Widget w);
   ```

   - 捕获异常对象的副本。

2. **传引用捕获**：

   ```cpp
   catch(Widget& w);
   ```

   - 捕获异常对象的引用。

3. **传常量引用捕获**：
   ```cpp
   catch(const Widget& w);
   ```
   - 捕获异常对象的常量引用。

- **捕获异常的注意事项**

* 一个被抛出的对象可以通过普通的引用捕获，不需要通过指向 [`const`]对象的引用捕获。
* 在函数调用中，不允许传递一个临时对象到一个非 [`const`]引用类型的参数中。
* 异常抛出时实际上是抛出对象创建的临时对象的拷贝。

- **类型转换**

在 [`try`]语句块中，抛出的异常不会进行类型转换（除了继承类和基类之间的类型转换，以及类型化指针转变成无类型指针的转换）。例如：

```cpp
void f(int value) {
    try {
        throw value; // value 可以是 int 也可以是 double 等其他类型的值
    }
    catch(double d) {
        // 这里只处理 double 类型的异常，如果遇到 int 或者其他类型的异常则不予理会
    }
}
```

在这个例子中，[`catch`]子句只处理 [`double`]类型的异常，如果抛出的是 [`int`]类型的异常，则不会被捕获。

- **捕获异常的顺序**

异常捕获是按照顺序进行的。如果有多个 [`catch`]子句，程序会优先进入第一个匹配的 [`catch`]子句。例如：

```cpp
try {
    // 可能抛出异常的代码
}
catch(const std::exception& e) {
    // 捕获 std::exception 类型的异常
}
catch(...) {
    // 捕获所有类型的异常
}
```

在这个例子中，如果抛出的是 `std::exception` 类型的异常，会优先进入第一个 [`catch`]子句。如果没有匹配的 [`catch`]子句，则会进入第二个捕获所有类型异常的 [`catch`]子句。

- **总结**

* **传递参数和捕获异常的方式**：可以是传值、传引用或传指针。
* **控制权的返回**：函数调用会返回控制权，异常抛出不会。
* **捕获异常的方法**：可以通过传值、传引用或传常量引用捕获异常。
* **类型转换**：异常抛出时不会进行类型转换，除了继承类和基类之间的类型转换。
* **捕获顺序**：异常捕获是按照顺序进行的，优先进入第一个匹配的 [`catch`]子句。

通过理解这些差异，可以更好地编写和调试 C++ 程序，确保异常处理机制的正确性和有效性。
