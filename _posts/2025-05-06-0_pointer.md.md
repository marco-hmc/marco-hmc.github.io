---
layout: post
title: 指针
categories: language
related_posts: True
tags: cpp grammar pointer
toc:
  sidebar: left
---

## 指针

### 1. 指针的本质

指针的目的是为了表示内存的一个数据。

首先，简单回顾下内存是怎么存数据的。内存有若干个单元格，每个单元格会有一个地址，一个单元格能存储的容量是一个字节，这相当于一个 char 类型所占的空间大小。而硬件层面上提供了根据地址找到存储数据的方式。一份数据可能由一个单元格或者若干个单元格一块存储。

那么如果想表示内存的一个数据可以怎么做？

1. 记录这个数据所有单元格所在的地址。
2. 基于同一份数据的单元格都是连续存储的先验，只需要首地址和数据总长度。
   第二种方式是不言自明地优于第一种方式。而指针本质就是第二种的表达方式。
   > 进一步来说，数据总长度信息是等价于数据类型信息的。一个数据类型就是说明要占用几个单元格去存储这个数据，数据总长度在表达上容易产生歧义。因此更喜欢用类型去表示类型长度这个概念。
   > 更进一步地说，类型表示地是编译器如何理解首地址。编译器是会把c/c++等高级语言转变成汇编语言，而汇编语言是不存在自定义类型长度概念的。当使用一个自定义类型的时候，编译器其实会理解这个类型，并知道这份数据要有几个单元格表示。当编译器生成汇编语言的时候，就会直接指明汇编语言是要按照多少个单元格的方式去取数据。因此，也会有人说类型的意义，在于让编译器知晓该按照何种格式去读取相应地址处的数据。

#### 1.1 指针的种类有哪些

1. 基本对象指针：
   - 基本数据类型的指针。
   - 如：`int* p`; 定义了一个指向整型数据的指针。
2. `void`指针：
   - `void*` 是一种特殊的指针类型，可以指向任何类型的数据，通常用于需要存储任意类型地址的场合，如通用函数的参数。但使用时通常需要类型转换。
3. 常量指针与指向常量的指针：
   1. 指向常量的指针：如 const int\* p;，指针可以指向一个整型常量，但不能通过指针修改所指向的值。
   2. 常量指针：如 int\* const p;，指针本身是一个常量，一旦初始化后就不能改变它指向的地址，但可以通过指针修改所指向的值。
   3. 指向常量的常量指针：如 const int\* const p;，指针和它指向的值都是不可变的。
4. 函数指针：
   - 指向函数的指针可以存储一个函数的地址，并通过该指针调用函数。如 void (\*func_ptr)(int); 定义了一个指向接受一个整型参数且无返回值的函数的指针。
5. 数组指针与指向数组的指针：
   - 数组名本身就可以视为指向其首元素的指针，如 int arr[10]; int\* ptr = arr;。
   - 可以声明指向整个数组的指针，如 int (\*ptr_to_array)[10];。
6. 多级指针：
   - 如 int \*\*ptr; 是一个二级指针，可以指向一个指针，该指针又指向一个整型数据。多级指针可以扩展到更多级别。
7. 成员指针：
   - 成员指针指向类的非静态成员变量。如 int MyClass::\*ptr; 指向 MyClass 中的某个整型成员。

#### 1.2 指针的大小

在给定的系统架构下，所有类型的指针所占用的内存大小是相同的。这是因为指针存储的是地址，而地址空间的大小是由硬件和操作系统决定的，不是由指针所指向的数据类型决定的。

- 在32位系统上，无论指针指向何种类型的数据（如 int*, char*, double\* 等），指针本身的大小通常是4字节（32位）。
- 在64位系统上，同样几乎不论指针指向的数据类型如何，指针的大小通常是8字节（64位）。

注意：使用特殊编译器选项或在某些特定的虚拟化环境中，即使是在32位系统上，也有可能配置指针为64位。但这种情况较为少见。

#### 1.3 总结

因此总结一下，指针的本质就是类型（等价于长度）和地址。

- 一个指针, 不管它指向那种数据类型, 其本身所需内存大小是固定的, 与计算机的位数一致，即一般8字节。
- 指针类型会指导编译器如何解释某个特定地址中的内存内容及其大小。
- void\*指针能够持有一个地址, 但不能通过它来操作所指对象, 因为不知道其覆盖怎样的地址空间。

但特别要注意的是，在使用指针时，最好将硬件亲和性纳入考量范围。内存访问并非是简单地逐个地址去获取数据，实际上，内存访问往往是按照**一定的行**来进行操作的，例如当通过指针访问 `int` （四字节数据）类型数据时，并不是分四次去访问对应的四个字节地址，而是一次性访问包含这四个字节的一行内存空间，字节对齐就是基于这样的内存访问机制而存在的。字节对齐能够确保数据在内存中的存放符合硬件高效访问的要求，从而提升整体的访问效率，让基于指针的内存操作更加顺畅高效。

> 更进一步地说，内存访问是查高速缓存再查内存的。这个行的大小长度，实际上是由缓存决定的。目前缓存在各种因素考虑下，缓存行的大小一般为64字节，8个地址长度，16个int型数据。
> 题外话，当读取一个非内存对齐的数据的时候，这个数据的读都不一定是原子的，比如说要读两行才能读完这个数据，读完第一行的时候，第二行被改了。但计算机硬件在发展，有些能保证是原子的。

那么当我存储一个数据的时候，很常见的要求就是连续存储同一类型数据多次。那要怎么做呢？

### 2. 指针和数组

同样地，如果要求连续存储同一类型数据多次，可以怎么做呢？

1. 记住所有数据的指针。
2. 基于同一类型数据连续存储的先验，只需要知道首数据地址和连续数据的个数。
   同样也是不言自明地第二种好。而数组的本质也是第二种方式的表达方式。

```c
    int arr[4] ={1,2,3,4};
    // arr本质上就是首数据地址，而4就是连续数据的个数。
    // arr = arr[0] = 0x0001 = 首数据地址
    // arr[1] = 首数据地址 + 类型长度 * 序数 = 0x0001 + 4 * 1 = 0x0005
    // arr[2] = ... = 0x0009
    // arr[3] = ... = 0x000C

    // > 序数为第几个数字；int的类型为4；0x0001为地址表示方式
```

因此，数组就是首数据指针和数组长度。进一步地，也可以说数组是一种基于指针概念的封装和抽象。

当谈论数组的时候，高维数组自然也是一种很常见的东西，那什么是高维数组，又有什么用呢？

### 3. 高维数组

首先，也简单明确一下什么是高维数组。数组表示的是存储同一类型数据多次，如果这个同一类型本身是一个数组，这就是高维数组了。

```c
    int arr[2][2] = { {1, 2}, {3, 4} };
```

再进一步理解，首先要知道任何高维东西的理解都离不开逐步降维。那`int arr[2][2]`降维了之后是什么？

```c
    // 其实typedef int[2] type可能更好理解，但parse解析规则不是这样的
    // 但理解是一个意思即可
    typedef int TYPE[2];
    TYPE arr = {x, x};
```

再接一个例子说明

```c
    /*
    // 从内存空间理解
                tab + 0        tab + 1
    Address  0x7ffc5c78b530  0x7ffc5c78b538  0x7ffc5c78b530  0x7ffc5c78b534  0x7ffc5c78b538  0x7ffc5c78b53c
      Value  0x7ffc5c78b530  0x7ffc5c78b538  1  				2  				3  				4
                    [0]           [1]         [0][0]          [0][1]          [1][0]          [1][1]

    tab = table[0] = table[0][0] = 0x7ffc5c78b530
    *tab = 0x7ffc5c78b530
    **tab = table[0][0] = 1

    tab + 1 = table[1] = table[1][0] = 0x7ffc5c78b538
    *(tab + 1) = 0x7ffc5c78b538
    **(tab + 1) = table[1][0] = 3

    // 从二维数组理解
                row: 0               row: 1
    col: 0   0x7ffc5c78b530--1   0x7ffc5c78b538--3
    col: 1   0x7ffc5c78b534--2   0x7ffc5c78b53c--4

     */
    int tab[2][2] = { {1, 2}, {3, 4} };
```

数据的表示都是顺序的，比如说`0-4Gb`的内存空间，全部都是一个单元格一个单元格挨着的。
高维数组本质上也是这样一个一个单元挨着的，是可以看成一行的。
因此，`int tab[2][2]`其实和`int row[4]`这种，在存储上本质是没区别的。
只是`int tab[2][2]`这种提供了刚方便的访问方式。
如第二行所有数据可以表示为`int tab[1]`,如第二行第一列，实际上就是第三个数据可以表示为`int tab[1][0]`

### 4. 多级指针

一句话简要说明，二级指针是指针的指针，三级指针是二级指针的指针，如此类推。
具体展开一些则是，多级指针有两个用途：

1. 在参数中传递一个指针进来或者出去。

   ```c
       class ID;
       bool getArr(ID id, int* cnt, int**arr) {
           return getArrById(id, cnt, arr);
       };

       void foo() {
           ID id = getId();
           int cnt;
           int *arr = NULL;
           bool isSuccess =getArr(id, &cnt, &arr);
       };
   ```

   一个arr数据已经在某个地方存好了，传入一个标识符就可以获取。但是返回值得有三个，操作状态，数组长度，数组地址。一般而言，则倾向于将操作状态作为函数返回值，那数组长度和数组地址就通过出参的方式返回。那就都得通过指针的方式去返回。而返回的是一个数组地址，那就是数组地址的指针，也就变成二维了。

2. 多级指针等价于高维数组
   ```c
       // 动态分配二维数组
       int **arr = malloc(nrows * sizeof(int *));
       for (int i = 0; i < nrows; i++) {
           arr[i] = malloc(ncols * sizeof(int));
       }
   ```

### 99. quiz

#### 1. 数组退化为指针是什么意思？

数组退化为指针是指在某些情况下，数组名会被编译器自动转换为指向数组第一个元素的指针。这种情况通常发生在数组作为函数参数传递时。

```c
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}

void printArray(int arr[5], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}


int main() {
    int array[5] = {1, 2, 3, 4, 5};
    printArray(array, 5);  // array 退化为指针
    return 0;
}
```

在这个例子中，`array` 作为参数传递给 `printArray` 函数时，退化为指向 `array` 第一个元素的指针。
正如前面说的，数组的本质是是首元素指针+数组长度

#### 2. 数组的内存安全如何保证？越界风险如何避免？

数组的内存安全是指在使用数组时，确保不访问数组边界之外的内存，以避免越界访问。越界访问可能导致程序崩溃或意外行为。

1. **使用数组长度**：在访问数组元素时，始终使用数组的长度进行边界检查。
2. **使用标准库函数**：使用标准库函数（如 `memcpy`、`memset` 等）时，确保传递的长度参数正确。
3. **使用动态数组**：使用动态数组（如 `std::vector`）可以自动管理数组的大小和边界检查。
4. **启用编译器警告**：启用编译器的警告和错误检查选项，可以帮助发现潜在的越界访问问题。
