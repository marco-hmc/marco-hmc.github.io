---
layout: post
title: 进程
categories: language
related_posts: True
tags: cpp 并发编程 multiProcess
toc:
  sidebar: left
---

## 进程

### 2. 多进程的概念

- **什么是进程：**
  进程是操作系统进行资源分配和调度的基本单位,是应用程序在操作系统中的一次运行过程.进程拥有自己独立的内存空间,每个进程中都有至少一个线程.进程之间的通信需要使用特殊的进程间通信机制.

  - 优点：
    - 进程是互相独立的，不涉及锁什么之类的，代码编写方便，调试方便
    - 进程是独立的，所以稳定性更高，一个进程挂了，其他也不会挂；
  - 缺点：
    - 进程创建慢，占用内存多，进程的上下文切换代价高昂
    - 进程之间通信麻烦且慢，常用且好的多进程通信机制一般为socket，所以通信内容一般为指令而非数据

- **进程的 ID**
  - **PID**：
    - 进程的唯一标识。对于多线程的进程而言，所有线程调用 `getpid` 函数会返回相同的值。
  - **PGID**：
    - 进程组 ID。每个进程都会有进程组 ID，表示该进程所属的进程组。默认情况下，新创建的进程会继承父进程的进程组 ID。
  - **SID**：
    - 会话 ID。每个进程也都有会话 ID。默认情况下，新创建的进程会继承父进程的会话 ID。

#### 2.1 守护进程概念

- **守护进程**
  - **定义**：
    - 守护进程是后台运行的、不与任何终端关联的进程，无法通过终端进行输入输出。它们通常用于周期性地执行某种任务或等待处理特定的事件。
  - **实现思路**：
    - 将普通进程改造为守护进程的过程。不同版本的 Unix 系统其实现机制不同，BSD 和 Linux 下的实现细节有所不同。

#### 2.2 后台进程概念

后台进程是指在终端中启动后，不会阻塞终端，可以在终端中继续执行其他命令的进程。后台进程通常通过在命令末尾加上 & 符号来启动。后台进程在执行时，用户可以继续在终端中输入其他命令，而不需要等待后台进程完成。
后台进程其实和守护进程是非常类似的，只是严格意义下，后台进程一般还是和终端程序挂钩，而守护进程是与终端进程挂钩的。

#### 2.3 孤儿进程和僵尸进程

在操作系统中，进程的管理和状态是非常重要的。以下是对孤儿进程和僵尸进程的详细解释及其处理方法。

- **孤儿进程**

  - **定义**：
    - 孤儿进程是指一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。
    - 孤儿进程将被 `init` 进程（进程号为 1）所收养，并由 `init` 进程对它们完成状态收集工作。
  - **特点**：
    - 孤儿进程不会对系统造成危害，因为 `init` 进程会负责它们的状态收集和资源释放。

- **僵尸进程**

  - **定义**：
    - 僵尸进程是指一个进程使用 `fork` 创建子进程，如果子进程退出，而父进程没有调用 `wait` 或 `waitpid` 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。
  - **特点**：
    - 任何一个子进程（`init` 除外）在 `exit()` 之后，并非马上就消失，而是留下一个称为僵尸进程（Zombie）的数据结构，等待父进程处理。
    - 僵尸进程的进程号会一直被占用，系统所能使用的进程号是有限的，如果大量产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。
  - **危害**：
    - 僵尸进程会占用系统的进程号资源，如果不及时处理，可能导致系统无法创建新的进程。
  - **解决办法**：
    - 子进程退出时向父进程发送 `SIGCHLD` 信号，父进程处理 `SIGCHLD` 信号，在处理函数中调用 `wait` 或 `waitpid`。

- **僵尸进程的危害场景**

  - **场景描述**：
    - 例如有个进程，它定期产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了。因此这个子进程的生命周期很短。
    - 但是，父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问。这样，系统运行一段时间之后，系统中就会存在很多的僵尸进程。如果用 `ps` 命令查看的话，就会看到很多状态为 `Z` 的进程。
  - **根本原因**：
    - 严格地来说，僵尸进程并不是问题的根源，罪魁祸首是产生出大量僵尸进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵尸进程时，答案就是把产生大量僵尸进程的那个元凶进程终止掉（通过 `kill` 发送 `SIGTERM` 或者 `SIGKILL` 信号）。
  - **处理方法**：
    - 终止元凶进程之后，它产生的僵尸进程就变成了孤儿进程，这些孤儿进程会被 `init` 进程接管，`init` 进程会 `wait()` 这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程就能被清理掉。

- **总结**
  简单来说孤儿进程是死了父进程，但是父进程还是会将孤儿进程委托给收养院。因此孤儿能健康长大；而僵尸进程则是被父进程遗弃了，父进程不处理子进程了。因此这个时候子进程就不能健康长大，就有危险了。

### 3. 进程和线程篇

- **_什么是进程和线程?_**
  - **进程**:**进程是程序在某个数据集合上的一次运行活动,也是操作系统进行资源分配和保护的基本单位**.通俗来说,**'进程就是程序的一次执行过程'**,程序是静态的,它作为系统中的一种资源是永远存在的.而进程是动态的,它是动态的产生,变化和消亡的,拥有其自己的生命周期
  - **进程:**线程是独立调度的基本单位.一个进程中可以有多个线程,它们共享进程资源
- **_如何保证线程安全?_**
- **_什么是协程?_**

# 进程管理

## 进程和线程

- **进程的概念**：**进程是程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位**。通俗来说，**「进程就是程序的一次执行过程」**，程序是静态的，它作为系统中的一种资源是永远存在的。而进程是动态的，它是动态的产生，变化和消亡的，拥有其自己的生命周期

- 进程的组成

  - **进程控制块 PCB**。包含如下几个部分：
    - 进程描述信息，如pid，gid
    - 进程控制和管理信息，如进程状态，优先级，未决信号集，信号屏蔽字
    - 资源分配清单，如页表，打开文件列表
    - CPU 相关信息，如寄存器，状态寄存器，堆栈指针
  - **数据段**。即进程运行过程中各种数据（比如程序中定义的变量）
  - **程序段**。就是程序的代码（指令序列）

- 进程上下文切换

  - 首先，将进程 A 的运行环境信息存入 PCB，这个运行环境信息就是进程的上下文（Context）
  - 然后，将 PCB 移入相应的进程队列
  - 选择另一个进程 B 进行执行，并更新其 PCB 中的状态为运行态
  - 当进程 A 被恢复运行的时候，根据它的 PCB 恢复进程 A 所需的运行环境

- 线程的概念：线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源

- 线程的实现可以分为两类：

  - 用户级线程：不需要内核支持而在**用户程序中实现的线程**，其不依赖于操作系统核心，在语言层面利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。**不需要用户态/内核态切换，速度快，操作系统内核不知道多线程的存在，因此一个线 程阻塞将使得整个进程（包括它的所有线程）阻塞**。由于这里的**处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少**
  - 内核线线程：又称为内核支持的线程或轻量级进程，所以线程切换时需要进入到内核态

- **同一进程中线程资源共享情况**
  - 线程共享的资源包括：**进程代码段、进程的公有数据**(利用这些共享的数据，线程很容易的实现相互之间的通讯)、**进程打开的文件描述符**、**信号的处理函数**、**进程的当前目录和进程用户ID与进程组ID**
  - 线程不共享的资源包括：
    - **线程ID**：每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程
    - **寄存器组的值**：由于线程间是并发运行的，**每个线程有自己不同的运行线索**，当从一个线程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复
    - **线程的堆栈**：堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响
    - **错误返回码(errno)**：由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量
    - **线程的信号屏蔽码**：由于**每个线程所感兴趣的信号不同**，所以**线程的信号屏蔽码应该由线程自己管理**。**但所有的线程都共享同样的信号处理器**
    - **线程的优先级**：由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级
- 线程的优缺点

  - 优点：
    - 一个进程中可以同时存在多个线程，这些线程共享该进程的资源。**进程间的通信必须请求操作系统服务**（因为 CPU 要切换到内核态），开销很大。而同进程下的线程间通信，无需操作系统干预，开销更小。不过，需要注意的是：**从属于不同进程的线程间通信，也必须请求操作系统服务**
    - **线程间的并发比进程的开销更小**，**系统并发性提升**。同样，需要注意的是：**从属于不同进程的线程间切换，它是会导致进程切换的，所以开销也大**
  - 缺点：
    - 当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃。举个例子，**对于游戏的用户设计，就不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程**

- **进程和线程的区别**
  - 拥有资源
    - 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源
  - 调度
    - 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换
  - 系统开销
    - 进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。**进程切换需要分两步**：**切换页目录、刷新TLB以使用新的地址空间**；**切换内核栈和硬件上下文（寄存器）**；**而同一进程的线程间逻辑地址空间是一样的，线程切换时不需要切换页目录、刷新TLB，只需保存和设置少量寄存器内容、堆栈指针，开销较小**
    - **进程在创建、销毁时开销比较大，而线程比较小**。进程创建的时候需要分配**虚拟地址空间、IO设备**等系统资源，而**销毁的的时候需要释放系统资源**；线程只需要**创建栈，栈指针，程序计数器，通用目的寄存器和条件码**等，**不需要创建独立的虚拟地址空间**等系统资源
  - 通信方面
    - **线程间可以通过直接读写同一进程中的数据进行通信**，但是进程通信需要借助 IPC
- 高并发
  - 高并发指的是是一种系统运行过程中遇到的一种“**短时间内遇到大量操作请求**”的情况，主要发生在web系统集中大量访问或者socket端口集中性收到大量请求（例如：12306的抢票情况；天猫双十一活动）。该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。如果高并发处理不好，不仅仅降低了用户的体验度（请求响应时间过长），同时可能导致系统宕机，严重的甚至导致OOM异常，系统停止工作等

## 同步互斥

## 死锁

- **产生死锁的四大必要条件**

  - **资源互斥/资源不共享**：每个资源要么已经分配给了一个进程，要么是可用的，只有这两种状态，资源不可以被共享使用，所以所谓的互斥是指：资源不共享，如果被使用，只能被一个进程使用
  - **占有和等待/请求并保持**：已经得到资源的进程还能继续请求新的资源
  - **资源不可剥夺**：当一个资源分配给了一个进程后，其它需要该资源的进程不能强制性获得该资源，除非该资源的当前占有者显示地释放该资源
  - **环路等待**：死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，环路上的每个进程都在等待下一个进程所占有的资源

- 编程中避免死锁：

  - 避免多次锁定。**尽量避免同一个线程对多个 Lock 进行锁定**。例如上面的死锁程序，主线程要对 A、B 两个对象的 Lock 进行锁定，副线程也要对 A、B 两个对象的 Lock 进行锁定，这就埋下了导致死锁的隐患。
  - **具有相同的加锁顺序**。如果多个线程需要对多个 Lock 进行锁定，则应该保证它们以相同的顺序请求加锁。比如上面的死锁程序，主线程先对 A 对象的 Lock 加锁，再对 B 对象的 Lock 加锁；而副线程则先对 B 对象的 Lock 加锁，再对 A 对象的 Lock 加锁。这种加锁顺序很容易形成嵌套锁定，进而导致死锁。如果让主线程、副线程按照相同的顺序加锁，就可以避免这个问题。
  - **使用定时锁**。程序在调用 acquire() 方法加锁时可指定 timeout 参数，该参数指定超过 timeout 秒后会自动释放对 Lock 的锁定，这样就可以解开死锁了。
  - 死锁检测。死锁检测是一种依靠算法机制来实现的死锁预防机制，它主要是针对那些不可能实现按序加锁，也不能使用定时锁的场景的。
  - **无锁编程**：cas、原子变量、原子操作等

- 预防死锁

  - 预防死锁的发生**只需破坏死锁产生的四个必要条件之一**即可
  - 下面的方法开销非常之大，目前没有一个操作系统可以实现
    - **破坏互斥条件**：如果允许系统资源都能共享使用，则系统不会进入死锁状态； **缺点**：有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，**破坏互斥条件而预防死锁的方法不太可行**，而且在有的场合应该保护这种互斥性
    - **破坏请求并保持条件**：釆用**预先静态分配**方法，即**进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行**。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。**缺点**：**系统资源被严重浪费**，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会**导致“饥饿”**现象，**当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行**
    - **破坏不可剥夺条件**：当一个已保持了某些不可剥夺资源的进程，**请求新的资源而得不到满足时**，它**必须释放已经保持的所有资源，待以后需要时再重新申请**。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。**缺点**：该策略**实现起来比较复杂**，**释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量**。这种方法**常用于状态易于保存和恢复的资源**，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源
    - **破坏循环等待条件**：为了**破坏循环等待条件**，可釆用**顺序资源分配法**。首先**给系统中的资源编号**，规定每个进程，必须**按编号递增的顺序请求资源，同类资源一次申请完**。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。**缺点**： 这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种**按规定次序申请资源的方法，也必然会给用户的编程带来麻烦**
  - 因此，目前使用的方法是避免死锁，而不是预防死锁

- 避免死锁的算法

  - 判断“**系统安全状态**”法：**在进行系统资源分配之前，先计算此次资源分配的安全性**。若此次分配不会导致系统进入不安全状态，则将资源分配给**进程； 否则，让进程**等待

    ![safe_status](imgs/os/safe_status.png)

    - **图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数**。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得**所有进程都能成功运行**，因此可以称图 a 所示的状态是安全的
    - 定义：**如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的**
    - 安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比

  - 银行家算法

    - 申请的贷款额度不能超过银行现有的资金总额
    - 分批次向银行提款，但是贷款额度不能超过一开始最大需求量的总额
    - 暂时不能满足客户申请的资金额度时，在有限时间内给予贷款
    - 客户要在规定的时间内还款

  - 单个资源银行家算法

    - 一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，**算法要做的是判断对请求的满足是否会进入不安全状态**，如果是，就拒绝请求；否则予以分配

      ![bank](imgs/os/bank.png)

      上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态

  - 多个资源银行家算法

    ![multi_bank](imgs/os/multi_bank.png)

    - 上图中有**五个进程，四个资源**。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：**总资源、已分配资源以及可用资源**，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0
    - 检查一个状态是否安全的算法如下：
      - **查找右边的矩阵是否存在一行小于等于向量 A**。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的
      - 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中
      - 重复以上两步，直到所有进程都标记为终止，则状态是安全的
    - 如果一个状态不是安全的，需要拒绝进入这个状态

## CAS技术

- 概念

  - 比较并交换(compare and swap, CAS)，是原子操作的一种。**在多线程没有锁的状态下，可以保证多个线程对同一个值的更新**。CAS可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性，产生的数据不一致问题。该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值

- 原理

  - 执行函数：CAS(V，E，N) ，CAS有3个操作数，内存值`V`，旧的期望值 `E`，要修改的新值 `N`。当且仅当预期值`E`和内存值`V`相同时（比较），它就认为这个期间没有人来访问过这个贡献资源，所以就把`V`值改为新值`N`（交换）
  - **如果多个线程同时使用CAS操作一个变量的时候，只有一个线程能够修改成功。其余的线程提供的期望值已经与共享变量的值不一样了，所以均会失败**
  - 由于CAS操作属于乐观派，它总是认为自己能够操作成功，所以操作失败的线程将会再次发起操作，而不是被OS挂起。所以说，即使CAS操作没有使用同步锁，其它线程也能够知道对共享变量的影响
  - 因为其它线程没有被挂起，并且将会再次发起修改尝试，所以无锁操作即CAS操作天生免疫死锁
  - **CAS是系统原语，CAS操作是一条CPU的原子指令（cmpxchg），这个指令是给数据总线进行加锁，所以不会有线程安全问题**

- 特点

  - CAS结合`volatile`可以实现无锁并发，**适用于线程数少，多核CPU场景下**(线程数不要超过CPU核数)
  - CAS是**基于乐观锁实现**（本身并无锁，区别于synchronized）
  - CAS体现的是**无锁并发、无阻塞并发**
    - CAS的原子性 + `volatile`的可见性，不断的【比较与交换】保证线程安全
    - 没有用锁来保证线程安全，所以不会阻塞
    - 如果竞争激烈，会导致**重试**频繁发生，效率下降

- 自旋–比较和交换

  - **自旋：** 就是不停的判断比较，看能否将值交换
  - 多个线程在访问共享资源的时候，会产生同步问题，所以需要加锁来保证安全。但是，一旦加了锁，同一时刻只能有一个线程获取锁对象，效率自然变低了
  - 不加锁的情况下来修改值，CAS是怎么自旋如下图

    <img src="imgs/os/cas.png" alt="cas" style="zoom: 67%;" />

  - 现在`Data`中存放的是`num=0`，线程A将`num=0`拷贝到自己的工作内存中计算（做+1操作）`E=0`，计算的结果为`V=1`

  - 由于是在多线程不加锁的场景下操作，所以可能此时`num`会被别的线程修改为其他值。此时需要再次读取`num`看其是否被修改，记再次读取的值为`N`

  - 如果被修改，即`E != N`，说明被其他线程修改过。那么此时工作内存中的E已经和主存中的`num`不一致了，根据EMSI协议，保证安全需要重新读取`num`的值。直到`E = N`才能修改

  - 如果没被修改，即`E = N`，说明没被其他线程修改过。那么将工作内存中的`E=0`改为`E=1`，同时写回主存。将`num=0`改为`num=1`

- CAS三大问题

  - **ABA问题**
    - CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。这就是CAS的ABA问题
    - 常见的解决思路是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么`A-B-A` 就会变成`1A-2B-3A`，由于每个过程值都会有对应的版本，所以我们在修改过程中需要传入期望版本和当前的值，数据库的多版本并发控制也类似
    - 添加时间戳：添加世时间戳也可以解决。查询的时候把时间戳一起查出来，对的上才修改并且更新值的时候一起修改更新时间，这样也能保证，方法很多但是跟版本号都是异曲同工之妙
  - 无限循环问题（自旋）
    - 如果CAS不成功，则会原地自旋，如果长时间自旋会**给CPU带来非常大且没必要的开销**
    - 可以使用java8中的LongAdder，分段CAS和自动分段迁移
    - 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率
  - **只能保证一个共享变量的原子操作**
    - 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是**把多个共享变量合并成一个共享变量来操作**。比如有两个共享变量 i=2，j=a，合并一下 ij=2a，然后用CAS来操作
    - 可以用AtomicReference (java)，这个是封装自定义对象的，多个变量可以放一个自定义对象里，然后他会检查这个对象的引用是不是同一个。如果多个线程同时对一个对象变量的引用进行赋值，用AtomicReference的CAS操作可以解决并发冲突问题

## [IPC](https://mp.weixin.qq.com/s/b6HLr348-v7ibntuWs1yRA)

- 进程间通信(IPC)，[详见](https://www.cnblogs.com/zgq0/p/8780893.html)

### 管道

- 通常指无名管道，是 UNIX 系统IPC最古老的形式

- 它是**半双工**的（即数据只能在一个方向上流动），具有固定的读端和写端
- 它只能用于**具有亲缘关系的进程之间的通信**（也是父子进程或者兄弟进程之间）
- 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并**不属于其他任何文件系统**，并且**只存在于内存**中
- 原型

```c
1 #include <unistd.h>
2 int pipe(int fd[2]);    // 返回值：若成功返回0，失败返回-1
```

### FIFO

- 也称为命名管道，它是一种文件类型

- FIFO可以在无关的进程之间交换数据，与无名管道不同
- FIFO有路径名与之相关联，它以一种**特殊设备文件形式存在于文件系统**中
- FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。**在数据读出时，FIFO管道中同时清除数据，并且“先进先出”**
- 原型

```c
1 #include <sys/stat.h>
2 // 返回值：成功返回0，出错返回-1
3 int mkfifo(const char *pathname, mode_t mode);
```

- 其中的`mode`参数与`open`函数中的 `mode `相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它

  - 当 open 一个FIFO时，是否设置非阻塞标志（`O_NONBLOCK`）的区别：
    - 若没有指定`O_NONBLOCK`（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 `open` 要阻塞到某个其他进程为读而打开它
    - 若指定了`O_NONBLOCK`，则只读`open`立即返回。而只写`open`将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其`errno`置`ENXIO`。

### 消息队列

- **是消息的链接表，存放在内核中**。一个消息队列由一个标识符（即队列ID）来标识

- 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级
  - 消息队列独立于发送与接收进程。**进程终止时，消息队列及其内容并不会被删除**
  - **消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取,也可以按消息的类型读取**
  - 原型

```c
#include <sys/msg.h>
// 创建或打开消息队列：成功返回队列ID，失败返回-1
int msgget(key_t key, int fslag);
// 添加消息：成功返回0，失败返回-1
int msgsnd(int msqid, const void *ptr, size_t size, int flag);
// 读取消息：成功返回消息数据的长度，失败返回-1
int msgrcv(int msqid, void *ptr, size_t size, long type,int flag);
// 控制消息队列：成功返回0，失败返回-1
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

- 在以下两种情况下，`msgget`将创建一个新的消息队列：

  - 如果没有与键值key相对应的消息队列，并且flag中包含了`IPC_CREAT`标志位。
  - key参数为`IPC_PRIVATE`。

  * 函数`msgrcv`在读取消息队列时，`type`参数有下面几种情况：
    - `type == 0`，返回队列中的第一个消息
    - `type > 0`，返回队列中消息类型为 `type` 的第一个消息
    - `type < 0`，返回队列中消息类型值小于或等于`type`绝对值的消息，如果有多个，则取类型值最小的消息
  * 可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把` type` 看做优先级的权值

### [信号(signal)](https://blog.csdn.net/h___q/article/details/84245317)

- 信号是一种比较复杂的通信方式，**用于通知接收进程某个事件已经发生**

- 程序不可捕获、阻塞或忽略的信号有：**SIGKILL(9)，SIGSTOP(19)**

  - 它们向超级用户提供一种使进程终止或停止的可靠方法
  - 如果忽略某些由硬件异常产生的信号（例如非法存储访问或除以0），则进程的行为是未定义的

- 常见信号表

  ![signal_tab](imgs/os/signal_tab.png)

- 信号产生方式

  - [信号可以通过六个函数产生](https://www.jianshu.com/p/e4ce1f6488af):

    - **kill函数**
    - **raise函数**
    - **sigqueue函数**
    - **alarm函数**
    - **setitimer函数**
    - **abort函数**

  - 键盘产生

    - 如ctrl+c，ctrl+z，ctrl+/等

  - 程序异常

    - 除0错误。除0错误会导致硬件错误
    - core dumped（核心转储）：**当进程异常退出时，操作系统会将该进程发生异常退出之前在内存中的数据存储至硬盘上**
    - **2、9号信号不会产生core文件**

  - 使用kill命令

    - **kill 在无指定时默认发送2号信号，可将指定程序终止**。若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序。程序或工作的编号可利用 ps 指令或 jobs 指令查看

    ```shell
    kill [-s <信息名称或编号>][程序]　或　
    kill [-l <信息编号>]

    -l <信息编号> 　若不加<信息编号>选项，则 -l 参数会列出全部的信息名称
    -s <信息名称或编号> 　指定要送出的信息
    [程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号

    最常用的信号是：
    1 (HUP)：重新加载进程
    9 (KILL)：杀死一个进程
    15 (TERM)：正常停止一个进程
    ```

  - 通过系统调用接口给特定进程发送信号

    ```c++
    #include<signal.h>

    int kill(pid_t pid, int signo);
    //向特定进程发送特定信号;成功返回0;失败返回-1

    int raise(int signo);
    //向当前进程发送特定信号;成功返回0;失败返回-1

    #include<stdlib.h>
    void abort(void);
    //使当前进程收到信号而异常终止；就像exit()函数一样，abort()函数总是会成功的，所以没有返回值
    ```

  - 由软件条件发送信号

    - SIGPIPE：SIGPIPE是一种由软件条件产生的信号，**当一个管道的读端被关闭时，这时候操作系统就会检测到该管道中写入的数据不会在有人来管道内读文件了，操作系统会认为该管道的存在会造成内存资源的极大浪费，则操作系统就会向写端对应的目标进程发送SIGPIPE信号**
    - 定时器

      ```c++
      #include<unistd.h>
      unsigned int alarm(unsigned int seconds);
      //调用alarm函数可以对当前进程设置一个闹钟，也就是告诉操作系统在seconds秒之后对当前进程发送SIGALRM信号，该信号的默认处理动作是终止当前进程
      ```

- **信号集操作函数**

  ```c++
  #include<signal.h>

  //注意：在使用sigset_t类型的变量前，一定要调用sigemptyset或sigfillset进行初始化，使信号集处于某种确定的状态，初始化之后就可以调用sigaddset或sigdelset在信号集中添加或删除某种有效信号

  int sigemptyset(sigset_t *set);
  //初始化set所指向的信号集，使其中所有信号对应的比特位清零，表示该信号集不包含任何信号

  int sigfillset(sigset_t *set);
  //初始化set所指向的信号集，将其中所有信号对应的比特位置1，表示该信号集的有效信号包括系统支持的所有信号

  int sigaddset(sigset_t *set, int signo);
  //表示将set所指向的信号集中的signo信号置1

  int sigdelset(sigset_t *set, int signo);
  //表示将set所指向的信号集中的signo信号清零

  int sigismember(const sigset_t *set, int signo);
  //用来判断set所指向的信号集的有效信号中是否包含signo信号，包含返回1，不包含返回0，出错返回-1

  int sigpending(sigset_t *set);
  // 获取进程的pending信号集
  // 成功返回0；失败返回-1
  ```

- **设置/修改进程的信号屏蔽字（block表）**

  ```c++
  #include<signal.h>

  int sigprocmask(int how, const sigset_t *set, sigset_t *oset);

  /*
    int how：
        SIG_BLOCK：set包含了用户希望添加到当前信号屏蔽字的信号，即就是在老的信号屏蔽字中添加上新的信号。相当于：mask=mask|set
        SIG_UNBLOCK：set包含了用户希望从当前信号屏蔽字中解除阻塞的信号，即就是在老的信号屏蔽字中取消set表中的信号。相当于：mask=mask&~set
        SIG_SETMASK：设置当前进程的信号屏蔽字为set所指向的信号集。相当于：mask=set
    const sigset_t *set：
        将要设置为进程block表的信号集
    sigset_t *oset：
        用来保存进程旧的block表
        若无需保存进程旧的block表，传递空指针即可
  */
  ```

- **自定义信号处理方式**

  ```c++
  #include<signal.h>

  struct sigaction
  {
      void (*sa_handler)(int);	//指向信号处理对应的函数
      void (*sa_sigaction)(int, siginfo_t *, void *);
      sigset_t sa_mask; //当在处理所收到信号时，想要附带屏蔽的其他普通信号，当不需要屏蔽其他信号时，需要使用sigemptyset初始化sa_mask
      int sa_flags;
      void (*sa_restorer)(void);
  };

  int sigaction(int signo, const struct sigaction *act, struct sigaction *oact);
  /*
  int signo：
    指定的信号编号
  const struct sigaction *act：
    若该act指针非空，则根据act指针来修改进程收到signo信号的处理动作
  struct sigaction *oact：
    若oact指针非空，则使用oact来保存信号旧的处理动作
  */
  ```

- **信号处理过程**

  <img src="imgs/os/sig_cap.png" alt="sig_cap" style="zoom:80%;" />

- 信号接收

  - **接收信号的任务是由内核代理的，但内核接收到信号后，会将其放到对应进程的PCB的未决信号集中，同时向进程发送一个中断，使其陷入内核态**

- **此时信号只是在未决信号集中，对进程来说是不知道信号到来的**
- 信号的检测

  - 进程陷入内核后，**有两种场景会对信号集进行检测**：
    - 进程**从内核态返回到用户态前进行信号检测**
    - 进程在内核态中，**从睡眠状态被唤醒的时候进行信号检测**
  - 当发现有新信号后，便会进入下一步，信号处理

- 信号的处理

  - 如果用户**未注册信号处理函数**，则内核按照信号的**默认处理方式**处理
  - **如果用户注册了信号处理函数，则信号处理函数是运行在用户态的**，调用处理函数前，**内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器(eip)将其指向信号处理函数**
  - **接下来进程返回到用户态中，执行相应的信号处理函数**
  - **信号处理函数执行完成后，还需要返回内核态，检查是否还有其他信号未处理**
  - **如果所有信号都处理完成了，就会将内核栈回复(从用户栈的备份拷贝回来)，同时恢复指令寄存器(eip)将其指向中断前的运行位置，最后回到用户态继续执行进程**
  - 如果同时有多个信号到达，处理流程为上面1，2，3，4步骤间重复进行，直到所有信号处理完毕

- **处理信号的时机**

  - 进程收到一个信号时，**并不会立即就去处理这个信号，而是先将收到的信号保存下来，并在合适的时候对信号进行处理**，**操作系统会在进程进入了内核态并从内核态返回用户态时，检测进程中可以进行处理的信号，并进行处理**

- 用户写好的代码会在什么情况下进入内核态呢？

  - 调用系统调用接口
  - 异常
  - 中断

### 信号量

- 与已经介绍过的 IPC 结构不同，它是**一个计数器**。信号量**用于实现进程间的互斥与同步，而不是用于存储进程间通信数据**

- 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存

  - 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作
  - 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数
  - 支持信号量组
  - 原型

    ```c
    #include <sys/sem.h>
    // 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1
    int semget(key_t key, int num_sems, int sem_flags);
    // 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1
    int semop(int semid, struct sembuf semoparray[], size_t numops);
    // 控制信号量的相关信息
    int semctl(int semid, int sem_num, int cmd, ...);
    ```

- 当`semget`创建新的信号量集合时，必须指定集合中信号量的个数（即`num_sems`），通常为1； 如果是引用一个现有的集合，则将`num_sems`指定为 0 。在`semop`函数中，`sembuf`结构的定义如下：

  ```
  struct sembuf
  {
      short sem_num; // 信号量组中对应的序号，0～sem_nums-1
      short sem_op;  // 信号量值在一次操作中的改变量
      short sem_flg; // IPC_NOWAIT, SEM_UNDO
  }
  ```

- 其中` sem_op` 是一次操作中的信号量的改变量：

  - 若`sem_op > 0`，表示进程释放相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则换行它们

    - 若`sem_op < 0`，请求 `sem_op `的绝对值的资源
      - 如果相应的资源数可以满足请求，则将该信号量的值减去sem_op的绝对值，函数成功返回。
      - 当相应的资源数不能满足请求时，这个操作与`sem_flg`有关
        - `sem_flg `指定`IPC_NOWAIT`，则semop函数出错返回`EAGAIN`
        - `sem_flg` 没有指定`IPC_NOWAIT`，则将该信号量的`semncnt`值加1，然后进程挂起直到下述情况发生：
          1. 当相应的资源数可以满足请求，此信号量的`semncnt`值减1，该信号量的值减去sem_op的绝对值。成功返回；
          2. 此信号量被删除，函数`smeop`出错返回`EIDRM`；
          3. 进程捕捉到信号，并从信号处理函数返回，此情况下将此信号量的`semncnt`值减1，函数`semop`出错返回`EINTR`
    - 若`sem_op == 0`，进程阻塞直到信号量的相应值为0：
      - 当信号量已经为0，函数立即返回。
      - 如果信号量的值不为0，则依据`sem_flg`决定函数动作：
        - `sem_flg`指定`IPC_NOWAIT`，则出错返回`EAGAIN`。
        - `sem_flg`没有指定`IPC_NOWAIT`，则将该信号量的`semncnt`值加1，然后进程挂起直到下述情况发生：
          1. 信号量值为0，将信号量的`semzcnt`的值减1，函数`semop`成功返回；
          2. 此信号量被删除，函数`smeop`出错返回`EIDRM`；
          3. 进程捕捉到信号，并从信号处理函数返回，在此情况将此信号量的`semncnt`值减1，函数`semop`出错返回`EINTR`

  - 在`semctl`函数中的命令有多种，这里就说两个常用的：
    - `SETVAL`：用于初始化信号量为一个已知的值。所需要的值作为联合`semun`的`val`成员来传递。在信号量第一次使用之前需要设置信号量。
    - `IPC_RMID`：删除一个信号量集合。如果不删除信号量，它将继续在系统中存在，即使程序已经退出，它可能在你下次运行此程序时引发问题，而且信号量是一种有限的资源。

### 共享内存

- 指两个或多个进程共享一个给定的存储区

- **共享内存是最快的一种 IPC，因为进程是直接对内存进行存取**

- **因为多个进程可以同时操作，所以需要进行同步**

- **信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问**

- **共享内存实现原理**：共享内存是通过**把同一块内存分别映射到不同的进程空间**中实现进程间通信。而共享内存本身不带任何互斥与同步机制，但当多个进程同时对同一内存进行读写操作时会破坏该内存的内容，所以，在实际中，同步与互斥机制需要用户来完成

- 在**/proc/sys/kernel/**目录下，记录着共享内存的一些限制，如一个共享内存区的**最大字节数shmmax**，系统范围内最大共享内存区标识符数shmmni等，可以手工对其调整，但不推荐这样做

- 共享内存使用

  - 进程必须首先分配它
  - 随后需要访问这个共享内存块的每一个进程都必须将这个共享内存绑定到自己的地址空间中
  - 当完成通信之后，所有进程都将脱离共享内存，并且由一个进程释放该共享内存块

- 原型

  ```c
  #include <sys/shm.h>
  // 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1
  int shmget(key_t key, size_t size, int flag);
  // 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1
  void *shmat(int shm_id, const void *addr, int flag);
  // 断开与共享内存的连接：成功返回0，失败返回-1
  int shmdt(void *addr);
  // 控制共享内存的相关信息：成功返回0，失败返回-1
  int shmctl(int shm_id, int cmd, struct shmid_ds *buf);
  ```

- 当用`shmget`函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0

  - **当一段共享内存被创建以后，它并不能被任何进程访问。必须使用`shmat`函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问**
  - `shmdt`函数是用来断开`shmat`建立的连接的。注意，**这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已**
  - `shmctl`函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是`IPC_RMID`（从系统中删除该共享内存）

- **mmap实现共享内存**

  - mmap系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，**当然mmap()实现共享内存也是其主要应用之一**
  - **mmap系统调用使得进程之间通过映射同一个普通文件实现共享内存**。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。
  - mmap并不分配空间，只是**将文件映射到调用进程的地址空间里**，然后你就可以用memcpy等操作写文件，而不用write()了。写完后用msync()同步一下，你所写的内容就保存到文件里了。 **不过这种方式没办法增加文件的长度**，**因为要映射的长度在调用mmap()的时候就决定了**
  - 简单说就是把一个文件的内容在内存里面做一个映像，内存比磁盘快些

#### 2.4 fork，vfork，clone

守护进程怎么创建

### line-----

## c/c++中多进程编程

### 1. 基本概念

- **_多进程如何实现？_**

  - ```c++
    #include <stdio.h>
    #include <unistd.h>

    int main(int argc,char *argv[]){
        //fork函数使用
        int i = 0;
        printf("before fork\n");
        pid_t pid = fork();
        printf("after fork\n");
        if (pid < 0){
            printf("error\n");
            return 1;
        }
        else if (pid == 0){
            printf("fork success,this is son process\n");
            while (i<5){
                i += 1;
                printf("this is son process,i=%d\n",i);
                sleep(1);
            }
        }
        else{
            printf("fork success,this is father process,son process id is %d \n",pid);
            while (i<5){
                i += 2;
                printf("this is father process,i=%d\n",i);
                sleep(1);
            }
        }
        return 0;
    }
    ```

  - ```shell
    # 断点运行结果，因此才是子进程运行完，再人为控制跑完父进程。
    before fork
    after fork
    fork success,this is son process
    this is son process,i=1
    this is son process,i=2
    this is son process,i=3
    this is son process,i=4
    this is son process,i=5
    after fork
    fork success,this is father process,son process id is 9983
    this is father process,i=2
    this is father process,i=4
    this is father process,i=6
    ```

  - 只需要注意注意一次before fork，这说明子进程是从fork()之后开始的，所以子进程不会因为这样有孙进程。但是有两个fork()的话，还是会有孙进程的。理性告诉我要避免多个fork()的代码，因为子进程再fork()返回的也是0，所以父进程判断变得很难控制。

  - 所以说fork()函数是一次调用，两次返回，对于父进程返回的是子进程的pid，对于子进程返回的是0。

  - 而fork()之前的变量，进程是复制拷贝了一份的。

### 2. 补充

- **_除了fork()之外还有其他多进程编程api吗？_**

  ​ 除了fork()之外，还有wait()用于阻塞父进程直到子进程完成，还有exec()、spawn()等等，说实话exec()和spawn()也是很少见，资料很少，了解不多，待我有进一步了解再考虑更新。

- **_小测试_**

  ```c++
  int main(　){
       int i;
       for(i = 0; i < 5;i++){
          int pid = fork();
          if(pid == 0){
              //do something
          } else {
        //do something
          }
      }
      // do somthing,sleep
      return 0;
  }
  // 总共有多少个进程？ 答案是32个，读者自行思考
  ```

---

---

title: "多进程管理(转载)"
layout: post
author: "Marco"
header-style: text
hidden: true
tags:

- 计算机系统
- 多线程

---

> [转载自](https://github.com/CyC2018/CS-Notes)

<!-- GFM-TOC -->

- [进程管理](#进程管理)
  - [进程和线程](#进程和线程)
  - [协程](#协程)
  - [同步互斥](#同步互斥)
  - [死锁](#死锁)
  - [CAS技术](#cas技术)
  - [IPC](#ipc)
    - [管道](#管道)
    - [FIFO](#fifo)
    - [消息队列](#消息队列)
    - [信号(signal)](#信号signal)
    - [信号量](#信号量)
    - [共享内存](#共享内存)
      - [2.4 fork，vfork，clone](#24-forkvforkclone)
    - [line-----](#line-----)
  - [c/c++中多进程编程](#cc中多进程编程)
    - [1. 基本概念](#1-基本概念)
    - [2. 补充](#2-补充)
- [进程与线程](#进程与线程)
  - [1. 进程](#1-进程)
  - [2. 线程](#2-线程)
  - [3. 区别](#3-区别)
- [进程状态的切换](#进程状态的切换)
- [进程调度算法](#进程调度算法)
  - [1. 批处理系统](#1-批处理系统)
  - [2. 交互式系统](#2-交互式系统)
  - [3. 实时系统](#3-实时系统)
- [进程同步](#进程同步)
  - [1. 临界区](#1-临界区)
  - [2. 同步与互斥](#2-同步与互斥)
  - [3. 信号量](#3-信号量)
  - [4. 管程](#4-管程)
- [经典同步问题](#经典同步问题)
  - [1. 哲学家进餐问题](#1-哲学家进餐问题)
  - [2. 读者-写者问题](#2-读者-写者问题)
- [进程通信](#进程通信)
  - [1. 管道](#1-管道)
  - [2. FIFO](#2-fifo)
  - [3. 消息队列](#3-消息队列)
  - [4. 信号量](#4-信号量)
  - [5. 共享存储](#5-共享存储)
  - [6. 信号](#6-信号)
  - [7. 套接字](#7-套接字) - [3. 进程控制块PCB](#3-进程控制块pcb)
  <!-- GFM-TOC -->

# 进程状态的切换

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" width="500"/> </div><br>

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

应该注意以下内容：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

# 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

## 1. 批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

**1.1 先来先服务 first-come first-serverd（FCFS）**

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

**1.2 短作业优先 shortest job first（SJF）**

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

**1.3 最短剩余时间优先 shortest remaining time next（SRTN）**

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

## 2. 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

**2.1 时间片轮转**

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png"/> </div><br>

**2.2 优先级调度**

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

**2.3 多级反馈队列**

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png"/> </div><br>

## 3. 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

# 进程同步

## 1. 临界区

对临界资源进行访问的那段代码称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

```html
// entry section // critical section; // exit section
```

## 2. 同步与互斥

- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

## 3. 信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

- **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。

```c
typedef int semaphore;
semaphore mutex = 1;
void P1() {
    down(&mutex);
    // 临界区
    up(&mutex);
}

void P2() {
    down(&mutex);
    // 临界区
    up(&mutex);
}
```

<font size=3> **使用信号量实现生产者-消费者问题** </font> </br>

问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。

因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。

为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。

注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。

```c
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;

void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}

void consumer() {
    while(TRUE) {
        down(&full);
        down(&mutex);
        int item = remove_item();
        consume_item(item);
        up(&mutex);
        up(&empty);
    }
}
```

## 4. 管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。

```pascal
monitor ProducerConsumer
    integer i;
    condition c;

    procedure insert();
    begin
        // ...
    end;

    procedure remove();
    begin
        // ...
    end;
end monitor;
```

管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

<font size=3> **使用管程实现生产者-消费者问题** </font><br>

```pascal
// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;
```

# 经典同步问题

生产者和消费者问题前面已经讨论过了。

## 1. 哲学家进餐问题

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg"/> </div><br>

五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。

```c
#define N 5

void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
```

为了防止死锁的发生，可以设置两个条件：

- 必须同时拿起左右两根筷子；
- 只有在两个邻居都没有进餐的情况下才允许进餐。

```c
#define N 5
#define LEFT (i + N - 1) % N // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
typedef int semaphore;
int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥
semaphore s[N];              // 每个哲学家一个信号量

void philosopher(int i) {
    while(TRUE) {
        think(i);
        take_two(i);
        eat(i);
        put_two(i);
    }
}

void take_two(int i) {
    down(&mutex);
    state[i] = HUNGRY;
    check(i);
    up(&mutex);
    down(&s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去
}

void put_two(i) {
    down(&mutex);
    state[i] = THINKING;
    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了
    check(RIGHT);
    up(&mutex);
}

void eat(int i) {
    down(&mutex);
    state[i] = EATING;
    up(&mutex);
}

// 检查两个邻居是否都没有用餐，如果是的话，就 up(&s[i])，使得 down(&s[i]) 能够得到通知并继续执行
void check(i) {
    if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
        state[i] = EATING;
        up(&s[i]);
    }
}
```

## 2. 读者-写者问题

允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。

```c
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() {
    while(TRUE) {
        down(&count_mutex);
        count++;
        if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&count_mutex);
        read();
        down(&count_mutex);
        count--;
        if(count == 0) up(&data_mutex);
        up(&count_mutex);
    }
}

void writer() {
    while(TRUE) {
        down(&data_mutex);
        write();
        up(&data_mutex);
    }
}
```

以下内容由 [@Bandi Yugandhar](https://github.com/yugandharbandi) 提供。

The first case may result Writer to starve. This case favous Writers i.e no writer, once added to the queue, shall be kept waiting longer than absolutely necessary(only when there are readers that entered the queue before the writer).

```c
int readcount, writecount;                   //(initial value = 0)
semaphore rmutex, wmutex, readLock, resource; //(initial value = 1)

//READER
void reader() {
<ENTRY Section>
 down(&readLock);                 //  reader is trying to enter
 down(&rmutex);                  //   lock to increase readcount
  readcount++;
  if (readcount == 1)
   down(&resource);              //if you are the first reader then lock  the resource
 up(&rmutex);                  //release  for other readers
 up(&readLock);                 //Done with trying to access the resource

<CRITICAL Section>
//reading is performed

<EXIT Section>
 down(&rmutex);                  //reserve exit section - avoids race condition with readers
 readcount--;                       //indicate you're leaving
  if (readcount == 0)          //checks if you are last reader leaving
   up(&resource);              //if last, you must release the locked resource
 up(&rmutex);                  //release exit section for other readers
}

//WRITER
void writer() {
  <ENTRY Section>
  down(&wmutex);                  //reserve entry section for writers - avoids race conditions
  writecount++;                //report yourself as a writer entering
  if (writecount == 1)         //checks if you're first writer
   down(&readLock);               //if you're first, then you must lock the readers out. Prevent them from trying to enter CS
  up(&wmutex);                  //release entry section

<CRITICAL Section>
 down(&resource);                //reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource
  //writing is performed
 up(&resource);                //release file

<EXIT Section>
  down(&wmutex);                  //reserve exit section
  writecount--;                //indicate you're leaving
  if (writecount == 0)         //checks if you're the last writer
   up(&readLock);               //if you're last writer, you must unlock the readers. Allows them to try enter CS for reading
  up(&wmutex);                  //release exit section
}
```

We can observe that every reader is forced to acquire ReadLock. On the otherhand, writers doesn’t need to lock individually. Once the first writer locks the ReadLock, it will be released only when there is no writer left in the queue.

From the both cases we observed that either reader or writer has to starve. Below solutionadds the constraint that no thread shall be allowed to starve; that is, the operation of obtaining a lock on the shared data will always terminate in a bounded amount of time.

```source-c
int readCount;                  // init to 0; number of readers currently accessing resource

// all semaphores initialised to 1
Semaphore resourceAccess;       // controls access (read/write) to the resource
Semaphore readCountAccess;      // for syncing changes to shared variable readCount
Semaphore serviceQueue;         // FAIRNESS: preserves ordering of requests (signaling must be FIFO)

void writer()
{
    down(&serviceQueue);           // wait in line to be servicexs
    // <ENTER>
    down(&resourceAccess);         // request exclusive access to resource
    // </ENTER>
    up(&serviceQueue);           // let next in line be serviced

    // <WRITE>
    writeResource();            // writing is performed
    // </WRITE>

    // <EXIT>
    up(&resourceAccess);         // release resource access for next reader/writer
    // </EXIT>
}

void reader()
{
    down(&serviceQueue);           // wait in line to be serviced
    down(&readCountAccess);        // request exclusive access to readCount
    // <ENTER>
    if (readCount == 0)         // if there are no readers already reading:
        down(&resourceAccess);     // request resource access for readers (writers blocked)
    readCount++;                // update count of active readers
    // </ENTER>
    up(&serviceQueue);           // let next in line be serviced
    up(&readCountAccess);        // release access to readCount

    // <READ>
    readResource();             // reading is performed
    // </READ>

    down(&readCountAccess);        // request exclusive access to readCount
    // <EXIT>
    readCount--;                // update count of active readers
    if (readCount == 0)         // if there are no readers left:
        up(&resourceAccess);     // release resource access for all
    // </EXIT>
    up(&readCountAccess);        // release access to readCount
}

```

# 进程通信

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

## 1. 管道

管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

```c
#include <unistd.h>
int pipe(int fd[2]);
```

它具有以下限制：

- 只支持半双工通信（单向交替传输）；
- 只能在父子进程或者兄弟进程中使用。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png"/> </div><br>

## 2. FIFO

也称为命名管道，去除了管道只能在父子进程中使用的限制。

```c
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png"/> </div><br>

## 3. 消息队列

相比于 FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。
- 匿名管道是跟随进程的,消息队列是跟随内核的,也就是说进程结束之后,匿名管道就死了,但是消息队列还会存在(除非显示调用函数销毁).
- 管道是文件,存放在磁盘上,访问速度慢,消息队列是数据结构,存放在内存,访问速度快.
- 管道是数据流式存取,消息队列是数据块式存取.

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
int msgget(key_t key, int msgflg);

```

## 4. 信号量

它是一个计数器，用于为多个进程提供对共享数据对象的访问。
信号量多用于进程间的同步和互斥.

信号量的工作机制,它可以直接理解成计数器,信号量会有初值(>0),每当有进程申请使用信号量,通过一个P操作来对信号量进行-1操作,当计数器减到0的时候就说明没有资源了,其他进程要想访问就必须等待(比如忙等待或者睡眠),当该进程执行完这段工作(我们称之为临界区)之后,就会执行V操作来对信号量进行+1操作.

进程AB利用信号量通信,A创建信号量/初始化信号量;B用同样的key创建信号量;然后它们就可以利用信号量进行通信了.

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
int semget(key_t key, int nsems, int semflg); // 信号量的创建:
int semop(int semid, struct sembuf *sops, unsigned nsops); // 信号量操作:P/V操作通过一个函数实现
```

## 5. 共享存储

允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

需要使用信号量用来同步对共享存储的访问。

多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。

## 6. 信号

信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生.

信号可以在任何时候发送给某一进程,而无须知道该进程的状态.如果该进程未处于执行状态,则该信号就由内核保存起来,直到该进程恢复执行并传递给它为止.如果一个信号被进程设置为阻塞,则该信号的传递被延迟,直到其阻塞被取消时才被传递给进程.

Linux提供了几十种信号,分别代表着不同的意义.信号之间依靠他们的值来区分,但是通常在程序中使用信号的名字来表示一个信号.通常程序中直接包含<signal.h>就好.

信号是在软件层次上对中断机制的一种模拟,是一种异步通信方式,信号可以在用户空间进程和内核之间直接交互.内核也可以利用信号来通知用户空间的进程.

信号的来源:

硬件来源,例如按下了cltr+C,通常产生中断信号sigint.
软件来源,例如使用系统调用或者命令发出信号.最常用的发送信号的系统函数是kill,raise,setitimer,sigation,sigqueue函数.软件来源还包括一些非法运算等操作.
一旦有信号产生,用户进程对信号产生的相应有三种方式:

执行默认操作,linux对每种信号都规定了默认操作.
捕捉信号,定义信号处理函数,当信号发生时,执行相应的处理函数.
忽略信号,当不希望接收到的信号对进程的执行产生影响,而让进程继续执行时,可以忽略该信号,即不对信号进程作任何处理.
但是有两个信号SIGKILL和SEGSTOP是应用进程无法捕捉和忽略的,这是为了使系统管理员能在任何时候中断或结束某一特定的进程.

## 7. 套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。

### 3. 进程控制块PCB

​ PCB是操作系统中的一个数据结构描述,它是对系统的进程进行管理的重要依据,和进程管理相关的操作无一不用到PCB中的内容.一般情况下,PCB中包含以下内容:

(1)进程标识符(内部,外部)
(2)处理机的信息(通用寄存器,指令计数器,PSW,用户的栈指针).
(3)进程调度信息(进程状态,进程的优先级,进程调度所需的其它信息,事件)
(4)进程控制信息(程序的数据的地址,资源清单,进程同步和通信机制,链接指针)

​ 不同操作系统PCB的具体实现可能会略有不同.

#### (4) 进程之间的通信方法有哪几种 (重点)

进程之间的通信方式主要有六种,包括**管道,信号量,消息队列,信号,共享内存,套接字**.

- 管道:管道是半双工的,双方需要通信的时候,需要建立两个管道.管道的实质是一个内核缓冲区,进程以先进先出的方式从缓冲区存取数据:管道一端的进程顺序地将进程数据写入缓冲区,另一端的进程则顺序地读取数据,该缓冲区可以看做一个循环队列,读和写的位置都是自动增加的,一个数据只能被读一次,读出以后再缓冲区都不复存在了.当缓冲区读空或者写满时,有一定的规则控制相应的读进程或写进程是否进入等待队列,当空的缓冲区有新数据写入或慢的缓冲区有数据读出时,就唤醒等待队列中的进程继续读写.管道是最容易实现的
  ![fig/管道通信.png](fig/管道通信.png)

  匿名管道pipe和命名管道除了建立,打开,删除的方式不同外,其余都是一样的.匿名管道只允许有亲缘关系的进程之间通信,也就是父子进程之间的通信,命名管道允许具有非亲缘关系的进程间通信.

  管道的底层实现 https://segmentfault.com/a/1190000009528245

- 信号量:信号量是一个计数器,可以用来控制多个进程对共享资源的访问.信号量只有等待和发送两种操作.等待(P(sv))就是将其值减一或者挂起进程,发送(V(sv))就是将其值加一或者将进程恢复运行.

- 信号:信号是Linux系统中用于进程之间通信或操作的一种机制,信号可以在任何时候发送给某一进程,而无须知道该进程的状态.如果该进程并未处于执行状态,则该信号就由内核保存起来,知道该进程恢复执行并传递给他为止.如果一个信号被进程设置为阻塞,则该信号的传递被延迟,直到其阻塞被取消时才被传递给进程. 信号是开销最小的

- 共享内存:共享内存允许两个或多个进程共享一个给定的存储区,这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中,就像由malloc()分配的内存一样使用.一个进程写入共享内存的信息,可以被其他使用这个共享内存的进程,通过一个简单的内存读取读出,从而实现了进程间的通信.共享内存的效率最高,缺点是没有提供同步机制,需要使用锁等其他机制进行同步.

- 消息队列:消息队列就是一个消息的链表,是一系列保存在内核中消息的列表.用户进程可以向消息队列添加消息,也可以向消息队列读取消息.
  消息队列与管道通信相比,其优势是对每个消息指定特定的消息类型,接收的时候不需要按照队列次序,而是可以根据自定义条件接收特定类型的消息.
  可以把消息看做一个记录,具有特定的格式以及特定的优先级.对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息,对消息队列有读权限的进程可以从消息队列中读取消息.

- 套接字:套接口也是一种进程间通信机制,与其他通信机制不同的是,它可用于不同设备及其间的进程通信.

#### (5) 进程调度方法详细介绍

https://blog.csdn.net/u011080472/article/details/51217754

https://blog.csdn.net/leex_brave/article/details/51638300

- 先来先服务 (FCFS first come first serve):按照作业到达任务队列的顺序调度 FCFS是非抢占式的,易于实现,效率不高,性能不好,有利于长作业(CPU繁忙性)而不利于短作业(I/O繁忙性).
- 短作业优先 (SHF short job first):每次从队列里选择预计时间最短的作业运行.SJF是非抢占式的,优先照顾短作业,具有很好的性能,降低平均等待时间,提高吞吐量.但是不利于长作业,长作业可能一直处于等待状态,出现饥饿现象;完全未考虑作业的优先紧迫程度,不能用于实时系统.
- 最短剩余时间优先 该算法首先按照作业的服务时间挑选最短的作业运行,在该作业运行期间,一旦有新作业到达系统,并且该新作业的服务时间比当前运行作业的剩余服务时间短,则发生抢占;否则,当前作业继续运行.该算法确保一旦新的短作业或短进程进入系统,能够很快得到处理.
- 高响应比优先调度算法(Highest Reponse Ratio First, HRRF)是非抢占式的,主要用于作业调度.基本思想:每次进行作业调度时,先计算后备作业队列中每个作业的响应比,挑选最高的作业投入系统运行.响应比 = (等待时间 + 服务时间) / 服务时间 = 等待时间 / 服务时间 + 1.因为每次都需要计算响应比,所以比较耗费系统资源.
- 时间片轮转 用于分时系统的进程调度.基本思想:系统将CPU处理时间划分为若干个时间片(q),进程按照到达先后顺序排列.每次调度选择队首的进程,执行完1个时间片q后,计时器发出时钟中断请求,该进程移至队尾.以后每次调度都是如此.该算法能在给定的时间内响应所有用户的而请求,达到分时系统的目的.
- 多级反馈队列(Multilevel Feedback Queue)

#### (16) 说一下PCB/说一下进程地址空间/

https://blog.csdn.net/qq_38499859/article/details/80057427

PCB就是进程控制块,是操作系统中的一种数据结构,用于表示进程状态,操作系统通过PCB对进程进行管理.

PCB中包含有:进程标识符,处理器状态,进程调度信息,进程控制信息

#### 9. Daemon 进程和僵尸进程

- **Daemon 进程**：后台运行的服务进程，无控制终端。

  - **产生方法**：通过 `fork` 创建子进程，父进程退出，子进程成为 Daemon 进程。

- **僵尸进程**：子进程退出后，父进程未调用 `wait` 系统调用回收子进程资源。
  - **消除方法**：父进程调用 `wait` 系统调用回收子进程资源。

什么是守护进程？ 如何查看守护进程？
什么是僵尸进程？ 如何查看僵尸进程？
创建进程的步骤？
进程切换发生的原因？
处理进程切换的步骤？
