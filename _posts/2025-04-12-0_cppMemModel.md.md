---
layout: post
title: C++对象的内存模型设计
categories: language
related_posts: True
tags: cpp grammar class
toc:
  sidebar: left
---

## C++对象的内存模型设计

### 0. prerequisites

- **什么是对象？为什么要有对象？**

在长久的 c/c++开发来说，逐渐发展出来三种开发范式

- 面向过程编程：
  - 像 C 一样，普通的程序
- 抽象数据类型模型（ADT）：
  - 提供封装和抽象的能力。
- 面向对象模型：
  - 在 ADT 的基础上，增加继承和多态。
  - C++通过 class 的 pointers 和 references 来支持多态，这种程序设计风格被称为“面向对象”。

这三种范式反映的其实是对数据结构的不同要求，面向过程这种范式不强调数据结构的概念，最多就是`struct`封装一些成员变量。
而当业务逐渐复杂起来，这些成员变量会有大量相关的函数，那将这些成员函数和成员变量绑定到一块，其实也就是 ADT编程了；
而进一步的，但这些数据结构需要有继承关系的时候，然后需要有多态的时候，也就是面向对象编程oop了。

### 1. 对象内存模型的设计

而对象内存模型的设计，其实说白了就是 c++如何以零抽象成本实现，封装，继承，多态。
而 C++内存对象模型的设计，实际上是 C++编译器这一层的工作。c++编译器其实就是将 C++翻译成汇编语言的，而汇编语言操作的是硬件对象，无非就是是内存和寄存器上的读写操作，以及 cpu 的计算操作。
再具体一点，结合 C++对象的需求展开，C++零抽象成本实现对象需要考虑的就是，如何从编译器层面（或者说汇编层面，又或者说怎么操作寄存器和 ALU 等等）实现以下这些：

- 成员变量和成员函数的存储
- 成员函数的使用
- 静态成员变量和静态成员函数的存储以及使用
- 继承对象的存储和实现
- 多态的实现

#### 1.1 成员变量和成员函数的存储？

- 成员变量的存储

```c++
class Foo{
    int a;
    int b;
}
Foo foo;
foo.a;
```

对于编译器来说`foo`是一个栈上的值，基于这个值所在的地址，进行与`a`相关特定的偏移值，按照`int`类型去读值，就可以得到`a`了。

- 访问限制符号
  public/ private/ protected
  正如我前面说的，汇编层不会有这些概念。
  这些操作实际上都是编译器去限制函的调用。
  编译器识别到如果在外部调用 private 函数的时候，就中断了编译。
  因此，如果查编译器内存布局规则，计算偏移值，通过偏移的方式是可以取`private`的成员变量的。

#### 1.2 成员函数如何存储和使用？

- 成员函数的存储

```c++
class Foo {
    void func1();
    void func2();
}
Foo foo;
foo.func1();
```

一般的成员函数实际起到的就是封装，和非成员函数相比，编译器的做法都是差不多的。
唯一不同的是，调用成员函数实际上，会隐式带着一个`this`指针。
即调用`foo.func1()`等价于调用非成员函数的`xcvvd_foo_func1(this)`。
前面的`xcvvd`是 c++为了支持函数重载做的符号调整，一般还会带上类名信息，以及传入一个 this 指针，当内部使用成员变量的时候，编译器能够解读，并自动补上 this，所以是根据 this 然后偏移地址去读写值。

#### 1.3 静态成员变量和静态成员函数的存储和使用

- 静态成员变量
  同理，其实和普通的静态变量是一样的，只是需要藏在对象里面，实现了封装的目的而已。
  静态成员变量和静态变量都是存在静态区，和类无关。

- 静态成员函数
  如果和静态函数对比的话，其实有点不妥。
  因为静态函数的`static`表示的是静态函数的作用域被限制在定义它的源文件内，其他源文件无法访问该函数。

而静态成员函数表明的是，函数在这个类的内部，但是不会传 this 指针的。
注意的是，因为静态成员函数在内部，所以其实这个函数是可以访问私有成员的。

#### 1.4 继承的实现

对于基类的成员变量来说，基类的数据成员直接放在派生类对象中。
对于基类的非虚成员函数来说，也没有特别操作。

而为了解决菱形继承问题，即基类不管被派生多少次，永远只会存在一个实例（subobjet），则需要添加一个指针，指向一个 base table。
即将公共数据放在一个表格上

```c++
class A { int a; };
class B : virtual A { int b; };
class C : virtual A { int c; };
class D : public B, public C { int d; };
```

B 有一个`vbptr`指向 A 的数据，C 也有一个`vbptr`指向 A 的数据。
`D.a`使用哪一个`vbptr`则取决于编译器了。

#### 1.5 多态的实现

类的多态主要说的是虚函数。

```c++
class A { virtual int foo(); };
class B : public A { int foo() override; };
A* b = new B();
b->foo();
```

编译器能够知道这个`foo`是一个虚函数，也能够知道是第几个。
因此`b->foo()`其实类似于`b->virtualFunTable[0]()`。
`virtualFunTable[0]`是 b 的虚函数表，偏移是编译器能够算出来的。
编译器是要知道`foo()`这个符号，和函数地址的映射关系的，知道偏移地址也是理所应当的。
取出这个函数，再调用一下。
而`new B()`的时候，是按照`B`去构造的，得到的`b`的`virtualFunTable`这个虚函数表就是 B 的。

> A 也有这个表，如果是`new A()`，就是 A 的虚函数表。

#### 1.6 类对象所占的空间

1. 成员函数无论是静态还是非静态，都不占用对象空间。
2. 静态成员变量跟着类走，不占用对象的空间。
3. 虚函数表是基于类的，类对象持有一个指针指向这个表就可以了，这个表的 size 不属于类对象的。因此虚函数，无论有几个，都只占用一个函数指针大小的对象空间。

4. 非静态成员变量跟着对象走，占用类对象的空间。
5. 如果类中有多个数据成员，编译器为了提高访问速度和性能，会字节对齐。
6. 非静态的数据成员
7. 虚继承的话，就再多一个指针

一个类只要有虚函数，类对象就会有虚函数表指针(vptr)，虚函数表指针指向虚函数表(vtbl)。

![alt text](./imgs/3_class_image.png)

### 99. quiz

#### 1. class 和 struct 的区别

struct 的默认访问修饰符是 public；而 class 的默认访问修饰符是 private。
除此之外使用时没有区别。

但是他们背后直接承载的设计意义有一定区别。
class 它还会引入它所支持的封装和继承的哲学，是 oop 概念的
而 struct 作为 c 语言的关键字，更多时候是作为纯粹数据类型集合而存在的，C 语言的 struct 没有继承，也没有成员函数。

#### 2. 空类对象所占的空间是多少，为什么？

1byte。这是为了确保每个空类对象都有一个唯一的地址，从而使得不同的空类对象在内存中是可区分的。
