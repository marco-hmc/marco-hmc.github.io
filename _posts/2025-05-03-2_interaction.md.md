---
layout: post
title: 系统和程序的交互
categories: 计算机系统
related_posts: True
tags: kernel
toc:
  sidebar: left
---

## 系统和程序的交互

### 1. 程序的交互方式

#### 1.0 交互方式有哪些？

在客户端程序中，交互指的是用户与软件界面之间的交互方式，这些交互方式不依赖于传统的命令行输入或菜单选择。交互通常依赖于图形用户界面（GUI）元素，允许用户通过直观的操作来与软件进行交互。以下是一些常见的交互方式：鼠标、键盘、触屏、语音、手势等等。

一般 PC 客户端主要的还是以鼠标和键盘为主。

- **鼠标事件**：包括点击、双击、右键点击、拖拽、悬停等操作。
- **键盘事件**：除了基本的按键输入外，还包括快捷键、组合键等。

#### 1.1 客户端程序是怎么理解键盘输入的？

当鼠标和键盘产生输入的时候，操作系统首先会通过硬件驱动解析这些输入，得到鼠标位置或键盘按键等信息。然后将这些信息转换为标准化的事件消息，并放入操作系统的全局事件队列中。操作系统根据当前活动窗口和焦点窗口，将这些事件消息分发到相应的客户端程序。一般客户端程序也有自己的事件队列，用于维护从操作系统和其他进程传入的事件。客户端程序通过事件循环不断从事件队列中获取事件，并调用相应的事件处理函数进行处理。

当用户在键盘上按下一个键，并在客户端程序中显示相应的字符，这个过程涉及多个步骤，包括硬件层、操作系统层和应用程序层。以下是详细的步骤：

1. **硬件层**：

   - 用户按下键盘上的一个键，硬件设备会生成一个中断信号
   - 操作系统的中断处理程序捕获这个信号，并生成相应的事件。
   - 键盘控制器检测到按键事件，并将按键的扫描码发送到计算机。
   - 更进一步地，其实键盘控制器能够捕捉某一个按键的按下或者释放状态。

2. **操作系统层**：

   - 操作系统接收到键盘控制器发送的扫描码。
   - 操作系统将扫描码转换为虚拟键码（Virtual Key Code）。
   - 因为不同地区的键盘可能不一样的，因此扫描码和虚拟键码需要有一个映射关系。映射关系由输入法，键盘布局（地区）等决定。
   - 操作系统生成一个键盘事件（如 `WM_KEYDOWN` 和 `WM_CHAR`），并将其放入全局的事件队列中。
   - 操作系统维护一个全局事件队列，用于存储所有输入事件和系统事件。
   - 操作系统根据当前活动窗口和焦点窗口，将事件消息分发到相应的客户端程序。

3. **应用程序层**：
   - 应用程序通过事件处理机制获取键盘事件。
   - 应用程序处理键盘事件，将虚拟键码转换为字符。
   - 应用程序在适当的位置显示字符。

#### 1.2 事件队列的存在形式

事件队列是操作系统用于管理和分发事件的机制。以下是事件队列的存在形式和工作原理：

1. **操作系统的事件队列**：

   - 运行在内核态
   - 操作系统维护一个全局的事件队列，用于接收来自硬件设备（如键盘、鼠标等）的事件。
   - 操作系统根据事件的目标窗口，将事件分发到相应应用程序的消息队列中。

2. **应用程序的事件队列**：
   - 运行在用户态
   - 每个应用程序都有自己的事件队列，用于接收和处理来自操作系统的事件。
   - 应用程序通过事件循环（Event Loop）不断从消息队列中获取事件，并进行处理。
   - 事件循环不是单独一个线程，一般是和主线程共享。
   - 但程序在阻塞的时候，这个事件队列还可以接受新的事件。这是因为事件的接收和处理是分离的。
   - 程序进入未响应的时候就是因为主线程阻塞，事件队列无法再接受新的事件。
   - 测试程序如下：在qt中，每输入一个字符就显示这个字符，并停顿5s。一次性输入123456789字符，输入到7的时候就发生未响应。不识别之后的输入字符。而前面输入的1234567都会每隔5s显示出来。

#### 1.3 图形库的适配和接口提供

图形库（如 Qt、GTK、WinAPI 等）提供了对操作系统事件队列的适配，并提供了方便的接口供开发者使用。以下是图形库如何适配事件队列并提供接口的过程：

1. **事件适配**：

   - 图形库通过操作系统提供的 API 接口，访问操作系统的事件队列。
   - 图形库将操作系统的原始事件转换为库内部的事件对象。

2. **事件循环**：

   - 图形库实现了自己的事件循环，用于从操作系统获取事件，并将其分发到应用程序的各个窗口和控件。
   - 开发者可以通过重写事件处理函数（如 Qt 中的 `keyPressEvent`）来处理特定的事件。

3. **接口提供**：
   - 图形库提供了丰富的事件处理接口，供开发者使用。例如，Qt 提供了 `QKeyEvent` 类和 `keyPressEvent` 函数，用于处理键盘事件。
   - 开发者可以通过这些接口，方便地获取和处理事件，而不需要直接与操作系统的事件队列交互。

#### 1.4 操作系统怎么知道将鼠标和键盘响应给到对应的事件？

- **活动窗口**：操作系统维护一个活动窗口（Active Window）的概念，表示用户当前正在与之交互的窗口。通常，只有活动窗口会接收键盘输入。
- **焦点窗口**：焦点窗口（Focus Window）是当前接收键盘输入的窗口。通常，活动窗口也是焦点窗口，但在某些情况下（如嵌套窗口或对话框），焦点窗口可能是活动窗口的子窗口。

1. **鼠标事件**：

   - 当用户移动鼠标或点击鼠标按钮时，鼠标事件会被生成。
   - 操作系统根据鼠标指针的位置确定目标窗口，并将鼠标事件分发给该窗口。
   - 如果鼠标指针位于某个窗口的区域内，该窗口将接收到鼠标事件。

2. **键盘事件**：
   - 当用户按下键盘上的一个键时，键盘事件会被生成。
   - 操作系统将键盘事件分发给当前的焦点窗口。
   - 焦点窗口通常是用户最后点击或激活的窗口。

#### 1.5 全局热键的实现原理是什么？

全局热键（Global Hotkey）是一种特殊的键盘快捷键，可以在任何应用程序中触发特定的操作。全局热键的实现通常涉及操作系统级别的钩子（Hook）机制。

钩子是一种允许应用程序监视系统消息的机制。通过设置钩子，应用程序可以拦截和处理特定类型的系统消息。

1. **设置全局钩子**：

   - 应用程序可以使用操作系统提供的 API 设置全局钩子，以监视键盘事件。
   - 在 Windows 中，可以使用 `SetWindowsHookEx` 函数设置键盘钩子。

2. **处理钩子事件**：
   - 当键盘事件发生时，钩子函数会被调用。
   - 钩子函数可以检查按键组合是否匹配预定义的全局热键。
   - 如果匹配，钩子函数可以执行相应的操作，并选择是否继续将事件传递给其他应用程序。

#### 1.6 操作系统和qt是怎么处理和理解组合键的？

组合键（Modifier Keys）是指用户同时按下多个键以触发特定功能或操作的键盘输入方式。常见的组合键包括 Ctrl、Shift、Alt 等修饰键与其他键的组合。操作系统通过一系列步骤来处理和理解组合键，并将其传递给应用程序进行相应的处理。

> 修饰键有哪些：ctrl, shift, alt, Fn, Meta(windows-win, mac-command)

> 键盘事件有哪些：
>
> - 一般事件：键盘按下/释放/重复

键盘事件可以简单理解为按下、释放和重复三个基本事件，但对于修饰键有特殊处理。如果检测到修饰键按下，事件的修饰位状态位就会被修改为对应按键，修饰位状态位可以是多个按键的组合。
一般来说，应用程序收到键盘事件，然后检查修饰键状态就知道是不是组合键了。

#### 1.6 操作系统是怎么处理选择集的？怎么处理选中对象的？怎么处理多选的？

> 鼠标事件有哪些：左键右键滚轮的点击和释放、鼠标移动、鼠标进入/离开窗口、滚轮移动、双击、拖拽开始/进行/结束。

从底层来说，即从硬件、硬件驱动和鼠标事件的角度来看，不存在选择集的概念。选择集是一个抽象概念，需要客户端软件去实现和管理。

操作系统本身并不直接处理选择集的概念。选择集的管理和处理通常由应用程序来实现。操作系统通过鼠标事件（如点击、拖拽等）将用户的输入传递给应用程序，应用程序根据这些事件来管理选择集。

Qt 也没有抽象出选择集的概念。如果需要处理多选的情况，通常由开发者在 Qt 应用程序中维护一个被选中对象的容器。选择集的抽象层次是一个集合，选择集的子集是选择路径。选择路径需要与选择对象关联起来，除此之外，选择对象一般还需要提供一个高亮能力以表示被选中。

#### 2. 接收事件和处理事件是怎么分离的？

操作系统会为每一个应用程序分配一个事件缓冲区，当应用程序非阻塞的时候，就会从这个缓冲区读取事件；如果阻塞，就会在缓冲区写入事件，如果缓冲区满了，就会提示未响应。这个缓冲区由操作系统管理和写入，应用程序仅仅可以消费。

事件接收和处理分离是操作系统与框架（如 Qt）共同实现的机制。
操作系统为每个应用程序分配了事件缓冲区，操作系统负责管理和写入，应用程序负责消费。
主线程阻塞时，操作系统仍能写入缓冲区，应用程序的队列可以接收事件，但无法处理。
缓冲区满或事件处理长时间延迟时，可能触发“未响应”。

1. 操作系统确实为每个应用程序维护一个事件缓冲区，但这通常是底层窗口系统（如 WinAPI 或 X11）的职责，而不是由 Qt 或应用程序直接管理。
2. 操作系统的缓冲区负责事件的接收和存储，应用程序通过事件循环主动读取这些事件。应用程序自身（如 Qt）也有独立的事件队列，进一步管理事件的消费。
3. 当主线程阻塞时：
   - 操作系统的缓冲区仍可以写入事件。
   - Qt 的事件队列也可以接受操作系统分发的事件，但这些事件不会被处理，直到主线程恢复。
4. 如果缓冲区满，操作系统可能会丢弃事件或标记应用程序为“未响应”。

#### 未整理

2. **事件队列**：

然后wukong是对QApplication封装一下叫Application对吧.
所以我理解像一些handleMouseEvent, handleKeyboardEvent, handleCommand的事件都应该是放在Application::eventFilter的.

但似乎wukong并不是将事件处理能力放在这里。

wukong是走的UI-协程和文档协程的方式. 文档协程内部有一个死循环的commandLessLoop，只有在需要获取input如鼠标和键盘输入的时候才返回到UI-协程处理。

为了实现上面这个设计，处理事件的能力wukong是直接自己做的，而不是直接依赖于QApplication的能力。
具体实现是在文档的addDocView过程中，然后在addDocView的时候都会给view上信号槽能力，去监听onUIMouseEvent和其他事件等等。然后把这个事件处理过后添加到InputEventProcessor。
与此同时文档协程在死循环的时候，如果需要getInput，就会走到InputEventProcessor去消费。
