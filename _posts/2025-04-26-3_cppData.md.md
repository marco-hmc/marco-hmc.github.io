---
layout: post
title: c++ 数据内存布局 && 内存分配
categories: language
related_posts: True
tags: cpp grammar class
toc:
  sidebar: left
---

## c++ 数据内存布局 && 内存分配

### 1. 程序的内存布局

1. 代码段（Text Segment/Code Segment）:
   存放程序的机器代码，即编译后的可执行指令。这部分内存是只读的，以防止程序在运行时修改自己的代码。

   1. 常量存储区：常量数据（如字符串字面量、编译时常量表达式的结果）被存储在代码段中，这部分内存是只读的，用于存放程序执行过程中不会改变的数据。因此，当我们讨论常量存储区时，它实质上指的是存放程序中固定不变数据的区域，这部分内容在程序加载到内存时被放置在代码段里，与程序的机器代码存放在一起。

2. 数据段（Data Segment）:
   分为初始化数据段和未初始化数据段（BSS段）。

   1. 初始化数据段：存储程序中已初始化的全局变量和静态变量的值。
   2. BSS段（Block Started by Symbol）：存储未初始化的全局变量和静态变量，通常会被自动初始化为0或空指针。
   3. 全局区/静态区:
      这个术语有时与数据段的概念混用，但主要是强调存储全局变量和静态变量的地方。

3. 堆区（Heap）:
   动态内存分配区域，程序在运行时通过如malloc、calloc、new等函数申请的空间就位于此处。程序员需要手动管理这块区域的内存分配和释放，否则可能导致内存泄漏。

4. 栈区（Stack）:
   用于存储函数调用时的局部变量、函数参数、返回地址等。每当函数调用发生时，一个新的栈帧会被压入栈中，函数返回时相应的栈帧会被弹出。栈的分配和释放由编译器自动管理。

5. 动态库加载区域:
   如果程序使用动态链接库（DLL或.so文件），这些库的代码和数据会被加载到此区域。操作系统负责管理这些共享库的加载和卸载。

6. 程序计数器（PC Register）:
   不是内存区域，但与程序执行密切相关，用于存储下一条待执行指令的地址。

7. 寄存器:
   CPU内部的高速存储单元，用于快速存储和访问数据。编译器会尽可能利用寄存器来提高程序性能。

8. 内存映射区域:
   包括文件映射、共享内存等，操作系统可以将磁盘上的文件或其他资源映射到内存中，使得程序可以直接访问这些资源如同访问内存一样。

9. 栈顶指针（Stack Pointer, SP）和基指针（Base Pointer, BP/EBP）:
   这些不是内存区域，但对理解栈的工作原理很重要。SP指向栈顶，BP通常指向当前函数的栈帧底部，用于维护函数调用栈的结构。

### 2. 全局变量

#### 2.1 全局对象的存储位置/地址分配

- **数据段**：全局变量和全局对象存储在数据段中。数据段是程序的一个部分，用于存储静态分配的变量，包括全局变量和静态变量。
- **内存清零**：在不给全局对象初值的情况下，编译器默认会将全局对象所在的内存全部清零。这意味着全局对象的所有成员变量在初始化时都会被设置为零值。
- **编译阶段分配**：全局变量在编译阶段就会分配空间，并且它们的地址在编译期间就确定好了。这意味着全局对象的地址在程序运行期间是固定的，内存也是在编译时分配好的，并且在程序运行期间一直存在。
- **构造**：全局对象的构造在 `main()` 函数之前进行。全局对象存储在数据段中，默认值为零。编译器会在程序开始执行之前调用全局对象的构造函数，确保它们被正确初始化。
- **析构**：全局对象的析构在 `main()` 函数执行完毕之后进行。编译器会在程序结束时调用全局对象的析构函数，确保它们被正确清理，释放资源。

#### 2.2 全局对象的构造和析构步骤

1. **地址分配**：
   - 全局对象 `g_aobj` 的地址在编译时确定，并且内存也是在编译时分配好的。这意味着在程序运行期间，`g_aobj` 的地址是固定的，内存也是预先分配好的。
2. **静态初始化**：
   - 在程序开始执行之前，编译器会将全局对象 `g_aobj` 的内存内容清零。这一步称为静态初始化，确保全局对象的所有成员变量在初始化时都被设置为零值。
3. **调用构造函数**：
   - 在程序的 `main()` 函数执行之前，编译器会调用全局对象 `g_aobj` 所对应的类 `A` 的构造函数。这一步确保全局对象在 `main()` 函数执行之前被正确初始化。
4. **执行 `main()` 函数**：
   - 程序的 `main()` 函数开始执行。在 `main()` 函数中，可以使用全局对象 `g_aobj`，因为它已经被初始化。
5. **调用析构函数**：
   - 在 `main()` 函数执行完毕之后，编译器会调用全局对象 `g_aobj` 所对应类 `A` 的析构函数。这一步确保全局对象在程序结束时被正确清理，释放资源。

#### 2.3 局部静态对象的构造和析构

- **构造**：局部静态对象的构造函数只会在第一次调用包含它的函数时被调用一次。之后再次调用该函数时，不会再次构造该对象。
- **地址**：局部静态对象的内存地址在编译期间就确定好了，每次调用函数时，该对象的地址是相同的。
- **初始化**：局部静态对象在程序开始时会被初始化为零值（如果没有显式初始化）。在第一次调用包含它的函数时，才会调用其构造函数进行初始化。
- **析构**：局部静态对象的析构函数会在 `main()` 函数执行结束后被调用，确保在程序结束时正确释放资源。

### 3. 类数据成员布局

C++中的数据成员布局决定了类实例在内存中的存储方式，涉及到数据成员的排列顺序、对齐、以及如何与其他类特性（如虚函数表）集成。

1. 声明顺序与排列：非静态数据成员在对象中的排列顺序与其在类定义中声明的顺序一致。这意味着编译器会按照声明的顺序来分配内存。在同一个访问控制段（如private、protected、public）中，较晚声明的数据成员会分配在较高的内存地址上。

   1. 比较晚出现的成员变量在内存中有更高的地址；
      1. 从低地址向高地址分配/存储
      2. 大端存储和小端存储
         1. 大端：数据的低位保存在内存中的高地址中，数据的高位保存在内存中的低地址中；
         2. 小端：数据的低位保存在内存中的低地址中，数据的高位保存在内存中的高地址中；

2. 内存对齐：为了优化访问速度，数据成员会被对齐到它们自然对齐边界上。例如，一个四字节的整型通常会被对齐到四字节边界。这种对齐可能会导致额外的填充字节插入到数据成员之间，以满足对齐要求。

```cpp
#pragma pack(1) //对齐方式设置为1字节对齐（不对齐）

#pragma pack() //取消指定对齐，恢复缺省对齐；
```

3. 静态数据成员：静态数据成员不在对象实例中存储，而是在程序的全局数据区域或静态区分配。这意味着所有类实例共享相同的静态数据成员实例。
4. 虚函数表：如果类中包含虚函数，编译器会为该类生成一个虚函数表（vtable），它是一个函数指针数组，存储了类中所有虚函数的地址。每个含有虚函数的类实例会包含一个指向这个vtable的指针（称为vptr），通常位于对象的开始位置，但这也依赖于编译器实现。
5. 多重继承：在多重继承的情况下，派生类可能有多个虚函数表指针，分别指向其基类的虚函数表，以支持正确的动态调度。此外，为了确保正确的基类子对象布局，可能还需要额外的偏移量调整。
6. 空对象：即使一个类没有数据成员，编译器也可能为其分配一个字节的空间，以确保每个对象实例都有唯一的地址，这有助于识别空对象。
7. 访问控制：不同的访问控制段（public、protected、private）不会影响数据成员在内存中的物理布局，但会影响成员的访问权限。
8. 位域成员：如果类定义中包含位域，这些成员的布局将根据位域的定义紧密打包，这可能导致非直观的内存布局。

#### 3.1 多重继承数据布局

1. 基类子对象：每个基类的子对象都会被嵌入到派生类对象中，保持各自基类的布局。这些基类子对象的排列顺序可能依据编译器的具体实现，但一些编译器倾向于按照继承列表中基类出现的顺序来安排。每个基类子对象内包含其自身的非静态数据成员，以及如果有的话，一个指向该基类虚函数表的指针（vptr）。
2. 内存对齐：每个基类子对象的起始位置需要满足其内部数据成员的对齐要求。此外，派生类的开始部分以及各个基类子对象间的布局也会考虑对齐，以确保最佳访问性能。
3. 虚函数表指针（vptr）：在多重继承情况下，可能存在多个虚函数表指针。如果基类中存在虚函数，派生类对象通常需要包含一个或多个指向虚函数表的指针。对于有相同虚函数的基类，编译器可能采用虚基类机制或优化策略（如共享虚函数表指针）来避免重复。
4. 虚基类：如果基类本身也是多重继承的产物，且被继承为虚基类，派生类对象中只会包含一个虚基类的实例，而不是每个直接或间接继承路径上的一个。虚基类表指针（vbptr）可能被用来定位这个共享的虚基类实例，确保正确地访问虚基类的数据成员。
5. 派生类特有的数据成员：在所有基类子对象之后，是派生类自己定义的非静态数据成员，按照声明顺序排列并满足对齐要求。
6. 内存填充：为了确保对齐，编译器可能会在基类子对象之间、基类子对象与派生类数据成员之间插入填充字节。
7. 菱形继承问题：菱形继承是最典型的多重继承问题，即一个类直接继承自两个或更多个类，而这些类又共同继承自同一个基类。C++通过引入虚基类来解决这一问题，确保基类的子对象只被继承一次，避免了数据的重复。

### 3. 内存分配

#### 3.1 `new` 类对象时加括号与不加括号的差异

在 C++ 里，使用 `new` 来创建类对象或者基本数据类型的对象时，加括号和不加括号的表现有所不同。以下是相关示例代码：

```cpp
A *pa = new A(); // 函数调用
delete pa;

A *pa2 = new A;

int *p3 = new int;  // 初始值随机
int *p4 = new int(); // 初始值为 0
int *p5 = new int(100); // 初始值为 100
```

- **对于基本数据类型**：
  - 当使用 `new` 创建基本数据类型的对象时，若不加括号，对象的初始值是随机的。就像 `int *p3 = new int;`，`p3` 所指向的 `int` 类型对象的初始值是随机的。
  - 若加括号，对象会被初始化为默认值。比如 `int *p4 = new int();`，`p4` 所指向的 `int` 类型对象的初始值为 0。
  - 也可以通过括号传入具体的值来进行初始化，如 `int *p5 = new int(100);`，`p5` 所指向的 `int` 类型对象的初始值为 100。

```c++
void func(){
	auto foo = new char[10];    // 不为0
	auto foo = new char[10]();  // 为0
}
```

- **对于类类型**：
  - **空类的情况**：如果类为空（即没有任何成员变量和用户自定义的构造函数），那么 `new A()` 和 `new A` 这两种写法没有区别。不过在实际编程中，很少会只定义一个空类。
  - **类有成员变量但无自定义构造函数的情况**：当类 `A` 包含成员变量时，使用 `new A()` 进行初始化会把与成员变量相关的部分内存清零，但并非将整个对象的内存都清零。而 `new A` 不会进行这种默认初始化操作。
  - **类有构造函数的情况**：要是类 `A` 有构造函数，不管是 `new A()` 还是 `new A`，都会调用类的构造函数来完成对象的初始化，所以最终结果是一样的。

#### 3.2 `new` 和 `delete` 的本质

在 C++ 中，`new` 和 `delete` 属于关键字（也可称为操作符）。它们在对象的创建和销毁过程中发挥着关键作用：

- **`new` 的操作**：`new` 实际上做了两件事。首先，它会调用 `operator new` 函数（该函数底层通常使用 `malloc` 来分配内存），为对象分配所需的内存空间；接着，会调用类 `A` 的构造函数，对分配的内存进行初始化。
- **`delete` 的操作**：`delete` 同样做了两件事。它先调用类 `A` 的析构函数，释放对象内部动态分配的资源；然后调用 `operator delete` 函数（该函数底层通常使用 `free` 来释放内存），将对象占用的内存归还给系统。

综上所述，在使用 `new` 和 `delete` 时，要留意加括号和不加括号的区别，以及它们在对象创建和销毁过程中的具体操作，这样才能正确地管理内存和对象的生命周期。

#### 3.3 delete的时候需要知道长度吗？

对于非数组数据来说，类型信息是已知的，根据类型信息就可以知道长度，delete就可以了。如果是多态场景下，也是根据当前类型去调用析构函数，因此多态的父类析构必须为虚方法才不会泄露。

对于数组数据来说，编译器会额外存储数组的长度信息。一般而言，这些长度信息会被存储在分配的内存块的起始位置之前，也就是所谓的“头部”。`delete[]` 在释放内存时，会先读取这个头部信息，从而知晓要释放多少个元素的内存。

#### 3.4 `operator new` 和`new`的区别

- **`new`**：这是 C++ 里的一个运算符，它具备两个功能，一是调用 `operator new` 来分配内存，二是调用对象的构造函数。
- **`operator new`**：这是一个函数，它的作用仅仅是分配内存，不会调用对象的构造函数。
- **`delete`**：这是 C++ 里的一个运算符，它具备两个功能，一是调用对象的析构函数，二是调用 `operator delete` 来释放内存。
- **`operator delete`**：这是一个函数，它的作用仅仅是释放内存，不会调用对象的析构函数。

#### 3.5 placement new

`placement new` 是 C++ 中的一种特殊的 `new` 表达式，它允许你在已经分配好的内存块上构造对象，而不是像普通的 `new` 那样去分配新的内存。下面是一个使用 `placement new` 的代码示例，同时会说明其用法和用途。

```cpp
class MyClass;

void foo() {
    char* rawMemory = new char[sizeof(MyClass)];
    MyClass* obj = new (rawMemory) MyClass();
    delete[] rawMemory;

    return 0;
}
```

有placement new，但是没有对应的placement delete
功能：在已经分配的原始内存中初始化一个对象；

- 已经分配，定位new并不分配内存，你需要提前将这个定位new要使用的内存分配出来
- 初始化一个对象（初始化一个对象的内存），我们就理解成调用这个对象的构造函数；
  说白了，定位new就是能够在一个预先分配好的内存地址中构造一个对象；
  格式：
  new (地址) 类类型()

为什么使用free函数释放内存时不需要指明长度？

6.2 new 和 delete 运算符
对于 delete 来说 delete pi;
则先进行保护 if( pi != 0)
再调用 delete \_delete(pi)

对于成员对象:
对于 Point3d* origin = new Point3d
实际调用 operator new,其代码如下
extern void* operator new (size*t size){
if(size == 0)
size = 1;
void * last*alloc;
while(!(last_alloc = malloc(size))){
if(\_new_handler)
( *\_new_handler)();
else
return 0;
}
return last_alloc;
}

语言要求每一次对 new 的调用都必须传回一个独一无二的指针,为了解决这个问题,传回一个指向默认为 1Byte 的内存区块,允许程序员自己定义\_new*handler 函数,并且循环调用
至于 delete 也相同
extern void operator delete (void \_ptr){
if(ptr)
free( (char*)ptr)
}

对于对象数组,会在分配的内存上方放上 cookies,来存储数组个数,方便 delete 调用来析构
程序员最好避免以一个基类指向一个子类所组成的数组---如果子类对象比其基类大的话
解决方式:
for(int ix = 0; ix < elem*count; ++ix){
Point3d \_p = &((Point3d*)ptr)[ix];
delete p;
}

程序员必须迭代走过整个数组,把 delete 运算符实施与每一个元素身上.以此方式,调用操作将是 virtual.因此,Point3d 和 Point 的析构函数都会实施与每一个对象上

Placement Operator new 的语意
有一个预先定义好的重载的 new 运算符,称为 placement operator new.它需要第二个参数,类型为 void*
形如 Point2w *ptw = new (arena) Point2w,其中 arena 指向内存中的一个区块,用以放置新产生出来的 Point2w 对象
void* operator new(size_t , void* p){
return p;
}

如果我们在已有对象的基础上调用 placement new 的话,原来的析构函数并不会被调用,而是直接删除原来的指针,但是不能使用 delete 原来的指针
正确的方法应该是 :
//错误:
delete p2w;
p2w = new(arwna) Point2w;
//正确:
p2w->Point2w;
p2w = new(arena) Point2w;

6.3 临时性对象
临时对象在类的表达式并赋值,函数以值方式传参等都会产生临时对象-----而临时对象会构造和析构,所以会拖慢程序的效率,我们应该尽量避免
