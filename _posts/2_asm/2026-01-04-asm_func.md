---
layout: post
title: （二）汇编：C 函数调用方式与栈原理
categories: Assembly
related_posts: True
tags: Grammar
toc:
  sidebar: right
---

## C 函数调用方式与栈原理

### 1. 函数调用的本质

#### 1.1 CPU 视角下的函数概念

从 CPU 的工作机制出发，CPU 的主要工作是从内存读取指令、进行计算，然后将结果写回内存。对于 CPU 而言，并不存在"函数"的抽象概念，它处理的只是一条条机器指令。

**函数的本质**：函数实际上是多个指令、函数参数以及局部变量的有机集合，是对以下要素的抽象：

- **指令序列**：一系列按特定逻辑组织的机器指令
- **参数数据**：函数执行所需的输入数据
- **局部状态**：函数内部的临时变量和中间结果
- **返回机制**：确保函数执行完毕后能返回到调用点

#### 1.2 函数调用的核心问题

当程序执行函数调用时，需要解决以下关键问题：

1. **控制流转移**：如何从当前执行位置跳转到被调用函数
2. **返回地址保存**：如何记住调用完成后的返回位置
3. **参数传递**：如何将调用者的数据传递给被调用函数
4. **局部状态管理**：如何为函数分配独立的工作空间
5. **上下文保护**：如何保护调用者的执行环境

### 2. 栈帧结构与管理

#### 2.1 典型栈帧结构

栈帧是函数执行时在栈上分配的内存区域，包含函数运行所需的所有数据：

```
                  高地址
    +------------------------+
    | 调用者的局部变量        |
    +------------------------+
    | ...                   |
    +------------------------+
    | 参数n (最后一个参数)    | ← 参数按从右到左顺序压栈
    | 参数n-1               |
    | ...                   |
    | 参数2                 |
    | 参数1 (第一个参数)     |
    +------------------------+
    | 返回地址               | ← CALL指令自动压入
    +------------------------+
    | 调用者的EBP (old EBP)  | ← 函数序言保存
    +------------------------+ ← EBP指向此处
    | 局部变量1              |
    | 局部变量2              |
    | ...                   |
    | 局部变量n              |
    +------------------------+
    | 保存的寄存器           | ← 被调用者保存寄存器
    +------------------------+
    | 临时数据               | ← 中间计算结果
    +------------------------+ ← ESP指向此处
                  低地址
```

1. **关键指针与概念**
   - **函数参数入栈顺序**：通常情况下，函数参数按照从右到左的顺序入栈。这种顺序保证了在函数调用时，参数能以特定的逻辑顺序被压入栈中，便于被调用函数正确获取参数值。
   - **函数局部变量在栈中的布局**：局部变量在栈帧中按照声明顺序依次分配空间。这使得局部变量在栈中的存储位置与它们在代码中的声明顺序相关，有利于编译器准确地为变量分配和管理内存。
   - **栈帧指针（Frame Pointer, FP）**：一般用寄存器（如 EBP）作为栈帧指针，它指向当前栈帧的起始位置。通过栈帧指针，函数可以方便地访问栈帧内的各个部分，如局部变量、保存的寄存器等。
   - **栈顶指针（Stack Pointer, SP）**：栈顶指针始终指向当前栈顶的位置。它用于跟踪栈的使用情况，每当有数据压入栈或从栈弹出时，栈顶指针都会相应地移动。
2. **栈帧创建与寄存器操作** 通常，用一个名为`栈基址`（bp，常对应 EBP 寄存器）的寄存器来保存正在运行函数栈帧的`开始地址`。而`栈指针`（sp，常对应 ESP 寄存器）始终保存栈顶的地址，也就意味着它指向正在运行函数栈帧的`结束地址`。每次发生函数调用时，`栈基址`（bp）的值需要被修改为新栈帧的`开始地址`，这会导致其原始值被覆盖。为了保存和恢复`栈基址`，利用`寄存器的保存与恢复`机制，通过栈来实现。在函数调用开始时，`栈基址`和`栈指针`分别指向调用者栈帧的`开始地址`和`结束地址`。创建新栈帧时，首先将调用者栈帧的`开始地址`（即此时的`栈基址`）压入栈中保存。由于`栈基址`属于`被调用者保存`寄存器，所以它存储在被调用函数的栈帧中。随后，将`栈基址`（bp）的值修改为此时`栈指针`（sp）的值，使得二者指向同一位置。如果被调用函数还需要栈空间，便可以继续将`栈指针`（sp）向低地址方向移动来分配空间。最终，`栈基址`和`栈指针`又分别指向了`被调用者`栈帧的`开始地址`和`结束地址`。
3. **栈帧各部分详细说明** - **函数参数（arguments）**：在`X64`架构中，函数参数的传递方式较为特殊。如果函数参数超过 6 个，前 6 个参数通过寄存器进行传递，其余参数则通过栈来传递。当参数少于等于 6 个或没有参数时，栈帧中的参数部分可以忽略。在需要通过栈传递参数时，`调用函数`需要先将参数压入自己的栈帧中，然后`被调用函数`从`调用函数`的栈帧中访问这些参数。因此，在栈帧结构图中，参数部分位于调用函数的栈帧内。 - **返回地址（ret addr）**：在将函数参数压入栈之后，需要把调用位置处的下一条指令地址压入栈中。这个地址被称为返回地址，其作用是确保被调用函数执行完毕后，程序能够回到原来的位置继续执行后续指令。 - **保存的寄存器（saved regs）**：这部分存放需要`被调用者`来保存的寄存器。例如，`旧的栈基址`（old bp）就保存在此区域。这样，在函数返回时，能够恢复调用者的寄存器状态，保证程序的连续性和正确性。 - **局部变量（local vars）**：该部分存储的是那些存储在栈中而非寄存器中的局部变量。如果函数没有局部变量，或者局部变量都存储在寄存器中，那么栈帧中的这部分可以忽略。

函数的执行环境主要由以下四个部分构成：

1. **可执行的二进制代码**：二进制代码由编译器生成，编译完成后，它会被固定存储在二进制文件的 `.text` 段中。在程序运行时，这部分代码会被加载到内存的只读代码区。正常情况下，这些代码是不可修改的，但在某些特殊场景下，可通过动态指令修改，不过这部分内容超出了当前讨论的范畴。程序编译后，代码段被加载至内存。在 x86 的 CPU 平台下，由 **EIP 寄存器** 指向下一条待执行指令的内存地址；而在 X64 平台，则是由 **RIP 寄存器** 来承担此功能，RIP 为 64 位，其本质与 EIP 类似。对于 **协程** 而言，需要手动记录并切换与 EIP/RIP 相关的内存地址，具体的实现方法将在后续详细阐述。
2. **运行所需寄存器**：寄存器在汇编代码的学习与编写过程中至关重要。随着 CPU 的不断升级，除了普通寄存器外，还涌现出了各种专用寄存器和指令，例如 SSE 指令集所使用的 XMM 寄存器，以及 ARM 的 NEON 加速指令等。对于协程来说，主要关注以下三类寄存器：
   - **ESP 和 EBP**：这是与堆栈操作和记录紧密相关的寄存器。ESP（Extended Stack Pointer）指向栈顶，用于栈操作的定位；EBP（Extended Base Pointer）则常作为栈帧的基地址，方便对栈内数据进行访问。
   - **EAX、EBX、ECX 等通用寄存器**：它们广泛应用于指令的具体运算过程，同时也承担着传参、返回值等功能。
   - **EIP**：该寄存器负责控制指令的执行流程，决定下一条要执行的指令地址。在 X64 平台上，情况基本类似，只是寄存器的数量有所增加。协程在离开和恢复函数时，需要正确还原部分寄存器的值。根据 Intel i386 的 ABI 调用约定，像 EAX、ECX、EDX 这些寄存器的值在函数调用过程中允许被改变，而 EBX、ESI、EDI 等寄存器的值则需要调用者自行保存和恢复 。
3. **运行所需栈内存**：函数的运行依赖于栈内存。栈内存中包含了函数的参数、返回地址、需要保护的寄存器值以及局部变量等信息。函数栈帧的结构在各类资料中较为常见。参数的入栈方式并非都采用压栈操作，其具体方式取决于调用约定。对于协程而言，记录栈内存状态十分关键。例如，当函数局部变量被修改后，下次调用时应确保保持修改后的值。这主要涉及两大模式：**有独立栈协程和无独立栈协程**，其他变种暂不展开讨论。
4. **运行可能所需堆内存**：在函数执行过程中，可能需要动态分配堆内存，比如通过 `new` 或 `malloc` 函数来实现。对于初步理解协程的概念来说，这部分内容可以暂时不做重点关注。

#### 2.2 关键寄存器的作用

**栈指针寄存器（ESP/RSP）**：

- 始终指向当前栈顶位置
- 随 PUSH/POP 操作自动调整
- 用于栈空间的动态分配和释放

**基址指针寄存器（EBP/RBP）**：

- 指向当前栈帧的固定基准点
- 提供稳定的参数和局部变量访问基址
- 通过偏移量访问栈帧内的数据

**指令指针寄存器（EIP/RIP）**：

- 指向下一条待执行指令的地址
- 函数调用时保存为返回地址
- 控制程序执行流程

#### 2.3 栈帧创建过程

**函数调用序列**：

```assembly
; 调用者操作
push param3          ; 压入参数（从右到左）
push param2
push param1
call function        ; 调用函数（自动压入返回地址）

; 被调用函数序言
push ebp             ; 保存调用者的栈基址
mov ebp, esp         ; 建立新的栈帧基址
sub esp, N           ; 分配局部变量空间
```

**栈帧销毁序列**：

```assembly
; 被调用函数尾声
mov esp, ebp         ; 释放局部变量空间
pop ebp              ; 恢复调用者的栈基址
ret                  ; 返回（自动弹出返回地址）

; 调用者清理（cdecl约定）
add esp, 12          ; 清理参数空间（3个参数 × 4字节）
```

#### 2.4 销毁栈帧

当函数返回时，需要销毁之前为该函数创建的栈帧，以释放其所占用的空间。

销毁栈帧时，首先将栈指针（sp）移动到当前栈基址（bp）的位置，此时栈指针和栈基址指向相同位置。

- **栈变化过程**
  在这一步操作后，栈顶位置存放的正是创建栈帧时保存的调用者栈帧的栈基址。接下来，将该值从栈中弹出到栈基址（bp）寄存器中，此时栈结构发生相应变化，被调用者的栈帧空间已被释放，但函数返回的步骤尚未完成。

- **返回地址处理**
  此时，调用者的栈帧中仍保存着返回地址。为了恢复到调用函数前的执行位置，需要将返回地址从栈中弹出到程序计数器（PC）中。至此，函数完成返回，栈帧恢复到调用前的状态。

需要注意的是，在C/C++中，销毁栈帧并不会清空被销毁栈帧中的数据。这些数据在栈空间被重新分配之前，仍然保留在内存中，但从程序逻辑角度，已无法直接访问这些数据。

### 3. 参数传递机制

#### 3.1 调用约定概览

| 调用约定     | 参数传递方式 | 栈清理责任 | 用途场景                 |
| ------------ | ------------ | ---------- | ------------------------ |
| **cdecl**    | 栈（右到左） | 调用者     | C 语言标准，支持可变参数 |
| **stdcall**  | 栈（右到左） | 被调用者   | Windows API              |
| **fastcall** | 寄存器+栈    | 被调用者   | 高性能场景               |
| **thiscall** | ECX+栈       | 被调用者   | C++成员函数              |

#### 3.2 不同架构的参数传递

**x86-32 架构（传统方式）**：

```c
// 函数声明
int add(int a, int b, int c);

// 调用时的汇编等效代码
push ecx             // 参数c
push ebx             // 参数b
push eax             // 参数a
call add             // 调用函数
add esp, 12          // 清理栈空间（3×4字节）
```

**x86-64 架构（寄存器优先）**：

```c
// 同样的函数调用
int add(int a, int b, int c, int d, int e, int f, int g, int h);

// x64参数传递方式
// 前6个参数：RDI, RSI, RDX, RCX, R8, R9
// 剩余参数通过栈传递
```

**ARM64 架构**：

```c
// ARM64参数传递
// 前8个参数：X0-X7
// 剩余参数通过栈传递
// 返回值：X0
```

#### 3.3 复杂数据类型的传递

**结构体传递**：

```c
struct Point {
    int x, y;
};

// 小结构体（≤8字节）：通过寄存器
// 大结构体（>8字节）：通过隐藏指针参数
Point createPoint(int x, int y);
// 可能转换为：
void createPoint(Point* result, int x, int y);
```

**浮点数传递**：

```c
double calculate(double a, float b);
// x64：XMM0传递a，XMM1传递b
// 返回值通过XMM0
```

### 4. 控制流转移机制

控制转移指的是在函数调用过程中，程序执行流程需从当前位置跳转至被调用函数的起始位置，待被调用函数执行完毕后，再返回到原位置继续执行。

以如下C语言代码为例：

```c
void Q() {
    printf("this is Q.");
    return;
}

void P() {
    printf("readying to call Q.");
    Q();
    return;
}
```

假设代码的`行号`等同于`指令地址`，初始时，程序计数器（PC）的值为7，即函数`P`的起始指令地址。CPU按顺序执行，遇到函数调用时，会将PC修改为被调用函数`Q`的起始指令地址2。待`Q`函数执行完毕，最后再把PC修改为`P`中调用`Q`语句的下一条指令地址9，至此本次函数调用过程结束。

在此过程中，函数`返回地址`的保存是个关键问题。当存在大量函数嵌套调用时，每次调用都会产生一个返回地址，且这些返回地址需与每次调用相关联。为满足这一需求，我们利用`栈`来存储函数的`返回地址`。每次发生函数调用时，将`返回地址`压入栈中，函数执行完毕后，再将其从栈中弹出至`PC`中。

以下是一个C语言嵌套函数调用的示例，分别对其调用和返回过程进行详细说明：

```c
void Q() {
    printf("this is Q.\n");
    return;
}

void P() {
    printf("readying to call Q.\n");
    Q();
    return;
}

void main() {
    printf("readying to call P.\n");
    P();
    return;
}
```

- 调用过程
  依旧假设代码的`行号`为每条指令的地址。最初，PC为13，即`main`函数的第一行代码处。程序继续执行到14，发现此处调用了函数`P`，于是将PC设为`P`的起始指令地址7。随后，将调用`P`处的下一条指令地址15压入栈中。程序继续执行到`P`函数的第8行，又发现调用了函数`Q`，同样将PC设为`Q`的起始指令地址2，最后把调用`Q`处的下一条指令地址9压入栈中。此时，栈中存储了两个`返回地址`，分别为9和15。

- 返回过程
  函数`Q`执行完毕后，开始返回。返回时，会将栈中先前保存的`返回地址`弹出到PC中。此时栈顶的指令地址为9，将其从栈中弹出到PC中，函数便成功返回到`P`函数中。待`P`函数执行完成后，继续将栈顶的指令地址15弹出到PC中，最终函数返回到`main`函数，栈也恢复到调用前的状态。

#### 4.1 CALL 指令的本质

```assembly
call target_function
; 等效于：
push eip             ; 保存下一条指令地址
jmp target_function  ; 跳转到目标函数
```

#### 4.2 RET 指令的本质

```assembly
ret
; 等效于：
pop eip              ; 恢复返回地址到指令指针
; CPU自动跳转到该地址继续执行
```

#### 4.3 嵌套调用的栈管理

```c
void func_c() {
    printf("In function C\n");
}

void func_b() {
    printf("In function B\n");
    func_c();
    printf("Back to function B\n");
}

void func_a() {
    printf("In function A\n");
    func_b();
    printf("Back to function A\n");
}

int main() {
    func_a();
    return 0;
}
```

**栈状态变化**：

```
调用func_a时：   调用func_b时：   调用func_c时：
+----------+    +----------+    +----------+
| main栈帧 |    | main栈帧 |    | main栈帧 |
+----------+    +----------+    +----------+
| ret_addr |    | ret_addr |    | ret_addr |
+----------+    +----------+    +----------+
| func_a帧 |    | func_a帧 |    | func_a帧 |
+----------+    +----------+    +----------+
              | ret_addr |    | ret_addr |
              +----------+    +----------+
              | func_b帧 |    | func_b帧 |
              +----------+    +----------+
                            | ret_addr |
                            +----------+
                            | func_c帧 |
                            +----------+
```

### 5. 寄存器管理策略

#### 5.1 寄存器分类

在程序执行过程中，常常需要对寄存器进行保存与恢复操作，以确保函数调用前后寄存器状态的一致性，避免数据丢失或混乱。以下面这段代码为例，展示了如何分别将`ax`、`bx`这两个寄存器的值保存在栈中：

```c
push(ax);
push(bx);
```

- **保存过程**
  上述代码中，`push`指令会将寄存器`ax`的值压入栈中，栈指针会相应地调整以适应新压入的数据。接着，`bx`的值也被压入栈中，栈指针再次调整。此时，`ax`的值位于栈底，`bx`的值位于栈顶。

当需要恢复寄存器的值时，代码如下：

```c
pop(bx);
pop(ax);
```

- **恢复过程**
  `pop`指令的作用是从栈顶弹出数据，并将其赋值给指定的寄存器。这里要特别注意，出栈和入栈的顺序是相反的。因为在保存过程结束后，栈顶存储的是之前`bx`的值，所以在恢复时，首先要把栈顶的值弹出到`bx`寄存器中，然后再把栈顶此时的值（即之前`ax`的值）弹出到`ax`寄存器中。通过这样的操作，就能够将保存的值与对应的寄存器正确对应起来，恢复到函数调用前寄存器的状态。

值得注意的是，并不是所有的寄存器都需要进行`保存与恢复`操作。根据相关约定，寄存器被划分为`被调用者保存`和`调用者保存`两类。这一划分有助于明确在函数调用过程中，哪一方（调用函数还是被调用函数）负责保存和恢复特定寄存器的值，从而更有效地管理寄存器资源，提高程序执行的效率和稳定性。具体哪些寄存器属于`被调用者保存`，哪些属于`调用者保存`，取决于不同的硬件架构和编程规范。例如，在x86架构下，某些通用寄存器（如`ebp`、`esi`、`edi`）通常被视为`被调用者保存`寄存器，被调用函数需要在使用前保存这些寄存器的值，并在返回前恢复；而像`eax`、`ebx`、`ecx`、`edx`等寄存器，在一些情况下可能被当作`调用者保存`寄存器，调用函数在调用其他函数前需自行保存其值，如果被调用函数修改了这些寄存器的值，调用函数需要自行恢复。这种约定在不同的编译器和操作系统中可能会有细微差别，但总体原则是一致的，都是为了保证函数调用过程中寄存器状态的正确维护。

**调用者保存寄存器（Caller-saved）**：

- **EAX, ECX, EDX**：调用函数前需要主动保存
- 被调用函数可以自由修改
- 适用于临时计算和返回值传递

**被调用者保存寄存器（Callee-saved）**：

- **EBX, ESI, EDI, EBP**：被调用函数必须保护
- 函数返回时必须恢复原值
- 适用于跨函数调用的持久数据

#### 5.2 寄存器保存示例

```assembly
my_function:
    ; 函数序言 - 保护寄存器
    push ebp             ; 保存帧指针
    push ebx             ; 保存被调用者保存寄存器
    push esi
    push edi

    mov ebp, esp         ; 建立栈帧
    sub esp, 16          ; 分配局部变量空间

    ; 函数体 - 可以自由使用所有寄存器
    mov eax, [ebp+8]     ; 获取参数
    mov ebx, eax         ; 使用EBX进行计算
    ; ...

    ; 函数尾声 - 恢复寄存器
    add esp, 16          ; 释放局部变量空间
    pop edi              ; 恢复寄存器（逆序）
    pop esi
    pop ebx
    pop ebp
    ret                  ; 返回
```

#### 5.3 局部变量的存储

在函数执行过程中，寄存器和内存都可用于存放所需数据。寄存器具有极快的存取速度，因此通常优先考虑将数据存入寄存器。然而，寄存器数量有限，当寄存器不足以存放所有数据时，就需要将部分数据存放在栈内存中。

我们可通过移动栈指针（sp）向栈顶方向移动，为函数在栈中分配用于存放局部数据的内存空间。

以如下C语言代码为例：

```c
void main() {
    long foo = 100;
    long bar = 200;
}
```

此代码定义了两个`long`类型变量`foo`和`bar`。假设它们都存放在栈中，由于`long`类型每个占用8个字节，所以总共需要在栈中分配16个字节的空间。

- **分配过程（假设一个单元格为8个字节）**
  栈指针（sp）向栈顶方向移动16个字节，从而为`foo`和`bar`在栈中预留出相应的存储空间。

- **存储变量**
  移动栈指针完成空间分配后，将变量`foo`的值100存入分配好的栈空间起始位置，接着将变量`bar`的值200存入紧挨着`foo`的栈空间。

### 6. 返回值处理机制

#### 6.1 不同类型返回值的处理

**基本数据类型**：

```c
int func1();         // 返回值在EAX/RAX
long long func2();   // x86: EDX:EAX, x64: RAX
float func3();       // x87 ST(0) 或 XMM0
double func4();      // x87 ST(0) 或 XMM0
```

**结构体返回值**：

```c
struct SmallStruct {
    int a, b;        // 8字节，通过RAX返回
};

struct LargeStruct {
    int data[10];    // 40字节，通过隐藏参数返回
};

// 编译器可能将这样的调用：
LargeStruct func();
// 转换为：
void func(LargeStruct* result);
```

函数的返回值一般会使用 `eax`（32 位平台）/`rax`（64 位平台）/`x0`（ARM64 平台）等寄存器作为返回载体，但这并非绝对。在一些特殊情况下，也可借助其他寄存器来返回值，比如 `edx`、`xmm0` 等。当函数返回值为结构体，一个寄存器无法容纳全部数据时，可能会将返回值的地址作为隐藏参数进行传递，例如 Boost 的协程切换函数就采用了类似的机制。

从 C/C++ 层面来看，函数的调用与返回形式较为常规。然而，从汇编层面深入分析，一般函数调用采用 `call functionA` 的形式，函数返回则使用 `ret` 形式。

#### 6.2 返回值优化（RVO）

```cpp
class MyClass {
public:
    MyClass(int val) : value(val) {}
    int value;
};

MyClass createObject() {
    return MyClass(42);  // 可能直接在调用者空间构造
}

int main() {
    MyClass obj = createObject();  // 可能避免拷贝
    return 0;
}
```

### 7. 高级主题与优化技术

#### 7.1 栈帧优化

**帧指针消除（Frame Pointer Omission）**：

```assembly
; 传统方式
push ebp
mov ebp, esp
sub esp, 16
; 使用 [ebp-4], [ebp-8] 访问局部变量

; 优化后（-fomit-frame-pointer）
sub esp, 16
; 直接使用 [esp+12], [esp+8] 访问局部变量
```

**尾调用优化（Tail Call Optimization）**：

```c
int factorial(int n, int acc) {
    if (n <= 1) return acc;
    return factorial(n-1, n*acc);  // 尾调用，可优化为跳转
}

; 优化后可能变成：
factorial_loop:
    cmp edi, 1
    jle end
    imul esi, edi
    dec edi
    jmp factorial_loop
end:
    mov eax, esi
    ret
```

#### 7.2 安全机制

**栈金丝雀（Stack Canary）**：

```assembly
function_with_buffer:
    push ebp
    mov ebp, esp
    mov eax, gs:[0x14]   ; 读取金丝雀值
    push eax             ; 保存到栈上
    sub esp, 256         ; 分配缓冲区

    ; 函数体...

    mov eax, [ebp-4]     ; 读取金丝雀值
    xor eax, gs:[0x14]   ; 检查是否被修改
    jnz stack_overflow   ; 如果修改则跳转到错误处理

    add esp, 260
    pop ebp
    ret

stack_overflow:
    call __stack_chk_fail
```

### 8. 实际应用示例

#### 8.1 完整的函数调用分析

```c
long add_numbers(long a, long b, long c, long d, long e, long f, long g, long h) {
    long local_var = a + b;
    return local_var + c + d + e + f + g + h;
}

int main() {
    long result = add_numbers(1, 2, 3, 4, 5, 6, 7, 8);
    printf("Result: %ld\n", result);
    return 0;
}
```

**编译后的汇编分析（x64）**：

```assembly
main:
    ; 函数序言
    pushq %rbp
    movq %rsp, %rbp
    subq $16, %rsp           ; 分配局部变量空间

    ; 准备参数（前6个通过寄存器，后2个通过栈）
    pushq $8                 ; 第8个参数
    pushq $7                 ; 第7个参数
    movl $6, %r9d           ; 第6个参数 -> R9
    movl $5, %r8d           ; 第5个参数 -> R8
    movl $4, %ecx           ; 第4个参数 -> RCX
    movl $3, %edx           ; 第3个参数 -> RDX
    movl $2, %esi           ; 第2个参数 -> RSI
    movl $1, %edi           ; 第1个参数 -> RDI

    call add_numbers
    addq $16, %rsp          ; 清理栈参数

    ; 使用返回值（在RAX中）
    movq %rax, %rsi
    movq $.LC0, %rdi        ; "Result: %ld\n"
    call printf

    movl $0, %eax           ; 返回0
    leave                   ; 等价于 movq %rbp, %rsp; popq %rbp
    ret

add_numbers:
    ; 函数序言
    pushq %rbp
    movq %rsp, %rbp

    ; 保存寄存器参数到栈（如果需要）
    movq %rdi, -8(%rbp)     ; a
    movq %rsi, -16(%rbp)    ; b
    ; ... 其他参数

    ; 计算 local_var = a + b
    movq -8(%rbp), %rax
    addq -16(%rbp), %rax
    movq %rax, -56(%rbp)    ; local_var

    ; 计算最终结果
    movq -56(%rbp), %rax    ; local_var
    addq -24(%rbp), %rax    ; + c
    addq -32(%rbp), %rax    ; + d
    addq -40(%rbp), %rax    ; + e
    addq -48(%rbp), %rax    ; + f
    addq 16(%rbp), %rax     ; + g (栈参数)
    addq 24(%rbp), %rax     ; + h (栈参数)

    ; 返回（结果已在RAX中）
    popq %rbp
    ret
```

#### 8.2 栈溢出攻击与防护

**栈溢出示例**：

```c
void vulnerable_function() {
    char buffer[64];
    gets(buffer);  // 危险：无边界检查
}
```

**防护措施**：

1. **栈金丝雀**：检测栈覆盖
2. **ASLR**：地址空间随机化
3. **NX 位**：栈不可执行
4. **安全编程**：使用安全函数

#### 8.3 调试技巧

**GDB 调试栈帧**：

```bash
(gdb) bt                    # 显示调用栈
(gdb) frame 2              # 切换到第2个栈帧
(gdb) info frame           # 显示当前栈帧信息
(gdb) x/10wx $esp          # 查看栈内容
(gdb) disas                # 反汇编当前函数
```

### 9. 常见问题与解答

#### 9.1 栈相关概念澄清

**Q: 内存的栈和汇编的栈是同一个概念吗？**

A: 是的，它们是同一物理结构的不同抽象层次：

- **内存栈（高级视角）**：操作系统分配的 LIFO 内存区域，用于函数调用管理
- **汇编栈（底层视角）**：通过 ESP/RSP 和 EBP/RBP 寄存器操作的具体实现

#### 9.2 性能相关问题

**Q: 函数调用的性能开销有多大？**

A: 典型开销包括：

- 参数传递：寄存器传递几乎无开销，栈传递有内存访问开销
- 栈帧管理：约 5-10 条指令的开销
- 寄存器保存/恢复：取决于使用的寄存器数量
- 分支预测：现代 CPU 的分支预测器可减少跳转开销

#### 9.3 获取指令指针的技术

```cpp
// 方法1：编译器内置函数
uint64_t get_return_address() {
    return (uint64_t)__builtin_return_address(0);
}

// 方法2：内联汇编
void* get_current_address() {
    void* addr;
    asm("call 1f\n1: pop %0" : "=r"(addr));
    return addr;
}

// 方法3：利用异常机制
#include <setjmp.h>
jmp_buf env;
void save_context() {
    if (setjmp(env) == 0) {
        // 第一次调用，保存上下文
        longjmp(env, 1);
    } else {
        // 第二次到达，上下文已保存
    }
}
```

### 10. 总结

函数调用机制是现代计算机系统的基础，涉及多个层面的协调配合：

1. **硬件层面**：CPU 提供栈操作指令和寄存器支持
2. **指令层面**：CALL/RET 指令实现控制流转移
3. **约定层面**：调用约定确保兼容性
4. **编译器层面**：代码生成和优化
5. **操作系统层面**：栈空间管理和安全保护

现代编译器虽然已经高度优化了函数调用，但深入理解其原理仍然是系统程序员必备的基础知识。随着处理器架构的演进和新技术的出现，函数调用机制也在不断发展，但其核心原理保持相对稳定。
