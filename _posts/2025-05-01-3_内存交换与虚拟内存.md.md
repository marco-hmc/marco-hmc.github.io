---
layout: post
title: 内存交换和虚拟内存
categories: 计算机系统
related_posts: True
tags: 内存
toc:
  sidebar: left
---

## 内存交换和虚拟内存

### 1. concepts

1. **内存交换（Swapping）**：

   - 当内存不足时，将暂时不需要运行的进程换出到硬盘上，以腾出内存空间。
   - 硬盘上用于交换的分区称为交换区（Swap Space）。
   - 内存交换主要用于解决多个程序同时运行时对内存的需求。

2. **虚拟内存（Virtual Memory）**：

   - 通过将物理内存和磁盘空间结合起来，为每个进程提供一个比实际物理内存更大的虚拟地址空间。
   - 虚拟内存涉及分页管理（Paging），将内存划分为固定大小的页面，并在需要时将页面换入换出。
   - 虚拟内存使得程序可以运行在比物理内存更大的虚拟地址空间中，从而满足对大内存的需求。

3. **关系**：
   - 内存交换是虚拟内存管理的一部分，但虚拟内存的功能和范围更广泛。
   - 虚拟内存包括内存交换和分页技术，通过这两种技术实现内存的高效管理和利用。
   - 两者的区分：以前朴素的内存交换，不要求分页，一个进程可以是连续的内存空间，交换的是活跃进程和不活跃进程的内存；而虚拟内存强调结合硬盘实际增加内存空间，需要对程序分页管理。

### 2. 虚拟内存

- **设计目的**

虚拟内存的主要目的是通过将物理内存和磁盘空间结合起来，为每个进程提供一个比实际物理内存更大的虚拟地址空间，从而提高内存的利用率和系统的并发性能。

- **实现方式**

1. **地址空间管理**：操作系统为每个进程分配一个独立的虚拟地址空间，通过页表等机制将虚拟地址映射到物理地址。
2. **内存分配与回收**：操作系统根据进程的需求动态分配和回收内存，确保内存的高效利用。
3. **页面置换**：当物理内存不足时，操作系统将部分不常用的页面换出到磁盘，以腾出空间给当前需要的页面。
4. **内存保护**：虚拟内存技术本身就提供了内存保护的功能，确保每个进程只能访问自己的内存空间。

- **应用场景**

虚拟内存通常在以下情况下使用：

- 当系统需要运行比物理内存更大的程序时。
- 当系统需要提高内存利用率和系统并发性能时。
- 当系统需要提供内存保护功能时。

* **优缺点**

- **优点**：虚拟内存可以显著提高内存利用率和系统并发性能，提供内存保护功能，使得程序可以运行在比物理内存更大的虚拟地址空间中。
- **缺点**：虚拟内存的实现复杂度较高，频繁的页面置换操作可能会导致系统性能下降。

#### 2.1 内存交换

设计思想：当内存空间紧张时，系统将内存中的某些进程暂时换出外存，同时将外存中某些已具备运行条件的进程换入内存，从而实现进程在内存与磁盘间的动态调度。
暂时换出外存等待的进程状态为挂起状态（挂起态，suspend），挂起态又可以进一步细分为就绪挂起和阻塞挂起两种状态。

> 在具有对换功能的操作系统中，通常把磁盘空间分为文件区和交换区两部分。
> 文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；
> 交换区空间只占磁盘空间的小部分，被换出的进程数据就存放在交换区。
> 由于交换的速度直接影响到系统的整体速度，因此交换区空间的管理主要追求换入换出速度，因此通常交换区采用连续分配方式（学过文件管理章节后即可理解）。
> 总之，交换区的 I/O 速度比文件区的更快。

#### 2.2 细节

- **应该什么时候发生内存交换？**

  内存交换通常在以下情况下发生：

* 当系统中的内存资源紧张，不足以容纳所有需要运行的进程时；
* 当系统中的某些进程长时间处于阻塞状态，占用了宝贵的内存资源时；
* 当系统需要为新的进程或线程分配内存，但内存空间不足时。

  内存交换的触发条件通常由操作系统的内存管理策略决定，例如，操作系统可能会设置一个内存阈值，当内存使用量超过这个阈值时，就会触发内存交换。

- **应该换出哪些进程？**

在进行内存交换时，操作系统通常会选择换出以下类型的进程：

- 优先级较低的进程：这些进程对系统的重要性较低，换出它们对系统的影响较小；
- 阻塞状态的进程：这些进程由于等待某些事件（如 I/O 操作）而无法继续执行，换出它们可以释放内存资源；
- 长时间未被使用的进程：这些进程可能已经不再需要，换出它们可以提高内存的利用率；
- 内存占用较大的进程：这些进程可能会占用大量的内存资源，换出它们可以为其他进程腾出更多的内存空间。

操作系统在选择换出进程时，还会考虑进程的驻留时间、换入换出的开销等因素，以确保内存交换的效率和公平性。

#### 2.3 虚拟内存

![Alt text](imgs/image-18.png)

- 传统存储管理方式的特征/缺点
  - 一次性：作业数据必须一次全部调入内存
  - 驻留性：作业数据在整个运行期间都会常驻内存
- 局部性原理
  - 时间局部性：现在访问的指令/数据在不久后很可能会被再次访问
  - 空间局部性：在访问的内存单元周围的内存空间，很可能在不久后会被访问
  - 高速缓存技术：使用频繁的数据放到更高速的存储器中
- 虚拟内存的定义和特征
  - 程序不需全部装入即可运行，运行时根据需要动态调入数据，若内存不够，还需换出一些数据
  - 特征
    - 多次性：需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
    - 对换性：需在作业运行时一直常驻内存，而是允许在作业运行过程中，将作业换入/换出。
    - 虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量
- 如何实现虑拟内存技术
  - 访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存(请求调页功能)
  - 内存空间不够时，将内存中暂时用不到的信息换出到外存(页面置换功能)
- 虚拟内存的实现
  - 请求分页式存储管理
  - 请求分段存储管理
  - 请求段页式存储管理
- trivial
  - 易混知识点：虚拟内存的最大容量是由计算机的地址结构(CPU 寻址范围)确定的
  - 虚拟内存的实际容量 = min(内存和外存容量之和，CPU 寻址范围 )

* 虚拟内存概念
  - 虚拟内存技术是操作系统的一种扩容技术，它使得不同进程在运行过程中，它所看到的是**自己独自占有了当前系统的4G内存**。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。
  - 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，**实际上并不立即就把虚拟内存对应位置的程序数据和代码**（比如.text .data段）**拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好**（叫做存储器映射），**等到运行到对应的程序时，才会通过缺页异常，来拷贝数据**
  - 还有进程运行过程中，要动态分配内存，比如**malloc时，也只是分配了虚拟内存**，即为这块虚拟内存对应的页表项做相应设置，**当进程真正访问到此数据时，才引发缺页异常**
  - 请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换
* **虚拟内存的好处**
  - 扩大地址空间
  - **内存保护**：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改
  - 公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间
  - 当进程通信时，可采用虚存共享的方式实现
  - **方便内存映射：当不同的进程使用同样的代码时，比如动态库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存。还有COW**
  - 虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高
  - **惰性分配**：在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，首次使用这块内存时才分配物理内存，可以利用碎片
* **虚拟内存的代价**
  - **虚存的管理需要建立很多数据结构(如页表等)，这些数据结构要占用额外的内存**
  - **虚拟地址到物理地址的转换，增加了指令的执行时间**
  - **页面的换入换出需要磁盘I/O，这是很耗时的**
  - 如果一页中只有一部分数据，会浪费内存
* 颠簸(thrashing)
  - 分页(Page)写入磁盘的过程被称作Page-Out，分页(Page)从磁盘重新回到内存的过程被称作Page-In。当内核需要一个分页时，但发现此分页不在物理内存中(因为已经被Page-Out了)，此时就发生了分页错误（Page Fault）
  - 当系统内核发现**可运行内存变少**时，就会通过Page-Out来释放一部分物理内存。经管Page-Out不是经常发生，但是如果**Page-out频繁不断的发生**，直到当内核管理分页的时间超过运行程式的时间时，**系统效能会急剧下降**。这时的**系统已经运行非常慢或进入暂停状态**，这种状态亦被称作thrashing(颠簸)
  - 解决策略
    - 如果是因为页面置换策略失误，可以修改置换算法来解决这个问题
    - 如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量
    - 否则，还剩下两个办法：1. 终止该进程；2. 增加物理内存容量
* TLB
  - TLB( Translation Look- aside buffer)**专门用于缓存内存中的页表项**，一般**在MMU单元内部**，页表一般存储在物理内存中。**当处理器要访问一个虚拟地址时，首先会在TLB中查询**。如果TLB表项中没有相应的表项，称为TLB Miss，那么就需要访问页表来计算出相应的物理地址。如果TLB表项中有相应的表项，那么直接从TLB表项中获取物理地址，称为TLB命中

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

虚拟内存是操作系统中的一种内存管理技术，它通过将物理内存和磁盘空间结合起来，为每个进程提供一个比实际物理内存更大的虚拟地址空间。虚拟内存的主要目的是提高内存的利用率和系统的并发性能。虚拟内存的实现通常包括以下几个步骤：

1. **地址空间管理**：操作系统为每个进程分配一个独立的虚拟地址空间，通过页表等机制将虚拟地址映射到物理地址。

2. **内存分配与回收**：操作系统根据进程的需求动态分配和回收内存，确保内存的高效利用。

3. **页面置换**：当物理内存不足时，操作系统将部分不常用的页面换出到磁盘，以腾出空间给当前需要的页面。

4. **内存保护**：虚拟内存技术本身就提供了内存保护的功能，确保每个进程只能访问自己的内存空间。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0\~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7b281b1e-0595-402b-ae35-8c91084c33c1.png"/> </div><br>

在运行一个进程的时候,它所需要的内存空间可能大于系统的物理内存容量.通常一个进程会有 4G 的空间,但是物理内存并没有这么大,所以这些空间都是虚拟内存,它的地址都是逻辑地址,每次在访问的时候都需要映射成物理地址.
当进程访问某个逻辑地址的时候,会去查看页表,如果页表中没有相应的物理地址,说明内存中没有这页的数据,发生缺页异常,这时候进程需要把数据从磁盘拷贝到物理内存中.如果物理内存已经满了,就需要覆盖已有的页,如果这个页曾经被修改过,那么还要把它写回磁盘.

虚拟内存是现在 OS 最普遍使用的一种技术。前面所讲的抽象满足了多进程的要求，但很多情况下，现有内存无法满足仅仅一个大进程的内存要求例如(游戏 🎮，都是 10G+级别)。早期 OS 曾使用(overlays)来解决这个问题，将一个程序分为多个块，基本思想是先将块 0 加入内存，块 0 执行完，将块 1 加入内存。依次往复，所以费力又费时。聪明的程序员就想到了虚拟内存。<br>

虚拟内存的基本思想是，将物理主存扩大到便宜、大容量的磁盘上，即将磁盘空间看作主存空间的一部分。 **也就是在内存容量不足时将不经常访问的内存空间中的数据写入硬盘，以增加“账面上”可用内存容量的手段**。虚拟内存的优点在于除了让程序员感觉到内存增大了，还让程序员感觉到内存速度也增快了。但是如果硬盘与主存之间谁交换过于频繁，处理速度就会下降，表面上就像卡住了，这现象称为抖动(Thrushing)。(造成死机 💀 的主要原因之一就是抖动)。<br>

![虚拟内存和物理内存以及磁盘的映射关系](./img/virtual_memory.png "虚拟内存和物理内存以及磁盘的映射关系")

如上图可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问 MMU(内存管理单元)区匹配对应的物理地址如图中的 0，1，2(也就是说，其实虚拟内存提供的是地址)，而如果虚拟内存的页 📃 并不存在于物理内存中，就会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。<br>

![动态地址翻译](./img/process_addr.jpeg "用户进程发出的虚拟地址由MMU翻译成物理地址")

上图表示在多道编程环境下，无法将程序总是加到固定的内存地址上，也就是无法使用静态地址翻译，所以进程存的都是相对地址，这个时候，如果直接使用物理内存会怎样？用了别的进程在用的地址造成崩溃。这时候就需要地址翻译器也就是 MMR，内存管理单元。在程序加载完毕之后才能计算物理地址，这就叫做动态地址翻译。<br>

介绍完分区，我们明白，分区内存管理在交换技术方面，存在着缺陷，因为分区技术为进程分配的空间是连续的，使用的地址都是物理地址，如果允许讲一个进程分散到许多不连续的空间，就可以 **避免内存紧凑，减少碎片。** 基于这一思想，通过引入进程的 **逻辑地址**，把进程地址空间与实际存储空间分离，增加存储管理的灵活性。地址空间和存储空间两个基本概念的定义

- 地址空间: 将源程序经过编译后得到的目标程序，存在于它所限定的地址范围内，这个范围称为地址空间。**地址空间是逻辑地址的集合**
- 存储空间: 指主存中一系列存储信息的物理单元的集合，这些单元的编号称为物理地址。**存储空间是物理地址的集合**

根据分配时所采用的基本单位不同，可以将离散分配的管理方式分为以下三种
分页存储管理，分段存储管理和段页式存储管理。<br>

内存交换（Swapping）和虚拟内存（Virtual Memory）是两种不同的内存管理技术，它们的主要区别在于设计目的、实现方式和应用场景。以下是对这两种技术的详细比较：

### 3. 内存交换（Swapping）

- **设计目的**

内存交换的主要目的是在内存资源紧张时，通过将暂时不需要运行的进程换出到外存（如磁盘）中，同时将需要运行的进程换入到内存中，从而实现进程在内存与磁盘间的动态调度。

- **实现方式**

1. **换出**：当内存资源紧张时，操作系统会选择一些暂时不需要运行的进程，将它们的内存内容换出到外存（如磁盘）中。
2. **换入**：当需要运行某个进程时，如果该进程的内存内容已经被换出到外存，操作系统会将其换入到内存中。

- **应用场景**

内存交换通常在以下情况下发生：

- 当系统中的内存资源紧张，不足以容纳所有需要运行的进程时。
- 当系统中的某些进程长时间处于阻塞状态，占用了宝贵的内存资源时。
- 当系统需要为新的进程或线程分配内存，但内存空间不足时。

* **优缺点**

- **优点**：内存交换可以有效地利用内存资源，提高系统的并发性能。
- **缺点**：内存交换的开销较大，频繁的换入换出操作可能会导致系统性能下降。

### 4. 比较总结

| 特性     | 内存交换（Swapping）                     | 虚拟内存（Virtual Memory）                       |
| -------- | ---------------------------------------- | ------------------------------------------------ |
| 设计目的 | 动态调度进程，解决内存资源紧张问题       | 提供更大的虚拟地址空间，提高内存利用率和系统性能 |
| 实现方式 | 换出和换入进程的内存内容                 | 地址空间管理、内存分配与回收、页面置换、内存保护 |
| 应用场景 | 内存资源紧张时，进程换入换出             | 运行大程序，提高内存利用率和系统并发性能         |
| 优点     | 提高系统并发性能，利用内存资源           | 提高内存利用率和系统性能，提供内存保护功能       |
| 缺点     | 换入换出开销大，频繁操作可能导致性能下降 | 实现复杂度高，频繁页面置换可能导致性能下降       |

通过以上比较，可以看出内存交换和虚拟内存是两种不同的内存管理技术，它们在设计目的、实现方式和应用场景上都有所不同。内存交换主要用于解决内存资源紧张问题，而虚拟内存则通过提供更大的虚拟地址空间来提高内存利用率和系统性能。

请求页面置换策略有哪些方式？他们的区别是什么？各自有什么算法解决？虚拟内存实现有哪几种方式？
