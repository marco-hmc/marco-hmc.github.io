---
layout: post
title: 创建型模式
categories: 程序设计
related_posts: True
tags: 设计模式
toc:
  sidebar: left
---

## 创建型模式

创建模式（Creational Patterns）主要关注对象的创建过程。它们提供了一种创建对象的方式，使得对象的创建过程独立于使用这些对象的代码。创建模式通过封装实例化过程，帮助系统在创建对象时更加灵活和可扩展。
创建模式通过提供不同的对象创建方式，解决了对象创建过程中的各种问题。它们的共同点在于都关注对象的创建。

创建模式（Creational Patterns）有以下几种方法：

1. **工厂方法模式（Factory Method Pattern）**：

   - 定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法使一个类的实例化延迟到其子类。

2. **抽象工厂模式（Abstract Factory Pattern）**：

   - 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。抽象工厂模式通常用于创建一组相关的产品对象，这些对象可以一起工作。

3. **建造者模式（Builder Pattern）**：

   - 将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。建造者模式允许逐步构建对象，可以在构建过程中灵活地添加、修改或删除部件。

4. **原型模式（Prototype Pattern）**：

   - 通过复制现有对象来创建新对象，而不是通过实例化类。原型模式使用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象。

5. **单例模式（Singleton Pattern）**：
   - 确保一个类只有一个实例，并提供一个全局访问点来访问这个实例。单例模式通常用于需要全局唯一实例的场景，如配置管理、日志记录等。

### 1. 工厂方法/ 抽象工厂

在使用面向对象编程范式时，不直接使用构造函数构造对象，而是通过一个辅助类（通常称为工厂类）调用工厂类的创建方法来构造对象。
委托工厂类去构造对象的好处在于，可以一次创建若干相关对象，或者在创建对象时执行一些额外的操作。
工厂方法模式强调的是使用工厂类的创建方法创建对象，适用于需要在运行时决定实例化哪一个类的情况；

而抽象工厂模式强调的是工厂类的创建方法可以一次批量创建多个相关或相互依赖的对象，适用于需要创建一组相关或相互依赖的对象的情况。
通过这种方式，可以将对象的创建过程与使用过程分离，提高代码的灵活性和可扩展性。

### 2. 建造者

当构造函数很长，或者一个对象的构造非常复杂，就可以使用 builder 模式。
当一个对象可能有多种风格，并且为了避免构造函数伸缩问题时，使用建造者模式。与工厂模式的关键区别在于：工厂模式用于创建是一个步骤的过程，而建造者模式用于创建是多步骤的过程。

例如，假设我们要制作一个汉堡，汉堡有非常多的定制化选项，如是否需要双层芝士、是否需要洋葱、是否需要酸黄瓜等等。我们可以委托给汉堡建造者（Burger Builder）去完成，建造者会根据订单和状态，分步骤完成最终汉堡的构造。

1. **更好的控制**：建造者模式允许逐步构建对象，可以在构建过程中灵活地添加、修改或删除部件。
2. **代码可读性**：通过将构造过程分解为多个步骤，代码更加清晰易读。
3. **避免构造函数污染**：避免了构造函数参数过多的问题，使得对象的创建过程更加灵活。

建造者模式通过将复杂对象的构造过程分解为多个步骤，使得构造过程更加灵活和可控。它允许一步一步地构建对象，并且可以根据需要灵活地添加、修改或删除构建步骤，从而提高代码的可读性和维护性。

### 3. 原型模式

在 C++ 中，原型设计模式的概念相对较弱。其主要意图在于通过复用现有对象来创建新对象，而不是通过实例化类来创建新对象。在 C++ 中，我们可以通过拷贝构造函数或移动构造函数来实现类似的行为。因此，C++ 中的原型设计模式显得不那么明显。

### 4. 单例模式

单例模式简单来说，就是确保一个特定类的对象只被创建一次，并提供一个全局访问点来访问这个实例。但是存在这些缺点：

1. **难以调试**：单例模式在应用程序中引入了全局状态，在一个地方的更改可能会影响其他区域，导致调试变得困难。
2. **难以单元测试**：模拟单例可能会很困难，因为单例模式使得类的依赖关系变得紧密耦合，难以进行单元测试。
3. **隐藏依赖**：单例模式可能会隐藏类之间的依赖关系，使代码难以理解和维护。

尽管单例模式有一些缺点，但在以下条件都满足的时候，不必忌讳使用单例模式。使用单例模式即可。

1. **唯一性**：该类的对象在系统中应该只有一个实例。
2. **高可见性**：该实例需要在多个地方被访问和使用。
3. **生命周期不关心**：不需要关心该实例的生命周期管理。

以前存在线程安全问题，就会区分饿汉模式的单例和懒汉模式的单例。
但现在 modern c++当中，使用饿汉模式的 c++也可以延迟实例化和线程安全了。因此不再需要太区分这个概念了。

```c++
   static EagerSingleton& getInstance() {
      static EagerSingleton instance;
      return instance;
   }
```

### 总结

其实就是管理一个实例、一个对象如何创建。
如果要有基本的控制，就是工厂模式；如果有复杂的流程控制，
