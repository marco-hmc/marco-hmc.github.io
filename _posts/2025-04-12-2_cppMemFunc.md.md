---
layout: post
title: 特殊成员函数
categories: language
related_posts: True
tags: cpp grammar class
toc:
  sidebar: left
---

## 特殊成员函数

### 0. concepts

#### 0.1 六个特殊成员函数

```c++
class Example {
public:
    int value;
};

public:

Example::Example() : value(0) {}  // 一般构造

Example::~Example() {}  // 析构

// 拷贝构造
Example::Example(const Example& other) : value(other.value) {}

// 拷贝赋值
Example& Example::operator=(const Example& other) {
    if (this != &other) {
        value = other.value;
    }
    return *this;
}

// 移动构造
Example::Example(Example&& other) noexcept : value(other.value) {
    other.value = 0;
}

// 移动赋值
Example& Example::operator=(Example&& other) noexcept {
    if (this != &other) {
        value = other.value;
        other.value = 0;
    }
    return *this;
}
```

1. 默认构造函数（如果没有定义任何构造函数）
   `T()`
2. 析构函数（如果没有定义）
   `~T()`
3. 拷贝构造函数（如果没有定义并且某些条件满足）
   `T(const T& other)`
4. 拷贝赋值运算符（如果没有定义并且某些条件满足）
   `T& operator=(const T& other)`
5. 移动构造函数（如果没有定义并且某些条件满足，C++11 及以后）
   `T(T&& other)`
6. 移动赋值运算符（如果没有定义并且某些条件满足，C++11 及以后）
   `T& operator=(T&& other)`

这些函数被称为特殊成员函数。它们是编译器为了支持一些基本操作（如初始化、拷贝、移动、销毁对象）而自动为类生成的。但是，如果你为类定义了自己的版本，编译器就不会再生成这些函数。
除此不同函数，在不同特定条件下也不会自动生成。

### 1. 构造函数

#### 1.1 默认构造函数

编译器大部分情况下，都能生成默认构造函数，只有以下情形不可以。

1. 类中有一个没有默认构造函数的成员对象。
2. 基类没有默认构造函数。
3. 类中有一个 `const` 或 `引用` 类型的成员。
4. 类中有一个 `delete` 的默认构造函数。
5. 类中有一个私有的默认构造函数。
   简单来说，就是父类，成员变量没有默认构造，或者成员变量必须初始化的时候，没办法生成合法的默认构造函数。其他时候都能生成默认构造函数。

#### 1.2 对象的构造顺序

```cpp
C cObj;
    C::C()
        B::B()
            A::A()
                vptr = A::vftable;
                cout << "A::A()" << endl;
            vptr = B::vftable;
            cout << "B::B()" << endl;
        vptr = C::vftable;
        m_c = 11;
        cout << "C::C()" << endl;
```

#### 1.3 构造函数中对虚函数的调用

父类构造期间：在父类构造函数执行时，对象的虚函数表指针指向的是父类的虚函数表，因此调用虚函数时，会调用父类版本的虚函数。
子类构造期间：在子类构造函数执行时，虚函数表指针已经更新为指向子类的虚函数表，但在子类构造函数执行前，父类构造函数已经执行完毕，所以在父类构造函数里调用虚函数时，还是调用父类版本的虚函数。

### 2. 析构函数

当类没有自定义析构函数时，编译器会自动生成一个合成析构函数。

#### 2.1 合成析构函数行为

- **空函数**：如果类中没有自定义的资源管理（如动态分配的内存），合成的析构函数不会执行任何特定的操作，它仅仅是一个空函数。这意味着它不负责清理任何类成员的资源。
- **成员变量的析构**：如果类中有非静态成员变量，并且这些成员变量有自己的析构函数（无论是用户定义的还是合成的），合成的析构函数会按照这些成员在类声明中的逆序调用它们的析构函数。这样做确保了每个成员的资源被适当地释放。
- **基类析构函数的调用**：在继承层次中，如果基类有合成的析构函数，派生类的合成析构函数会在调用自己的析构函数之后自动调用基类的析构函数，同样保持逆序的原则。

#### 2.2 自定义析构函数的扩展行为

当我们自定义析构函数时，编译器会在适当的情况下扩展我们的析构函数代码，以确保所有资源都被正确释放。

- **成员变量的析构**：如果类成员 `m_j` 是一个类类型成员，并且这个成员 `m_j` 带有析构函数 `~JI()`，编译器会扩展类 `A` 的析构函数 `~A()` 代码，先执行类 `A` 的析构函数代码，再执行 `JI` 的析构函数代码。
- **基类析构函数的调用**：如果类 `A` 继承了一个基类，并且基类中带有析构函数，那么编译器会扩展类 `A` 的析构函数来调用基类的析构函数。这确保了基类的资源也能被正确释放。

### 3. 拷贝构造函数

#### 3.1 什么时候不会生成默认拷贝构造函数？

1. 类中显式声明/删除拷贝构造函数。
2. 类成员变量/基类有一个没有拷贝构造函数的成员对象。
3. 类中有一个 `const` 或 `引用` 类型的成员。

简单来说，如果你没有显式定义拷贝函数，且类中的所有成员都可以被拷贝，编译器就会为你生成这两个函数。
反过来说，如果类中有不能被拷贝的成员（例如，`std::unique_ptr`或者定义了删除的拷贝构造函数的类型的成员），编译器就不会生成这两个函数。

#### 3.2 生成的拷贝构造函数有什么特殊行为？

- 逐bit的拷贝构造（或者说没有拷贝构造）

  - 类没有用户自定义的拷贝构造函数。
  - 类没有虚函数。
  - 类没有基类或者基类没有自定义的拷贝构造函数。
  - 类的所有非静态数据成员都可以进行位逐次拷贝。
    这个时候拷贝的表现是类似于`memset()`的方式的，因此不会调用到这个拷贝构造函数，有些书本也会说这个过程不会调用拷贝构造。

- 一般的拷贝构造
  - 能逐bit拷贝的逐bit拷贝
  - 虚函数指针不会被覆盖
  - 调用父类子类的拷贝构造函数，再调用自己的。

#### 3.3 什么时候会调用拷贝构造函数？

```c++
    Foo func(Foo foo){  // foo was passed by copy
        return Foo{};
    }

    Foo foo;
    Foo copiedFoo = foo; // assignment was done by copy
    auto newFoo = func(foo);  // return val was copied to newFoo
```

#### 3.4 为什么拷贝的形参是`const T&`？？

1. **性能**:当参数是值时,会创建该对象的一个新的副本,这涉及到对象的复制操作,可能会消耗大量的时间和内存.特别是当对象较大时,复制的代价会非常高.而当参数是常量引用时,只需要传递引用,不需要复制对象,因此性能更高.

2. **避免无限递归**:如果拷贝构造函数的参数是值,那么在调用拷贝构造函数时,需要先创建一个新的对象,这又需要调用拷贝构造函数,从而形成无限递归,导致程序崩溃.而当参数是常量引用时,不会触发拷贝构造函数,因此可以避免无限递归.

所以,拷贝构造函数的参数通常是常量引用,而不是值.

### 4. 移动构造函数

#### 4.1 什么时候会生成移动构造函数/移动赋值函数？

- 没有析构、拷贝构造、拷贝赋值的时候
- 所有成员变量都可以移动。

简单来说，从 C++11 开始，如果你没有显式定义析构、拷贝构造、拷贝赋值这三个函数，且类中的所有成员都可以被移动，编译器就会为你生成这两个函数。
反过来说，如果类中有不能被移动的成员（例如，定义了删除的移动构造函数的类型的成员）；或者你已经定义了拷贝构造函数、拷贝赋值运算符或析构函数，编译器就不会生成这两个函数。

#### 4.3 移动的时候如果不将原来的置空会怎样？

在编程中，"移动"通常指的是移动语义，这是 C++11 引入的一个新特性。移动语义允许资源（如动态分配的内存）从一个对象转移到另一个对象，这样可以避免不必要的临时对象的复制。

如果在移动操作后不将原对象置空，可能会导致一些问题。例如，如果原对象是一个拥有动态分配内存的对象，那么当原对象和新对象都试图释放同一块内存时，就会发生双重删除，这会导致程序崩溃。

因此，通常在执行移动操作后，我们会将原对象置空或设置为一个安全的状态，以防止这种问题的发生。

#### 4.5 为什么移动的构造赋值用 noexcept，但是拷贝的没有？

移动操作：通常仅转移资源指针，不会抛出异常（如std::vector的移动构造保证noexcept）。声明noexcept允许编译器进行优化（如std::vector在空间不足时，优先移动而非拷贝元素）。
拷贝操作：可能涉及资源分配（如new），可能抛出异常（如内存不足），因此不能标记为noexcept。
标准库约束：
C++ 标准要求，若移动构造函数未标记noexcept，容器（如std::vector）在扩容时会退化为拷贝操作，丧失移动优化的优势。

### 5. 成员初始化列表

#### 5.1 何时需要初始化列表

```c++
class Base {
  public:
    explicit Base(int value) : baseValue(value) {}

  private:
    int baseValue;
};

class AnotherClass {
  public:
    explicit AnotherClass(int num) : number(num) {}

  private:
    int number;
};

class Derived : public Base {
  public:
    // 3. 类继承自一个基类，基类中有构造函数，构造函数里还有参数
    Derived(int& refValue, int constValue, int baseInitValue,
            int anotherClassInitValue)
        : Base(baseInitValue),
          ref(refValue),
          constMember(constValue),
          another(anotherClassInitValue) {
        std::cout << "Derived constructor called" << std::endl;
    }

  private:
    int& ref;               // 1. 成员变量是引用类型
    const int constMember;  // 2. 成员变量是 const
    // 4. 类中成员变量的类型是某个类类型，类类型的构造函数有参数
    AnotherClass another;
};
```

1. 成员变量是引用类型，引用必须在构造时(初始化时)就需要绑定对象。
2. 成员变量是 const
3. 类继承自一个基类，基类中有构造函数，构造函数里还有参数。
4. 类中成员变量的类型是某个类类型，类类型的构造函数有参数。

其实不初始化会报错，所以知道一下就行。

#### 5.2 初始化列表的优势

- 提升程序运行效率
- 主要是类类型放在初始化列表中效率较高，其他简单类型效率基本一致。
  1. 对于类类型的提升明显，因为生成临时对象再析构开销较大。
  2. 内置类型不明显。
  3. 尽可能使用初始化成员列表。

1. 初始化列表中的代码可以看作是编译器安插在构造函数之中的。
2. 初始化列表中的代码是在构造函数的函数体代码执行前被执行的。
3. 初始化列表中成员变量的初始化顺序看的是成员变量在类中定义的顺序，而不是在初始化列表中出现的顺序。
   - 如果有类类型成员类型，在进入函数体前，类类型成员类型就已经被调用默认构造函数生成了。

- 如果函数体内初始化，则会产生一个临时对象进行拷贝赋值运算符，效率很低。因此最好使用初始化列表进行调用该类类型的构造函数。
- 当使用初始化列表时，则会直接调用构造函数，提高了效率。
- 可以把初始化列表理解为函数体内的正常语句。只是在所有的代码前执行。

### 6. 成员函数

#### 6.1 成员函数的调用方式

- 对于非静态成员函数：

  1. **非静态成员函数:C++会保证至少和一般的普通的函数有相同的效率,经过三个步骤的转换**

  - 非静态成员函数是指那些需要通过对象实例来调用的成员函数。
  - C++ 保证非静态成员函数的调用效率至少与普通函数相同。为了实现这一点，编译器会对非静态成员函数进行一些转换。

  2. **改写函数,安插一个额外的参数到该函数中,用来提供一个存取管道------即 this 指针**

  - 编译器会将非静态成员函数改写为一个普通函数，并插入一个额外的参数，这个参数就是 `this` 指针。
  - `this` 指针指向调用该成员函数的对象实例，提供了对对象成员变量和其他成员函数的访问。

  3. **对每一个非静态成员的存取操作改成使用 this 指针来调用**

  - 在改写后的函数中，所有对非静态成员变量和成员函数的访问都会通过 `this` 指针来进行。
  - 例如，访问成员变量 `x` 会被改写为 `this->x`。

  4. **将成员函数改写成一个外部函数,并且名称改为独一无二的**

  - 编译器会将成员函数改写为一个外部函数，并为其生成一个独一无二的名称，以避免与其他函数冲突。
  - 这个独一无二的名称通常包含类名和成员函数名。

#### 6.2 虚函数成员函数的调用？

### 99. quiz

#### 1. 为什么基类的析构函数要声明 `virtual`?

因为存在多态情况，取到一个父类型指针的时候，其实际类型也许是某一个派生类的。
当如果你有一个基类指针指向一个派生类对象:

```c++
Copy code
Base* ptr = new Derived();
delete ptr; // 这里会首先调用Derived的析构函数,然后调用Base的析构函数
```

如果基类的析构函数不是虚函数,那么只会调用基类的析构函数,而 Derived 的析构函数将不会被调用,可能导致资源泄漏.

另外注意，派生类的析构函数是一定会隐式调用父类析构的。
因此父类的资源由父类管理，子类不需要管理。

> 简单回忆构造析构顺序：父构-子构-子析-父析
> 拷贝的时候也是：父拷--子拷的顺序

#### 2. 如果父类声明了虚析构，那么同样地，拷贝，移动也需要是虚的吗？

不需要。

父类声明虚析构函数是为了确保析构方法被正确调用。对于多态类型来说，析构方法通常会在某个 RAII（资源获取即初始化）管理器中调用，或者在对象自身被销毁时调用。如果此时的类型是基类类型，就无法正确释放派生类的资源。例如，在一个 `std::vector<Animal*>` 的容器中，释放这些资源时，虚析构函数是必要的。

然而，拷贝构造函数和移动构造函数本质上属于构造方法，在构造过程中不能使用虚函数。这是因为，在对象的构造过程中，首先调用基类的构造函数，然后调用派生类的构造函数。在基类的构造函数执行时，派生类的部分尚未构造完成。

如果我们希望编译器支持构造函数调用虚方法，

- 在父类的构造函数的时候，虚函数指针指向的也是基类虚函数表。
- 因为子类的虚函数可能依赖子类成员变量，不应该被调用。
- 出于安全考虑，父虚函数指针只能指向父类方法。
- 在子类的时候，虚函数指针才能指向子类虚函数表
  如此一来，父类走父类方法，子类走子类方法，多态特性无从体现了。
  还非常容易出现混淆，因此构造函数不可以调用虚方法。
  对于拷贝、移动情况也是类型的。因为也是先完成父类拷贝，才执行子类拷贝。

#### 3. 为什么虚函数指针不能被拷贝？

```c++
#include <iostream>

class Animal {
   public:
    Animal() { std::cout << "Animal constructor" << std::endl; }

    Animal(const Animal& other) {
        std::cout << "Animal copy constructor" << std::endl;
    }

    virtual void eat() { std::cout << "Animal eats" << std::endl; }
};

class Dog : public Animal {
   public:
    Dog() { std::cout << "Dog constructor" << std::endl; }

    void eat() override { std::cout << "Dog eats" << std::endl; }
};

int main() {
    Animal dog = Dog();  // 对象切片，调用 Animal 的拷贝构造函数
    dog.eat();           // 调用 Animal::eat()
    return 0;
}

/*
1. 为什么调用的是animal::eat()方法？

2. Animal dog = Dog();这个过程发生了什么？
    抛开Dog的构造过程，Animal dog = Dog()，这个过程是拷贝构造，调用了Animal的拷贝构造函数。
    由于 `Animal` 类的拷贝构造函数的形参是 `const Animal&`，因此需要将 `Dog` 对象转换为 `Animal` 对象。
    也就是说dog首先会发生一次隐式转换。
    在这个过程中Dog()的部分会被切掉，只剩下Animal的部分，被拷贝到dog中，
    因为dog在栈上申请内存的时候是按照Animal的大小申请的，dog的内存布局是按照Animal来的。
    所以切掉Dog()的部分，只剩下Animal的部分是显然的。
    这个过程就是对象切片。

    根据结果我们知道，虚函数指针也被切掉了。那为什么虚函数指针也被切掉了呢？

    如果派生类有虚函数指针的时候，父类没有虚函数指针，因此Dog的虚函数指针被切掉了。是很好理解的。
    可如果父类有虚函数指针，为什么不能直接拷贝子类的虚函数指针呢？
    这是为了安全考虑，编译器禁止了这种行为。
    如果子类的虚函数指针被拷贝到父类的对象中，那么在这个对象就可以调用子类的虚函数。
    这个时候子类的虚函数有可能是使用了子类特有的类成员变量的，但是父类的对象中并没有这个成员变量，因此会出现问题的。
    因此编译器在设计的时候，为了避免这个问题，直接将子类的虚函数指针给切掉了。

*/
```

#### 4. 成员函数模板可以为虚函数吗？

如果允许存在虚函数模板，那么每次以不同的模板类型调用虚函数模板时，都会生成一个新的虚函数实例。这意味着虚函数表的内容只能在程序链接阶段才能确定，而无法在编译阶段确定。

如果虚函数表的内容只能在链接阶段确定，链接器需要重新解析和调整所有涉及虚函数调用的代码，这会增加链接器的复杂性和工作量。

成员函数模板不能为虚函数，因为虚函数表的大小是固定的，而成员函数模板的实例化个数要编译完成后才能确定

- 虚函数可以是模板的吗？

不，虚函数不能是模板函数。虚函数依赖于虚函数表（vtable）来实现运行时多态，而模板函数在编译时根据模板参数的不同实例化为不同的函数。因为模板实例化发生在编译时，而虚函数的动态绑定发生在运行时，所以二者的机制不兼容。

简而言之，虚函数的多态性是在运行时通过虚函数表解析的，而模板函数的多态性是在编译时通过生成不同的函数实例来实现的。因此，虚函数不能是模板函数。

#### 5. 类的构造、析构出现异常会怎么样？怎么处理？

当构造函数中使用 `new` 操作符分配内存时，如果分配成功，资源会被分配给指针变量。如果在构造函数的某个 `new` 操作之后抛出异常，构造函数会立即退出，且不会调用析构函数，因为对象还没有完全构造出来。

然而，已经成功构造的成员变量会被自动销毁，这意味着它们的析构函数会被调用，从而释放已经分配的资源。
可如果成员变量是堆上的资源，则会出现资源泄露问题。因此最好是使用智能指针去管理。因为智能指针对于这个类来说，是栈上的资源。栈上的资源即使抛出异常也会正常释放。

类的析构函数也是类似的。
类的构造和析构一般是和资源相关的，资源通过智能指针可以保证异常安全的。

构造函数中的异常处理：

当构造函数中使用 new 操作符分配内存时，如果分配成功，资源会被分配给指针变量。
如果在构造函数的某个 new 操作之后抛出异常，构造函数会立即退出，且不会调用析构函数，因为对象还没有完全构造出来。
但是，已经成功构造的成员变量会被自动销毁，这意味着它们的析构函数会被调用，从而释放已经分配的资源。
智能指针的作用：

使用智能指针（如 std::unique_ptr）可以确保资源在异常发生时自动释放。智能指针在其析构函数中会自动释放所管理的资源，即使在异常情况下也不例外。

#### 6 为什么拷贝赋值、移动复制要判断 this 指针不相同？

拷贝赋值：若先释放自身资源，再拷贝other，会导致「释放自己的资源后，无法从other拷贝」（如other已被释放）。
移动赋值：若直接窃取other的资源而不判断，会导致「自己释放自己的资源」（如data = other.data; other.data = nullptr;在自赋值时，data被置空）。

#### 7. 如果我的拷贝被构造函数用`T& other`会怎么样？

简单来说，以拷贝构造函数为例，即使不使用`const T& other`作为形参，而是使用`T& other`也是可以声明拷贝构造函数的。但一般来说，我们需要`override`编译器默认生成的拷贝构造函数，而且`const T& other`会比`T& other`好，因为使用`const T& other`作为参数，可以从任何对象（包括 const 对象和临时对象）中拷贝。

> 临时对象（也称为右值）是不能绑定到非 const 的左值引用上的，但可以绑定到 const 的左值引用上。这是 C++语言规则的一部分，主要是为了保护临时对象不被意外修改。

#### 9. 为什么要声明 `override`?

对于开发人员来说：可以明确意图，提高可读性和维护性；
对于编译器来说：让编译器检查函数签名是否匹配。

虽然使用 `override` 和不使用 `override` 生成的代码是一样的，去掉已有代码中的所有 `override` 关键字也不会改变程序的运行时行为，但为了提高代码的可读性和可维护性，并避免潜在的错误，建议在重写基类虚函数时使用 `override` 关键字。

1. **明确意图**

   - `override` 关键字明确表示派生类中的函数是重写基类中的虚函数。
   - 这有助于代码的可读性和可维护性，使得代码意图更加清晰。
   - `override` 关键字本身不会改变程序的运行时行为，它的主要作用是提升代码的可读性和可维护性，并且提供编译器检查功能。
     以下是详细解释：

2. **编译器检查**

   - 使用 `override` 关键字可以让编译器检查函数签名是否正确匹配基类中的虚函数。
   - 如果函数签名不匹配，编译器会报错，避免潜在的错误。
   - 示例：

     ```cpp
     class Base {
     public:
         virtual void func(int) {}
     };

     class Derived : public Base {
     public:
         void func(int) override { // 正确匹配基类函数
             // Derived 的具体实现
         }
     };
     ```

3. **防止意外重载**

   - 如果派生类中的函数签名与基类中的虚函数不匹配，编译器会将其视为新的函数，而不是重写基类函数。
   - 使用 `override` 可以防止这种意外重载的情况。
   - 示例：

     ```cpp
     class Base {
     public:
         virtual void func(int) {}
     };

     class Derived : public Base {
     public:
         void func(double) override { // 编译错误，签名不匹配
             // Derived 的具体实现
         }
     };
     ```

4. **提高代码质量**
   - 使用 `override` 关键字可以提高代码质量，减少错误，提高代码的健壮性和可维护性。

#### 10. 继承的析构函数一般要怎么处理？继承的特殊成员函数怎么处理？

如果有基类，这个类的析构函数一般就得是虚的。
对于默认构造函数（无参构造）不管是 override 还是使用默认的，派生类都会自动调用父类的构造方法，不需要额外操作。
但是如果是有参的构造方法，基类不会知道要传入什么参数，因此都得手动调用父类的构造方法。
很多时候会出现的情况是，父类同时支持默认构造和有参构造，派生类使用有参构造的时候，没有显式调用父类的构造方法，因此默认走的是父类的无参构造。
注意，为了避免重复调用父类的构造方法，必须是通过初始化列表去调用。

而对于拷贝构造、拷贝赋值、移动构造、移动赋值而言，也是一样首先在初始化列表调用父类的方法，再实现派生类逻辑。
注意，对于移动来说，不需要担心资源安全问题。因为初始化列表，看上去是`std::move(other)`整个对象都被移动走了，但是父类只会处理父类资源，子类资源还是可以放心继续使用。可以说初始化列表的 move 只是部分移动，因此派生类继续使用 other 对象完成子类资源的移动是安全的。

总结如下：

- 基类的析构函数应声明为虚函数，以确保正确调用派生类的析构函数。
- 派生类的构造函数应显式调用基类的构造函数，尤其是带参数的构造函数。
- 派生类的复制构造函数、复制赋值运算符、移动构造函数和移动赋值运算符应显式调用基类的相应函数，以确保基类部分正确复制或移动。

#### 11. 拷贝构造函数实现方式可以用`memcpy()`方法吗？

最好不要。
正如前面说的，编译器会往类内部增加一些我们看不见 但真实存在的成员变量（隐藏成员变量），比如说虚函数指针。
使用`memcpy()`进行逐 bit 的拷贝的时候，虚函数指针往往不能够被正确处理。

#### 12. 为什么移动构造函数一般情况下会比拷贝构造函数快？

#### 13. 为什么移动的形参是`T&&`？？

#### 14. 普通继承与虚继承构造顺序的区别

在普通继承中，派生类对象构造时，会先调用基类的构造函数，再调用自身的构造函数。例如，如果 `B` 普通继承自 `A`，那么创建 `B` 对象时，会先调用 `A` 的构造函数，再调用 `B` 的构造函数。

但在虚继承中，为了确保虚基类在整个继承体系中只有一份实例，最底层的派生类会直接控制虚基类的构造。

- **具体到当前代码的构造顺序**

当创建 `D` 类的对象时，构造顺序如下：

1. **调用虚基类 `A` 的构造函数**：`D` 类对象在构造时，会首先调用虚基类 `A` 的构造函数，创建 `A` 部分（`A part`）。这是因为 `D` 是最底层的派生类，它要保证 `A` 只有一份实例。
2. **调用 `B` 的构造函数**：`B` 的构造函数在执行时，不会再去构造 `A`，因为 `A` 已经由 `D` 构造好了。`B` 构造函数可能会做一些与自身相关的初始化工作，同时初始化 `vbp of B` 指向对应的虚基类表。
3. **调用 `C` 的构造函数**：同理，`C` 的构造函数也不会再构造 `A`，而是进行自身的初始化工作，并初始化 `vbp of C` 指向对应的虚基类表。
4. **调用 `D` 的构造函数**：最后调用 `D` 自身的构造函数，完成 `D` 类对象的剩余初始化工作。

```cpp
#include <iostream>

class A {
public:
    A() {
        std::cout << "A's constructor is called." << std::endl;
    }
};

class B : public virtual A {
public:
    B() {
        std::cout << "B's constructor is called." << std::endl;
    }
};

class C : public virtual A {
public:
    C() {
        std::cout << "C's constructor is called." << std::endl;
    }
};

class D : public B, public C {
public:
    D() {
        std::cout << "D's constructor is called." << std::endl;
    }
};

int main() {
    D d;
    return 0;
}
/*
A's constructor is called.
B's constructor is called.
C's constructor is called.
D's constructor is called.
*/
```

#### 15. 如果在构造函数中调用 memset(this, 0, sizeof(\*this))来初始化内存空间，有什么问题吗？
