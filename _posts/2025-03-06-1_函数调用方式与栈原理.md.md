---
layout: post
title: C 函数调用方式与栈原理
categories: language
related_posts: True
tags: asm
toc:
  sidebar: left
---

## C 函数调用方式与栈原理

### 1. concepts

理解原理的时候，不妨少一些抽象。让我们从cpu开始想，是怎么完成函数调用的。
cpu无法是从内存读指令，计算，然后将结果写回到内存。
对cpu来说是没有函数这一回事的，只有一个个的指令。

那函数是对什么的抽象呢？函数是指令的集合、函数参数以及局部变量的集合。
更准确的说，函数集合的表示是通过目标指令地址表示的，如果切换到另一个指令，这个集合就完整了。

假设程序已经在运行了，这个时候要发生一次函数调用。

这个时候指令的地址就发生了变化，但是完成函数调用之后还要回来，因此要传入目标指令地址，记住当前指令地址。
如果有函数参数的话，要怎么传过去呢？
也简单，把这些参数变量什么的，全部压入栈，
（从栈读值的时候，取回来不需要从栈顶一个一个pop掉，才能取出目标值，可以直接通过偏移在栈里面取出目标值。）
（栈的偏移值的正确性是由编译器保证的，比如说当前函数有2个函数参数，5个局部变量，第一个函数参数可能就是第stack.offset(6),最后一个局部变量可能就是stack.offset(0)。切换函数的时候，这些偏移都不会变，函数切过去的时候会压栈，都是执行完又会出栈，就还是这些偏移了。）

#### 1. 一个典型的栈帧

```
+----------------------+
| 上一个栈帧的帧指针   | <-- 上一个栈帧的帧指针（旧的 EBP），用于函数返回时恢复调用者的栈帧。
+----------------------+
| 返回地址             | <-- 返回地址（调用函数的下一条指令地址），用于函数返回时跳转到调用函数的正确位置。
+----------------------+
| 函数参数             | <-- 函数参数（从右到左依次压入栈）
+----------------------+
| 局部变量             | <-- 局部变量（函数内部定义的变量）
+----------------------+
| 临时数据             | <-- 临时数据（如中间计算结果）
+----------------------+
| 保存的寄存器         | <-- 保存的寄存器（如调用者保存寄存器），用于函数返回时恢复调用者的寄存器状态。
+----------------------+
| 当前栈帧的帧指针     | <-- 当前栈帧的帧指针（新的 EBP），用于访问当前栈帧中的数据。
+----------------------+
```

1. **函数调用时**：

   - 调用函数时，调用者会将返回地址压入栈，并跳转到被调用函数的入口。
   - 被调用函数会在栈上分配一个新的栈帧，并保存上一个栈帧的帧指针。
   - 被调用函数会将新的帧指针设置为当前栈顶，并在栈帧中分配局部变量和临时数据的空间。

2. **函数返回时**：
   - 被调用函数会将返回值（如果有）存储在约定的寄存器或栈上。
   - 被调用函数会恢复上一个栈帧的帧指针，并跳转到返回地址。
   - 调用者会从栈上弹出返回地址，并继续执行调用函数的下一条指令。

#### 2. 栈调用涉及哪些寄存器，其作用是什么?

在栈调用中，涉及到以下几个寄存器:

1. ESP(Extended Stack Pointer):栈指针寄存器，用于指示栈的当前位置，即栈顶的地址。在函数调用过程中，ESP 会被用来分配和释放栈空间，以及保存函数的局部变量和临时变量。
2. EBP(Extended Base Pointer):基址指针寄存器，也称为帧指针寄存器。EBP 的值被用作栈帧的基准指针，通过对 EBP 加上偏移量，可以访问函数的参数和局部变量。EBP 的主要作用是提供一个固定的参考点，使得在函数调用过程中可以方便地访问栈中的数据。
3. EAX/ECX/EDX:这些寄存器被称为调用者保存寄存器。在函数调用前，如果调用者希望保留这些寄存器的值，需要将它们压入栈中。被调用者在函数调用结束后，需要将这些寄存器的值恢复到之前的状态。
4. EBX/ESI/EDI:这些寄存器被称为被调用者保存寄存器。如果被调用者在函数执行过程中需要使用这些寄存器，需要将它们保存在栈中，并在函数调用结束后恢复它们的值。调用者不需要关心这些寄存器的值。

**ESP 被 foo 使用来指示栈顶。EBP 相当于一个"基准指针"**.

这些寄存器在函数调用过程中的作用是为了保存和传递数据，以及保持寄存器的状态。通过合理地使用这些寄存器，可以提高函数调用的效率和灵活性。

![](./imgs/stack1.png)

图 1 是一个典型的栈帧，图中，栈顶在上，地址空间往下增长。

```cpp
int foo(int arg1， int arg2， int arg3);
```

并且，foo 有两个局部的 int 变量（4 个字节）。在这个简化的场景中，main 调用 foo，而程序的控制仍在 foo 中。这里，main 是调用者（caller），foo 是被调用者（callee）。

从 main 传递到 foo 的参数以及 foo 本身的局部变量都可以通过这个基准指针为参考，加上偏移量找到。
由于被调用者允许使用 EAX，ECX 和 EDX 寄存器，所以如果调用者希望保存这些寄存器的值，就必须在调用子函数之前显式地把他们保存在栈中。
另一方面，如果除了上面提到的几个寄存器，被调用者还想使用别的寄存器，比如 EBX，ESI 和 EDI，那么，被调用者就必须在栈中保存这些被额外使用的寄存器，并在调用返回前回复他们。也就是说，如果被调用者只使用约定的 EAX，ECX 和 EDX 寄存器，他们由调用者负责保存并回复，但如果被调用这还额外使用了别的寄存器，则必须有他们自己保存并回复这些寄存器的值。
传递给 foo 的参数被压到栈中，最后一个参数先进栈，所以第一个参数是位于栈顶的。foo 中声明的局部变量以及函数执行过程中需要用到的一些临时变量也都存在栈中。

**小于等于 4 个字节的返回值会被保存到\*\***EAX\***\*中**，如果大于 4 字节，小于 8 字节，那么 EDX 也会被用来保存返回值。如果返回值占用的空间还要大，那么调用者会向被调用者传递一个额外的参数，这个额外的参数指向将要保存返回值的地址。用 C 语言来说，就是函数调用：

```cpp
x = foo(a， b， c);
```

被转化为：

```cpp
foo(&x， a， b， c);
```

注意，这仅仅在返回值占用大于**8 个字节**时才发生。有的编译器不用 EDX 保存返回值，所以当返回值大于 4 个字节时，就用这种转换。
当然，并不是所有函数调用都直接赋值给一个变量，还可能是直接参与到某个表达式的计算中，如：

```cpp
m = foo(a， b， c) + foo(d， e， f);
```

有或者作为另外的函数的参数， 如：

```cpp
fooo(foo(a， b， c)， 3);
```

这些情况下，foo 的返回值会被保存在一个临时变量中参加后续的运算，所以，foo(a， b， c)还是可以被转化成**foo(&tmp， a， b， c)**。

让我们一步步地看一下在 c 函数调用过程中，一个栈帧是如何建立及消除的。

### 函数调用前调用者的动作

在我们的例子中，调用者是 main，它准备调用函数 foo。在函数调用前，main 正在用 ESP 和 EBP 寄存器指示它自己的栈帧。

首先，main 把 EAX，ECX 和 EDX 压栈。这是一个可选的步骤，只在这三个寄存器内容需要保留的时候执行此步骤。
接着，main 把传递给 foo 的参数一一进栈，最后的参数最先进栈。例如，我们的函数调用是：

```cpp
a = foo(12， 15， 18);
```

相应的汇编语言指令是：

```cpp
push dword 18
push dword 15
push dword 12
```

最后，main 用 call 指令调用子函数：

```cpp
call foo
```

**当 call 指令执行的时候，EIP 指令指针寄存器的内容被压入栈中**。因为 EIP 寄存器是指向 main 中的下一条指令，所以现在返回地址就在栈顶了。在 call 指令执行完之后，下一个执行周期将从名为 foo 的标记处开始。
图 2 展示了 call 指令完成后栈的内容。图 2 及后续图中的**粗线**指示了函数调用前栈顶的位置。我们将会看到，当整个函数调用过程结束后，栈顶又回到了这个位置。

![](./imgs/stack2.png)

### 被调用者在函数调用后的动作

当函数 foo，也就是被调用者取得程序的控制权，它**必须做 3 件事**：建立它自己的栈帧，为局部变量分配空间，最后，如果需要，保存寄存器 EBX，ESI 和 EDI 的值。
首先 foo 必须建立它自己的栈帧。EBP 寄存器现在正指向 main 的栈帧中的某个位置，这个值必须被保留，因此，EBP 进栈。然后 ESP 的内容赋值给了 EBP。这使得函数的参数可以通过对 EBP 附加一个偏移量得到，而栈寄存器 ESP 便可以空出来做其他事情。如此一来，几乎所有的 c 函数都由如下两个指令开始：

```assembly
push ebp
mov ebp， esp
```

此时的栈入图 3 所示。在这个场景中，第一个参数的地址是 EBP 加 8，因为 main 的 EBP 和返回地址各在栈中占了 4 个字节。

![](./imgs/stack3.png)

​下一步，foo 必须为它的局部变量分配空间，同时，也必须为它可能用到的一些临时变量分配空间。比如，foo 中的一些 C 语句可能包括复杂的表达式，其子表达式的中间值就必须得有地方存放。这些存放中间值的地方同城被称为临时的，因为他们可以为下一个复杂表达式所复用。为说明方便，我们假设我们的 foo 中有两个 int 类型（每个 4 字节）的局部变量，需要额外的 12 字节的临时存储空间。简单地把栈指针减去 20 便为这 20 个字节分配了空间：

```assembly
sub esp， 20
```

现在，局部变量和临时存储都可以通过基准指针 EBP 加偏移量找到了。
最后，如果 foo 用到 EBX，ESI 和 EDI 寄存器，则它 f 必须在栈里保存它们。结果，现在的栈如图 4 所示。

![](./imgs/stack4.png)

​

foo 的函数体现在可以执行了。这其中也许有进栈、出栈的动作，栈指针 ESP 也会上下移动，但 EBP 是保持不变的。这意味着我们可以一直用[EBP+8]找到第一个参数，而不管在函数中有多少进出栈的动作。
函数 foo 的执行也许还会调用别的函数，甚至递归地调用 foo 本身。然而，只要 EBP 寄存器在这些子调用返回时被恢复，就可以继续用 EBP 加上偏移量的方式访问实际参数，局部变量和临时存储。

### 被调用者返回前的动作

在把程序控制权返还给调用者前，被调用者 foo 必须先把返回值保存在**EAX**寄存器中。我们前面已经讨论过，当返回值占用多于 4 个或 8 个字节时，接收返回值的变量地址会作为一个额外的指针参数被传到函数中，而函数本身就不需要返回值了。这种情况下，被调用者直接通过内存拷贝把返回值直接拷贝到接收地址，从而省去了一次通过栈的中转拷贝。
其次，foo 必须恢复 EBX，ESI 和 EDI 寄存器的值。如果这些寄存器被修改，正如我们前面所说，我们会在 foo 执行开始时把它们的**原始值压入栈中**。如果 ESP 寄存器指向如图 4 所示的正确位置，寄存器的原始值就可以出栈并恢复。可见，在 foo 函数的执行过程中正确地跟踪 ESP 是多么的重要————也就是说，进栈和出栈操作的次数必须保持平衡。
这两步之后，我们不再需要 foo 的局部变量和临时存储了，我们可以通过下面的指令消除栈帧：

```
mov esp， ebp
pop ebp
```

其结果就是现在栈里的内容跟图 2 中所示的栈完全一样。现在可以执行返回指令了。从栈里弹出返回地址，赋值给 EIP 寄存器。栈如图 5 所示：

![](./imgs/stack5.png)

i386 指令集有一条**“leave”**指令，它与上面提到的 mov 和 pop 指令所作的动作完全相同。所以，C 函数通常以这样的指令结束：

```
leave
ret
```

### 调用者在返回后的动作

在程序控制权返回到调用者（也就是我们例子中的 main）后，栈如图 5 所示。这时，传递给 foo 的参数通常已经不需要了。我们可以把 3 个参数一起弹出栈，这可以通过把栈指针加 12（=3 个 4 字节）实现：

```
add esp， 12
```

如果在函数调用前，EAX，ECX 和 EDX 寄存器的值被保存在栈中，调用者 main 函数现在可以把它们弹出。这个动作之后，栈顶就回到了我们开始整个函数调用过程前的位置，也就是图 5 中粗线的位置。

看个具体的实例：

这段代码反汇编后，代码是什么呢？

```
#include <stdio.h>
long test(int a， int b)
{
	a = a + 3;
	b = b + 5;
	return a + b;
}

int main(int argc， char* argv[])
{
	printf("%d"， test(10，90));
	return 0;
}
```

先来看一个概貌：

```
9:   int main(int argc， char* argv[])
10:   {
00401070   push        ebp
00401071   mov         ebp，esp
00401073   sub         esp，40h
00401076   push        ebx
00401077   push        esi
00401078   push        edi
00401079   lea         edi，[ebp-40h]
0040107C   mov         ecx，10h
00401081   mov         eax，0CCCCCCCCh
00401086   rep stos    dword ptr [edi]
11:        printf("%d"，test(10，90));
00401088   push        5Ah
0040108A   push        0Ah
0040108C   call        @ILT+0(test) (00401005)
00401091   add         esp，8
00401094   push        eax
00401095   push        offset string "%d" (0042201c)
0040109A   call        printf (004010d0)
0040109F   add         esp，8
12:        return 0;
004010A2   xor         eax，eax
13:   }
```

下面来解释一下，

![](./imgs/stack6.png)
开始进入 Main 函数 esp=0x12FF84 ebp=0x12FFC0
完成椭圆形框起来的部分：

```
00401070   push        ebp
```

**ebp 的值入栈，保存现场(调用现场**，从 test 函数看，如红线所示，即保存的 0x12FF80 用于从 test 函数堆栈返回到 main 函数)：

```
00401071    mov        ebp，esp
```

此时 ebp ＝ 0x12FF80 **此时 ebp 就是“当前函数堆栈”的基址 以便访问堆栈中的信息；还有就是从当前函数栈顶返回到栈底：**

```
00401073     sub        esp，40h
```

函数使用的堆栈，默认 64 个字节，堆栈上就是 16 个横条（密集线部分）此时 esp=0x12FF40。
在上图中，上面密集线是 test 函数堆栈空间，下面是 Main 的堆栈空间(补充，其实这个就叫做 **Stack Frame**)：

```
00401076   push        ebx
00401077   push        esi
00401078   push        edi    入栈
00401079   lea         edi，[ebp-40h]
0040107C   mov         ecx，10h
00401081   mov         eax，0CCCCCCCCh
00401086   rep stos    dword ptr [edi]
```

初始化用于该函数的栈空间为 0XCCCCCCCC，即从 0x12FF40~0x12FF80 所有的值均为 0xCCCCCCCC：

```
11:        printf("%d"，test(10，90));
00401088   push        5Ah    参数入栈 从右至左 先90  后10
0040108A   push        0Ah
0040108C   call        @ILT+0(test) (00401005)
```

函数调用，转向 eip 00401005 。
**注意，此时仍入栈，入栈的是 call test 指令下一条指令的地址 00401091 下一条指令是 add esp，8。**
@ILT+0(?test@@YAJHH@Z):

```
00401005   jmp       test (00401020)
```

即转向被调函数 test：

```
 2:    long test(int a，int b)
 3:    {
00401020   push        ebp
00401021   mov         ebp，esp
00401023   sub         esp，40h
00401026   push        ebx
00401027   push        esi
00401028   push        edi
00401029   lea         edi，[ebp-40h]
0040102C   mov         ecx，10h
00401031   mov         eax，0CCCCCCCCh
00401036   rep stos    dword ptr [edi]       //这些和上面一样
4:        a = a + 3;
00401038   mov         eax，dword ptr [ebp+8] //ebp=0x12FF24 加8 [0x12FF30]即取到了参数10
0040103B   add         eax，3
0040103E   mov         dword ptr [ebp+8]，eax
5:        b = b + 5;
00401041   mov         ecx，dword ptr [ebp+0Ch]
00401044   add         ecx，5
00401047   mov         dword ptr [ebp+0Ch]，ecx
6:        return a + b;
0040104A   mov         eax，dword ptr [ebp+8]
0040104D   add         eax，dword ptr [ebp+0Ch]  //最后的结果保存在eax， 结果得以返回
7:   }
00401050   pop         edi
00401051   pop         esi
00401052   pop         ebx
00401053   mov         esp，ebp    //esp指向0x12FF24， test函数的堆栈空间被放弃，从当前函数栈顶返回到栈底
00401055   pop         ebp        //此时ebp=0x12FF80， 恢复现场  esp=0x12FF28
00401056   ret                    //ret负责栈顶0x12FF28之值00401091弹出到指令寄存器中，esp=0x12FF30
```

因为 win32 汇编一般用 eax 返回结果 所以如果最终结果不是在 eax 里面的话 还要把它放到 eax。

注意，从被调函数返回时，是弹出 EBP，恢复堆栈到函数调用前的地址，弹出返回地址到 EIP 以继续执行程序。

从 test 函数返回，执行：

```
00401091   add         esp，8
```

清栈，清除两个压栈的参数 10 90 调用者 main 负责。
**(所谓\_\_cdecl 调用由调用者负责恢复栈，调用者负责清理的只是入栈的参数，test 函数自己的堆栈空间自己返回时自己已经清除，靠！一直理解错)**

```
00401094   push        eax          //入栈，计算结果108入栈，即printf函数的参数之一入栈
00401095   push        offset string "%d" (0042201c)//入栈，参数 "%d"  当然其实是％d的地址
0040109A   call        printf (004010d0)//函数调用 printf("%d"，108) 因为printf函数时
0040109F   add         esp，8       //清栈，清除参数 ("%d"， 108)
19:        return 0;
004010A2   xor         eax，eax     //eax清零
20:   }
```

main 函数执行完毕 此时 esp=0x12FF34 ebp=0x12FF80：

```
004010A4   pop         edi
004010A5   pop         esi
004010A6   pop         ebx
004010A7   add         esp，40h    //为啥不用mov esp， ebp? 是为了下面的比较
004010AA   cmp         ebp，esp   //比较，若不同则调用chkesp抛出异常
004010AC   call        __chkesp (00401150)
004010B1   mov         esp，ebp
004010B3   pop         ebp          //ESP=0X12FF84
```

EBP=0x12FFC0 尘归尘 土归土 一切都恢复最初的平静了 :)

```
004010B4   ret
```

另：

1. 如果函数调用方式是**\_\_stdcall**不同之处在于 main 函数 call 后面没有了 add esp， 8；test 函数最后一句是 ret 8 (由 test 函数清栈， ret 8 意思是执行 ret 后，esp+8)。
2. 运行过程中 0x12FF28 保存了指令地址 00401091 是怎么保存的？栈每个空间保存 4 个字节（粒度 4 字节） 例如下一个栈空间 0x12FF2C 保存参数 10，因此：

```
0x12FF28 0x12FF29 0x12FF2A 0x12FF2B
   91       10       40       00
```

little-endian 认为其读的第一个字节为最小的那位上的数。

3. char a[] = "abcde"
   对局部字符数组变量（栈变量）赋值，是利用寄存器从全局数据内存区把字符串“abcde”拷贝到栈内存中的。
4. int szNum[5] = { 1， 2， 3， 4， 5 }; 栈中是如何分布的？

```
00401798   mov         dword ptr [ebp-14h]，1
0040179F   mov         dword ptr [ebp-10h]，2
004017A6   mov         dword ptr [ebp-0Ch]，3
004017AD   mov         dword ptr [ebp-8]，4
004017B4   mov         dword ptr [ebp-4]，5
```

可以看出来是从右边开始入栈，所以是 5 4 3 2 1 入栈，

```
int *ptrA = (int*)(&szNum+1);
int *ptrB = (int*)((int)szNum + 1);
std::cout<< ptrA[-1] << *ptrB << std::endl;
```

结果如何？

```
28:       int *ptrA = (int*)(&szNum+1);
004017BB   lea         eax，[ebp]
004017BE   mov         dword ptr [ebp-18h]，eax
```

&szNum 是指向数组指针；加 1 是加一个数组宽度；&szNum+1 指向移动 5 个 int 单位之后的那个地方， 就是把 EBP 的地址赋给指针；
ptrA[-1]是回退一个 int\*宽度，即 ebp-4；

```
29:       int *ptrB = (int*)((int)szNum + 1);
004017C1   lea         ecx，[ebp-13h]
004017C4   mov         dword ptr [ebp-1Ch]，ecx
```

如果上面是指针算术，那这里就是地址算术，只是首地址+1 个字节的 offset，即 ebp-13h 给指针。实际保存是这样的：

```
01 00 00 00 02 00 00 00
ebp-14h ebp-13h ebp-10h
```

注意，是 int\*类型的，最后获得的是 00 00 00 02，由于 Little-endian， 实际上逻辑数是 02000000，转换为十进制数就为 33554432，最后输出 533554432。

## 函数调用约定

函数调用约定（Calling Convention）定义了函数在调用时如何传递参数、返回值以及如何管理堆栈。这些约定在不同的编译器、操作系统和硬件平台上可能有所不同。函数调用约定的主要作用和应用场景如下：

### 作用

1. **参数传递**：

   - 定义参数在寄存器或堆栈中的传递顺序。
   - 确定参数是从左到右还是从右到左传递。

2. **返回值处理**：

   - 指定返回值是通过寄存器还是堆栈传递。

3. **堆栈管理**：

   - 确定函数调用过程中谁负责堆栈的清理（调用者或被调用者）。

4. **寄存器使用**：
   - 规定哪些寄存器需要保存和恢复，哪些寄存器可以自由使用。

### 应用场景

1. **跨语言调用**：

   - 当需要在不同编程语言之间调用函数时，必须确保它们使用相同的调用约定。例如，从 C++ 调用 C 函数时，通常使用 `extern "C"` 来指定 C 的调用约定。

2. **系统调用**：

   - 操作系统的系统调用通常有特定的调用约定，应用程序必须遵循这些约定才能正确调用系统服务。

3. **库函数调用**：

   - 使用第三方库时，必须遵循库函数的调用约定，否则可能导致参数传递错误或堆栈损坏。

4. **性能优化**：

   - 某些调用约定可以通过减少堆栈操作或优化寄存器使用来提高性能。例如，`fastcall` 调用约定通过使用寄存器传递参数来减少堆栈操作。

5. **嵌入式系统**：
   - 在嵌入式系统中，不同的硬件平台可能有特定的调用约定，开发者需要遵循这些约定以确保代码的正确性和效率。

### 常见的调用约定

1. **cdecl**（C Declaration）：

   - 参数从右到左传递，调用者负责堆栈清理。
   - 常用于 C 语言函数。

2. **stdcall**（Standard Call）：

   - 参数从右到左传递，被调用者负责堆栈清理。
   - 常用于 Windows API 函数。

3. **fastcall**（Fast Call）：

   - 前几个参数通过寄存器传递，剩余参数从右到左传递。
   - 提高函数调用的效率。

4. **thiscall**：

   - 用于 C++ 成员函数，`this` 指针通过寄存器传递。

5. **vectorcall**：
   - 用于传递 SIMD 向量参数，通过寄存器传递向量参数。

### 示例

以下是一个使用 `cdecl` 和 `stdcall` 调用约定的示例：

```cpp
#include <iostream>

// 使用 cdecl 调用约定
extern "C" void __cdecl cdeclFunction(int a， int b) {
    std::cout << "cdeclFunction: " << a + b << std::endl;
}

// 使用 stdcall 调用约定
extern "C" void __stdcall stdcallFunction(int a， int b) {
    std::cout << "stdcallFunction: " << a + b << std::endl;
}

int main() {
    cdeclFunction(1， 2);
    stdcallFunction(3， 4);
    return 0;
}
```

在这个示例中，`cdeclFunction` 使用 `cdecl` 调用约定，而 `stdcallFunction` 使用 `stdcall` 调用约定。不同的调用约定会影响参数传递和堆栈管理方式。

### 总结

函数调用约定在跨语言调用、系统调用、库函数调用、性能优化和嵌入式系统中发挥重要作用。了解和正确使用调用约定可以确保函数调用的正确性和效率。

## c/c++中的函数调用

### 1. concepts

#### 1.1 prerequisites

1. **什么是栈？**

   栈（Stack）是一种后进先出（LIFO，Last In First Out）的数据结构，它允许数据的存入(push)和取出(pop)操作仅在一端进行，这一端被称为栈顶。栈可以用数组或链表实现，广泛应用于程序的执行流程控制，如函数调用的实现。

2. **和内存中的栈有什么区别？**

   当我们提到“栈”时，可能指的是抽象的数据结构概念，也可能指的是程序运行时在内存中用于存储局部变量、函数参数和返回地址等信息的区域。这两者之间的主要区别在于：

   - **抽象的数据结构**：栈是一种抽象的数据结构概念，它定义了数据的存储和访问方式，即后进先出。这个概念可以用多种方式实现，例如，通过数组或链表。

   - **内存中的栈**：在程序运行时，内存中的栈（通常称为调用栈或执行栈）是用来存储函数调用过程中的局部变量、函数参数、返回地址等信息的内存区域。这个栈是按照栈的数据结构概念来管理这些信息的，确保函数调用和返回能够正确执行。内存中的栈是操作系统在程序开始执行时自动分配的，其大小通常有限制。

   总的来说，栈作为一种数据结构的概念，可以在不同的场景下以不同的形式实现。而程序运行时内存中的栈是这一概念在程序执行流程控制中的具体应用，是自动管理的，主要用于处理函数调用。

#### 1.2 内存中入栈出栈的示意图

为了方便表示本文后面的所有栈结构图中的每个格子都是 8 个字节 ，同时我们也假设 push 和 pop 指令每次操作 8 个字节

下图是一个大小为 80 个字节（图中每个格子是 8 个字节）的`栈`，地址范围是 0~79。`栈指针`指向栈顶的位置：

![alt text](imgs/_6_howFuncWorks_image.png)

入栈：

![alt text](imgs/_6_howFuncWorks_image-1.png)

出栈

![alt text](imgs/_6_howFuncWorks_image-2.png)

### 2. 控制转移

控制转移：当进行函数调用时，程序的执行流程需要从当前位置跳转到被调用函数的起始位置，执行完被调用函数后再返回到原来的位置继续执行。

考虑有如下 C 语言代码：

```c
void Q() {
    printf("this is Q.");
    return;
}

void P() {
    printf("readying to call Q.");
    Q();
    return;
}
```

我们假设代码的`行号`就是`指令地址`，在最开始时 PC 为 7，也就是函数`P`的起始指令地址。CPU 往下执行后发现是一个函数调用，此时把 PC 修改为被调用函数`Q`的起始指令地址 2。直至`Q`执行完毕之后，最后再把 PC 修改为`P`中调用`Q`时的下一条指令地址 9，整个调用过程结束。

现在有一个问题就是对于函数`返回地址`的保存，考虑当有大量函数嵌套调用时，每发生一次函数调用都会产生一个返回地址，并且这些返回地址还要和每次调用进行关联。为了满足这个需求我们需要使用`栈`来存储函数的`返回地址`，当每次发生调用时就将`返回地址`压入到`栈`中，函数执行完之后再把从把它从栈中弹出到`PC`中。

下面是一个 C 语言嵌套函数调用的例子，我们分别对它的调用和返回过程进行说明：

```c
void Q() {
    printf("this is Q.\n");
    return;
}

void P() {
    printf("readying to call Q.\n");
    Q();
    return;
}

void main() {
    printf("readying to call P.\n");
    P();
    return;
}
```

**调用过程：**

还是假设代码的`行号`为每条指令的地址，最开始 PC 为 13，也就是`main`函数的第一行代码，程序继续执行到 14，发现这里调用了函数`P`，因此把 PC 设为`P`的起始指令地址 7。随后将调用`P`处的下一条指令地址 15 压入栈中。程序继续执行到 8，发现这里调用了函数`Q`，同样把 PC 设为`Q`的起始指令地址 2，最后将调用`Q`处的下一条指令地址 9 压入栈中，此时栈中存储了两个`返回地址`分别是 9 和 15。

栈变化过程：

![](https://image.coder.cat/stack8.png)

**返回过程：**

在函数`Q`执行完之后，函数开始返回，返回时会把栈中之前保存的`返回地址`弹出到 PC 中，此时栈顶是指令地址 9，将它从栈中弹出到 PC 中，函数成功的返回到`P`中。再待`P`执行完成之后，继续把栈顶的指令地址 15 弹出到 PC 中，到最后函数返回到了`main`中，栈也恢复成了发生调用前的样子。

栈变化过程：

![](https://image.coder.cat/stack9.png)

整套过程可以推广至任意层函数调用以及递归调用，栈完美的保存了函数的返回地址。这里为了举例方便把一行 C 代码当成一条指令，实际上这里的指令是经过编译后的`机器指令`，那么一行 C 代码可能会对应对条机器指令，每条机器指令在内存中都会有一个地址。

### 3. 数据传递

> 有时候调用者需要向被调用者`传递参数`，同时被调用者也可能需要向调用者`返回数据`。

## 参数传递

默认情况下`X64`（英特尔 64 位）中前 6 个参数存放在一组约定的寄存器中，其余参数以`从右到左`的顺序压入`堆栈`，因此调用者可以访问这组寄存器或`堆栈`来获取参数。而在`X86`（英特尔 32 位）中会直接将所有的参数以`从右到左`的顺序压入堆栈，所以调用者只需要访问`堆栈`就可以获取参数。

另外当被调用函数引用了参数的内存地址，那么这个参数也必须放在栈中，因为寄存器是没有内存地址的。

C 语言中参数传递的例子（以`X64`为例）：

```C
void Q(long arg1， long arg2， long arg3， long arg4， long arg5， long arg6， long arg7， long arg8) {
    printf("this is Q.\n");
    return;
}

void main() {
    printf("readying to call Q.\n");
    Q(1， 2， 3， 4 ，5 ，6 ，7 ，8);
    return;
}
```

上面代码中函数`Q`有 8 个参数，前 6 个参数通过寄存器传递，多出来的 2 个参数`arg7`和`arg8`以`从右到左`的顺序压入堆栈，所以这里的压栈顺序是先`arg7`后`arg8`。为了方便绘图所以这里使用了`long`类型，它占 8 个字节刚好对应图中一个单元格。

压栈过程：

![](https://image.coder.cat/stack10.png)

## 返回值

### 4. 寄存器的保存与恢复

下面代码分别把`ax，bx`这两个寄存器保存在栈中：

```c
push(ax);
push(bx);
```

保存过程：

![](https://image.coder.cat/stack11.png)

把栈中的值逐个恢复到寄存器中：

```c
pop(bx);
pop(ax);
```

恢复过程：

![](https://image.coder.cat/stack12.png)

这里要注意的是出栈和入栈的顺序是相反的，因为此时`栈顶`是之前`bx`的值，所以在恢复时需要先把`栈顶`的值弹出到`bx`，然后再把下一个值弹出至`ax`，这样就把值与寄存器对应起来了。

**并不是所有的寄存器都需要`保存与恢复`，根据约定把寄存器中的一部分划分为`被调用者保存`和`调用者保存`：**

### 5. 局部变量的存储

> 寄存器和内存都可以用来存放`函数执行时`所需的`数据`。寄存器的存取速度比内存快很多，所以通常会优先把数据存入寄存器中。但是由于寄存器数量有限，因此当寄存器不够用时会将数据存放在`栈`内存中。

**我们可以把`栈指针`（sp）向`栈顶移动`来为函数在栈中分配用于存放`局部数据`的内存空间。**

例如有如下 C 语言代码：

```c
void main() {
    long foo = 100;
    long bar = 200;
}
```

代码中定义了两个`long`类型变量`foo`和`bar`，我们假设它们都放在`栈`中，由于`long`类型占用 8 个字节，因此我们需要在栈中分配 16 个字节的空间。

分配过程（一个单元格 8 个字节）：

![](https://image.coder.cat/stack13.png)

最后再把这两个变量分别存入栈中：

![](https://image.coder.cat/stack14.png)

### 6. 函数栈帧

> 当一个函数在运行时，需要为它在`堆栈`中创建一个`栈帧`（stack frame）用来记录运行时产生的相关信息，因此每个函数在执行前都会创建一个栈帧，在它返回时会销毁该栈帧。

**本节的示意图我们通过颜色区分调用者与被调用者的栈帧，蓝色表示被调用者，绿色表示调用者。**

## 创建栈帧

通常用一个叫做`栈基址`（bp）的寄存器来保存正在运行函数栈帧的`开始地址`，由于`栈指针`（sp）始终保存的是栈顶的地址，所以`栈指针`保存的也就是正在运行函数栈帧的`结束地址`。

![](https://image.coder.cat/stack3.png)

> 每次发生函数调用时都要修改`栈基址`（bp）使它保存新栈帧的`开始地址`，这将导致它被覆盖。因此我们可以利用之前讲到的`寄存器的保存与恢复`使用栈来对`栈基址`进行保存与恢复。

在一开始`栈基址`和`栈指针`都分别指向调用者栈帧的`开始地址`和`结束地址`，创建时首先将调用者栈帧的`开始地址`也就是此时的`栈基址`压栈保存，由于`栈基址`是`被调用者保存`寄存器，所以它存放在被调用的栈帧中。

栈变化过程：

![](https://image.coder.cat/stack18.png)

随后将`栈基址`（bp）修改成此时`栈指针`（sp）的值，使这它们都指向同一个位置（下面左图），如果被调用函数还需要栈空间，那么它可以继续把`栈指针`（sp）向低地址移动来分配空间（下面右图），最终`栈基址`和`栈指针`又分别指向了`被调用者`栈帧的`开始地址`和`结束地址`。

栈变化过程：

![](https://image.coder.cat/stack19.png)

栈帧中存储了函数参数、返回地址、保存的寄存器、局部变量，因此完整的栈结构可能像下面这样：

![](https://image.coder.cat/stack20.png)

**图中各个部分说明：**

- 函数参数（arguments）

  在`X64`中如果函数参数超过 6 个，前 6 个通过寄存器进行传递，其余参数则通过栈来进行参数传递，当少于等于 6 个或没有参数时，这个时候该栈帧部分可以忽略。

  在需要通过栈来传递参数时，`调用函数`需要先将参数压入自己的栈帧中，然后`被调用函数`从`调用函数`的栈帧中对参数进行访问。所以图中参数部分在调用函数的栈帧中。

- 返回地址（ret addr）

  将函数参数压栈之后，需要把调用位置处的下一条指令地址压栈，以便被调用函数执行完之后可以回到原来的位置继续执行，这个地址就是返回地址。

- 保存的寄存器（saved regs）

  这里存放的是需要`被调用者`来保存的寄存器，例如`旧的栈基址`（old bp）旧保存在其中。

- 局部变量（local vars）

  这个部分是存储在栈中而不是寄存器中的局部变量，如果函数没有局部变量或局部变量都存储在寄存器中，那么该栈帧部分可以忽略。

**如果再次发生函数调用，那就重复整个创建栈帧的过程，因此对于递归函数来说和普通函数也没什么区别。**

## 销毁栈帧

> 在函数返回时会把之前给这个函数创建的栈帧`销毁`，以释放空间。

销毁时先把`栈指针`（sp）移动到此时`栈基址`（bp）的位置，此时`栈指针`和`栈基址`都指向同样的位置。

栈变化过程：

![](https://image.coder.cat/stack5.png)

现在栈顶刚好是我们在创建栈帧时保存的调用者`栈帧`的`栈基址`，现在把它出栈至`栈基址`（bp），得到下图中的栈结构：

![](https://image.coder.cat/stack7.png)

到目前位置`被调用者`的栈帧已经被销毁空间得到释放，但是函数的返回步骤并没有完，`调用者`的栈帧中还保存者`返回地址`，此时需要把`返回地址`出栈至`程序计数器`（PC）以恢复到原来的位置继续执行，返回后的栈帧：

![](https://image.coder.cat/stack6.png)

**C/C++中销毁栈帧并不会清空被销毁栈帧中的数据。**

### 7. C 语言函数栈帧实例

> 我们通过把一段具有函数调用的 C 语言代码编译成汇编，逐步分析函数栈帧生命周期的完整变化过程。

有如下 C 语言代码：

```c
long callee(long arg1， long arg2， long arg3， long arg4， long arg5， long arg6， long arg7， long arg8) {
    return arg7 + arg8;
}

int main() {
    long a = 7;
    long b = 8;
    callee(1， 2， 3， 4 ，5 ，6， a， b);
    return 0;
}
```

代码中`callee`函数有 8 个参数分别是`arg1~arg8`，它返回`arg7`和`arg8`相加后的结果。由于我们的代码是运行在`X64`的机器上，所以`arg1~arg6`会通过寄存器来传递，`arg7`和`arg8`通过栈来传递。`main`中定义了两个局部变量`a`和`b`，它对`callee`发起调用，局部变量`a，b`分别对应`callee`函数的`arg7，arg8`。

将上面 C 语言代码编译成汇编，把由编译器产生的其他与我们分析函数栈帧不相关的指令删除，得到如下指令（根据编译器版本以及操作系统的不同编译出的汇编指令会有所差异，这里使用的编译器和操作系统分别是`gcc9.0`和`ubuntu 20.04 x-64`）：

```ASM
callee:
    pushq	%rbp
    movq	%rsp， %rbp
    movq	%rdi， -8(%rbp)
    movq	%rsi， -16(%rbp)
    movq	%rdx， -24(%rbp)
    movq	%rcx， -32(%rbp)
    movq	%r8， -40(%rbp)
    movq	%r9， -48(%rbp)
    movq	16(%rbp)， %rdx
    movq	24(%rbp)， %rax
    addq	%rdx， %rax
    popq	%rbp
    ret
main:
    pushq	%rbp
    movq	%rsp， %rbp
    subq	$16， %rsp
    movq	$7， -16(%rbp)
    movq	$8， -8(%rbp)
    pushq	-8(%rbp)
    pushq	-16(%rbp)
    movl	$6， %r9d
    movl	$5， %r8d
    movl	$4， %ecx
    movl	$3， %edx
    movl	$2， %esi
    movl	$1， %edi
    call	callee
    addq	$16， %rsp
    movl	$0， %eax
    leave
    ret
```

指令中的`callee:`和`main:`表示的是为它下面的指令取一个名字，可以理解为函数名。

**在`X64`中`栈指针`和`栈基址`分别叫`rsp，rbp`。**

我们逐步分析这些指令对堆栈的影响，首先是`main`的第前两行指令：

```asm
pushq	%rbp
movq	%rsp， %rbp
```

实际上`main`函数是被系统内一个叫做`_start`的函数所调用，所以第 1 条指令将`调用者`\_start 的`栈基址`压栈保存，第 2 条指令移动`栈基址`使它指向和`栈指针`同样的位置。

栈变化过程（在一开始我们`栈指针`和`栈基址`指向`_start`的栈帧，这里没有画出`_start`的栈帧也就没有标注它们）：

![](https://image.coder.cat/stack22.png)

初始化局部变量并准备`callee`的后两个参数：

```asm
subq	$16， %rsp
movq	$7， -16(%rbp)
movq	$8， -8(%rbp)
pushq	-8(%rbp)
pushq	-16(%rbp)
```

第 1 条指令中的`subq`是减法指令，这里用于把`栈指针`减去 16，使它向低地址移动来给局部变量`a，b`分配 16 字节的空间（long 占 8 个字节）。

第 2~3 条指令中的`movq`是数据移动指令，在这里它通过对`栈基址`进行适当偏移来对`a，b`赋值。例如`movq $7， -16(%rbp)`表示把 7 放到相对于`栈基址`-16 的内存中。下图中可以看到这两条指令执行完以后`-16`和`-8`的位置刚好放置了变量`a，b`。

第 4~5 条指令把栈帧中`a，b`的值复制一份然后把它们压栈，这是为了准备函数`callee`的后 2 个参数`arg7`与`arg8`。

栈变化过程（图中右侧的数字表示基于`栈基址`的偏移量，每个格子 8 字节，由于栈空间是向低地址发展的，所以相对于`栈基址`上面内存的偏移量是负的）：

![](https://image.coder.cat/stack23.png)

把`callee`的前 6 个参数`arg1~arg6`存放在寄存器中：

```asm
movl	$6， %r9d
movl	$5， %r8d
movl	$4， %ecx
movl	$3， %edx
movl	$2， %esi
movl	$1， %edi
```

开始调用`callee`：

```asm
call	callee
```

这条指令对应了两个操作，首先将它下面一条指令的地址也就是`addq $16， %rsp`的地址（返回地址）压入栈中，随后修改`程序计数器`（PC）为`callee`的第一条指令的地址，最后 CPU 就从`callee`处开始执行。

这条指令执行后的栈：

![](https://image.coder.cat/stack24.png)

现在 CPU 从`callee`开始执行：

```asm
pushq	%rbp
movq	%rsp， %rbp
```

先压入`main`栈帧的`栈基址`，然后移动`栈基址`使它指向和`栈指针`同样的位置。此时产生了`callee`的栈帧：

第 2 条指令使`栈基址`发生了改变，相应的右图中基于`栈基址`的偏移量也需要发生变化（由于栈空间是向低地址发展的，所以相对于`栈基址`下面内存的偏移量是正的）：

![](https://image.coder.cat/stack25.png)

复制前 6 个参数到栈帧中：

```asm
movq	%rdi， -8(%rbp)
movq	%rsi， -16(%rbp)
movq	%rdx， -24(%rbp)
movq	%rcx， -32(%rbp)
movq	%r8， -40(%rbp)
movq	%r9， -48(%rbp)
```

这 6 个寄存器`rdi，rsi，rdx，rcx，r8，r9`分别存放了`callee`的前 6 个参数，现在将它们从寄存器中复制到`callee`自己的栈帧中。我对这个操作有点迷，为啥还需要复制呢，直接从寄存器中取出来使用不就行了吗？我想可能是为了腾出寄存器吧。

执行之后的栈结构：

![](https://image.coder.cat/stack26.png)

执行到这里奇怪的事情发生了，`栈指针`并没有继续向低地址移动，让它指向栈顶的位置。其实这里是编译器的优化，`栈指针`的目的是为了确定被调用函数的`栈基址`，由于`callee`没有再继续调用其他任何函数，因此也无需修改`栈指针`。

执行相加：

```asm
movq    16(%rbp)， %rdx
movq	24(%rbp)， %rax
addq	%rdx， %rax
```

将`arg7`与`arg8`相加，然后把结果放在`rdx`寄存器，`mian`函数可以访问`rdx`寄存器来获取返回值，以此来达到函数返回值传递的目的。

返回到`main`：

```asm
popq	%rbp
ret
```

恢复`栈基址`并跳转到返回地址处开始继续执行。

栈变化过程：

![](https://image.coder.cat/stack27.png)

返回到`_start`：

```asm
addq	$16， %rsp
movl	$0， %eax
leave
ret
```

第 1 条指令中的`addq`是加法指令，这里用于把`栈指针`加上 16，使它向高地址移动以此来释放`arg7，arg8`的内存。通过这一步可以发现，函数执行完后会立马释放参数的栈内存。

第 2 条指令把`main`的返回值 0 放入到`eax`寄存器中。

第 3 条指令`leave`隐含执行了两个操作，它等价与下面两条指令：

```asm
movq	%rbp， %rsp
popq	%rbp
```

先修改`栈指针`使它与`栈基址`指向同样的位置，这一步主要用于释放局部空间，然后恢复`栈基址`。此时`栈指针`和`栈基址`就分别指向了`_start`的栈帧。

到这里我们发现`main`和`callee`的返回过程不一样，这是由于在`callee`一开始没有修改`栈基址`，所以返回的时候也就不需要再对它进行恢复。由此我们可以得出一个结论：如果某个函数调用了其他函数和没有调用其他函数，它们在返回时的过程有略微的不一致。

第 4 条指令`ret`使 CPU 返回到`_start`中去执行，最后一切又恢复了平静。

栈变化过程：

![](https://image.coder.cat/stack28.png)

**最后我们发现数据仍然还保存在栈中，因为释放栈空间并不会修改里面的数据，只是对`栈指针`和`栈基址`做了移动。**

### 8. quiz 一个有趣的例子

这是一个 C 语言的例子：

```c
void init_array() {
    int arr[10];
    for (int i = 0; i < 10; ++i) {
        arr[i] = i;
    }
}

void print_array() {
    int arr[10];
    for (int i = 0; i < 10; ++i) {
       printf("%ld\t"， arr[i]);
    }
}

int main() {
    init_array();
    print_array();
}
```

代码中`init_array`和`print_array`各自有一个长度为 10 的局部数组`arr`。`init_array`把它内部的`arr`初始化成 0~9，print_array 把它内部的`arr`遍历输出到控制台，然后在`main`函数中对它们进行调用。

`print_array`执行后输出到控制台：

```bash
0	1	2	3	4	5	6	7	8	9
```

结果有点让人疑惑，似乎这两个函数有着某种关系。

现在取消对`init_array`的调用，再看下结果：

```bash
177988	32765	5497827	21857	2157688	32518	9257904	21857	0	0
```

这次输出了随机值，因为 C/C++并不会初始化内存中的值，这些值都是上一次使用这些内存的程序留下的。

对比两次结果发现`init_array`确实对`print_array`中的数组`arr`产生了影响。`init_array`和`print_array`中的`arr`看起来都各自独立，为什么会出现这种情况？

来看下这两个函数各自在返回前的栈帧结构：

![](https://image.coder.cat/stack29.png)

可以发现它们的栈帧结构和大小完全一样。`init_array`执行完之后它的栈帧被销毁，但是原来的值还在内存中。当`print_array`执行时继续给它分配了同一块内存且栈帧结构也一样，这样就把`init_array`在内存中遗留的数据拿到了。

我们对代码稍作修改，让这两个函数都把各自`arr`在内存中的地址输出到控制台：

```c
void init_array() {
    int arr[10];
    printf("%p\n"， arr);
}

void print_array() {
    int arr[10];
    printf("%p"， arr);
}

int main() {
    init_array();
    print_array();
}
```

控制台结果：

```bash
0x7ffd2aaf3ff0
0x7ffd2aaf3ff0
```

结果再一次印证了这两个`arr`被放到了是同一块栈内存中。所以`print_array`输出了原先在`init_array`中`arr`的值。

### 10 .手动修改栈帧数据

> 我们可以获取某一局部变量在内存中的地址，然后对该地址进行偏移来修改栈中其他位置的数据。只要我们对栈结构足够了解，就可以修改你想修改的数据。

## 修改局部存储

> 由于 C/C++不检查数组越界访问，因此我们可以借助这一特点来修改栈帧中的数据。

有如下代码：

```c
int main() {
    long foo = 10;
    long arr[2] = {1， 2};
    arr[-1] = 20;
    printf("foo is %ld"， foo);
    return 0;
}
```

代码中数组`arr`和变量`foo`它们在栈中是连续存放的：

![](https://image.coder.cat/stack30.png)

图中还发现变量`foo`放在了更低的地址上，所以在修改` arr[-1]`时也是修改变量`foo`。

代码输出到控制中的结果：

```bash
foo is 20
```

### stack canary

这个例子的栈帧最底部多了一个`canary`（译为金丝雀），它用来防止栈溢出攻击。在进入函数时会先往`返回地址`的上面放置一个任意值，然后在返回时检查这个值是否有被修改，如果被修改就说明栈帧中其他数据也可能被修改过，然后触发相关异常。这个值就叫`canary`。

只有在函数内有指针操作时，编译器才会生成`canary`相关指令。我们这里使用了数组，数组操作在 C/C++中其实也是指针操作，所以这里生成了`canary`。

## 修改返回地址

> 同样的方式我们也可以对一个内存地址进行适当偏移来修改函数的返回地址，从而控制函数返回路径。

有如下代码：

```c
void bar() {
    printf("This is bar!\n");
}

void foo() {
    printf("This is foo!\n");
    long arr[2] = {1， 2， 3};
    arr[5] = bar;
}

int main() {
    foo();
    return 0;
}
```

这个例子中在数组`arr[5]`的位置存放了返回地址，至于为什么是 5，我们先来看下在`foo`返回前的栈帧结构（绿色是 main 的栈帧，蓝色是 foo 的栈帧）：

![](https://image.coder.cat/stack31.png)

现在我们从`arr[0]`往下数，刚好在`arr[5]`的位置放置了函数返回地址，我们把它修改成函数`bar`的地址（C/C++中函数名表示函数第一条指令的地址）然后执行，于是得到如下控制台结果：

```bash
This is foo!
This is bar!
段错误 (核心已转储)
```

结果如我们所愿这里成功跳转到了`bar`，但也收获了一个`段错误`。为什么会发生这个`段错误`呢？我们继续看下在`bar`运行前后的栈帧变化（绿色是 main 的栈帧，蓝色是 bar 的栈帧）：

![](https://image.coder.cat/stack32.png)

上面左图是在`ret`指令执行前的栈帧状态，这个时候`栈指针`和`栈基址`已经恢复到调用`foo`前的状态，右图是在`ret`指令执行后，此时`bar addr`已经被出栈，随后跳转到`bar`去执行，`bar`也创建了自己的栈帧。这个时候我们想像一下，当`bar`返回时会发生什么？显然它会把`_start rbp`做为`返回地址`，`_start rbp`不是一个指令的地址，当 CPU 把它当成一个指令地址去寻找指令时，就发生了`段错误`。

**这两个例子中我们都修改了栈帧数据，但是并没有异常发生，`canary`好像没有起到作用。之所以没有触发异常是因为我跳过了`canary`没有修改它，`canary`可以防止修改连续的一段空间，如果这段空间刚好有`canary`，就会触发异常。**

**这两个例子也说明了数组越界访问可能导致非常严重的 bug**

## main 函数执行前完成什么工作？

main 函数执行之前主要是初始化系统资源

1. 设置栈指针
2. 初始化 static 静态和 global 全局变量，即 data 段内容
3. 将未初始化部分的赋初值：数值型 short，int，long 等为 0，bool 为 FALSE，指针为 NULL，等等，即。bss 段的内容
4. 运行全局构造器，估计是 C++中构造函数之类
5. 将 main 函数的参数，argc，argv 等传递给 main 函数，然后才真正运行 main 函数

#### 1. 地址是被谁读的?cpu 处理顺序是自上向下，还是自下向上?

地址是由 CPU 读取的。CPU 通过地址总线将地址发送到内存中，以读取或写入数据。

CPU 处理指令的顺序是根据程序的执行流程确定的，而不是根据地址的增长方向。在大多数情况下，CPU 按照程序的顺序从上到下执行指令。但是，有些指令可能会改变程序的执行流程，例如跳转指令或函数调用指令，这可能导致 CPU 按照不同的顺序执行指令。总的来说，CPU 的处理顺序是由程序的逻辑和控制流程决定的，而不是由地址的增长方向决定的。

#### 4. 栈的结构和细节

- **函数参数入栈顺序**：通常从右到左入栈。
- **函数局部变量在栈中的布局**：局部变量在栈帧中按声明顺序分配。
- **栈帧指针（Frame Pointer, FP）**：指向当前栈帧的起始位置。
- **栈顶指针（Stack Pointer, SP）**：指向当前栈顶位置。
