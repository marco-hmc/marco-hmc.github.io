---
layout: post
title: coroutine了解
categories: language
related_posts: True
tags: cpp 并发编程 coroutine
toc:
  sidebar: left
---

## coroutine了解

### 1. 基础概念

- 函数怎么提前返回？
- 怎么手动模拟函数调用？
- 函数参数到底怎么传？
- 函数如何能跨调用层次返回？
- 怎么能获取 EIP/RIP？
- 函数怎么跳转到特定地址执行？
- 函数怎么保存上下文？
- 汇编中为什么要保存寄存器？
- 汇编中怎么恢复栈？
- 汇编怎么平衡栈？
- 什么是 `__stdcall` 和 `__cdecl`？

#### 0.1 什么是协程？什么是纤程？

- **什么是协程：**
  协程(Coroutine)是一种用户态的轻量级线程,协程的调度完全由用户控制.协程有点类似于线程,但协程避免了无意义的调度,而且提供了方便的协作式多任务处理能力.协程在某些场景下,如IO密集型任务,可以提高程序的执行效率.

协程和纤程都是一种比线程更加轻量级的并发单元。两者的调度都不是由操作系统决定，而是由用户决定。两者都允许在一个函数执行过程中暂停执行，并在稍后恢复执行，从而实现非阻塞的并发操作。

两者的实现原理也是相同的，本质上都是以下几点：

1. **记住上下文信息**：无论是纤程还是协程，都需要记住当前的执行上下文，包括寄存器状态、栈指针等。
2. **切换执行位置**：在需要时，切换到另一个执行位置，继续执行其他任务。
3. **还原上下文信息**：在切换回原来的执行位置时，还原之前保存的上下文信息，继续执行。

| 特性       | 纤程（Fiber）    | 协程（Coroutine）        |
| ---------- | ---------------- | ------------------------ |
| 平台依赖   | Windows 特定实现 | 跨平台                   |
| 内存共享   | 共享线程栈       | 共享进程内存空间         |
| 实现复杂度 | 依赖操作系统 API | 可以通过库或语言特性实现 |

#### 0.2 协程的原理是什么？

协程实现的基础：C/C++ 函数调用过程，执行过程，返回过程。

- **记住离开的位置**：一个函数离开时能记住离开的位置。在 Windows 平台下，这意味着要能记住 EIP/RIP 寄存器的值，因为 EIP/RIP 指示了下一条指令要执行的地址。
- **恢复现场**：再次进入时能恢复现场。这要求能够保存当时函数栈内存和寄存器的值，并在恢复时恢复栈内存和寄存器的值。后面我们会详细说明并手动完成这个过程，这要求我们对函数调用有深入的理解。

#### 1.1 协程是什么？

协程（Coroutine）是一种比线程更轻量级的并发单元。与线程不同，协程不依赖于操作系统的线程调度，而是由程序自身控制的。协程可以在一个线程内实现多任务的切换，避免了线程上下文切换的开销。协程的主要特点是可以在执行过程中暂停，并在稍后恢复执行。

#### 1.2 协程有什么用？

协程主要用于实现并发编程，特别是在 I/O 密集型任务中。以下是协程的一些主要用途：

1. **异步编程**：协程可以在等待 I/O 操作（如网络请求、文件读写）时暂停执行，释放 CPU 资源给其他任务，从而提高程序的并发性能。
2. **生成器**：协程可以用作生成器，逐步生成数据，而不是一次性生成所有数据。这对于处理大数据集或流式数据非常有用。
3. **协作多任务**：协程可以在多个任务之间切换，模拟多任务处理，而不需要多线程或多进程的开销。
4. **简化代码**：协程可以使异步代码看起来像同步代码，简化了编写和维护异步代码的复杂性。

通过这些用途，协程在现代编程中变得越来越重要，特别是在需要高并发和高性能的应用程序中。

生成器的恢复执行由用户显式调用来决定。
异步函数的恢复执行由后台线程来决定。

#### 1.3 协程的优缺点是什么？

优点

- 轻量级：协程比线程更轻量级，创建和切换的开销更小。
- 无锁并发：协程可以避免多线程编程中的锁和竞态条件问题。
- 简化异步编程：协程可以使异步代码看起来像同步代码，简化了编写和维护异步代码的复杂性。
  缺点
- 不适用于多核并行：协程在单个线程内运行，不能利用多核 CPU 的并行计算能力。
- 手动调度：协程的调度需要手动管理，增加了编程复杂性。
- 栈大小限制：协程的栈大小通常是固定的，可能会限制递归深度和局部变量的使用。

#### 1.4 协程的应用场景

网络编程（当成异步使用，提高可读性）：协程可以简化异步网络编程，使代码更易读。
数据处理（生成器，逐步处理数据）：协程可以用于处理大数据集，逐步生成和处理数据。
用户界面（ui协程和业务协程切换）：协程可以用于实现响应式用户界面，避免界面卡顿。

#### 1.5 协程实现的基本原理是什么？

协程的实现的关键在于上下文切换。 而上下文切换涉及到三个过程：保存状态、切换上下文、恢复状态。

保存状态主要涉及保存当前协程的执行上下文，包括以下内容：

- 程序计数器（PC）：指示当前执行的指令地址。
- 栈指针（SP）：指示当前栈顶的位置。
- 寄存器：保存当前协程的寄存器状态，包括通用寄存器和特殊寄存器。

恢复状态是指将之前保存的执行上下文恢复到当前协程中，使其能够继续执行。恢复状态的过程包括：

- 恢复程序计数器：将程序计数器恢复到保存时的值。
- 恢复栈指针：将栈指针恢复到保存时的值。
- 恢复寄存器：将寄存器恢复到保存时的状态。

而切换上下文就是保存当前协程状态，恢复到目标协程状态。

### 2. 协程使用的一般例子

#### 2.1 协程的切换

```c++
#include <boost/coroutine/coroutine.hpp>
#include <iostream>

void coroutine_function(boost::coroutines::coroutine<void>::push_type &yield) {
  std::cout << "Hello from coroutine!" << std::endl;
  yield();
  std::cout << "Back in coroutine!" << std::endl;
}

int main() {
  boost::coroutines::coroutine<void>::pull_type source(coroutine_function);
  std::cout << "Hello from main!" << std::endl;
  source();
  std::cout << "Back in main!" << std::endl;
  return 0;
}
/*
Hello from coroutine!
Hello from main!
Back in coroutine!
Back in main!
*/
```

- push_type和pull_type怎么理解？
  - push_type
    定义：push_type 是一个类型，用于将控制权推送到协程中。
    作用：在协程函数中，push_type 对象用于暂停协程的执行并返回到调用者。它通常作为协程函数的参数传递。
    使用场景：当协程需要暂停执行并返回到主程序或其他协程时，使用 push_type 对象的 operator() 来实现这一点。
  - pull_type
    定义：pull_type 是一个类型，用于从协程中拉取控制权。
    作用：在主程序或调用者中，pull_type 对象用于启动和恢复协程的执行。它通常在主程序中创建，并与协程函数关联。
    使用场景：当主程序或其他协程需要启动或恢复协程的执行时，使用 pull_type 对象的 operator() 来实现这一点。

#### 2.2 带返回值的协程

```c++
#include <boost/coroutine2/all.hpp>
#include <iostream>

void coroutine_function(boost::coroutines2::coroutine<int>::push_type &yield) {
  for (int i = 0; i < 5; ++i) {
    std::cout << "Coroutine yields: " << i << std::endl;
    yield(i);
  }
}

int main() {
  boost::coroutines2::coroutine<int>::pull_type source(coroutine_function);

  while (source) {
    int value = source.get();
    std::cout << "Main received: " << value << std::endl;
    source();
  }

  return 0;
}
```

### 98. 习题

```c++
#include <boost/coroutine2/all.hpp>
#include <iostream>

int main() {
  boost::coroutines2::coroutine<int>::pull_type source(
      [&](boost::coroutines2::coroutine<int>::push_type &sink) {
        int first = 1, second = 1;
        sink(first);
        sink(second);
        for (int i = 0; i < 8; ++i) {
          int third = first + second;
          first = second;
          second = third;
          sink(third);
        }
      });

  for (auto i : source) {
    std::cout << i << std::endl;
  }

  return 0;
}
```

### 99. quiz

#### 1. yield_type和call_type是什么？和push_type还有pull_type的联系是什么？

yield_type 和 call_type 是旧版本 Boost.Coroutine 库中的类型，而 push_type 和 pull_type 是新的 Boost.Coroutine2 库中的类型。
它们在功能和目的上有相似之处，都是用于在协程中暂停执行并返回到调用者，但它们的内部实现和对外使用方式有所不同。

```c++
#include <boost/coroutine/coroutine.hpp>
#include <iostream>

void coroutine_function(boost::coroutines::yield_type &yield) {
  std::cout << "Hello from coroutine!" << std::endl;
  yield();
  std::cout << "Back in coroutine!" << std::endl;
}

int main() {
  boost::coroutines::call_type coroutine(coroutine_function);
  std::cout << "Hello from main!" << std::endl;
  coroutine();
  std::cout << "Back in main!" << std::endl;
  return 0;
}
```

#### 2. 什么是对称协程？什么是非对称协程？

非对称协程：

- 使用 boost::coroutines2::asymmetric_coroutine 实现。
- 非对称协程只能从主程序或调度器中启动和恢复，而不能直接相互调用。
- 非对称协程能知道其调用方，调用一些方法能让出当前的控制回到调用方手上。

对称协程：

- 使用 boost::coroutines2::coroutine 实现。
- 对称协程允许协程之间相互切换，而不需要返回到主调度器。
- 对程协程都是平等的，一个对程协程能把控制让给任意一个协程，因此，当对称协程让出控制的时候，必须指定被让出的协程是哪一个。

对称协程可以当成非对称协程使用。对称协程提供了更灵活的控制流，可以在协程之间相互切换，但也可以像非对称协程一样，从主程序中启动和恢复协程。
具体什么时候建议使用非对称协程欢迎补充。

#### 3. 有栈协程和无栈协程的实现是什么？

协程的实现的关键在于上下文切换。 而上下文切换涉及到三个过程：保存状态、切换上下文、恢复状态。
而有栈协程实现和无栈协程的实现区别就在于状态保存在哪里。
有栈实现：每一个协程有一个独立的栈空间。受到栈空间大小约束，有空间损耗
无栈实现：将协程的状态存储在堆（Heap）空间中，通过状态机的方式去管理。不受栈空间大小约束，没有空间损耗。实现麻烦。

而协程的状态包含以下三个方面

- 程序计数器（PC）：指示当前执行的指令地址。
- 栈指针（SP）：指示当前栈顶的位置。
- 寄存器：保存当前协程的寄存器状态，包括通用寄存器和特殊寄存器。

- boost的是有栈协程
- c++20的是无栈协程

协程的实现涉及到底层的上下文切换和状态保存，这些操作通常需要使用汇编语言来直接操作寄存器和栈指针。高级语言通常不直接提供这些底层接口，因此实现协程通常依赖于库（调用一些其他类似接口去模拟）或语言特性（编译器层面直接操作）。

#### 4. 堆空间和栈空间概念

不同线程：

- 栈空间：每个线程都有自己的栈空间，用于存储该线程的局部变量、函数调用的参数、返回地址等。这意味着栈空间是线程私有的。
- 堆空间：同一进程内的所有线程共享同一个堆空间。这意味着线程之间可以通过指针或引用共享堆上分配的数据。

不同进程：

- 栈空间：每个进程都有自己的虚拟地址空间，其中包括独立的栈空间。进程间的栈空间是完全隔离的。
- 堆空间：每个进程也有自己独立的堆空间。进程间的堆空间不共享，因此进程之间不能直接访问对方的堆数据。

### 3. ques

#### 3.1 C++的协程的实现原理是什么?

C++的协程是一种特殊的函数,它可以在执行过程中暂停和恢复.协程的实现原理涉及到两个关键概念:生成器和状态机.

生成器是协程的基础,它是一个可以产生多个值的函数.在C++中,生成器使用`yield`语句来暂停执行并返回一个值,然后可以通过调用生成器来恢复执行并继续生成下一个值.生成器的实现通常使用状态机来跟踪函数的执行状态.

状态机是一个用于管理协程执行状态的机制.它可以记录协程的当前状态,并根据不同的状态执行相应的操作.在C++中,状态机通常使用有限状态机(FSM)来实现.FSM由一组状态和状态之间的转换组成.每个状态都对应着协程的不同执行阶段,而状态之间的转换则由协程的控制流决定.

在C++中,协程的实现依赖于协程支持库,如Boost.Coroutine或C++20中引入的标准库中的协程.这些库提供了协程的底层实现,包括生成器和状态机的机制.通过使用这些库,我们可以更方便地编写和管理协程.

总结一下,C++的协程实现原理涉及生成器和状态机的概念.生成器用于产生多个值并支持暂停和恢复执行,而状态机用于管理协程的执行状态和控制流.通过使用协程支持库,我们可以更轻松地编写和管理协程.

#### 3.2

我的理解是协程只有两个主要功能，一个是保存上下文信息，一个是灵活的控制流。
协程是用来代替传统的异步编程的.
通过保存上下文和灵活的控制流操作，允许开发者以同步的方式编写代码，同时在执行阻塞操作时让出CPU，从而实现类似异步的非阻塞行为。这种方式简化了异步编程的复杂性，使得代码更易于理解和维护。

协程就是为了代替异步用的.
比如说你说在后端异步加载信息的时候，不想用异步，异步编程比较麻烦. 开了异步也要切换线程，也有消耗，
想用同步的方式去写，而且不阻塞的话.
这个时候的选择就是开协程.

去执行其他任务，从而提高程序的并发效率。
但它本质上是在单线程内通过协作式的调度来实现异步，适合处理大量 I/O 密集型任务场景。
然而，对于那些需要真正并行执行的计算密集型任务，比如复杂的数学计算等，仅靠 async 并不能充分利用多核 CPU 的优势来实现真正的并行加速。

## 协程

- 基本概念：**协程，英文Coroutines，是一种比线程更加轻量级的存在。**正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程

  <img src="imgs/os/corotines.png" alt="corotines" style="zoom:60%;" />

- 进程，线程，协程的上下文切换

  - 进程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户是无感知的。进程的切换内容包括**页全局目录、内核栈、硬件上下文，切换内容保存在内存**中。进程切换过程是由“**用户态到内核态到用户态**”的方式，**切换效率低**
  - 线程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户无感知。线程的切换内容**包括内核栈和硬件上下文**。线程切换内容保存在内核栈中。线程切换过程是由“用户态到内核态到用户态”， **切换效率中等**
  - 协程的切换者是用户（编程者或应用程序），**切换时机是用户自己的程序所决定的**。协程的**切换内容是硬件上下文**，**切换内存保存在用户自己的变量**（用户栈或堆）中。**协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高**
  - **协程是轻量级线程，拥有自己的寄存器上下文和栈**。**协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈**
  - 协程能保留上一次调用时的状态，即所有局部状态的一个特定组合，每次过程重入时，就相当于进入上一次调用的状态

- 协程相比进程和线程的优势

  - 协程拥有极高的执行效率。因为**子程序切换不是线程切换，协程不是被操作系统内核所管理，而是由程序自身完全控制(完全运行在用户态)，因此，没有线程切换的开销**，和多线程比，线程数量越多，协程的性能优势就越明显
  - 不需要多线程的锁机制，因为**只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多**

- 协程分类：

  - **按照控制传递机制**

    - **非对称式协程**：通过yield, 将控制权返回给调用方, 如达夫设备 就是一种非对称式协程，这种协程更像是一个可以返回多次的子例程(函数)，因此代码可读性会较高

    - **对称式协程**：通过resum, 将控制权交给任意协程, 这种协程更像goto 可以任意的跳转 返回，如果滥用会导致代码可读性较低

  - **按调实现分类**

    - **stackfull 有栈协程**：**每个协程都拥有自己的栈，协程上下文保存在自己的栈中**，切换协程就是切换栈然后恢复栈中的上下文，这种方法实现的协程更像是用户态的线程

    - **stackcopy 共享栈协程**：stackfull 的缺点显而易见，**十分浪费内存，当协程数量过多时会导致内存开销过大**。stackcopy 就是用来解决此问题的，**所有协程公用一个运行栈，当协程发生切换的时候，将协程数据copy到自身的独立栈中，独立栈可以进行动态的扩充**

    - **stackless 无栈协程**：stackless 协程公用一个栈，但是与stackcopy 不同，**协程切换的时候仅会将所需的上下文保存在堆中**, 可以将部分无用局部变量提前释放，通常这需要编译器的支持。stackless 协程通常只有顶层例程可以被挂起

- **应用场景**

  - I/O 密集型任务
    - 这一点与多线程有些类似，**但协程调用是在一个线程内进行的，是单线程，切换的开销小，因此效率上略高于多线程**
    - 当程序在执行 I/O 时操作时，CPU 是空闲的，此时可以充分利用 CPU 的时间片来处理其他任务。在单线程中，一个函数调用，一般是从函数的第一行代码开始执行，结束于 return 语句、异常或者函数执行（也可以认为是隐式地返回了 None ）
    - **有了协程，我们在函数的执行过程中，如果遇到了耗时的 I/O 操作，函数可以临时让出控制权，让 CPU 执行其他函数，等 I/O 操作执行完毕以后再收回控制权**
  - 当今无数的 Web 服务和互联网服务，**本质上大部分都是 IO 密集型服务**，什么是 IO 密集型服务？意思是处理的任务大多是和**网络连接或读写相关的高耗时任务**，高耗时是相对 CPU 计算逻辑处理型任务来说，两者的处理时间差距不是一个数量级的
    - **IO 密集型服务的瓶颈不在 CPU 处理速度，而在于尽可能快速的完成高并发、多连接下的数据读写**
  - **以前有两种解决方案：**
    - 如果用多线程，**高并发场景的大量 IO 等待会导致多线程被频繁挂起和切换**，非常消耗系统资源，同时多线程访问共享资源存在竞争问题
    - 如果用多进程，不仅存在频繁调度切换问题，同时还会存在每个进程资源不共享的问题，需要**额外引入进程间通信机制来解决**

  * **协程出现给高并发和 IO 密集型服务开发提供了另一种选择。**当然，世界上没有技术银弹，在这里我想把协程这把钥匙交到你手中，但是它也不是万能钥匙，最好的解决方案是贴合自身业务类型做出最优选择，不一定就选择一种模型，有时候是几种模型的组合，比如**多线程搭配协程是常见的组合**

- 因为协程是在一个线程执行，那怎么利用多核CPU呢？最简单的方法是**多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能**

- python协程完成生产者-消费者问题例子（Python对协程的支持还非常有限，用在generator中的**yield**可以一定程度上实现协程）

  ```python
  import time


  def consumer():
      r = ""
      while True:
          n = yield r  # 使用 yield 接收生产者发送的数据并返回结果
          if not n:
              return
          print("[CONSUMER] Consuming %s..." % n)
          time.sleep(1)
          r = "200 OK"


  def produce(c):
      c.send(None)  # 启动 consumer 协程
      n = 0
      while n < 5:
          n = n + 1
          print("[PRODUCER] Producing %s..." % n)
          r = c.send(n)  # 发送数据给 consumer 并接收结果
          print("[PRODUCER] Consumer return: %s" % r)
      c.close()


  if __name__ == "__main__":
      c = consumer()
      produce(c)

  ```

  注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：

  1. 首先调用c.next()启动生成器；
  2. 然后，一旦生产了东西，通过c.send(n)切换到consumer执行；
  3. consumer通过yield拿到消息，处理，又通过yield把结果传回；
  4. produce拿到consumer处理的结果，继续生产下一条消息；
  5. produce决定不生产了，通过c.close()关闭consumer，整个过程结束。

  整个流程**无锁**，由一个线程执行，produce和consumer**协作完成任务**，所以称为“协程”，而非线程的抢占式多任务

- 支持协程的编程语言

  - **Lua语言**
  - **Python语言**
  - **Go语言**
  - **Java语言(Kilim框架)**
