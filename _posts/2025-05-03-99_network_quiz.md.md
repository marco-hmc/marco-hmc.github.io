---
layout: post
title: 关于网络的一些quiz
categories: 计算机网络
related_posts: True
tags:
toc:
  sidebar: left
---

## 关于网络的一些quiz

网络
握手挥手基本都问，握手挥手中间有一次丢掉怎么办，处于什么状态，问就是time wait和重传。

有家问我套接字发送端确认发送出去了然后接收端收不到，我寻思有重传还能收不到，扯扯nagle，后来说他们抓包发现被防火墙挡住了，看我简历里有写抓包啥的问我这个。
tcp/udp什么区别，tcp自带心跳和应用层心跳啥的。

#### 1. 画出tcp头部的协议格式

#### 2.udp头部/ip头部/http头部

#### 3. 滑动窗口的作用

答:主要就是为了实现流量控制,控制了发送包的速率,每次发送方只能发送滑动窗口内部的数据包,才能保证接收方不会因为发送过快造成流量淹没,数据包的丢失.他的大小是 拥塞窗口和通告窗口 两者的最小值.

#### 4. io复用和异步io有什么区别?

答:IO复用其实一种同步IO,他只是将事件通知统一交给了select或者epoll,所以,对于IO复用,其实Select或者epoll在检测可用时是阻塞的,里面的读写一般也是阻塞的,而异步IO是不会阻塞的,数据从内核态拷贝到用户态缓冲区完成后,\*\*\*作系统会发送信号,通知进程处理,这个过程进程是可以继续执行的,这个就是异步io.

#### 5. 高并发系统限流

- 限流一般需要结合容量规划和压测来进行。当外部请求接近或者达到系统的最大阈值时，触发限流，采取其他的手段进行降级，保护系统不被压垮。**常见的降级策略包括延迟处理、拒绝服务、随机拒绝**等

##### 5.1 固定窗口限流/计数法

- 算法原理：

  - 将时间划分为固定的窗口大小，例如1s
  - 在窗口时间内，每来一个请求，对计数器+1
  - 当计数器达到设定限制后，该窗口时间内的之后的请求都被丢弃处理
  - 该窗口时间结束后，计数器清零，重新开始计数

- 算法缺陷

  - **临界问题**：假设限流阀值为5个请求，单位时间窗口是1s,如果我们在单位时间内的前0.8-1s和1-1.2s，分别并发5个请求。虽然都没有超过阀值，但是如果算0.8-1.2s,则并发数高达10，已经**超过单位时间1s不超过5阀值**的定义

    <img src="imgs/important_tech/window_limit.png" alt="window_limit" style="zoom:80%;" />

##### 5.2 滑动窗口限流/计数法

- 滑动窗口限流**解决固定窗口临界值**的问题。它将单位时间周期分为n个小周期，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期

- 算法原理：

  - 将时间划分为细粒度的时间区间，每个区间维持一个计数器，对每个区间每进入一个请求则将计数器+1

  - 多个区间组成一个单位时间窗口，每流逝一个小的时间区间，则抛弃一个旧的时间区间，纳入一个新的时间区间

  - 若当前组成的单位时间窗口中，所有时间区间的计数器总和超过限制数量，则本窗口后续请求都被丢弃

    <img src="imgs/important_tech/sliding_window_limit.png" alt="sliding_window_limit" style="zoom:80%;" />

  - 假设我们1s内的限流阀值还是5个请求，0.8\~1.0s内（比如0.9s的时候）来了5个请求，落在黄色格子里。时间过了1.0s这个点之后，又来5个请求，落在紫色格子里。如果**是固定窗口算法，是不会被限流的**，但是**滑动窗口的话，每过一个小周期，它会右移一个小格**。过了1.0s这个点后，会右移一小格，当前的单位时间段是0.2~1.2s，这个区域的请求已经超过限定的5了，已触发限流啦，实际上，紫色格子的请求都被拒绝

- 当滑动窗口的小区间划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确

- 缺点：滑动窗口算法虽然解决了**固定窗口的临界问题**，但是一旦到达限流后，请求都会直接暴力被拒绝。这样会损失一部分请求，这其实对于产品来说，并不太友好

##### 5.3 漏桶算法

- 漏桶算法面对限流，就更加的柔性，不存在直接的粗暴拒绝

- 原理

  - 它的原理很简单，可以认为就是**注水漏水**的过程。**往漏桶中以任意速率流入水，以固定的速率流出水。当水超过桶的容量时，会被溢出，也就是被丢弃。因为桶容量是不变的，保证了整体的速率**

  <img src="imgs/important_tech/bucket_limit.png" alt="bucket_limit" style="zoom:80%;" />

- 流入的水滴，可以看作是访问系统的请求，这个流入速率是不确定的

- 桶的容量一般表示系统所能处理的请求数

- 如果桶的容量满了，就达到限流的阀值，就会丢弃水滴（拒绝请求）

- 流出的水滴，是恒定速率的，对应服务按照固定的速率处理请求

- 缺点

  - **无法应对突发流量**：在正常流量的时候，系统按照固定的速率处理请求，是我们想要的。但是**面对突发流量**的时候，漏桶算法还是循规蹈矩地处理请求，这就不是我们想看到的啦。流量变突发时，我们肯定**希望系统尽量快点处理请求**，提升用户体验嘛

##### 5.4 令牌桶算法

- 面对**突发流量**的时候，我们可以使用令牌桶算法限流

- **令牌桶算法原理**：

  - 有一个令牌管理员，**根据限流大小，定速往令牌桶里放令牌**
  - 如果令牌数量满了，超过令牌桶容量的限制，那就丢弃
  - 系统在接受到一个用户请求时，都会先去令牌桶要一个令牌。如果拿到令牌，那么就处理这个请求的业务逻辑
  - 如果拿不到令牌，就直接拒绝这个请求

  <img src="imgs/important_tech/token_bucket_limit.png" alt="token_bucket_limit" style="zoom:80%;" />

- 如果令牌发放的策略正确，这个系统即不会被拖垮，也能提高机器的利用率。Guava的RateLimiter限流组件，就是基于**令牌桶算法**实现的

### NAT

## NAT穿透/UDP打洞

#### 慢启动曲线

慢启动,先发一个,可以就发两个,两个可以发四个,如此下去,遇到sshread?那就线性,一个一个加,咦?拥塞了,丢包了?两种方案,快速重传或者将shhresh设为窗口的一半,然后又一个发,两个发,三个发,遇到sshresh的点,就一个一个发,这时就会看见网络卡顿.快速重传就将减半的sshresh+3,然后又一个一个发.

#### 三次握手的具体实现,time_wait原理?

#### tcp以什么保证可靠

#### tcp数据校验是怎么做的

流量控制是怎么实现的?(滑动窗口)滑动窗口的大小具体是怎么变化的?

- 0.0.0.0是什么网络地址?

在网络编程中,IP地址`0.0.0.0`有特殊的含义,具体取决于上下文.

1. 在服务器编程中,如果一个服务器被告知监听`0.0.0.0`地址,那么它将在该机器的所有IP地址上监听传入的连接.这包括公共IP地址,私有IP地址,以及特殊的环回地址`127.0.0.1`.这样,无论客户端使用服务器的哪个IP地址来连接,服务器都可以接受连接.

2. 在路由表中,`0.0.0.0`通常用作默认路由的地址.这意味着,如果网络包的目标地址在路由表的其他条目中找不到匹配项,那么这个包将被发送到默认路由.

3. 在客户端编程中,`0.0.0.0`通常表示未指定的地址.例如,如果你告诉一个网络客户端连接到`0.0.0.0`,那么它通常会解释为"连接到本地主机".然而,这种行为并不总是一致的,因此通常不推荐这样做.
