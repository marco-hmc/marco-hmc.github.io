---
layout: post
title: ï¼ˆä¸ƒï¼‰å†…æ ¸é‚£äº›äº‹å„¿ï¼šæ“ä½œç³»ç»Ÿå¯¹ç½‘ç»œåŒ…çš„å¤„ç†
categories: OS
related_posts: True
tags: Kernel
toc:
  sidebar: right
---

## ï¼ˆä¸ƒï¼‰å†…æ ¸é‚£äº›äº‹å„¿ï¼šæ“ä½œç³»ç»Ÿå¯¹ç½‘ç»œåŒ…çš„å¤„ç†

ç½‘ç»œé€šä¿¡æ˜¯ç°ä»£è®¡ç®—æœºç³»ç»Ÿçš„æ ¸å¿ƒåŠŸèƒ½ä¹‹ä¸€ã€‚æ“ä½œç³»ç»Ÿä½œä¸ºç¡¬ä»¶ä¸åº”ç”¨ç¨‹åºä¹‹é—´çš„æ¡¥æ¢ï¼Œéœ€è¦æä¾›å®Œæ•´çš„ç½‘ç»œæ”¯æŒæ¡†æ¶ï¼Œç¡®ä¿æ•°æ®åŒ…èƒ½å¤Ÿå¯é ã€é«˜æ•ˆåœ°åœ¨ç½‘ç»œä¸­ä¼ è¾“ã€‚æœ¬ç« å°†æ·±å…¥æ¢è®¨æ“ä½œç³»ç»Ÿå¦‚ä½•å¤„ç†ç½‘ç»œæ•°æ®åŒ…ï¼Œä»ç¡¬ä»¶å±‚é¢çš„ä¿¡å·æ¥æ”¶åˆ°åº”ç”¨å±‚çš„æ•°æ®ä½¿ç”¨ã€‚

### æ“ä½œç³»ç»Ÿç½‘ç»œæ”¯æŒæ¦‚è§ˆ

æ“ä½œç³»ç»Ÿæä¾›äº†ä»¥ä¸‹ä¸»è¦ç½‘ç»œæ”¯æŒï¼š

#### **1. ç½‘ç»œåè®®æ ˆï¼ˆTCP/IP åè®®æ ˆï¼‰**

æ“ä½œç³»ç»Ÿå†…æ ¸å®ç°äº†å®Œæ•´çš„ç½‘ç»œåè®®æ ˆï¼Œæ”¯æŒå¤šç§ç½‘ç»œåè®®ï¼š

- **åº”ç”¨å±‚åè®®**ï¼šHTTP/HTTPSã€FTPã€SMTPã€DNS ç­‰
- **ä¼ è¾“å±‚åè®®**ï¼šTCPï¼ˆå¯é ä¼ è¾“ï¼‰ã€UDPï¼ˆæ— è¿æ¥ä¼ è¾“ï¼‰ã€SCTP ç­‰
- **ç½‘ç»œå±‚åè®®**ï¼šIPï¼ˆIPv4/IPv6ï¼‰ã€ICMPã€IGPã€BGP ç­‰è·¯ç”±åè®®
- **é“¾è·¯å±‚åè®®**ï¼šEthernetã€WiFiï¼ˆ802.11ï¼‰ã€PPPã€ARP ç­‰

**æ ¸å¿ƒåŠŸèƒ½åŒ…æ‹¬**ï¼š

- **æ•°æ®åˆ†æ®µä¸é‡ç»„**ï¼šå¤„ç† MTU é™åˆ¶ï¼Œå°†å¤§æ•°æ®åˆ†å‰²æˆé€‚åˆä¼ è¾“çš„åŒ…
- **æ ¡éªŒä¸çº é”™**ï¼šç¡®ä¿æ•°æ®ä¼ è¾“çš„å®Œæ•´æ€§å’Œæ­£ç¡®æ€§
- **è·¯ç”±å†³ç­–**ï¼šæ ¹æ®ç›®æ ‡åœ°å€é€‰æ‹©æœ€ä¼˜ä¼ è¾“è·¯å¾„
- **æ‹¥å¡æ§åˆ¶**ï¼šTCP çš„æ‹¥å¡çª—å£ç®¡ç†ï¼Œé¿å…ç½‘ç»œè¿‡è½½
- **æµé‡æ§åˆ¶**ï¼šæ¥æ”¶æ–¹å‘å‘é€æ–¹åé¦ˆæ¥æ”¶èƒ½åŠ›

#### **2. Socket ç¼–ç¨‹æ¥å£**

æ“ä½œç³»ç»Ÿæä¾›äº†æ ‡å‡†åŒ–çš„ç½‘ç»œç¼–ç¨‹æ¥å£ï¼ˆBSD Socket APIï¼‰ï¼Œåº”ç”¨ç¨‹åºé€šè¿‡ç»Ÿä¸€çš„å‡½æ•°è°ƒç”¨ä½¿ç”¨ç½‘ç»œï¼š

```c
// å…¸å‹çš„ TCP æœåŠ¡å™¨ç«¯ç¼–ç¨‹æµç¨‹
int server_fd = socket(AF_INET, SOCK_STREAM, 0);        // åˆ›å»º socket
bind(server_fd, &server_addr, sizeof(server_addr));     // ç»‘å®šåœ°å€å’Œç«¯å£
listen(server_fd, SOMAXCONN);                           // ç›‘å¬è¿æ¥
int client_fd = accept(server_fd, &client_addr, &len);   // æ¥å—è¿æ¥
ssize_t bytes = recv(client_fd, buffer, sizeof(buffer), 0); // æ¥æ”¶æ•°æ®
send(client_fd, response, strlen(response), 0);         // å‘é€æ•°æ®
close(client_fd);                                       // å…³é—­è¿æ¥
```

**å…³é”®ç³»ç»Ÿè°ƒç”¨**ï¼š

- **socket()**ï¼šåˆ›å»ºé€šä¿¡ç«¯ç‚¹
- **bind()**ï¼šå°† socket ç»‘å®šåˆ°ç‰¹å®šåœ°å€
- **listen()/accept()**ï¼šæœåŠ¡å™¨ç«¯ç›‘å¬å’Œæ¥å—è¿æ¥
- **connect()**ï¼šå®¢æˆ·ç«¯å‘èµ·è¿æ¥
- **send()/recv()** æˆ– **sendto()/recvfrom()**ï¼šæ•°æ®ä¼ è¾“
- **close()**ï¼šå…³é—­è¿æ¥

#### **3. ä¸­æ–­ç®¡ç†ä¸é©±åŠ¨æ”¯æŒ**

**ç½‘å¡ä¸­æ–­å¤„ç†æœºåˆ¶**ï¼š

- **ç¡¬ä»¶ä¸­æ–­**ï¼šç½‘å¡æ¥æ”¶åˆ°æ•°æ®åŒ…åï¼Œé€šè¿‡ä¸­æ–­çº¿é€šçŸ¥ CPU
- **ä¸­æ–­å¤„ç†ç¨‹åº**ï¼šé©±åŠ¨ç¨‹åºæ³¨å†Œçš„ä¸­æ–­æœåŠ¡ä¾‹ç¨‹ï¼ˆISRï¼‰
- **è½¯ä¸­æ–­**ï¼šå°†ç½‘ç»œåŒ…å¤„ç†æ¨è¿Ÿåˆ°è½¯ä¸­æ–­ä¸Šä¸‹æ–‡ï¼Œé¿å…é•¿æ—¶é—´å ç”¨ç¡¬ä»¶ä¸­æ–­

**ç°ä»£ä¼˜åŒ–æŠ€æœ¯**ï¼š

- **NAPIï¼ˆNew APIï¼‰**ï¼šè½®è¯¢ä¸ä¸­æ–­ç»“åˆï¼Œé«˜è´Ÿè½½æ—¶ä½¿ç”¨è½®è¯¢å‡å°‘ä¸­æ–­å¼€é”€
- **ä¸­æ–­åˆå¹¶**ï¼šå°†å¤šä¸ªä¸­æ–­åˆå¹¶ä¸ºä¸€ä¸ªï¼Œå‡å°‘ CPU å¼€é”€
- **å¤šé˜Ÿåˆ—ç½‘å¡**ï¼šæ¯ä¸ª CPU æ ¸å¿ƒå¯¹åº”ä¸€ä¸ªæ¥æ”¶é˜Ÿåˆ—ï¼Œæé«˜å¹¶è¡Œå¤„ç†èƒ½åŠ›

#### **4. æ•°æ®ç¼“å†²ä¸å†…å­˜ç®¡ç†**

æ“ä½œç³»ç»Ÿç»´æŠ¤å¤šç§ç¼“å†²åŒºä»¥ä¼˜åŒ–ç½‘ç»œæ€§èƒ½ï¼š

- **æ¥æ”¶ç¼“å†²åŒºï¼ˆRX Bufferï¼‰**ï¼šå­˜å‚¨ä»ç½‘å¡æ¥æ”¶çš„æ•°æ®åŒ…
- **å‘é€ç¼“å†²åŒºï¼ˆTX Bufferï¼‰**ï¼šç¼“å­˜å¾…å‘é€çš„æ•°æ®åŒ…
- **Socket ç¼“å†²åŒº**ï¼šåº”ç”¨å±‚å’Œå†…æ ¸å±‚ä¹‹é—´çš„æ•°æ®ç¼“å†²
- **é‡ç»„ç¼“å†²åŒº**ï¼šç”¨äº IP åˆ†ç‰‡é‡ç»„çš„ä¸´æ—¶å†…å­˜

**å†…å­˜ç®¡ç†ç­–ç•¥**ï¼š

```c
// Linux å†…æ ¸ä¸­çš„ sk_buff ç»“æ„ï¼ˆç®€åŒ–ç‰ˆï¼‰
struct sk_buff {
    struct sk_buff *next, *prev;     // é“¾è¡¨æŒ‡é’ˆ
    struct net_device *dev;          // å…³è”çš„ç½‘ç»œè®¾å¤‡
    unsigned char *head, *data;      // æ•°æ®æŒ‡é’ˆ
    unsigned char *tail, *end;       // ç¼“å†²åŒºè¾¹ç•Œ
    unsigned int len, data_len;      // æ•°æ®é•¿åº¦
    // ...æ›´å¤šå­—æ®µ
};
```

#### **5. è·¯ç”±ä¸é˜²ç«å¢™**

**è·¯ç”±å­ç³»ç»Ÿ**ï¼š

- **è·¯ç”±è¡¨**ï¼šå­˜å‚¨ç½‘ç»œæ‹“æ‰‘ä¿¡æ¯å’Œæœ€ä¼˜è·¯å¾„
- **è·¯ç”±ç¼“å­˜**ï¼šç¼“å­˜æœ€è¿‘ä½¿ç”¨çš„è·¯ç”±å†³ç­–ï¼Œæé«˜æŸ¥æ‰¾é€Ÿåº¦
- **ç­–ç•¥è·¯ç”±**ï¼šåŸºäºæºåœ°å€ã€æœåŠ¡ç±»å‹ç­‰è¿›è¡Œè·¯ç”±å†³ç­–

**é˜²ç«å¢™ä¸åŒ…è¿‡æ»¤**ï¼š

- **Netfilter æ¡†æ¶**ï¼šLinux å†…æ ¸çš„åŒ…è¿‡æ»¤æ¡†æ¶
- **iptables/nftables**ï¼šç”¨æˆ·ç©ºé—´çš„é˜²ç«å¢™é…ç½®å·¥å…·
- **è¿æ¥è·Ÿè¸ª**ï¼šè·Ÿè¸ªç½‘ç»œè¿æ¥çŠ¶æ€ï¼Œæ”¯æŒçŠ¶æ€é˜²ç«å¢™

```bash
# iptables è§„åˆ™ç¤ºä¾‹
iptables -A INPUT -p tcp --dport 80 -j ACCEPT    # å…è®¸ HTTP æµé‡
iptables -A INPUT -p tcp --dport 22 -s 192.168.1.0/24 -j ACCEPT  # é™åˆ¶ SSH è®¿é—®
```

#### **6. å¤šè·¯å¤ç”¨ä¸äº‹ä»¶é€šçŸ¥æœºåˆ¶**

ä¸ºäº†æ”¯æŒé«˜å¹¶å‘ç½‘ç»œåº”ç”¨ï¼Œæ“ä½œç³»ç»Ÿæä¾›äº†å¤šç§ I/O å¤šè·¯å¤ç”¨æœºåˆ¶ï¼š

**select() ç³»ç»Ÿè°ƒç”¨**ï¼š

```c
fd_set readfds, writefds;
FD_ZERO(&readfds);
FD_SET(sockfd, &readfds);
int ready = select(sockfd + 1, &readfds, &writefds, NULL, &timeout);
```

**poll() ç³»ç»Ÿè°ƒç”¨**ï¼š

```c
struct pollfd fds[MAX_CLIENTS];
fds[0].fd = server_fd;
fds[0].events = POLLIN;
int ready = poll(fds, nfds, timeout);
```

**epoll() ç³»ç»Ÿè°ƒç”¨ï¼ˆLinux ç‰¹æœ‰ï¼‰**ï¼š

```c
int epfd = epoll_create1(0);
struct epoll_event ev, events[MAX_EVENTS];
ev.events = EPOLLIN;
ev.data.fd = sockfd;
epoll_ctl(epfd, EPOLL_CTL_ADD, sockfd, &ev);
int nfds = epoll_wait(epfd, events, MAX_EVENTS, timeout);
```

**æ€§èƒ½å¯¹æ¯”**ï¼š

- **select/poll**ï¼šO(n) æ—¶é—´å¤æ‚åº¦ï¼Œé€‚åˆå°‘é‡è¿æ¥
- **epoll**ï¼šO(1) æ—¶é—´å¤æ‚åº¦ï¼Œé€‚åˆå¤§é‡è¿æ¥ï¼ˆC10K é—®é¢˜çš„è§£å†³æ–¹æ¡ˆï¼‰

---

## 1. æ•°æ®åŒ…ä»ç½‘å¡è¿›æ¥ä¹‹åçš„æµç¨‹

æˆ‘ä»¬ä»¥ Linux ä¸ºä¾‹ï¼Œä»ç¡¬ä»¶åˆ°åº”ç”¨å±‚æè¿°æ•°æ®åŒ…è¿›å…¥çš„å®Œæ•´è·¯å¾„ï¼š

```
[ç‰©ç†ä»‹è´¨] -> [ç½‘å¡ç¡¬ä»¶] -> [ç½‘å¡é©±åŠ¨] -> [å†…æ ¸åè®®æ ˆ] -> [Socketç¼“å†²åŒº] -> [ç”¨æˆ·è¿›ç¨‹]
```

### **è¯¦ç»†å¤„ç†æµç¨‹**ï¼š

#### **ç¬¬ä¸€é˜¶æ®µï¼šç¡¬ä»¶å±‚é¢çš„æ•°æ®æ¥æ”¶**

1. **ç‰©ç†ä¿¡å·è½¬æ¢**

   - ç½‘çº¿/æ— çº¿ç”µæ³¢æºå¸¦çš„æ¨¡æ‹Ÿä¿¡å·åˆ°è¾¾ç½‘å¡
   - ç½‘å¡çš„ PHY èŠ¯ç‰‡å°†æ¨¡æ‹Ÿä¿¡å·è½¬æ¢ä¸ºæ•°å­—ä¿¡å·
   - MAC æ§åˆ¶å™¨ä»æ•°å­—ä¿¡å·ä¸­æå–ä»¥å¤ªç½‘å¸§

2. **ç¡¬ä»¶è¿‡æ»¤ä¸æ ¡éªŒ**
   - **MAC åœ°å€è¿‡æ»¤**ï¼šæ£€æŸ¥ç›®æ ‡ MAC åœ°å€æ˜¯å¦åŒ¹é…
   - **CRC æ ¡éªŒ**ï¼šéªŒè¯å¸§å®Œæ•´æ€§ï¼Œä¸¢å¼ƒé”™è¯¯å¸§
   - **VLAN æ ‡ç­¾å¤„ç†**ï¼šè§£æ VLAN ä¿¡æ¯ï¼ˆå¦‚æœå­˜åœ¨ï¼‰

#### **ç¬¬äºŒé˜¶æ®µï¼šä¸­æ–­ä¸é©±åŠ¨å¤„ç†**

3. **ä¸­æ–­è§¦å‘æœºåˆ¶**

   ```c
   // ç½‘å¡é©±åŠ¨ä¸­æ–­å¤„ç†å‡½æ•°ç¤ºä¾‹
   static irqreturn_t ethernet_interrupt(int irq, void *dev_id)
   {
       struct net_device *dev = dev_id;
       struct private_data *priv = netdev_priv(dev);

       // ç¦ç”¨ç½‘å¡ä¸­æ–­ï¼Œé¿å…ä¸­æ–­é£æš´
       disable_irq_nosync(dev->irq);

       // è°ƒåº¦è½¯ä¸­æ–­è¿›è¡Œæ•°æ®åŒ…å¤„ç†
       napi_schedule(&priv->napi);

       return IRQ_HANDLED;
   }
   ```

4. **NAPI è½®è¯¢å¤„ç†**

   ```c
   // NAPI è½®è¯¢å‡½æ•°ç¤ºä¾‹
   static int ethernet_poll(struct napi_struct *napi, int budget)
   {
       struct private_data *priv = container_of(napi, struct private_data, napi);
       int work_done = 0;

       while (work_done < budget) {
           struct sk_buff *skb = receive_packet(priv);
           if (!skb) break;

           // å°†æ•°æ®åŒ…ä¼ é€’ç»™åè®®æ ˆ
           netif_receive_skb(skb);
           work_done++;
       }

       if (work_done < budget) {
           // å¤„ç†å®Œæ‰€æœ‰åŒ…ï¼Œé‡æ–°å¯ç”¨ä¸­æ–­
           napi_complete(napi);
           enable_irq(priv->dev->irq);
       }

       return work_done;
   }
   ```

#### **ç¬¬ä¸‰é˜¶æ®µï¼šå†…æ ¸åè®®æ ˆå¤„ç†**

5. **é“¾è·¯å±‚å¤„ç†ï¼ˆL2ï¼‰**

   ```c
   // ä»¥å¤ªç½‘å¸§å¤„ç†
   int eth_type_trans(struct sk_buff *skb, struct net_device *dev)
   {
       struct ethhdr *eth = (struct ethhdr *)skb->data;

       // ç§»é™¤ä»¥å¤ªç½‘å¤´éƒ¨
       skb_pull(skb, ETH_HLEN);

       // æ ¹æ® EtherType ç¡®å®šä¸Šå±‚åè®®
       switch (ntohs(eth->h_proto)) {
           case ETH_P_IP:   return ETH_P_IP;      // IPv4
           case ETH_P_IPV6: return ETH_P_IPV6;    // IPv6
           case ETH_P_ARP:  return ETH_P_ARP;     // ARP
           default:         return ETH_P_802_3;   // å…¶ä»–
       }
   }
   ```

6. **ç½‘ç»œå±‚å¤„ç†ï¼ˆL3 - IPï¼‰**

   ```c
   // IP åŒ…å¤„ç†æµç¨‹
   int ip_rcv(struct sk_buff *skb, struct net_device *dev,
              struct packet_type *pt, struct net_device *orig_dev)
   {
       struct iphdr *iph = ip_hdr(skb);

       // IP å¤´éƒ¨æ ¡éªŒ
       if (iph->version != 4 || ip_fast_csum((u8*)iph, iph->ihl))
           goto drop;

       // TTL æ£€æŸ¥
       if (iph->ttl <= 1)
           goto drop;

       // è·¯ç”±å†³ç­–
       if (ip_route_input(skb, iph->daddr, iph->saddr, iph->tos, dev))
           goto drop;

       // åˆ†ç‰‡é‡ç»„ï¼ˆå¦‚æœéœ€è¦ï¼‰
       if (iph->frag_off & htons(IP_MF | IP_OFFSET)) {
           skb = ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER);
           if (!skb) return 0;
       }

       // ä¼ é€’ç»™ä¼ è¾“å±‚
       return ip_local_deliver(skb);

   drop:
       kfree_skb(skb);
       return 0;
   }
   ```

7. **ä¼ è¾“å±‚å¤„ç†ï¼ˆL4 - TCP/UDPï¼‰**

   ```c
   // TCP åŒ…å¤„ç†
   int tcp_v4_rcv(struct sk_buff *skb)
   {
       struct tcphdr *th = tcp_hdr(skb);
       struct sock *sk;

       // æŸ¥æ‰¾å¯¹åº”çš„ socket
       sk = __inet_lookup_skb(&tcp_hashinfo, skb, th->source, th->dest);
       if (!sk)
           goto no_tcp_socket;

       // æ£€æŸ¥ socket çŠ¶æ€
       if (sk->sk_state == TCP_TIME_WAIT)
           goto do_time_wait;

       // å°†æ•°æ®åŒ…æ·»åŠ åˆ° socket æ¥æ”¶é˜Ÿåˆ—
       if (tcp_prequeue(sk, skb))
           goto discard_and_relse;

       // å¤„ç† TCP çŠ¶æ€æœº
       tcp_v4_do_rcv(sk, skb);
       return 0;

   no_tcp_socket:
       // å‘é€ RST åŒ…
       tcp_v4_send_reset(NULL, skb);
       goto discard_it;
   }
   ```

#### **ç¬¬å››é˜¶æ®µï¼šSocket å±‚ä¸åº”ç”¨å±‚äº¤äº’**

8. **Socket ç¼“å†²åŒºç®¡ç†**

   ```c
   // å°†æ•°æ®æ·»åŠ åˆ° socket æ¥æ”¶é˜Ÿåˆ—
   static int tcp_queue_rcv(struct sock *sk, struct sk_buff *skb, int hdrlen)
   {
       // æ£€æŸ¥æ¥æ”¶ç¼“å†²åŒºæ˜¯å¦æœ‰ç©ºé—´
       if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf) {
           __kfree_skb(skb);
           return -ENOMEM;
       }

       // å°†æ•°æ®åŒ…é“¾æ¥åˆ°æ¥æ”¶é˜Ÿåˆ—
       __skb_queue_tail(&sk->sk_receive_queue, skb);
       sk->sk_rmem_alloc += skb->truesize;

       // å”¤é†’ç­‰å¾…æ•°æ®çš„è¿›ç¨‹
       sk->sk_data_ready(sk, skb->len);
       return 0;
   }
   ```

9. **å”¤é†’é˜»å¡è¿›ç¨‹**

   ```c
   // æ•°æ®å°±ç»ªå›è°ƒå‡½æ•°
   static void sock_def_readable(struct sock *sk, int len)
   {
       read_lock(&sk->sk_callback_lock);
       if (sk_has_sleeper(sk))
           wake_up_interruptible_sync_poll(&sk->sk_sleep, POLLIN | POLLRDNORM);
       sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
       read_unlock(&sk->sk_callback_lock);
   }
   ```

10. **ç”¨æˆ·ç©ºé—´æ•°æ®è¯»å–**

```c
// ç”¨æˆ·ç¨‹åºé€šè¿‡ recv() ç³»ç»Ÿè°ƒç”¨è¯»å–æ•°æ®
ssize_t sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t size, int flags)
{
    struct sock *sk = sock->sk;
    int addr_len = 0;
    int err;

    // ä» socket æ¥æ”¶é˜Ÿåˆ—å¤åˆ¶æ•°æ®åˆ°ç”¨æˆ·ç¼“å†²åŒº
    err = sk->sk_prot->recvmsg(sk, msg, size, flags, &addr_len);
    if (err >= 0)
        msg->msg_namelen = addr_len;
    return err;
}
```

### **å®Œæ•´æµç¨‹å›¾**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç‰©ç†ä»‹è´¨      â”‚ â† ç”µä¿¡å·/å…‰ä¿¡å·/æ— çº¿ç”µæ³¢
â”‚ (ç½‘çº¿/æ— çº¿)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ ç‰©ç†å±‚è½¬æ¢
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç½‘å¡ç¡¬ä»¶      â”‚ â† PHYèŠ¯ç‰‡ï¼ŒMACæ§åˆ¶å™¨
â”‚ (NIC Hardware)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ ç¡¬ä»¶ä¸­æ–­/DMA
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç½‘å¡é©±åŠ¨ç¨‹åº   â”‚ â† ä¸­æ–­å¤„ç†ï¼ŒNAPIè½®è¯¢
â”‚ (NIC Driver)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ netif_receive_skb()
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å†…æ ¸åè®®æ ˆ     â”‚ â† åˆ†å±‚å¤„ç†: L2â†’L3â†’L4
â”‚   é“¾è·¯å±‚(L2)    â”‚   (Ethernet â†’ IP â†’ TCP/UDP)
â”‚   ç½‘ç»œå±‚(L3)    â”‚
â”‚   ä¼ è¾“å±‚(L4)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ SocketåŒ¹é…
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Socketç¼“å†²åŒº   â”‚ â† sk_receive_queue
â”‚ (Socket Buffer) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“ ç³»ç»Ÿè°ƒç”¨ (recv/read)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”¨æˆ·è¿›ç¨‹ä»£ç    â”‚ â† åº”ç”¨ç¨‹åºå¤„ç†æ•°æ®
â”‚ (User Process)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. å‘é€æ•°æ®åŒ…çš„æµç¨‹ï¼ˆåå‘è¿‡ç¨‹ï¼‰

äº†è§£æ¥æ”¶æµç¨‹åï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹æ•°æ®åŒ…æ˜¯å¦‚ä½•ä»åº”ç”¨ç¨‹åºå‘é€åˆ°ç½‘ç»œçš„ï¼š

### **å‘é€æµç¨‹æ¦‚è§ˆ**ï¼š

```
[ç”¨æˆ·è¿›ç¨‹] -> [ç³»ç»Ÿè°ƒç”¨] -> [Socketå±‚] -> [åè®®æ ˆ] -> [ç½‘å¡é©±åŠ¨] -> [ç½‘å¡ç¡¬ä»¶] -> [ç‰©ç†ä»‹è´¨]
```

#### **åº”ç”¨å±‚å‘é€æ•°æ®**

```c
// ç”¨æˆ·ç¨‹åºå‘é€æ•°æ®
char *message = "Hello, Network!";
ssize_t sent = send(sockfd, message, strlen(message), 0);
```

#### **ç³»ç»Ÿè°ƒç”¨å¤„ç†**

```c
// sys_sendto ç³»ç»Ÿè°ƒç”¨
SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,
                unsigned int, flags, struct sockaddr __user *, addr,
                int, addr_len)
{
    struct socket *sock;
    struct sockaddr_storage address;
    int err;

    // è·å– socket å¯¹è±¡
    sock = sockfd_lookup_light(fd, &err, &fput_needed);
    if (!sock)
        goto out;

    // è°ƒç”¨åè®®æ—çš„å‘é€å‡½æ•°
    err = sock_sendmsg(sock, &msg, len);

    sockfd_put_light(sock, fput_needed);
out:
    return err;
}
```

#### **TCP åè®®å±‚å¤„ç†**

```c
// TCP å‘é€å¤„ç†
int tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size)
{
    struct tcp_sock *tp = tcp_sk(sk);
    struct sk_buff *skb;
    int flags, err;

    // æ£€æŸ¥è¿æ¥çŠ¶æ€
    if (sk->sk_state != TCP_ESTABLISHED)
        return -EPIPE;

    // åˆ†é… sk_buff
    skb = sk_stream_alloc_skb(sk, select_size(sk), sk->sk_allocation);
    if (!skb)
        return -ENOMEM;

    // å¤åˆ¶ç”¨æˆ·æ•°æ®åˆ°å†…æ ¸ç¼“å†²åŒº
    if (skb_add_data(skb, from, copy) != 0) {
        __kfree_skb(skb);
        return -EFAULT;
    }

    // æ·»åŠ åˆ°å‘é€é˜Ÿåˆ—
    tcp_push(sk, flags, mss_now, tp->nonagle);

    return size;
}
```

#### **IP å±‚è·¯ç”±ä¸å°è£…**

```c
// IP å±‚å‘é€
int ip_queue_xmit(struct sk_buff *skb, struct flowi *fl)
{
    struct sock *sk = skb->sk;
    struct rtable *rt;
    struct iphdr *iph;

    // è·¯ç”±æŸ¥æ‰¾
    rt = ip_route_output_flow(&init_net, fl, sk);
    if (IS_ERR(rt))
        goto no_route;

    // æ„å»º IP å¤´éƒ¨
    skb_push(skb, sizeof(struct iphdr));
    iph = ip_hdr(skb);
    iph->version = 4;
    iph->ihl = 5;
    iph->tos = 0;
    iph->tot_len = htons(skb->len);
    iph->id = htons(ip_ident++);
    iph->frag_off = 0;
    iph->ttl = 64;
    iph->protocol = IPPROTO_TCP;
    iph->saddr = fl->fl4_src;
    iph->daddr = fl->fl4_dst;
    iph->check = 0;
    iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);

    // ä¼ é€’ç»™ç½‘ç»œè®¾å¤‡å±‚
    return dst_output(skb);
}
```

#### **ç½‘ç»œè®¾å¤‡å±‚å¤„ç†**

```c
// ç½‘ç»œè®¾å¤‡å‘é€
int dev_queue_xmit(struct sk_buff *skb)
{
    struct net_device *dev = skb->dev;
    struct netdev_queue *txq;

    // é€‰æ‹©å‘é€é˜Ÿåˆ—
    txq = netdev_pick_tx(dev, skb);

    // æ£€æŸ¥è®¾å¤‡çŠ¶æ€
    if (unlikely(dev->flags & IFF_UP) == 0) {
        kfree_skb(skb);
        return -ENETDOWN;
    }

    // è°ƒç”¨é©±åŠ¨ç¨‹åºå‘é€å‡½æ•°
    return dev_hard_start_xmit(skb, dev, txq);
}
```

---

## 3. é«˜çº§ç‰¹æ€§ä¸æ€§èƒ½ä¼˜åŒ–

### **é›¶æ‹·è´ï¼ˆZero-Copyï¼‰æŠ€æœ¯**

ä¼ ç»Ÿçš„ç½‘ç»œ I/O éœ€è¦å¤šæ¬¡æ•°æ®æ‹·è´ï¼Œé›¶æ‹·è´æŠ€æœ¯å‡å°‘äº†ä¸å¿…è¦çš„æ‹·è´æ“ä½œï¼š

```c
// sendfile() ç³»ç»Ÿè°ƒç”¨ - ç›´æ¥åœ¨å†…æ ¸ç©ºé—´ä¼ è¾“æ–‡ä»¶
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);

// splice() ç³»ç»Ÿè°ƒç”¨ - åœ¨ä¸¤ä¸ªæ–‡ä»¶æè¿°ç¬¦é—´ä¼ è¾“æ•°æ®
ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out,
               size_t len, unsigned int flags);

// å†…å­˜æ˜ å°„ + write
void *mapped = mmap(NULL, file_size, PROT_READ, MAP_PRIVATE, fd, 0);
write(sockfd, mapped, file_size);
munmap(mapped, file_size);
```

**æ€§èƒ½æå‡**ï¼š

- å‡å°‘ CPU ä½¿ç”¨ç‡
- é™ä½å†…å­˜å¸¦å®½å ç”¨
- å‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢
- é€‚åˆå¤§æ–‡ä»¶ä¼ è¾“åœºæ™¯

### **ç½‘ç»œåŒ…è¿‡æ»¤ä¸å¤„ç†**

#### **eBPFï¼ˆExtended Berkeley Packet Filterï¼‰**

eBPF å…è®¸åœ¨å†…æ ¸ç©ºé—´è¿è¡Œç”¨æˆ·å®šä¹‰çš„ç¨‹åºï¼Œå®ç°é«˜æ€§èƒ½çš„åŒ…å¤„ç†ï¼š

```c
// eBPF ç¨‹åºç¤ºä¾‹ï¼šä¸¢å¼ƒç‰¹å®šç«¯å£çš„åŒ…
#include <linux/bpf.h>
#include <linux/if_ether.h>
#include <linux/ip.h>
#include <linux/tcp.h>

SEC("prog")
int packet_filter(struct __sk_buff *skb)
{
    void *data = (void *)(long)skb->data;
    void *data_end = (void *)(long)skb->data_end;

    struct ethhdr *eth = data;
    if ((void *)eth + sizeof(*eth) > data_end)
        return XDP_PASS;

    if (eth->h_proto != htons(ETH_P_IP))
        return XDP_PASS;

    struct iphdr *ip = (void *)eth + sizeof(*eth);
    if ((void *)ip + sizeof(*ip) > data_end)
        return XDP_PASS;

    if (ip->protocol != IPPROTO_TCP)
        return XDP_PASS;

    struct tcphdr *tcp = (void *)ip + sizeof(*ip);
    if ((void *)tcp + sizeof(*tcp) > data_end)
        return XDP_PASS;

    // ä¸¢å¼ƒç›®æ ‡ç«¯å£ä¸º 8080 çš„åŒ…
    if (ntohs(tcp->dest) == 8080)
        return XDP_DROP;

    return XDP_PASS;
}
```

#### **XDPï¼ˆeXpress Data Pathï¼‰**

XDP åœ¨é©±åŠ¨å±‚ç›´æ¥å¤„ç†ç½‘ç»œåŒ…ï¼Œå®ç°æœ€ä½å»¶è¿Ÿçš„åŒ…å¤„ç†ï¼š

```c
// XDP ç¨‹åºï¼šç®€å•çš„è´Ÿè½½å‡è¡¡
SEC("xdp")
int load_balancer(struct xdp_md *ctx)
{
    void *data = (void *)(long)ctx->data;
    void *data_end = (void *)(long)ctx->data_end;

    struct ethhdr *eth = data;
    struct iphdr *ip = (void *)eth + sizeof(*eth);

    // è¾¹ç•Œæ£€æŸ¥
    if ((void *)ip + sizeof(*ip) > data_end)
        return XDP_PASS;

    // åŸºäºæº IP çš„ç®€å•å“ˆå¸Œè´Ÿè½½å‡è¡¡
    __u32 hash = ip->saddr % 4;

    switch (hash) {
        case 0:
            // è½¬å‘åˆ°æœåŠ¡å™¨ 1
            return bpf_redirect_map(&server_map, 0, 0);
        case 1:
            // è½¬å‘åˆ°æœåŠ¡å™¨ 2
            return bpf_redirect_map(&server_map, 1, 0);
        default:
            return XDP_PASS;
    }
}
```

### **DPDKï¼ˆData Plane Development Kitï¼‰**

DPDK ç»•è¿‡å†…æ ¸ï¼Œåœ¨ç”¨æˆ·ç©ºé—´ç›´æ¥å¤„ç†ç½‘ç»œåŒ…ï¼š

```c
// DPDK åº”ç”¨ç¨‹åºç¤ºä¾‹
#include <rte_eal.h>
#include <rte_ethdev.h>
#include <rte_mbuf.h>

#define RX_RING_SIZE 1024
#define TX_RING_SIZE 1024
#define NUM_MBUFS 8191
#define MBUF_CACHE_SIZE 250

int main(int argc, char *argv[])
{
    struct rte_mempool *mbuf_pool;
    uint16_t portid = 0;

    // åˆå§‹åŒ– EAL
    int ret = rte_eal_init(argc, argv);
    if (ret < 0)
        rte_exit(EXIT_FAILURE, "Error with EAL initialization\n");

    // åˆ›å»ºå†…å­˜æ± 
    mbuf_pool = rte_pktmbuf_pool_create("MBUF_POOL", NUM_MBUFS,
        MBUF_CACHE_SIZE, 0, RTE_MBUF_DEFAULT_BUF_SIZE, rte_socket_id());

    // é…ç½®ç½‘ç»œç«¯å£
    if (port_init(portid, mbuf_pool) != 0)
        rte_exit(EXIT_FAILURE, "Cannot init port %"PRIu16 "\n", portid);

    // ä¸»å¾ªç¯ï¼šæ¥æ”¶å’Œå¤„ç†åŒ…
    for (;;) {
        struct rte_mbuf *bufs[BURST_SIZE];
        const uint16_t nb_rx = rte_eth_rx_burst(portid, 0, bufs, BURST_SIZE);

        if (unlikely(nb_rx == 0))
            continue;

        // å¤„ç†æ¥æ”¶åˆ°çš„åŒ…
        for (int i = 0; i < nb_rx; i++) {
            process_packet(bufs[i]);
        }

        // å‘é€å¤„ç†åçš„åŒ…
        const uint16_t nb_tx = rte_eth_tx_burst(portid, 0, bufs, nb_rx);

        // é‡Šæ”¾æœªå‘é€çš„åŒ…
        if (unlikely(nb_tx < nb_rx)) {
            for (int i = nb_tx; i < nb_rx; i++)
                rte_pktmbuf_free(bufs[i]);
        }
    }

    return 0;
}
```

**DPDK ä¼˜åŠ¿**ï¼š

- ç»•è¿‡å†…æ ¸åè®®æ ˆï¼Œå‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢
- è½®è¯¢æ¨¡å¼ï¼Œé¿å…ä¸­æ–­å¼€é”€
- å¤§é¡µå†…å­˜ï¼Œå‡å°‘ TLB ç¼ºå¤±
- CPU äº²å’Œæ€§ï¼Œé¿å…ç¼“å­˜é¢ ç°¸
- é›¶æ‹·è´ï¼Œç›´æ¥åœ¨ç”¨æˆ·ç©ºé—´å¤„ç†åŒ…

---

## 4. å®é™…åº”ç”¨åœºæ™¯

### **é«˜æ€§èƒ½ Web æœåŠ¡å™¨**

```c
// ä½¿ç”¨ epoll çš„é«˜æ€§èƒ½æœåŠ¡å™¨ç¤ºä¾‹
#include <sys/epoll.h>
#include <unistd.h>

#define MAX_EVENTS 10000
#define BUFFER_SIZE 4096

int main() {
    int server_fd, epoll_fd;
    struct epoll_event ev, events[MAX_EVENTS];
    struct sockaddr_in address;

    // åˆ›å»ºæœåŠ¡å™¨ socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);

    // è®¾ç½®éé˜»å¡
    int flags = fcntl(server_fd, F_GETFL, 0);
    fcntl(server_fd, F_SETFL, flags | O_NONBLOCK);

    // ç»‘å®šåœ°å€
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(8080);
    bind(server_fd, (struct sockaddr *)&address, sizeof(address));

    // ç›‘å¬è¿æ¥
    listen(server_fd, SOMAXCONN);

    // åˆ›å»º epoll å®ä¾‹
    epoll_fd = epoll_create1(0);

    // æ·»åŠ æœåŠ¡å™¨ socket åˆ° epoll
    ev.events = EPOLLIN;
    ev.data.fd = server_fd;
    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &ev);

    // ä¸»äº‹ä»¶å¾ªç¯
    for (;;) {
        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);

        for (int n = 0; n < nfds; ++n) {
            if (events[n].data.fd == server_fd) {
                // æ–°è¿æ¥
                int client_fd = accept(server_fd, NULL, NULL);
                if (client_fd != -1) {
                    // è®¾ç½®éé˜»å¡
                    int flags = fcntl(client_fd, F_GETFL, 0);
                    fcntl(client_fd, F_SETFL, flags | O_NONBLOCK);

                    // æ·»åŠ åˆ° epoll
                    ev.events = EPOLLIN | EPOLLET;  // è¾¹ç¼˜è§¦å‘
                    ev.data.fd = client_fd;
                    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_fd, &ev);
                }
            } else {
                // å®¢æˆ·ç«¯æ•°æ®
                int client_fd = events[n].data.fd;
                char buffer[BUFFER_SIZE];

                ssize_t bytes = read(client_fd, buffer, sizeof(buffer));
                if (bytes > 0) {
                    // å¤„ç†è¯·æ±‚å¹¶å‘é€å“åº”
                    handle_request(client_fd, buffer, bytes);
                } else if (bytes == 0 || errno != EAGAIN) {
                    // è¿æ¥å…³é—­æˆ–é”™è¯¯
                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, client_fd, NULL);
                    close(client_fd);
                }
            }
        }
    }

    return 0;
}
```

### **ç½‘ç»œç›‘æ§ä¸åˆ†æ**

```c
// ä½¿ç”¨åŸå§‹å¥—æ¥å­—è¿›è¡Œç½‘ç»œç›‘æ§
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/if_ether.h>

int main() {
    int sock_fd;
    char buffer[65536];
    struct sockaddr saddr;
    int saddr_len = sizeof(saddr);

    // åˆ›å»ºåŸå§‹å¥—æ¥å­—
    sock_fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (sock_fd < 0) {
        perror("Socket Error");
        return 1;
    }

    while (1) {
        // æ¥æ”¶æ•°æ®åŒ…
        ssize_t data_size = recvfrom(sock_fd, buffer, 65536, 0, &saddr, (socklen_t*)&saddr_len);
        if (data_size < 0) {
            perror("Recvfrom error");
            return 1;
        }

        // è§£æä»¥å¤ªç½‘å¤´éƒ¨
        struct ethhdr *eth = (struct ethhdr *)buffer;

        if (ntohs(eth->h_proto) == ETH_P_IP) {
            // è§£æ IP å¤´éƒ¨
            struct iphdr *iph = (struct iphdr*)(buffer + sizeof(struct ethhdr));

            printf("IP Packet: %s -> ", inet_ntoa(*(struct in_addr*)&iph->saddr));
            printf("%s\n", inet_ntoa(*(struct in_addr*)&iph->daddr));

            if (iph->protocol == IPPROTO_TCP) {
                // è§£æ TCP å¤´éƒ¨
                struct tcphdr *tcph = (struct tcphdr*)(buffer + sizeof(struct ethhdr) + iph->ihl*4);
                printf("TCP Packet: Port %d -> %d\n", ntohs(tcph->source), ntohs(tcph->dest));

                // è¿›è¡Œæµé‡ç»Ÿè®¡ã€å¼‚å¸¸æ£€æµ‹ç­‰
                analyze_tcp_packet(iph, tcph);
            }
        }
    }

    close(sock_fd);
    return 0;
}
```

---

## 5. ç½‘ç»œå®‰å…¨ä¸é˜²æŠ¤

### **DDoS é˜²æŠ¤æœºåˆ¶**

```c
// ç®€å•çš„ SYN flood é˜²æŠ¤
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>

static struct {
    __u32 src_ip;
    unsigned long timestamp;
    int count;
} syn_table[SYN_TABLE_SIZE];

static unsigned int syn_flood_hook(void *priv,
                                   struct sk_buff *skb,
                                   const struct nf_hook_state *state)
{
    struct iphdr *iph = ip_hdr(skb);
    struct tcphdr *tcph;

    if (iph->protocol != IPPROTO_TCP)
        return NF_ACCEPT;

    tcph = tcp_hdr(skb);

    // æ£€æŸ¥æ˜¯å¦ä¸º SYN åŒ…
    if (tcph->syn && !tcph->ack) {
        int hash = iph->saddr % SYN_TABLE_SIZE;
        unsigned long now = jiffies;

        // æ£€æŸ¥é¢‘ç‡
        if (syn_table[hash].src_ip == iph->saddr) {
            if (time_before(now, syn_table[hash].timestamp + HZ)) {
                syn_table[hash].count++;

                // è¶…è¿‡é˜ˆå€¼ï¼Œä¸¢å¼ƒåŒ…
                if (syn_table[hash].count > SYN_THRESHOLD) {
                    printk(KERN_INFO "SYN flood detected from %pI4\n", &iph->saddr);
                    return NF_DROP;
                }
            } else {
                // é‡ç½®è®¡æ•°å™¨
                syn_table[hash].count = 1;
                syn_table[hash].timestamp = now;
            }
        } else {
            // æ–°çš„æº IP
            syn_table[hash].src_ip = iph->saddr;
            syn_table[hash].count = 1;
            syn_table[hash].timestamp = now;
        }
    }

    return NF_ACCEPT;
}
```

### **æµé‡æ•´å½¢ä¸ QoS**

```bash
# ä½¿ç”¨ tc (traffic control) é…ç½® QoS
# ä¸ºç½‘å¡ eth0 æ·»åŠ æ ¹é˜Ÿåˆ—è§„åˆ™
tc qdisc add dev eth0 root handle 1: htb default 30

# åˆ›å»ºä¸»ç±»åˆ«
tc class add dev eth0 parent 1: classid 1:1 htb rate 100mbit

# ä¸º HTTP æµé‡åˆ›å»ºé«˜ä¼˜å…ˆçº§ç±»åˆ«
tc class add dev eth0 parent 1:1 classid 1:10 htb rate 80mbit ceil 100mbit
tc class add dev eth0 parent 1:1 classid 1:20 htb rate 15mbit ceil 100mbit
tc class add dev eth0 parent 1:1 classid 1:30 htb rate 5mbit ceil 100mbit

# æ·»åŠ è¿‡æ»¤å™¨
tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 \
    match ip dport 80 0xffff flowid 1:10

tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 \
    match ip dport 443 0xffff flowid 1:10
```

---

## 6. æ€§èƒ½ç›‘æ§ä¸è°ƒè¯•

### **ç½‘ç»œæ€§èƒ½ç›‘æ§å·¥å…·**

```bash
# æŸ¥çœ‹ç½‘ç»œæ¥å£ç»Ÿè®¡ä¿¡æ¯
cat /proc/net/dev

# ä½¿ç”¨ ss æŸ¥çœ‹ socket çŠ¶æ€
ss -tuln  # æŸ¥çœ‹ç›‘å¬ç«¯å£
ss -i     # æ˜¾ç¤ºè¯¦ç»†çš„ socket ä¿¡æ¯

# ä½¿ç”¨ iftop ç›‘æ§ç½‘ç»œæµé‡
iftop -i eth0

# ä½¿ç”¨ tcpdump æŠ“åŒ…åˆ†æ
tcpdump -i eth0 -w capture.pcap
tcpdump -r capture.pcap -A  # æ˜¾ç¤º ASCII å†…å®¹

# æŸ¥çœ‹ç½‘ç»œè¿æ¥çŠ¶æ€ç»Ÿè®¡
netstat -s
```

### **å†…æ ¸ç½‘ç»œè°ƒè¯•**

```bash
# å¯ç”¨ç½‘ç»œåŒ…è·Ÿè¸ª
echo 1 > /sys/kernel/debug/tracing/events/net/enable

# æŸ¥çœ‹ç½‘ç»œåŒ…å¤„ç†è·¯å¾„
cat /sys/kernel/debug/tracing/trace

# è°ƒæ•´ç½‘ç»œç¼“å†²åŒºå¤§å°
echo 'net.core.rmem_max = 16777216' >> /etc/sysctl.conf
echo 'net.core.wmem_max = 16777216' >> /etc/sysctl.conf
sysctl -p

# æŸ¥çœ‹ TCP è¿æ¥çŠ¶æ€
cat /proc/net/tcp
```

---

## 7. æ€»ç»“ä¸æœ€ä½³å®è·µ

### **å…³é”®çŸ¥è¯†ç‚¹å›é¡¾**

1. **ç½‘ç»œåŒ…å¤„ç†æ˜¯å¤šå±‚åä½œçš„ç»“æœ**

   - ç¡¬ä»¶å±‚ï¼šç‰©ç†ä¿¡å·è½¬æ¢å’ŒåŸºç¡€è¿‡æ»¤
   - é©±åŠ¨å±‚ï¼šä¸­æ–­å¤„ç†å’Œ NAPI è½®è¯¢
   - åè®®æ ˆï¼šåˆ†å±‚è§£æå’Œè·¯ç”±å†³ç­–
   - Socketå±‚ï¼šç¼“å†²ç®¡ç†å’Œè¿›ç¨‹é€šä¿¡

2. **æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯å¤šæ ·åŒ–**

   - é›¶æ‹·è´æŠ€æœ¯å‡å°‘æ•°æ®æ‹·è´å¼€é”€
   - eBPF/XDP å®ç°å¯ç¼–ç¨‹çš„åŒ…å¤„ç†
   - DPDK æä¾›ç”¨æˆ·ç©ºé—´çš„é«˜æ€§èƒ½æ–¹æ¡ˆ

3. **å®‰å…¨é˜²æŠ¤ä¸å¯å¿½è§†**
   - DDoS é˜²æŠ¤éœ€è¦åœ¨å¤šä¸ªå±‚æ¬¡å®æ–½
   - åŒ…è¿‡æ»¤å’Œé˜²ç«å¢™æ˜¯åŸºç¡€å®‰å…¨æªæ–½
   - æµé‡æ•´å½¢æœ‰åŠ©äºæœåŠ¡è´¨é‡ä¿éšœ

### **ç¼–ç¨‹æœ€ä½³å®è·µ**

```c
// é«˜æ•ˆçš„ç½‘ç»œç¼–ç¨‹å»ºè®®

// 1. ä½¿ç”¨åˆé€‚çš„ I/O å¤šè·¯å¤ç”¨æœºåˆ¶
#ifdef __linux__
    // Linux ç³»ç»Ÿä¼˜å…ˆä½¿ç”¨ epoll
    int epfd = epoll_create1(EPOLL_CLOEXEC);
#elif defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
    // BSD ç³»ç»Ÿä½¿ç”¨ kqueue
    int kq = kqueue();
#else
    // å…¶ä»–ç³»ç»Ÿé™çº§åˆ° poll
    struct pollfd fds[MAX_FDS];
#endif

// 2. æ­£ç¡®è®¾ç½® socket é€‰é¡¹
int enable = 1;
setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable));
setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(enable));
setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, &enable, sizeof(enable));

// 3. ä½¿ç”¨é€‚å½“çš„ç¼“å†²åŒºå¤§å°
int buf_size = 1024 * 1024;  // 1MB
setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &buf_size, sizeof(buf_size));
setsockopt(sockfd, SOL_SOCKET, SO_SNDBUF, &buf_size, sizeof(buf_size));

// 4. é”™è¯¯å¤„ç†è¦å®Œå–„
ssize_t bytes = recv(sockfd, buffer, sizeof(buffer), 0);
if (bytes < 0) {
    if (errno == EAGAIN || errno == EWOULDBLOCK) {
        // éé˜»å¡ socketï¼Œç¨åé‡è¯•
        continue;
    } else {
        // çœŸæ­£çš„é”™è¯¯
        perror("recv failed");
        close(sockfd);
    }
} else if (bytes == 0) {
    // è¿æ¥å·²å…³é—­
    close(sockfd);
}
```

### **è°ƒè¯•ä¸ä¼˜åŒ–æŒ‡å—**

```bash
# ç½‘ç»œæ€§èƒ½è°ƒä¼˜æ£€æŸ¥æ¸…å•

# 1. æ£€æŸ¥ç½‘å¡é©±åŠ¨å’Œç¡¬ä»¶
ethtool eth0                    # æŸ¥çœ‹ç½‘å¡çŠ¶æ€
ethtool -S eth0                 # æŸ¥çœ‹ç½‘å¡ç»Ÿè®¡ä¿¡æ¯
ethtool -k eth0                 # æŸ¥çœ‹ç½‘å¡åŠŸèƒ½

# 2. ç³»ç»Ÿç½‘ç»œå‚æ•°ä¼˜åŒ–
echo 'net.core.netdev_max_backlog = 5000' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_congestion_control = bbr' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_window_scaling = 1' >> /etc/sysctl.conf

# 3. ä¸­æ–­å’Œ CPU äº²å’Œæ€§
cat /proc/interrupts | grep eth0
echo 2 > /proc/irq/24/smp_affinity  # å°†ä¸­æ–­ç»‘å®šåˆ°ç‰¹å®š CPU

# 4. å†…å­˜å’Œç¼“å­˜ä¼˜åŒ–
echo 3 > /proc/sys/vm/drop_caches   # æ¸…ç†ç¼“å­˜
hugeadm --list-all-mounts          # æ£€æŸ¥å¤§é¡µå†…å­˜
```

é€šè¿‡æ·±å…¥ç†è§£ç½‘ç»œåŒ…å¤„ç†æœºåˆ¶ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ›´å¥½åœ°è®¾è®¡é«˜æ€§èƒ½ç½‘ç»œåº”ç”¨ï¼Œå……åˆ†åˆ©ç”¨æ“ä½œç³»ç»Ÿæä¾›çš„ç½‘ç»œåŠŸèƒ½ï¼Œå¹¶åœ¨éœ€è¦æ—¶è¿›è¡Œé’ˆå¯¹æ€§çš„ä¼˜åŒ–ã€‚ç½‘ç»œç¼–ç¨‹ä¸ä»…éœ€è¦æŒæ¡ API çš„ä½¿ç”¨ï¼Œæ›´éœ€è¦ç†è§£åº•å±‚çš„å·¥ä½œåŸç†ï¼Œè¿™æ ·æ‰èƒ½å†™å‡ºçœŸæ­£é«˜æ•ˆã€å¯é çš„ç½‘ç»œç¨‹åºã€‚

---

> **å­¦ä¹ å»ºè®®**ï¼šç½‘ç»œç¼–ç¨‹æ¶‰åŠå¤šä¸ªå±‚æ¬¡çš„çŸ¥è¯†ï¼Œå»ºè®®å…ˆç†è§£åŸºæœ¬çš„ Socket ç¼–ç¨‹ï¼Œå†æ·±å…¥å­¦ä¹ åè®®æ ˆåŸç†ï¼Œæœ€åæ¢ç´¢é«˜çº§ä¼˜åŒ–æŠ€æœ¯ã€‚å®è·µä¸­é‡åˆ°æ€§èƒ½é—®é¢˜æ—¶ï¼Œè¦å­¦ä¼šä½¿ç”¨å„ç§ç›‘æ§å’Œè°ƒè¯•å·¥å…·æ¥å®šä½ç“¶é¢ˆã€‚

**çŸ¥è¯†ä½“ç³»å¯¼èˆª**ï¼š

- âœ… **å½“å‰ç« èŠ‚**ï¼šç½‘ç»œåŒ…å¤„ç† - ä»ç¡¬ä»¶åˆ°åº”ç”¨çš„å®Œæ•´æ•°æ®è·¯å¾„
- ğŸ”— **ç›¸å…³ç« èŠ‚**ï¼šä¸­æ–­å’Œä¿¡å·æœºåˆ¶ã€è®¾å¤‡ç®¡ç†ã€ç³»ç»Ÿè°ƒç”¨
- ğŸš€ **åç»­ç« èŠ‚**ï¼šè¿›ç¨‹ç®¡ç†ã€å†…å­˜ç®¡ç†ç­‰æ ¸å¿ƒæœºåˆ¶
