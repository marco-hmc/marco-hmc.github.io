---
layout: post
title: 编译过程与原理
categories: 编译原理
related_posts: True
tags:
toc:
  sidebar: left
---

## 编译过程与原理

### 1. 编译过程 - 编译器在做什么？

如果想要机器按照我们的设想执行我们的命令，我们需要一个能够跟机器沟通的方式，而这种方式也就是==机器语言(第一代计算机语言)==，一堆`01`构成的指令。我们需要事先设计好指令集到机器上，比如说规定好从某寄存器阅读值的指令为什么。

可这种方式面临的第一个问题就是，不同机器之间指令集不一致，比如说DSP和ARM在实现加法上，可能就会出现不同寄存器的调用方法。那很显然就会设想出一种统一的语言，即==汇编语言(第二代计算机语言)==。而汇编实现的只是将`01`等机器码指令使用一个统一的命名，如`ADD`而已。令所有机器指令集可与汇编语言转换即可。

汇编语言仍存在很多问题，主要表现为阅读性极差、开发难度大、开发周期长、移植问题没有彻底解决。因此也就出现了==高级语言(第三代语言)==，在汇编语言的基础上实现了抽象，避免了繁琐寄存器的操作。

那源代码(高级语言)是如何让计算机理解的呢？其步骤是？

- 如果源代码在操作系统上：源代码生成汇编代码，再通过汇编和链接方式形成可执行文件，然后通过加载器加载到操作系统执行。
- 如果源代码在虚拟机(解释器)上：源代码生成中间代码(人可以直接理解的，而汇编则认为人无法理解)，如字节码等。

在Linux系统下，可用以下指令完成源程序到目标程序的转化：

> gcc -o hello hello.c main.c

gcc 编译器驱动程序读取源文件hello.c和main.c，经过预处理、编译、汇编、链接（分别使用预处理器、编译器、汇编器、链接器，这四个程序构成了编译系统）四个步骤，将其翻译成可执行目标程序hello。如下图所示：

![alt text](imgs/1_编译过程与原理_image.png)

#### 1.1 预处理

- 处理预处理指令，如宏定义的展开、条件编译指令、头文件的包含等。这一阶段，编译器会根据预处理指令修改源代码。

预处理器(CPP)根据源程序中以字符”#”开头的命令，修改源程序，得到另一个源程序，常以.i作为文件扩展名。修改主要包括#include、#define和条件编译三个方面。

> gcc -o main.i -E main.c

预处理只是对源文件进行了扩展，得到的仍然是C语言源程序。

#### 1.2 编译

编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。

编译器(CCL)将经过预处理器处理得到的文本文件hello.i和main.i翻译成hello.s与main.s，其中包含了汇编语言程序，汇编语言程序以一种标准的文本格式确切描述一条低级机器语言指令。
运行以下命令进行编译：

> gcc -S main.i hello.i

#### 1.3 汇编

汇编器(AS)将hello.s和main.s翻译成机器语言指令，并打包成可重定位目标程序，一般以.o为文件扩展名。可重定位目标程序是二进制文件，它的字节编码是机器语言指令而不是字符。
运行以下指令可得到重定位目标程序main.o和hello.o：

> gcc -c main.s hello.s

用文本编辑器打开main.o和hello.o发现文件是乱码，因为此时已经是二进制文件。

#### 1.4 链接

链接程序(LD）将main.o和hello.o以及一些其他必要的目标文件组合起来，创建可执行目标文件。

> gcc -o hello main.o hello.o

得到可执行程序hello.
在终端运行./hello，程序加载并运行.

根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种：

- 静态链接
  在这种链接方式下，函数的代码将从其所在的静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。
- 动态链接
  在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。
  对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。

[动态链接](https://kshttps0.wiz.cn/ks/note/view/2336be1c-7b66-490d-91e0-240081977c3d/e730f0ac-0a19-4994-8f7f-1355d3c86eec/#动态链接)
[动态库的编译](https://kshttps0.wiz.cn/ks/note/view/2336be1c-7b66-490d-91e0-240081977c3d/e730f0ac-0a19-4994-8f7f-1355d3c86eec/#动态库的编译)

##### 1.4.1 编译链接和载入

- 编译：将预处理生成的文件，经过**语法分析、词法分析、语义分析、以及优化后编译成若干个目标模块**。可以理解为将高级语言翻译为计算机可以理解的二进制代码，即机器语言
- 链接：由链接程序将编译后形成的**一组目标模块**以及他们所需要的**库函数**链接在一起，形成一个完整的**载入模型**。链接主要解决**模块间的相互引用问题**，分为**地址和空间分配**，**符号解析**和**重定位**几个步骤。**在编译阶段生成目标文件时，会暂时搁置这些外部引用**，而这些外部引用就是在链接时确定的，链接器在链接时，会**根据符号名称去相应模块中寻找对应的符号**，**待符号确定后，链接器会重写之前哪些未确定的符号的地址**，这个过程就是重定位
- 载入：由载入程序将载入模块载入内存

##### 1.4.2 动态链接和静态链接的区别

- 静态链接以一组可重定位目标文件为输入，文件由各种不同的代码和数据节组成，通过符号解析和重定位生成一个完全链接的可以加载和运行的可执行文件
- 静态链接有一些明显的缺点，**一是如果需要更新一个库，需要重新编译和链接库文件**。二是对于一些标准的函数，**如果将这些代码复制到每个程序运行的文本段中，会对存储器的资源造成很大的浪费**
- 共享库就是为解决静态链接问题而生，共享库是一个目标模块。在运行时，可以加载到任意存储器地址，并和一个在存储器中的程序链接起来。这个过程称为动态链接。共享库在unix下通常使用.so后缀，window下为dll
- 共享库使用两种方式共享，一是一个库只有一个so文件，**所有引用该库的执行程序共享这个文件的代码和数据**。**二是一个共享库的.text节的一个副本可以被不同的进程共享**
- 注意在整个程序的链接过程中，**链接器只是拷贝了一些重定位和符号信息**。**在程序加载（execve）时才会解析so文件中代码和数据的引用**

##### 1.4.3 动态库和静态库的创建与使用

- 库的名字由 lib+name+后缀，静态库的后缀为.a 动态库的后缀为.so

- 动态库的创建步骤

  - 将.c文件全部编译为.o文件

  - 在Shell下输入命令，创建动态库：

    ```shell
    gcc -shared –fPIC –o libname.so sourcefile.c
    -shared 该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件
    -fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的
    ```

  - 使用动态库

    ```shell
    gcc -o file file.c -L. -lname
    -L.：表示要链接的库在当前目录中
    ```

  - **动态链接时、执行时搜索路径顺序**

    - 编译目标代码时，`-L`指定的动态库搜索路径
    - 环境变量`LD_LIBRARY_PATH`指定的动态库搜索路径
    - 配置文件`/etc/ld.so.conf`中指定的动态库搜索路径
    - 默认的动态库搜索路径`/lib`，`/usr/lib`

- 静态库的创建步骤

  - 将.c文件全部编译为.o文件

  - 在Shell下输入命令，创建静态库：

    ```shell
    ar rcs libname.a 目标文件1 目标文件2...
    ```

- 使用静态库

  ```shell
   gcc  -o file file.c –L. -lname
   # -L 为静态库路径
   # -l 为是链接到库的名字（可以简写库的名字）
  ```

- **静态库链接时搜索路径顺序**

  - ld会去找GCC命令中的参数`-L`

  - 再找gcc的环境变量`LIBRARY_PATH`
  - 再找内定目录 `/lib`，`/usr/lib`， `/usr/local/lib` 这是当初compile gcc时写在程序内的

### 2. 编译原理 - 编译器是如何实现的？

![image-20220126215910369](https://s2.loli.net/2022/01/26/xVbeED8TKaYIG2w.png)

[编译原理入门篇|一篇文章理解编译全过程](https://www.cnblogs.com/fisherss/p/13905395.html)

[手把手教你构建C语言编译器](https://lotabout.me/2015/write-a-C-interpreter-0/)

- **程序的准备**：

  1. **编写源代码**：
     - 开发者使用编程语言编写源代码，并将其保存在硬盘上。
  2. **编译**：
     - 由编译程序将用户源代码编译成若干个目标模块。目标模块是机器码文件，通常保存在硬盘上。
     - **涉及内容**：词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成
  3. **链接**：
     - 由链接程序将编译后形成的目标模块和所需库函数链接在一起，形成一个完整的装入模块。装入模块也是机器码文件，保存在硬盘上。
     - **涉及内容**：静态链接、装入时动态链接、运行时动态链接

- **程序的运行**：

  1. **装入**：

     - 由装入程序将装入模块从硬盘装入内存。装入程序会将装入模块的内容复制到内存的某个位置，并准备好程序运行所需的环境。
     - **涉及内容**：绝对装入、静态装入、动态装入

  2. **取指**：

     - PC 保存了下一条要执行的指令的内存地址。在正常顺序执行时，PC 的值会自动递增，指向下一条指令的地址。
     - 在分支和跳转指令执行时，PC 的值会被修改为目标指令的地址，从而实现程序的流程控制，如条件分支、循环、函数调用和返回等。

  3. **译码**：

     - CPU 的控制单元根据指令的操作码部分，识别出指令的类型（如数据传输、算术运算、逻辑运算、控制流等）和操作数的寻址方式。
     - 对于不同的指令类型，控制单元会设置相应的控制信号，将操作数发送到相应的运算单元（如算术逻辑单元 ALU）或存储单元（如寄存器、内存）。
     - 对于复杂指令集（CISC）处理器，一条指令可能包含多个微操作，译码过程会将一条指令拆分为多个微操作，以提高处理器的性能；对于精简指令集（RISC）处理器，指令相对简单，译码过程相对简洁。

  4. **执行**：

     - 对于加法、减法、乘法、除法等算术运算，CPU 的 ALU 根据操作数和操作码进行计算。操作数可以来自寄存器或内存，计算结果可以存储在寄存器或写回内存。
     - 现代处理器通常具有多个执行单元，可以同时执行多个算术运算，提高并行处理能力。
     - **逻辑运算**：
       - 包括与、或、非、异或等逻辑运算，用于处理逻辑判断和位操作。逻辑运算在控制流、数据处理和错误检测等方面有广泛应用。
     - **内存访问**：
       - 对于内存访问指令，CPU 需要将逻辑地址转换为物理地址。这涉及到地址转换机制，通常由内存管理单元（MMU）完成。
       - **地址转换过程**：
         - **逻辑地址和物理地址**：逻辑地址是程序使用的地址，不考虑实际的物理内存布局；物理地址是内存中实际的存储位置。
         - **分页系统中的地址转换**：在分页系统中，逻辑地址分为页号和页内偏移量。MMU 通过查找页表将页号转换为页框号（物理页号），再结合页内偏移量得到物理地址。页表存储在内存中，通常由操作系统管理，为了提高性能，可能使用快表（TLB）作为页表的高速缓存，加快地址转换速度。
         - **分段系统中的地址转换**：在分段系统中，逻辑地址分为段号和段内地址。MMU 通过查找段表将段号转换为段的基地址，再加上段内地址得到物理地址。段表包含段的基地址、段限长等信息，用于段的保护和越界检查。
         - **段页式系统中的地址转换**：结合了分段和分页的优点，逻辑地址先通过段表找到段的页表，再通过页表找到页框号，最终得到物理地址。

  5. **写回**：
     - **结果的存储位置**：
       - 如果指令执行的结果需要保存，根据指令的语义，结果可以存储在寄存器或内存中。
       - 对于存储在内存中的结果，CPU 会将结果通过数据总线发送到内存，由内存控制器将数据写入相应的物理地址。
       - 对于存储在寄存器中的结果，将用于后续的指令操作，以提高数据的访问速度。

#### 2.1 c++的符号导入导出

- **C++中符号是什么意思?导入和导出又是什么?**

  - 符号:
    在C++中，"符号"通常指的是程序中的函数名、变量名等标识符。在编译和链接过程中，这些符号被用来标识和引用代码中的特定部分。
  - 导入导出:
    "导入"和"导出"是动态链接库（DLL）或共享对象（SO）中的概念。当你创建一个动态链接库时，你可能会有一些函数或变量想要让其他程序或库使用，这时你就需要将这些函数或变量"导出"。"导出"就是将这些符号（函数或变量的名字）添加到库的公开符号表中，这样其他程序就可以在运行时链接到这些函数或变量。

    相反，当你的程序或库想要使用动态链接库中的函数或变量时，你需要"导入"这些符号。"导入"就是在你的程序中引用这些公开的符号，然后在运行时，动态链接器会负责找到这些符号对应的实际函数或变量。

    总的来说，"导入"和"导出"是动态链接的基础，它们允许程序在运行时共享和使用代码。

  - 符号表:
    在C++中,符号表是编译器在编译过程中创建的一种数据结构,用于存储程序中定义的各种符号(如函数名/变量名等)及其相关信息(如类型/作用域/内存位置等).

    可以使用nm命令来查看一个编译后的二进制文件(如可执行文件或库文件)的符号表.例如:

    ```c++
      nm my_program
    ```

    这将列出my_program中的所有符号,以及它们在程序中的地址.

    需要注意的是,只有在编译时开启了调试信息(如使用-g选项)时,才能在编译后的二进制文件中看到完整的符号表.否则,可能只能看到部分或没有符号信息.

- **linux和windows的符号导入导出的行为差异？**

  - 在Windows中,符号的导入和导出通常需要明确指定.例如,当你创建一个DLL时,你需要使用**declspec(dllexport)关键字来明确标记哪些函数或变量需要导出.同样,当你使用一个DLL时,你需要使用**declspec(dllimport)来明确标记哪些函数或变量需要导入.

    ```c++
    // 在DLL中
    __declspec(dllexport) void MyFunction();

    // 在使用DLL的程序中
    __declspec(dllimport) void MyFunction();
    ```

  - 在Linux中,情况则不同.默认情况下,所有的函数和全局变量都会被导出,除非你明确地隐藏它们.你可以使用**attribute**((visibility("default")))和**attribute**((visibility("hidden")))来控制符号的可见性.

    ```c++
    // 这个函数会被导出
    void MyFunction1();

    // 这个函数不会被导出
    __attribute__((visibility("hidden"))) void MyFunction2();
    ```

- LTCG: incremental

内建函数是和机器指令直接相关的，不会产生函数调用。
C++ 本身并没有内建函数,但是一些编译器(如 GCC 和 Clang)提供了一些内建函数,用于实现一些特殊的功能或优化.以下是一些常用的 GCC 和 Clang 的内建函数:

**builtin_expect(long exp, long c):这个函数用于提供分支预测信息给编译器,以优化生成的代码.exp 是你预计的值,c 是你期望的值.如果 exp == c,那么这个表达式的结果更有可能为真.
**builtin_popcount(unsigned int x):这个函数返回 x 的二进制表示中 1 的数量.
**builtin_clz(unsigned int x) 和 **builtin_ctz(unsigned int x):这两个函数分别返回 x 的二进制表示中从最高位开始和最低位开始的连续 0 的数量.
**builtin_ffs(int x):这个函数返回 x 的二进制表示中第一个 1 的位置,如果 x 为 0,则返回 0.
**builtin_prefetch(const void \*addr, ...):这个函数用于预取 addr 指向的内存区域,以减少以后访问这个内存区域的延迟.

以上这些函数在 GCC 和 Clang 中都可用,但在其他编译器(如 MSVC)中可能不可用.在使用这些函数时,你需要确保你的代码能在目标编译器上正确编译和运行.
此外,这些函数都是编译器扩展,不是 C++ 标准的一部分,因此在使用这些函数时,你需要考虑到代码的可移植性问题.

如果可能,你应该优先使用标准库提供的功能,只有在必要的时候才使用这些内建函数.

如果是使用了模板，每一个编译单元都会有一个自己的实例代码。如果不是通过模板实现，函数的定义只会在自己对应的编译单元，其他编译单元通过链接的方式找到。

编译器之所以能够实现所谓的“开洞”行为，主要是因为它在编译过程中对源代码有深入的理解和控制。编译器的工作流程大致可以分为以下几个阶段：

- 处理预处理指令，如宏定义的展开、条件编译指令、头文件的包含等。这一阶段，编译器会根据预处理指令修改源代码。

2. **词法分析（Lexical Analysis）**：

   - 将源代码分解成一系列的标记（Tokens），如关键字、标识符、字面量等。

3. **语法分析（Syntax Analysis）**：

   - 根据语言的语法规则，将标记序列组织成抽象语法树（Abstract Syntax Tree, AST）。

4. **语义分析（Semantic Analysis）**：

   - 检查 AST 中的语义错误，如类型不匹配、未定义的标识符等，并生成中间表示（Intermediate Representation, IR）。

5. **优化（Optimization）**：

   - 对 IR 进行优化，以提高程序的性能或减少资源消耗。这一阶段，编译器会利用其对程序结构和语义的深入理解来执行各种优化。

6. **代码生成（Code Generation）**：

   - 将优化后的 IR 转换成目标代码，可能是汇编代码或直接的机器代码。

7. **链接（Linking）**：
   - 将编译生成的目标代码与库文件和其他模块链接在一起，生成可执行文件。

编译器能够实现“开洞”行为的关键因素包括：

- **全局视角**：编译器可以看到整个源代码，因此可以进行全局优化和分析，而用户代码只能看到局部。

- **语言和平台特性**：编译器了解目标编程语言的规范和特性，以及目标平台的硬件特性，因此可以利用这些信息进行优化。

- **控制编译过程**：编译器控制着从源代码到目标代码的整个转换过程，可以在任何阶段插入特殊的处理逻辑。

- **访问底层信息**：编译器可以访问底层的硬件和操作系统信息，这使得它能够生成针对特定平台优化的代码。

- **编译器扩展和内置函数**：编译器通常提供一些特殊的内置函数和扩展，这些是专门为编译器设计的，用户代码无法直接使用。

通过这些能力，编译器能够在编译过程中实现那些用户代码难以或无法实现的特殊功能。
