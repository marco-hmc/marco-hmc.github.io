<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="cn"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://marco-hmc.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://marco-hmc.github.io/" rel="alternate" type="text/html" hreflang="cn"/><updated>2025-05-06T16:35:23+00:00</updated><id>https://marco-hmc.github.io/feed.xml</id><title type="html">Marco’s blog</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">指针</title><link href="https://marco-hmc.github.io/blog/2025/0_pointer.md/" rel="alternate" type="text/html" title="指针"/><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/0_pointer.md</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/0_pointer.md/"><![CDATA[<h2 id="指针">指针</h2> <h3 id="1-指针的本质">1. 指针的本质</h3> <p>指针的目的是为了表示内存的一个数据。</p> <p>首先，简单回顾下内存是怎么存数据的。内存有若干个单元格，每个单元格会有一个地址，一个单元格能存储的容量是一个字节，这相当于一个 char 类型所占的空间大小。而硬件层面上提供了根据地址找到存储数据的方式。一份数据可能由一个单元格或者若干个单元格一块存储。</p> <p>那么如果想表示内存的一个数据可以怎么做？</p> <ol> <li>记录这个数据所有单元格所在的地址。</li> <li>基于同一份数据的单元格都是连续存储的先验，只需要首地址和数据总长度。 第二种方式是不言自明地优于第一种方式。而指针本质就是第二种的表达方式。 <blockquote> <p>进一步来说，数据总长度信息是等价于数据类型信息的。一个数据类型就是说明要占用几个单元格去存储这个数据，数据总长度在表达上容易产生歧义。因此更喜欢用类型去表示类型长度这个概念。 更进一步地说，类型表示地是编译器如何理解首地址。编译器是会把c/c++等高级语言转变成汇编语言，而汇编语言是不存在自定义类型长度概念的。当使用一个自定义类型的时候，编译器其实会理解这个类型，并知道这份数据要有几个单元格表示。当编译器生成汇编语言的时候，就会直接指明汇编语言是要按照多少个单元格的方式去取数据。因此，也会有人说类型的意义，在于让编译器知晓该按照何种格式去读取相应地址处的数据。</p> </blockquote> </li> </ol> <h4 id="11-指针的种类有哪些">1.1 指针的种类有哪些</h4> <ol> <li>基本对象指针： <ul> <li>基本数据类型的指针。</li> <li>如：<code class="language-plaintext highlighter-rouge">int* p</code>; 定义了一个指向整型数据的指针。</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">void</code>指针： <ul> <li><code class="language-plaintext highlighter-rouge">void*</code> 是一种特殊的指针类型，可以指向任何类型的数据，通常用于需要存储任意类型地址的场合，如通用函数的参数。但使用时通常需要类型转换。</li> </ul> </li> <li>常量指针与指向常量的指针： <ol> <li>指向常量的指针：如 const int* p;，指针可以指向一个整型常量，但不能通过指针修改所指向的值。</li> <li>常量指针：如 int* const p;，指针本身是一个常量，一旦初始化后就不能改变它指向的地址，但可以通过指针修改所指向的值。</li> <li>指向常量的常量指针：如 const int* const p;，指针和它指向的值都是不可变的。</li> </ol> </li> <li>函数指针： <ul> <li>指向函数的指针可以存储一个函数的地址，并通过该指针调用函数。如 void (*func_ptr)(int); 定义了一个指向接受一个整型参数且无返回值的函数的指针。</li> </ul> </li> <li>数组指针与指向数组的指针： <ul> <li>数组名本身就可以视为指向其首元素的指针，如 int arr[10]; int* ptr = arr;。</li> <li>可以声明指向整个数组的指针，如 int (*ptr_to_array)[10];。</li> </ul> </li> <li>多级指针： <ul> <li>如 int **ptr; 是一个二级指针，可以指向一个指针，该指针又指向一个整型数据。多级指针可以扩展到更多级别。</li> </ul> </li> <li>成员指针： <ul> <li>成员指针指向类的非静态成员变量。如 int MyClass::*ptr; 指向 MyClass 中的某个整型成员。</li> </ul> </li> </ol> <h4 id="12-指针的大小">1.2 指针的大小</h4> <p>在给定的系统架构下，所有类型的指针所占用的内存大小是相同的。这是因为指针存储的是地址，而地址空间的大小是由硬件和操作系统决定的，不是由指针所指向的数据类型决定的。</p> <ul> <li>在32位系统上，无论指针指向何种类型的数据（如 int<em>, char</em>, double* 等），指针本身的大小通常是4字节（32位）。</li> <li>在64位系统上，同样几乎不论指针指向的数据类型如何，指针的大小通常是8字节（64位）。</li> </ul> <p>注意：使用特殊编译器选项或在某些特定的虚拟化环境中，即使是在32位系统上，也有可能配置指针为64位。但这种情况较为少见。</p> <h4 id="13-总结">1.3 总结</h4> <p>因此总结一下，指针的本质就是类型（等价于长度）和地址。</p> <ul> <li>一个指针, 不管它指向那种数据类型, 其本身所需内存大小是固定的, 与计算机的位数一致，即一般8字节。</li> <li>指针类型会指导编译器如何解释某个特定地址中的内存内容及其大小。</li> <li>void*指针能够持有一个地址, 但不能通过它来操作所指对象, 因为不知道其覆盖怎样的地址空间。</li> </ul> <p>但特别要注意的是，在使用指针时，最好将硬件亲和性纳入考量范围。内存访问并非是简单地逐个地址去获取数据，实际上，内存访问往往是按照<strong>一定的行</strong>来进行操作的，例如当通过指针访问 <code class="language-plaintext highlighter-rouge">int</code> （四字节数据）类型数据时，并不是分四次去访问对应的四个字节地址，而是一次性访问包含这四个字节的一行内存空间，字节对齐就是基于这样的内存访问机制而存在的。字节对齐能够确保数据在内存中的存放符合硬件高效访问的要求，从而提升整体的访问效率，让基于指针的内存操作更加顺畅高效。</p> <blockquote> <p>更进一步地说，内存访问是查高速缓存再查内存的。这个行的大小长度，实际上是由缓存决定的。目前缓存在各种因素考虑下，缓存行的大小一般为64字节，8个地址长度，16个int型数据。 题外话，当读取一个非内存对齐的数据的时候，这个数据的读都不一定是原子的，比如说要读两行才能读完这个数据，读完第一行的时候，第二行被改了。但计算机硬件在发展，有些能保证是原子的。</p> </blockquote> <p>那么当我存储一个数据的时候，很常见的要求就是连续存储同一类型数据多次。那要怎么做呢？</p> <h3 id="2-指针和数组">2. 指针和数组</h3> <p>同样地，如果要求连续存储同一类型数据多次，可以怎么做呢？</p> <ol> <li>记住所有数据的指针。</li> <li>基于同一类型数据连续存储的先验，只需要知道首数据地址和连续数据的个数。 同样也是不言自明地第二种好。而数组的本质也是第二种方式的表达方式。</li> </ol> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
    <span class="c1">// arr本质上就是首数据地址，而4就是连续数据的个数。</span>
    <span class="c1">// arr = arr[0] = 0x0001 = 首数据地址</span>
    <span class="c1">// arr[1] = 首数据地址 + 类型长度 * 序数 = 0x0001 + 4 * 1 = 0x0005</span>
    <span class="c1">// arr[2] = ... = 0x0009</span>
    <span class="c1">// arr[3] = ... = 0x000C</span>

    <span class="c1">// &gt; 序数为第几个数字；int的类型为4；0x0001为地址表示方式</span>
</code></pre></div></div> <p>因此，数组就是首数据指针和数组长度。进一步地，也可以说数组是一种基于指针概念的封装和抽象。</p> <p>当谈论数组的时候，高维数组自然也是一种很常见的东西，那什么是高维数组，又有什么用呢？</p> <h3 id="3-高维数组">3. 高维数组</h3> <p>首先，也简单明确一下什么是高维数组。数组表示的是存储同一类型数据多次，如果这个同一类型本身是一个数组，这就是高维数组了。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>再进一步理解，首先要知道任何高维东西的理解都离不开逐步降维。那<code class="language-plaintext highlighter-rouge">int arr[2][2]</code>降维了之后是什么？</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// 其实typedef int[2] type可能更好理解，但parse解析规则不是这样的</span>
    <span class="c1">// 但理解是一个意思即可</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">TYPE</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">TYPE</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">};</span>
</code></pre></div></div> <p>再接一个例子说明</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cm">/*
    // 从内存空间理解
                tab + 0        tab + 1
    Address  0x7ffc5c78b530  0x7ffc5c78b538  0x7ffc5c78b530  0x7ffc5c78b534  0x7ffc5c78b538  0x7ffc5c78b53c
      Value  0x7ffc5c78b530  0x7ffc5c78b538  1  				2  				3  				4
                    [0]           [1]         [0][0]          [0][1]          [1][0]          [1][1]

    tab = table[0] = table[0][0] = 0x7ffc5c78b530
    *tab = 0x7ffc5c78b530
    **tab = table[0][0] = 1

    tab + 1 = table[1] = table[1][0] = 0x7ffc5c78b538
    *(tab + 1) = 0x7ffc5c78b538
    **(tab + 1) = table[1][0] = 3

    // 从二维数组理解
                row: 0               row: 1
    col: 0   0x7ffc5c78b530--1   0x7ffc5c78b538--3
    col: 1   0x7ffc5c78b534--2   0x7ffc5c78b53c--4

     */</span>
    <span class="kt">int</span> <span class="n">tab</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>数据的表示都是顺序的，比如说<code class="language-plaintext highlighter-rouge">0-4Gb</code>的内存空间，全部都是一个单元格一个单元格挨着的。 高维数组本质上也是这样一个一个单元挨着的，是可以看成一行的。 因此，<code class="language-plaintext highlighter-rouge">int tab[2][2]</code>其实和<code class="language-plaintext highlighter-rouge">int row[4]</code>这种，在存储上本质是没区别的。 只是<code class="language-plaintext highlighter-rouge">int tab[2][2]</code>这种提供了刚方便的访问方式。 如第二行所有数据可以表示为<code class="language-plaintext highlighter-rouge">int tab[1]</code>,如第二行第一列，实际上就是第三个数据可以表示为<code class="language-plaintext highlighter-rouge">int tab[1][0]</code></p> <h3 id="4-多级指针">4. 多级指针</h3> <p>一句话简要说明，二级指针是指针的指针，三级指针是二级指针的指针，如此类推。 具体展开一些则是，多级指针有两个用途：</p> <ol> <li> <p>在参数中传递一个指针进来或者出去。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">class</span> <span class="n">ID</span><span class="p">;</span>
    <span class="n">bool</span> <span class="nf">getArr</span><span class="p">(</span><span class="n">ID</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">cnt</span><span class="p">,</span> <span class="kt">int</span><span class="o">**</span><span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">getArrById</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">arr</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">ID</span> <span class="n">id</span> <span class="o">=</span> <span class="n">getId</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
        <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">bool</span> <span class="n">isSuccess</span> <span class="o">=</span><span class="n">getArr</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">);</span>
    <span class="p">};</span>
</code></pre></div> </div> <p>一个arr数据已经在某个地方存好了，传入一个标识符就可以获取。但是返回值得有三个，操作状态，数组长度，数组地址。一般而言，则倾向于将操作状态作为函数返回值，那数组长度和数组地址就通过出参的方式返回。那就都得通过指针的方式去返回。而返回的是一个数组地址，那就是数组地址的指针，也就变成二维了。</p> </li> <li> <p>多级指针等价于高维数组</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// 动态分配二维数组</span>
    <span class="kt">int</span> <span class="o">**</span><span class="n">arr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">nrows</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nrows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">ncols</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="p">}</span>
</code></pre></div> </div> </li> </ol> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-数组退化为指针是什么意思">1. 数组退化为指针是什么意思？</h4> <p>数组退化为指针是指在某些情况下，数组名会被编译器自动转换为指向数组第一个元素的指针。这种情况通常发生在数组作为函数参数传递时。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">printArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
    <span class="n">printArray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>  <span class="c1">// array 退化为指针</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在这个例子中，<code class="language-plaintext highlighter-rouge">array</code> 作为参数传递给 <code class="language-plaintext highlighter-rouge">printArray</code> 函数时，退化为指向 <code class="language-plaintext highlighter-rouge">array</code> 第一个元素的指针。 正如前面说的，数组的本质是是首元素指针+数组长度</p> <h4 id="2-数组的内存安全如何保证越界风险如何避免">2. 数组的内存安全如何保证？越界风险如何避免？</h4> <p>数组的内存安全是指在使用数组时，确保不访问数组边界之外的内存，以避免越界访问。越界访问可能导致程序崩溃或意外行为。</p> <ol> <li><strong>使用数组长度</strong>：在访问数组元素时，始终使用数组的长度进行边界检查。</li> <li><strong>使用标准库函数</strong>：使用标准库函数（如 <code class="language-plaintext highlighter-rouge">memcpy</code>、<code class="language-plaintext highlighter-rouge">memset</code> 等）时，确保传递的长度参数正确。</li> <li><strong>使用动态数组</strong>：使用动态数组（如 <code class="language-plaintext highlighter-rouge">std::vector</code>）可以自动管理数组的大小和边界检查。</li> <li><strong>启用编译器警告</strong>：启用编译器的警告和错误检查选项，可以帮助发现潜在的越界访问问题。</li> </ol>]]></content><author><name></name></author><category term="language"/><category term="cpp"/><category term="grammar"/><category term="pointer"/><summary type="html"><![CDATA[指针]]></summary></entry><entry><title type="html">c++的多线程</title><link href="https://marco-hmc.github.io/blog/2025/1_threads.md/" rel="alternate" type="text/html" title="c++的多线程"/><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/1_threads.md</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/1_threads.md/"><![CDATA[<h2 id="c的多线程">c++的多线程</h2> <p>多线程的使用可以从两个角度出发：</p> <ul> <li>多线程的创建和相关管理手段</li> <li> <p>多线程的通信和同步方式</p> </li> <li>cpu 的单核性能提升接近瓶颈，多核是未来 cpu 的趋势。</li> <li>因为缓存同步开销、资源竞争问题，n 核机器的性能是做不到是单核机器的 n 倍，但如何让性能接近 n 倍是一直在研究的。</li> <li> <p>并发和并行的区别：</p> <ul> <li>并发：追求的是提升处理个数能力，是要异步，单核场景下，多线程也是有意义。</li> <li>并行：追求的是提升处理能力，是要速度，单核场景下，多线程无意义。</li> </ul> </li> <li>线程和任务要区分： 在性能要要求的场景下，线程是复用的，是固定的，是常驻的； 任务才是可被消费的。 因此 tbb 和线程池的处理对象，或者说接受的输入对象都是 task。</li> </ul> <h3 id="0-多线程的概念">0. 多线程的概念</h3> <ul> <li> <p><strong>线程的优缺点</strong> 线程是进程内的执行单元，是操作系统进行调度的基本单位。一个进程中可以包含多个线程，它们共享进程的内存空间，因此线程间的通信更为方便。但是，多线程编程需要处理好同步和互斥，以避免数据竞争和死锁等问题。</p> <ul> <li>优点 <ul> <li>线程创建快，上下文切换快，创建开销小</li> <li>线程通信快</li> </ul> </li> <li>缺点 <ul> <li>要考虑锁机制，代码写起来麻烦</li> <li>不可靠，一个线程挂了，全挂了</li> </ul> </li> </ul> </li> <li> <p><strong>什么是线程安全？</strong> 简单来说就是，多线程一般是在同一个进程空间，共享内存空间。 因此多线程同时对一个变量操作的时候，就会出现安全问题。</p> <ul> <li>简单理解，确保在多线程访问的时候，我们的程序还能按照我们预期的行为去执行，那么就是线程安全 线程安全的定义可以总结为以下几点：</li> </ul> <ol> <li><strong>正确性</strong>：在多线程环境下，多个线程同时访问同一个对象时，程序的行为和结果是正确的，不会出现数据不一致或程序崩溃的情况。</li> <li><strong>原子性</strong>：操作是不可分割的，要么全部执行，要么全部不执行，不会被其他线程的操作中断。</li> <li><strong>可见性</strong>：一个线程对共享变量的修改对其他线程是可见的。</li> <li><strong>有序性</strong>：程序的执行顺序按照代码的先后顺序执行，不会因为指令重排序导致意外的行为。</li> </ol> </li> <li> <p><strong>怎么实现线程安全</strong></p> <ol> <li><strong>使用锁（Mutex）</strong>：通过互斥锁（<code class="language-plaintext highlighter-rouge">std::mutex</code>）来保护共享数据，确保同一时间只有一个线程可以访问或修改数据。</li> <li><strong>使用原子操作（Atomic Operations）</strong>：使用原子操作（<code class="language-plaintext highlighter-rouge">std::atomic</code>）来保证操作的原子性，不需要显式使用锁。</li> <li><strong>使用线程本地存储（Thread Local Storage）</strong>：为每个线程分配独立的数据，避免多个线程访问同一个共享数据。</li> <li><strong>无锁数据结构（Lock-Free Data Structures）</strong>：使用无锁数据结构，如无锁队列，避免使用锁来实现线程安全。</li> </ol> </li> <li> <p><strong>什么是可重入函数</strong> 可重入函数是指在任何时刻都可以安全地被中断，并且在中断后可以安全地重新进入执行的函数。具体来说，可重入函数具有以下特性：</p> <ol> <li><strong>可以被中断</strong>：函数可以在执行过程中被中断，并且在中断后可以安全地重新进入执行。</li> <li><strong>不依赖外部环境</strong>：函数除了使用自己栈上的变量外，不依赖于任何外部环境（包括静态变量和全局变量）。这样的函数被称为纯代码（pure code）可重入函数，可以允许多个副本同时运行，因为它们使用的是独立的栈，不会互相干扰。 简单来说，可重入函数只使用自己栈上的数据，不使用静态变量、全局变量或类成员变量。如果调用的子函数也只使用自己栈上的数据，那么这个函数就是可重入的。</li> </ol> </li> <li> <p><strong>可重入函数的特点</strong></p> <ol> <li>不在函数内部使用静态或全局数据。</li> <li>不返回静态或全局数据，所有数据都由函数的调用者提供。</li> <li>不调用不可重入函数。</li> <li>没有锁</li> <li>这些情况也是不可重入的</li> <li><strong>使用静态数据结构</strong>：例如 <code class="language-plaintext highlighter-rouge">getpwnam</code> 和 <code class="language-plaintext highlighter-rouge">getpwuid</code>。如果信号发生时正在执行 <code class="language-plaintext highlighter-rouge">getpwnam</code>，信号处理程序中执行 <code class="language-plaintext highlighter-rouge">getpwnam</code> 可能会覆盖原来 <code class="language-plaintext highlighter-rouge">getpwnam</code> 获取的旧值。</li> <li><strong>调用 <code class="language-plaintext highlighter-rouge">malloc</code> 或 <code class="language-plaintext highlighter-rouge">free</code></strong>：如果信号发生时正在执行 <code class="language-plaintext highlighter-rouge">malloc</code>（修改堆上存储空间的链接表），信号处理程序又调用 <code class="language-plaintext highlighter-rouge">malloc</code>，会破坏内核的数据结构。</li> <li><strong>使用标准 IO 函数</strong>：许多标准 IO 的实现都使用全局数据结构，例如 <code class="language-plaintext highlighter-rouge">printf</code>（文件偏移是全局的）。</li> <li><strong>调用 <code class="language-plaintext highlighter-rouge">longjmp</code> 或 <code class="language-plaintext highlighter-rouge">siglongjmp</code></strong>：如果信号发生时程序正在修改一个数据结构，处理程序返回到另外一处，可能会导致数据被部分更新。</li> </ol> </li> <li> <p><strong>可重入函数的意义是什么？</strong></p> <ol> <li><strong>信号处理程序</strong>：</li> </ol> <ul> <li>信号处理程序是处理异步信号的函数。当程序运行时，如果接收到某个信号（如 <code class="language-plaintext highlighter-rouge">SIGINT</code>、<code class="language-plaintext highlighter-rouge">SIGTERM</code> 等），操作系统会中断当前的执行流，转而执行信号处理程序。由于信号处理程序可以在任何时候被调用，因此它们必须是可重入的，以避免在中断时修改共享数据导致的数据不一致或程序崩溃。</li> </ul> <ol> <li><strong>中断处理程序</strong>：</li> </ol> <ul> <li>在嵌入式系统或操作系统内核中，中断处理程序用于处理硬件中断。中断处理程序可以在任何时候被调用，因此它们也必须是可重入的，以确保在中断时不会破坏系统的稳定性。</li> </ul> <ol> <li>可重入函数一般是信号函数相关的概念。而无论单线程还是多线程，‌被中断的线程/进程必须等待信号处理函数结束‌，才能回到原执行点。多线程的优势仅体现在未被中断的线程可以继续运行。 可重入函数就不能上锁，因为可重入函数基本指的就是信号处理函数，信号处理函数有非常高得优先级，如果有锁，且拿不到锁，就很容易卡死了，因为不会轻易让出线程，破坏了执行流。</li> </ol> </li> <li> <p><strong>可重入函数和线程安全的联系是什么</strong></p> <ul> <li><strong>可重入函数</strong>是线程安全函数的一个子集。可重入函数在任何时刻都可以安全地被中断，并且在中断后可以安全地重新进入。</li> <li><strong>线程安全函数</strong>可以通过使用锁来保护共享数据，但使用锁的函数在被中断后重新进入时可能会导致死锁或其他同步问题。</li> <li>线程安全函数可以使用静态或全局数据，只要这些数据受到适当的保护，但可重入函数不能使用静态或全局数据。</li> <li>线程安全函数可以调用其他线程安全但不可重入的函数，但可重入函数不能调用不可重入的函数。</li> </ul> </li> </ul> <h3 id="1-多线程的创建和管理手段">1. 多线程的创建和管理手段</h3> <ul> <li> <p><strong>1. <code class="language-plaintext highlighter-rouge">std::thread</code></strong></p> <ul> <li><strong>适用场景</strong>： <ul> <li><strong>需要直接控制线程的生命周期</strong>：当你需要精细控制线程的创建、启动、暂停、恢复和终止时，使用 <code class="language-plaintext highlighter-rouge">std::thread</code> 是合适的选择。</li> <li><strong>需要共享资源的复杂同步</strong>：当多个线程需要访问共享资源，并且需要复杂的同步机制（如互斥锁、条件变量）时，<code class="language-plaintext highlighter-rouge">std::thread</code> 提供了更大的灵活性。</li> <li><strong>需要高性能</strong>：在某些高性能计算场景中，直接使用 <code class="language-plaintext highlighter-rouge">std::thread</code> 可以避免一些抽象层带来的开销。</li> </ul> </li> </ul> </li> <li> <p><strong>2. <code class="language-plaintext highlighter-rouge">std::async</code></strong></p> <ul> <li><strong>适用场景</strong>： <ul> <li><strong>简单的异步任务</strong>：当你需要启动一个简单的异步任务，并且不需要显式管理线程时，使用 <code class="language-plaintext highlighter-rouge">std::async</code> 是最方便的选择。</li> <li><strong>任务的启动策略</strong>：当你希望任务可以根据需要立即执行或延迟执行时，<code class="language-plaintext highlighter-rouge">std::async</code> 提供了灵活的启动策略（如 <code class="language-plaintext highlighter-rouge">std::launch::async</code> 和 <code class="language-plaintext highlighter-rouge">std::launch::deferred</code>）。</li> <li><strong>需要返回值的异步任务</strong>：当你需要启动一个异步任务并获取其返回值时，<code class="language-plaintext highlighter-rouge">std::async</code> 会返回一个 <code class="language-plaintext highlighter-rouge">std::future</code> 对象，方便获取结果。</li> </ul> </li> </ul> </li> <li> <ol> <li><code class="language-plaintext highlighter-rouge">std::packaged_task</code>** <ul> <li><strong>适用场景</strong>： <ul> <li><strong>需要更高的灵活性</strong>：当你需要将任务与线程分离，并在不同的时间和上下文中启动任务时，使用 <code class="language-plaintext highlighter-rouge">std::packaged_task</code> 是合适的选择。</li> <li><strong>复杂的任务管理</strong>：当你需要显式管理任务的生命周期，并且可能需要将任务传递给其他线程或存储在容器中时，<code class="language-plaintext highlighter-rouge">std::packaged_task</code> 提供了更高的灵活性。</li> <li><strong>需要返回值的任务</strong>：与 <code class="language-plaintext highlighter-rouge">std::async</code> 类似，<code class="language-plaintext highlighter-rouge">std::packaged_task</code> 也会返回一个 <code class="language-plaintext highlighter-rouge">std::future</code> 对象，用于获取任务的结果。</li> </ul> </li> </ul> </li> </ol> </li> </ul> <p>如果用一句话总结区别的话就是，不需要线程返回结果就是用<code class="language-plaintext highlighter-rouge">std::thread</code>，需要线程返回结果就是用<code class="language-plaintext highlighter-rouge">async</code>和<code class="language-plaintext highlighter-rouge">packaged_task</code>；不想管理线程的，就是用<code class="language-plaintext highlighter-rouge">async</code>，想提升性能去管理线程的话，就是<code class="language-plaintext highlighter-rouge">packaged_task</code>和<code class="language-plaintext highlighter-rouge">std::thread</code>。</p> <h4 id="11-thread">1.1 thread</h4> <ul> <li> <p><strong>特点</strong></p> <ul> <li><strong>直接控制</strong>：<code class="language-plaintext highlighter-rouge">std::thread</code> 提供了对线程的直接控制，可以精细地管理线程的创建、执行和销毁。</li> <li><strong>手动管理</strong>：需要手动管理线程的生命周期，包括创建、等待（<code class="language-plaintext highlighter-rouge">join</code>）和分离（<code class="language-plaintext highlighter-rouge">detach</code>）线程。</li> <li><strong>无返回值</strong>：<code class="language-plaintext highlighter-rouge">std::thread</code> 无法直接返回任务的结果，需要使用其他同步机制（如 <code class="language-plaintext highlighter-rouge">std::promise</code> 和 <code class="language-plaintext highlighter-rouge">std::future</code>）来获取结果。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">join</code>定义</strong></p> <ul> <li>当你调用 <code class="language-plaintext highlighter-rouge">join</code> 时，它会等待被调用线程执行完毕，然后再继续执行主线程。换句话说，<code class="language-plaintext highlighter-rouge">join</code> 使得主线程等待被调用线程的完成。</li> <li>使用 <code class="language-plaintext highlighter-rouge">join</code> 可以确保在主线程继续执行之前，被调用线程的任务已经完成。这对于需要等待线程执行结果的情况很有用。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">detach</code>定义</strong></p> <ul> <li>当你调用 <code class="language-plaintext highlighter-rouge">detach</code> 时，它使得被调用线程成为后台线程，与主线程分离。主线程不再等待被调用线程的完成。</li> <li>使用 <code class="language-plaintext highlighter-rouge">detach</code> 可以使得主线程在后台线程运行的同时继续执行，而不必等待后台线程完成。这对于一些异步任务或长时间运行的任务很有用。</li> </ul> </li> </ul> <h4 id="12-async">1.2 async</h4> <p><code class="language-plaintext highlighter-rouge">std::async</code> 是一个强大的工具，是 C++11 中引入的一个用于启动异步任务的函数。通过合理使用 <code class="language-plaintext highlighter-rouge">std::async</code> 和选择适当的启动策略，可以提高程序的并发性能和响应速度。它自动处理线程的创建和销毁，使得异步编程变得更简单。如果你只需要在后台运行一个任务并获取其结果，那么<code class="language-plaintext highlighter-rouge">std::async</code>通常是最好的选择。</p> <ul> <li> <p><strong>特点</strong></p> <ul> <li> <ul> <li><strong>自动管理</strong>：<code class="language-plaintext highlighter-rouge">std::async</code> 提供了一个简单的接口来启动异步任务，并自动管理线程的生命周期。</li> </ul> </li> <li> <ul> <li><strong>返回 <code class="language-plaintext highlighter-rouge">std::future</code></strong>：<code class="language-plaintext highlighter-rouge">std::async</code> 返回一个 <code class="language-plaintext highlighter-rouge">std::future</code> 对象，通过这个对象可以获取异步任务的结果。</li> </ul> </li> <li> <ul> <li><strong>启动策略</strong>：可以指定启动策略（<code class="language-plaintext highlighter-rouge">std::launch::async</code> 或 <code class="language-plaintext highlighter-rouge">std::launch::deferred</code>），决定任务是立即异步执行还是延迟到调用 <code class="language-plaintext highlighter-rouge">get</code> 时执行。</li> </ul> </li> </ul> </li> <li> <p><strong>应用场景</strong></p> <ul> <li> <ul> <li><strong>简单异步任务</strong>：适用于简单的异步任务，不需要复杂的线程管理。</li> </ul> </li> <li> <ul> <li><strong>自动管理需求</strong>：适用于希望自动管理线程生命周期的场景，减少手动管理的复杂性。</li> </ul> </li> <li>多为同步计算和异步计算同时存在的场景。或者更进一步，用来处理io耗时而非cpu密集任务的。比如说要播放一个特效动画，然后计算伤害，特效动画开一个async去做，后面继续计算等等。</li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Fn</span><span class="err">，</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">Fn</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
      <span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span> <span class="n">policy</span><span class="err">，</span> <span class="n">Fn</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="err">，</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div></div> <ul> <li> <p><strong>参数及其意义</strong></p> <ol> <li><strong><code class="language-plaintext highlighter-rouge">policy</code></strong>：异步任务的启动策略，是一个 <code class="language-plaintext highlighter-rouge">std::launch</code> 类型的枚举值。可能的值有：</li> </ol> <ul> <li><code class="language-plaintext highlighter-rouge">std::launch::async</code>：异步执行任务，可能会在新的线程中执行。</li> <li><code class="language-plaintext highlighter-rouge">std::launch::deferred</code>： 延迟执行任务，直到调用 <code class="language-plaintext highlighter-rouge">std::future</code> 对象的 <code class="language-plaintext highlighter-rouge">get</code> 或 <code class="language-plaintext highlighter-rouge">wait</code> 函数时执行，可能在当前线程执行。</li> <li><code class="language-plaintext highlighter-rouge">std::launch::async | std::launch::deferred</code>：由系统自行选择执行方式，可能异步也可能延迟。</li> </ul> <ol> <li><strong><code class="language-plaintext highlighter-rouge">f</code></strong>：要异步执行的函数或可调用对象。</li> <li><strong><code class="language-plaintext highlighter-rouge">args...</code></strong>：传递给函数 <code class="language-plaintext highlighter-rouge">f</code> 的参数列表。</li> </ol> </li> <li> <p><strong>返回值</strong> <code class="language-plaintext highlighter-rouge">std::async</code> 返回一个 <code class="language-plaintext highlighter-rouge">std::future</code> 对象，通过这个对象可以获取异步任务的结果。<code class="language-plaintext highlighter-rouge">std::future</code> 是一个轻量级的异步结果管理器，提供了对异步任务的状态查询（是否完成/是否有异常等）以及获取最终结果的功能。</p> </li> <li> <p><strong>注意事项</strong></p> <ul> <li>使用 <code class="language-plaintext highlighter-rouge">std::async</code> 可以方便地在后台执行任务，而调用 <code class="language-plaintext highlighter-rouge">get</code> 函数时，如果任务尚未完成，主线程会等待直到任务完成。这有助于充分利用多核系统的性能，将计算密集型任务分配到不同的线程中执行。</li> <li>在使用 <code class="language-plaintext highlighter-rouge">std::async</code> 时，需要小心选择适当的启动策略，以避免不必要的线程创建和上下文切换。</li> </ul> </li> </ul> <h4 id="13-packaged_task">1.3 packaged_task</h4> <p><code class="language-plaintext highlighter-rouge">std::packaged_task</code> 是 C++11 中引入的一个类模板，用于将一个可调用对象（<code class="language-plaintext highlighter-rouge">task</code>，如函数、lambda 表达式或函数对象）包装成任务，并将其结果存储在一个 <code class="language-plaintext highlighter-rouge">std::future</code> 对象中，以便稍后获取。</p> <ul> <li> <p><strong>特点</strong></p> <ul> <li><strong>任务包装</strong>：<code class="language-plaintext highlighter-rouge">std::packaged_task</code> 将一个可调用对象（如函数、lambda 表达式或函数对象）包装成任务，并将其结果存储在一个 <code class="language-plaintext highlighter-rouge">std::future</code> 对象中。</li> <li><strong>灵活性和控制</strong>：提供了更多的灵活性，但也需要更多的管理工作。需要自己创建一个 <code class="language-plaintext highlighter-rouge">std::thread</code> 并将 <code class="language-plaintext highlighter-rouge">std::packaged_task</code> 对象传递给它。</li> <li><strong>与 <code class="language-plaintext highlighter-rouge">std::future</code> 关联</strong>：<code class="language-plaintext highlighter-rouge">std::packaged_task</code> 自动与 <code class="language-plaintext highlighter-rouge">std::future</code> 关联，简化了结果获取的过程。</li> <li>应该将<code class="language-plaintext highlighter-rouge">std::packaged_task</code>理解成原来传递给<code class="language-plaintext highlighter-rouge">std::thread</code>的<code class="language-plaintext highlighter-rouge">func</code>的封装。<code class="language-plaintext highlighter-rouge">std::thread</code>是os层面涉及线程调度的事情，<code class="language-plaintext highlighter-rouge">std::packaged_task</code>则是业务层面对调度对象的操作。</li> </ul> </li> <li><strong>应用场景</strong> <ul> <li><strong>复杂任务管理</strong>：适用于需要将任务与 <code class="language-plaintext highlighter-rouge">std::future</code> 关联的复杂场景。</li> <li><strong>线程池实现</strong>：适用于实现线程池等需要精细控制任务调度和执行的场景。</li> <li>当需要对多线程直接复杂管理的时候，因为线程没有返回值，而且什么时候开始运行也不好控制，这个时候一般就用packaged_task。因此一般线程池都是用这个。</li> </ul> </li> <li><strong>主要特点</strong> <ol> <li><strong>任务包装</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">std::packaged_task</code> 只是对一个任务类型的包装。经过包装之后的 <code class="language-plaintext highlighter-rouge">packaged_task</code> 返回值为 <code class="language-plaintext highlighter-rouge">future</code> 类型。</li> <li><code class="language-plaintext highlighter-rouge">future</code> 是对结果的一个包装，只有调用 <code class="language-plaintext highlighter-rouge">future::get()</code> 方法时，任务才会真正执行并返回结果。</li> </ul> </li> <li><strong>灵活性和控制</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">std::packaged_task</code> 提供了更多的灵活性，但也需要更多的管理工作。</li> <li>它只是将一个任务和一个 <code class="language-plaintext highlighter-rouge">std::future</code> 对象关联起来，并不创建线程。需要自己创建一个 <code class="language-plaintext highlighter-rouge">std::thread</code> 并将 <code class="language-plaintext highlighter-rouge">std::packaged_task</code> 对象传递给它。</li> <li>这使得可以更精细地控制线程的创建和销毁，以及任务的调度。例如，可以将任务提交给一个线程池，或者在特定的时间点启动线程。</li> </ul> </li> </ol> </li> </ul> <h3 id="2-多线程间的通信同步手段">2. 多线程间的通信、同步手段</h3> <p>相较于进程，线程是共享同一进程的地址空间的，线程间的通信将会很容易，直接就可以通过全局变量来交换数据。但这种访问的便利性也带来了一些风险，通常当有多个线程访问相同的共享数据时，做出的操作往往是不安全的。这就需要线程同步。所谓的线程同步，就是指多线程通过特定的设置（如互斥量、事件对象、临界区）来控制线程之间的执行顺序。</p> <p>同步的目的是协同、协助、互相配合线程的运行，而不是同时进行。例如，一个线程完成任务后，另一个线程才开始执行。线程同步通过建立线程之间的执行顺序关系，确保线程按预定的顺序运行。如果没有同步机制，线程将各自独立运行，可能导致资源竞争和数据不一致的问题。</p> <p>下面介绍c++中支持的常见同步手段。</p> <ul> <li> <p><strong>1. <code class="language-plaintext highlighter-rouge">std::mutex</code></strong></p> <ul> <li><strong>适用场景</strong>： <ul> <li><strong>互斥锁</strong>：当你需要确保只有一个线程可以访问共享资源时，使用 <code class="language-plaintext highlighter-rouge">std::mutex</code> 是合适的选择。</li> </ul> </li> <li><strong>解释</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">std::mutex</code> 提供了互斥锁，确保只有一个线程可以访问共享资源。</li> <li>使用 <code class="language-plaintext highlighter-rouge">std::lock_guard</code> 自动管理锁的生命周期，避免死锁。</li> </ul> </li> </ul> </li> <li> <p><strong>2. <code class="language-plaintext highlighter-rouge">std::condition_variable</code></strong></p> <ul> <li><strong>适用场景</strong>： <ul> <li><strong>条件变量</strong>：当你需要线程间的同步和通信时，使用 <code class="language-plaintext highlighter-rouge">std::condition_variable</code> 是合适的选择。</li> </ul> </li> <li><strong>解释</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">std::condition_variable</code> 提供了条件变量，用于线程间的同步和通信。</li> <li>一个线程等待条件变量，另一个线程设置条件并通知等待的线程。</li> </ul> </li> </ul> </li> <li> <p><strong>3. <code class="language-plaintext highlighter-rouge">std::promise</code> 和 <code class="language-plaintext highlighter-rouge">std::future</code> / <code class="language-plaintext highlighter-rouge">std::shared_future</code></strong></p> <ul> <li><strong>适用场景</strong>： <ul> <li><strong>线程之间的值传递</strong>：当你需要在线程之间传递值时，使用 <code class="language-plaintext highlighter-rouge">std::promise</code> 和 <code class="language-plaintext highlighter-rouge">std::future</code> 是合适的选择。</li> </ul> </li> <li><strong>解释</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">std::promise</code> 用于设置值，<code class="language-plaintext highlighter-rouge">std::future</code> 用于获取值。</li> <li>在一个线程中设置值，在另一个线程中获取值，实现线程间的值传递。</li> </ul> </li> </ul> </li> <li> <p><strong>4. <code class="language-plaintext highlighter-rouge">std::atomic</code></strong></p> <ul> <li><strong>适用场景</strong>： <ul> <li><strong>原子操作</strong>：当你需要进行原子操作以确保线程安全时，使用 <code class="language-plaintext highlighter-rouge">std::atomic</code> 是合适的选择。</li> </ul> </li> <li><strong>解释</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">std::atomic</code> 提供了原子操作，确保多个线程对共享变量的操作是线程安全的。</li> <li>在多个线程中对 <code class="language-plaintext highlighter-rouge">std::atomic</code> 变量进行操作，避免数据竞争。</li> </ul> </li> </ul> </li> </ul> <h4 id="21-互斥锁">2.1 互斥锁</h4> <h5 id="211-c标准库直接支持的锁类型">2.1.1 c++标准库直接支持的锁类型</h5> <ul> <li><strong><code class="language-plaintext highlighter-rouge">std::mutex</code></strong>：基本的互斥锁。</li> <li><strong><code class="language-plaintext highlighter-rouge">std::recursive_mutex</code></strong>：递归互斥锁，允许同一线程多次获取锁。</li> <li><strong><code class="language-plaintext highlighter-rouge">std::shared_mutex</code></strong>：读写锁，允许多个线程同时读取，但写入时需要独占锁。</li> <li><strong><code class="language-plaintext highlighter-rouge">std::timed_mutex</code></strong>：带有超时功能的互斥锁。</li> <li><strong><code class="language-plaintext highlighter-rouge">std::shared_timed_mutex</code></strong>：带有超时功能的共享互斥锁。</li> </ul> <h5 id="212-锁策略锁管理上锁方式">2.1.2 锁策略/锁管理/上锁方式</h5> <ul> <li> <p><strong><code class="language-plaintext highlighter-rouge">std::lock</code></strong></p> <ul> <li><strong>功能</strong>：一个函数模板，用于使用死锁避免算法锁定多个可锁对象。</li> <li><strong>特点</strong>：确保多个锁按顺序锁定，避免死锁。</li> <li><strong>使用场景</strong>：适用于需要同时锁定多个互斥锁的场景，确保线程安全。</li> <li><strong>如何使用</strong>：</li> <li>调用 <code class="language-plaintext highlighter-rouge">std::lock</code> 函数时传入多个互斥锁，使用死锁避免算法锁定所有互斥锁。</li> <li>在锁定成功后，可以使用 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 或 <code class="language-plaintext highlighter-rouge">std::lock_guard</code> 管理这些锁。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">std::try_lock</code></strong></p> <ul> <li><strong>功能</strong>：一个函数模板，尝试获取多个互斥锁的所有权，如果无法获取则返回。</li> <li><strong>特点</strong>：用于尝试锁定多个互斥锁，而不会阻塞线程。</li> <li><strong>使用场景</strong>：适用于需要尝试锁定多个互斥锁的场景，避免线程阻塞。</li> <li><strong>如何使用</strong>：</li> <li>调用 <code class="language-plaintext highlighter-rouge">std::try_lock</code> 函数时传入多个互斥锁，尝试获取所有互斥锁的所有权。</li> <li>如果成功获取所有互斥锁，返回 -1；如果无法获取某个互斥锁，返回该互斥锁的索引。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">std::unique_lock</code></strong></p> <ul> <li><strong>功能</strong>：提供更多灵活性和控制的锁管理类，可以延迟锁定、手动锁定和解锁、传递锁的所有权。</li> <li><strong>特点</strong>：适用于复杂的锁定需求，支持延迟锁定和手动解锁。</li> <li><strong>使用场景</strong>：适用于需要灵活控制锁定和解锁的场景，如需要在不同函数间传递锁的所有权。</li> <li><strong>如何使用</strong>：</li> <li>创建 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 对象时可以选择立即锁定或延迟锁定互斥锁。</li> <li>可以手动调用 <code class="language-plaintext highlighter-rouge">lock</code> 和 <code class="language-plaintext highlighter-rouge">unlock</code> 方法来控制锁定和解锁。</li> <li>可以将 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 对象传递给其他函数，传递锁的所有权。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">std::lock_guard</code></strong></p> <ul> <li><strong>功能</strong>：简单的 RAII 风格的锁管理类，在构造时自动锁定互斥锁，在析构时自动解锁互斥锁。</li> <li><strong>特点</strong>：适用于基本的锁定需求，确保在作用域结束时自动释放锁。</li> <li><strong>使用场景</strong>：适用于简单的临界区保护，确保在函数退出时自动释放锁。</li> <li><strong>如何使用</strong>：</li> <li>创建 <code class="language-plaintext highlighter-rouge">std::lock_guard</code> 对象时传入互斥锁，自动锁定互斥锁。</li> <li>在作用域结束时，<code class="language-plaintext highlighter-rouge">std::lock_guard</code> 会自动解锁互斥锁。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">std::scoped_lock</code></strong></p> <ul> <li><strong>功能</strong>：同时锁定多个互斥锁，并在作用域结束时自动解锁。</li> <li><strong>特点</strong>：RAII 风格的锁管理器，确保在作用域结束时自动释放锁，避免死锁和资源泄漏。</li> <li><strong>使用场景</strong>：适用于需要同时锁定多个互斥锁的场景，确保线程安全。</li> <li><strong>如何使用</strong>：</li> <li>创建 <code class="language-plaintext highlighter-rouge">std::scoped_lock</code> 对象时传入多个互斥锁。</li> <li>在作用域结束时，<code class="language-plaintext highlighter-rouge">std::scoped_lock</code> 会自动解锁所有互斥锁。</li> </ul> </li> </ul> <h5 id="213-未支持的锁类型其他锁概念">2.1.3 未支持的锁类型/其他锁概念</h5> <ul> <li> <p><strong>自旋锁（Spin Lock）</strong></p> <ul> <li><strong>功能</strong>：自旋锁在等待锁时会不断循环检查锁的状态，而不是阻塞线程。</li> <li><strong>特点</strong>：适用于高频率锁定和解锁的场景，避免线程上下文切换的开销。</li> <li><strong>使用场景</strong>：适用于锁持有时间短、频繁加锁解锁的场景，如短时间的临界区保护。</li> <li><strong>如何实现</strong>：通常使用原子操作（如 <code class="language-plaintext highlighter-rouge">std::atomic_flag</code>）实现，通过不断尝试获取锁来实现自旋。</li> </ul> </li> <li> <p><strong>分段锁（Segmented Locks）</strong></p> <ul> <li><strong>功能</strong>：将资源分割成多个部分，并对每个部分使用单独锁的机制，以减少锁竞争。</li> <li><strong>特点</strong>：通过分段锁减少锁竞争，提高并发性能。</li> <li><strong>使用场景</strong>：适用于需要对大块资源进行并发访问的场景，如哈希表、缓存等。</li> <li><strong>如何实现</strong>：将资源分割成多个部分，每个部分使用单独的锁，线程只锁定需要访问的部分。</li> </ul> </li> <li> <p><strong>票据锁（Ticket Locks）</strong></p> <ul> <li><strong>功能</strong>：先来先服务的锁机制，通过发放票据来控制对资源的访问顺序。</li> <li><strong>特点</strong>：确保公平性，先请求锁的线程先获得锁。</li> <li><strong>使用场景</strong>：适用于需要严格控制访问顺序的场景，确保公平性。</li> <li><strong>如何实现</strong>：使用两个计数器，一个表示下一个可用票据，一个表示当前服务的票据，线程获取票据后等待其票据号被服务。</li> </ul> </li> <li> <p><strong>乐观锁（Optimistic Lock）</strong></p> <ul> <li><strong>功能</strong>：假设并发冲突不会频繁发生，在访问资源时不加锁，而是在提交修改时检查冲突，如果发生冲突则重试。</li> <li><strong>特点</strong>：通过减少锁的使用提高并发性能，适用于低冲突的场景。</li> <li><strong>使用场景</strong>：适用于低冲突的场景，如数据库读操作、缓存等。</li> <li><strong>如何实现</strong>：CAS+版本号，在提交修改时检查版本号或时间戳是否变化，如果发生冲突则重试。</li> </ul> </li> </ul> <h4 id="22-condition_variable">2.2 condition_variable</h4> <p>条件变量是一种“事件通知机制”，它本身不提供、也不能够实现“互斥”的功能。因此，条件变量通常（也必须）配合互斥量来一起使用，其中互斥量实现对“共享数据”的互斥（即同步），而条件变量则去执行 “通知共享数据状态信息的变化”的任务。比如通知队列为空、非空，或任何其他需要由线程处理的共享数据的状态变化。可以说，条件变量是程序用来等待某个状态为真的机制。而这个状态必须得是线程安全的，因此需要搭配互斥量使用。</p> <p>在c++中，条件变量的关键词是<code class="language-plaintext highlighter-rouge">std::condition_variable</code>。它可以用来在多线程环境中实现复杂的同步模式。以下是一些常见的用法:</p> <ol> <li><strong>等待通知</strong>:一个线程可以使用<code class="language-plaintext highlighter-rouge">std::condition_variable::wait</code>或<code class="language-plaintext highlighter-rouge">wait_for</code>/<code class="language-plaintext highlighter-rouge">wait_until</code>方法来等待另一个线程的通知。当<code class="language-plaintext highlighter-rouge">wait</code>被调用时，当前线程将被阻塞，直到另一个线程调用<code class="language-plaintext highlighter-rouge">std::condition_variable::notify_one</code>或<code class="language-plaintext highlighter-rouge">notify_all</code>方法。</li> <li><strong>条件等待</strong>:<code class="language-plaintext highlighter-rouge">std::condition_variable::wait</code>方法还可以接受一个谓词(返回<code class="language-plaintext highlighter-rouge">bool</code>的函数或函数对象).只有当这个谓词返回<code class="language-plaintext highlighter-rouge">true</code>时，<code class="language-plaintext highlighter-rouge">wait</code>才会返回。这可以用来实现条件等待:线程等待某个条件成立。</li> <li><strong>唤醒一个或多个线程</strong>:可以使用<code class="language-plaintext highlighter-rouge">std::condition_variable::notify_one</code>方法唤醒一个等待的线程，或者使用<code class="language-plaintext highlighter-rouge">std::condition_variable::notify_all</code>方法唤醒所有等待的线程。</li> </ol> <h4 id="23-promise-future">2.3 promise/ future</h4> <p>future 是表示未来能够得到的值，具体什么时候能够得到，依赖于承诺对象的实现。 什么是承诺对象？ promise 和 packaged_task 就是承诺对象，但这些承诺对象 set_value 的时候，就可以执行 future.get()</p> <p>关于 future，promise，packaged_task，async 的理解，以下表述对吗？ promise 和 packaged_task 都是还没有给出具体值的承诺对象，当给出具体数值的时候，就表示承诺实现，可以用于计算。 而 async 是表示会开一个异步线程进行计算，返回的是一个 future 的值，如果 future 的值计算好之后，就可以通过 future.get()得到。</p> <p>所以说，在一个异步计算中，promise 和 packaged_task 是输入端的，async 是输出端的。</p> <h5 id="231-shared_future">2.3.1 shared_future</h5> <p><code class="language-plaintext highlighter-rouge">std::future</code>对象的设计是唯一所有权的，也就是说，一旦你从一个<code class="language-plaintext highlighter-rouge">std::future</code>对象中获取了值，这个<code class="language-plaintext highlighter-rouge">std::future</code>对象就不能再被用来获取值。这是因为<code class="language-plaintext highlighter-rouge">std::future::get</code>方法会移动(而不是复制)值或异常，这样可以避免不必要的复制，但也意味着你只能从一个<code class="language-plaintext highlighter-rouge">std::future</code>对象中获取值一次。</p> <p>因此，如果你需要在多个线程中共享同一个值，你不能直接使用<code class="language-plaintext highlighter-rouge">std::future</code>，而应该使用<code class="language-plaintext highlighter-rouge">std::shared_future</code>.<code class="language-plaintext highlighter-rouge">std::shared_future</code>对象可以被多次拷贝和读取，这意味着你可以在多个线程中共享同一个值。</p> <p>在你的代码中，你创建了一个<code class="language-plaintext highlighter-rouge">std::shared_future&lt;int&gt; sf</code>对象，并将它传递给了三个异步操作。这三个异步操作都可以通过<code class="language-plaintext highlighter-rouge">sf.get()</code>获取到同一个值。如果你试图直接使用<code class="language-plaintext highlighter-rouge">std::future&lt;int&gt; f</code>来做同样的事情，你会得到一个编译错误，因为<code class="language-plaintext highlighter-rouge">std::future</code>对象不能被拷贝。</p> <ul> <li>shared_future 可以直接对一个 promise 变量使用 get_future 方法吗</li> </ul> <p>不可以。<code class="language-plaintext highlighter-rouge">std::promise</code>的<code class="language-plaintext highlighter-rouge">get_future</code>方法只能返回一个<code class="language-plaintext highlighter-rouge">std::future</code>对象，而不是<code class="language-plaintext highlighter-rouge">std::shared_future</code>对象。如果你想要一个<code class="language-plaintext highlighter-rouge">std::shared_future</code>对象，你需要首先从<code class="language-plaintext highlighter-rouge">std::promise</code>获取一个<code class="language-plaintext highlighter-rouge">std::future</code>对象，然后调用<code class="language-plaintext highlighter-rouge">std::future</code>的<code class="language-plaintext highlighter-rouge">share</code>方法来获取一个<code class="language-plaintext highlighter-rouge">std::shared_future</code>对象。例如:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sf</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">share</span><span class="p">();</span>
</code></pre></div></div> <p>在这段代码中，<code class="language-plaintext highlighter-rouge">sf</code>是一个<code class="language-plaintext highlighter-rouge">std::shared_future</code>对象，它与<code class="language-plaintext highlighter-rouge">f</code>共享同一个状态，也就是说，它们都可以获取到同一个值。</p> <h4 id="24-atomic">2.4 atomic</h4> <p>std::call_once 和 std::once_flag： 这些用于确保某个函数或操作只被调用一次，即使在多线程环境中也不会被重复执行。</p> <ul> <li>解决多线程下共享变量的问题(i++，指令重排问题)：对于共享变量的访问进行加锁，加锁可以保证对临界区的互斥访问，</li> <li>C++11 提供了一些原子变量与原子操作解决用户加锁操作麻烦或者容易出错的问题</li> <li>C++11 标准在标准库 atomic 头文件提供了模版 std::atomic&lt;&gt;来定义原子量，而对于大部分内建类型，C++11 提供了一些特化，如，std::atomic_int (std::atomic<int>)等</int></li> <li>自定义类型变成原子变量的条件是该类型必须为<strong>Trivially Copyable 类型</strong>(简单的判断标准就是这个类型可以用 std::memcpy 按位复制)</li> <li>atomic 有一个成员函数 is_lock_free，这个成员函数可以告诉我们到底这个类型的原子量是使用了原子 CPU 指令实现了无锁化，还是依然使用的加锁的方式来实现原子操作</li> </ul> <h5 id="241-barrier">2.4.1 barrier</h5> <p>屏障主要用于多个线程之间的并行工作的协调。<strong>屏障允许每个线程等待，直到所有的合作线程都达到某个点，然后从该点继续执行</strong></p> <h3 id="3-标准库未直接提供的多线程工具">3. 标准库未直接提供的多线程工具</h3> <h4 id="31-信号量">3.1 信号量</h4> <p><code class="language-plaintext highlighter-rouge">semaphore.h</code> 是一个头文件，提供信号量相关的功能，用于控制对共享资源的访问。C++20 标准库引入了信号量类 <code class="language-plaintext highlighter-rouge">std::counting_semaphore</code> 和 <code class="language-plaintext highlighter-rouge">std::binary_semaphore</code>，提供了类似 <code class="language-plaintext highlighter-rouge">semaphore.h</code> 的功能。通过使用 C++ 标准库中的信号量类，可以实现对共享资源的同步控制，解决多线程编程中的同步问题。</p> <ul> <li> <p>信号量可以决定线程当前是继续运行还是等待</p> </li> <li> <p>信号量代表某一类资源，其值表示系统中该资源的数量。因此它是一个非负数的值</p> </li> <li> <p>信号量是一个受保护的变量，只能通过三种操作来访问：</p> <ul> <li>初始化</li> <li>P操作（申请资源） <ul> <li>当进行P操作时，它会去<strong>判断当前信号量的值是否大于0</strong>，<strong>若是，则申请P操作的任务继续运行，同时信号量的值减一</strong>。<strong>若否，则阻塞</strong></li> </ul> </li> <li>V操作（释放资源） <ul> <li>V操作则是<strong>先让信号量的值加一</strong>，<strong>再判断当前是否有正在等待资源的任务以让它继续运行</strong></li> </ul> </li> </ul> </li> </ul> <h4 id="32-临界区">3.2 临界区</h4> <h3 id="4-死锁的监测与避免">4. 死锁的监测与避免</h3> <h4 id="41-死锁的必要条件">4.1 死锁的必要条件</h4> <ul> <li>互斥：一些会被竞争的资源，一个时间只能被一个线程占用。 <blockquote> <p>解决方式：不上锁，用无锁方式；乐观锁模式；</p> </blockquote> </li> <li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。 <blockquote> <p>解决方式：一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p> </blockquote> </li> <li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 <blockquote> <p>提供某种机制，或者允许系统强制回收资源。</p> </blockquote> </li> <li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 <blockquote> <p>给资源统一编号，进程只能按编号顺序来请求资源。</p> </blockquote> </li> </ul> <p>(1) 互斥:一个资源每次只能被一个进程使用。<br/> (2) 占有并请求:一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br/> (3) 不可剥夺:进程已获得的资源，在末使用完之前，不能强行剥夺。<br/> (4) 循环等待:若干进程之间形成一种头尾相接的循环等待资源关系。<br/></p> <p>产生死锁的原因主要是:<br/> (1) 因为系统资源不足。<br/> (2) 进程运行推进的顺序不合适。<br/> (3) 资源分配不当等。<br/></p> <h4 id="42-死锁的解决方法">4.2 死锁的解决方法</h4> <ul> <li>死锁检测与死锁恢复 通过系统监测死锁的发生，并在检测到死锁时采取措施恢复系统。 具体方法包括终止一个或多个进程，或回收某些资源。</li> </ul> <ol> <li>重新启动:是最简单/最常用的死锁消除方法，但代价很大，因为在此之前所有进程已经完成的计算工作都将付之东流，不仅包括死锁的全部进程，也包括未参与死锁的全部进程。</li> <li>终止进程(process termination):终止参与死锁的进程并回收它们所占资源。 (1) 一次性全部终止;(2) 逐步终止(优先级，代价函数)</li> <li>剥夺资源(resource preemption):剥夺死锁进程所占有的全部或者部分资源。 (1) 逐步剥夺:一次剥夺死锁进程所占有的一个或一组资源，如果死锁尚未解除再继续剥夺，直至死锁解除为止。 (2) 一次剥夺:一次性地剥夺死锁进程所占有的全部资源。</li> <li>进程回退(rollback):让参与死锁的进程回退到以前没有发生死锁的某个点处，并由此点开始继续执行，希望进程交叉执行时不再发生死锁。但是系统开销很大: (1) 要实现”回退”，必须”记住”以前某一点处的现场，而现场随着进程推进而动态变化，需要花费大量时间和空间。 (2) 一个回退的进程应当”挽回”它在回退点之间所造成的影响，如修改某一文件，给其它进程发送消息等，这些在实现时是难以做到的</li> </ol> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-stdlock_guard和stdunique_lock有什么不同">1. <code class="language-plaintext highlighter-rouge">std::lock_guard</code>和<code class="language-plaintext highlighter-rouge">std::unique_lock</code>有什么不同？</h4> <p><code class="language-plaintext highlighter-rouge">std::lock_guard</code> 和 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 都是 RAII（Resource Acquisition Is Initialization）风格的互斥锁包装器，它们在构造时自动锁定互斥锁，在析构时自动解锁互斥锁。这种设计可以确保在函数退出（无论是正常退出还是异常退出）时自动释放锁，从而避免因忘记解锁而导致的死锁。<code class="language-plaintext highlighter-rouge">std::lock_guard</code>和<code class="language-plaintext highlighter-rouge">std::unique_lock</code>的主要区别在于:</p> <ol> <li><strong>延迟锁定</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">std::unique_lock</code> 可以在创建时不立即锁定互斥锁，然后在需要的时候再锁定。</li> <li><code class="language-plaintext highlighter-rouge">std::lock_guard</code> 则在创建时必须立即锁定互斥锁。</li> </ul> </li> <li><strong>所有权传递</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">std::unique_lock</code> 是可移动的，这意味着你可以将锁的所有权从一个 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 对象转移到另一个。</li> <li><code class="language-plaintext highlighter-rouge">std::lock_guard</code> 则不可移动。</li> </ul> </li> <li><strong>手动锁定和解锁</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">std::unique_lock</code> 提供了 <code class="language-plaintext highlighter-rouge">lock</code> 和 <code class="language-plaintext highlighter-rouge">unlock</code> 方法，允许你在任何时候手动锁定和解锁互斥锁。</li> <li><code class="language-plaintext highlighter-rouge">std::lock_guard</code> 则不提供这些方法。</li> </ul> </li> </ol> <p>简单来说，使用选择上：</p> <ul> <li> <p><strong><code class="language-plaintext highlighter-rouge">std::unique_lock</code></strong>：</p> <ul> <li>适用于需要更多控制的场景，例如延迟锁定、所有权传递或手动锁定和解锁。</li> <li>提供更大的灵活性，但相对开销也更大。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">std::lock_guard</code></strong>：</p> <ul> <li>适用于简单的锁定和解锁场景。</li> <li>更简单，且开销更小。</li> </ul> </li> </ul> <h4 id="2-stdunique_lock提供的锁策略参数是什么">2. <code class="language-plaintext highlighter-rouge">std::unique_lock</code>提供的锁策略参数是什么？</h4> <p><code class="language-plaintext highlighter-rouge">std::adopt_lock</code>/<code class="language-plaintext highlighter-rouge">std::defer_lock</code> 和 <code class="language-plaintext highlighter-rouge">std::try_to_lock</code> 都是 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 的构造函数可以接受的锁策略参数，它们的含义和使用场景如下:</p> <ol> <li><strong>std::adopt_lock</strong>:这个策略表示互斥锁在构造锁对象时已经被锁定。当你已经手动锁定了一个互斥锁，然后想要将它的管理权交给 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 时，可以使用 <code class="language-plaintext highlighter-rouge">std::adopt_lock</code>.这样，<code class="language-plaintext highlighter-rouge">std::unique_lock</code> 在构造时就不会再次尝试锁定互斥锁，而是直接接管已经被锁定的互斥锁。</li> <li><strong>std::defer_lock</strong>:这个策略表示在构造 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 时不锁定互斥锁。你可以稍后手动调用 <code class="language-plaintext highlighter-rouge">std::unique_lock::lock</code> 方法来锁定互斥锁。这个策略在你需要延迟锁定互斥锁的情况下很有用。</li> <li><strong>std::try_to_lock</strong>:这个策略表示在构造 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 时尝试锁定互斥锁，如果互斥锁已经被锁定，则立即返回，不会阻塞。你可以检查 <code class="language-plaintext highlighter-rouge">std::unique_lock::owns_lock</code> 方法的返回值，来判断是否成功锁定了互斥锁。</li> </ol> <h4 id="3-不使用-join-也不使用-detach会发生什么">3. 不使用 <code class="language-plaintext highlighter-rouge">join</code> 也不使用 <code class="language-plaintext highlighter-rouge">detach</code>，会发生什么</h4> <ul> <li> <p><strong>问题</strong>：</p> <ul> <li>在主线程退出时，可能会导致一些未定义行为，因为线程对象将被销毁，但线程本身可能仍在运行。</li> </ul> </li> <li> <p><strong>可能发生的情况</strong>：</p> <ol> <li><strong>程序可能终止，但线程可能仍在运行</strong>： <ul> <li>如果主线程退出，而被创建的线程仍在运行，可能导致程序终止，但线程继续执行。这可能导致线程无法正确完成其任务，因为主线程已经退出。</li> </ul> </li> <li><strong>程序可能会崩溃</strong>： <ul> <li>这是由于线程对象的销毁可能涉及到一些资源的释放，而线程本身仍在访问这些资源，导致未定义行为。</li> </ul> </li> <li><strong>资源泄漏</strong>： <ul> <li>如果线程分配了一些资源（例如内存），但在线程执行完毕前这些资源没有被释放，可能会导致资源泄漏。</li> </ul> </li> </ol> </li> </ul> <h4 id="4-为什么多线程传引用要用stdref">4. 为什么多线程传引用要用<code class="language-plaintext highlighter-rouge">std::ref</code></h4> <p>问题出在 std::thread 不能直接传递引用类型参数。std::thread 在创建线程时会复制传入的参数。 因为主线程和子线程是两个声明周期，如果直接传递引用，当主线程中的对象销毁后，线程函数中的引用就会成为悬空引用，访问悬空引用会导致未定义行为。</p> <p>如果能直接传递引用类型，因为线程的生命周期和原有函数不一定一直，可能会导致悬空引用。 而使用了std::ref本质上是没有解决悬空引用问题的，因此这个时候要开发者要有一个心智的认识，即这里的声明周期，以及会不会出现悬空引用。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span>
<span class="c1">// 线程函数</span>
<span class="kt">void</span> <span class="nf">modifyValue</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Value inside thread: "</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="c1">// 创建线程，尝试传递引用</span>
    <span class="c1">// std::thread t(modifyValue， value); // error</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">modifyValue</span><span class="err">，</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Value outside thread: "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="3-原子操作实现原理">3. 原子操作实现原理</h4> <p>原子操作通过硬件支持的原子指令和缓存行锁机制，确保在多核 CPU 环境中，对共享数据的操作是原子的。通过在操作期间将缓存行标记为 locked，可以防止多个 CPU 核心同时修改同一份数据，从而实现原子操作。这种实现方式要求操作的变量位于一个缓存行中。</p> <ul> <li> <p><strong>Cache Line Lock 的实现步骤</strong></p> <ol> <li><strong>CPU1 发出 “Read Invalidate” 消息</strong>：</li> </ol> <ul> <li>CPU1 发出 “Read Invalidate” 消息，通知其他 CPU 将原子变量所在的缓存无效，并从 Cache 返回数据。</li> <li>CPU1 将 Cache Line 置为 Exclusive 状态，并将该 Cache Line 标记为 locked。</li> </ul> <ol> <li><strong>CPU1 读取和修改原子变量</strong>：</li> </ol> <ul> <li>CPU1 读取原子变量，进行修改，并将修改后的数据写入 Cache Line。</li> </ul> <ol> <li><strong>将 Cache Line 置为 unlocked</strong>：</li> </ol> <ul> <li>CPU1 完成操作后，将 Cache Line 置为 unlocked。</li> </ul> </li> <li> <p><strong>处理并发操作</strong> 在步骤 (1) 和 (3) 之间，如果其他 CPU（例如 CPU0）尝试执行一个原子递增操作，以下是处理流程：</p> <ol> <li><strong>CPU0 发送 “Read Invalidate” 消息</strong>：</li> </ol> <ul> <li>CPU0 发送 “Read Invalidate” 消息，通知 CPU1 将原子变量所在的缓存无效。</li> </ul> <ol> <li><strong>CPU1 检查 Cache Line 状态</strong>：</li> </ol> <ul> <li>CPU1 收到消息后，检查对应的 Cache Line 的状态是 locked，暂时不回复消息。</li> <li>CPU0 会一直等待 CPU1 回复 Invalidate Acknowledge 消息。</li> </ul> <ol> <li><strong>等待 Cache Line 变为 unlocked</strong>：</li> </ol> <ul> <li>CPU0 等待 Cache Line 变为 unlocked。</li> <li>当 CPU1 将 Cache Line 置为 unlocked 后，CPU0 收到 Invalidate Acknowledge 消息，继续执行原子操作。</li> </ul> </li> <li> <p><strong>总结</strong> 这种方式称为锁 Cache Line，通过在操作期间将 Cache Line 标记为 locked，确保在操作期间其他 CPU 核心无法修改该数据，从而实现原子操作。这种实现方式要求操作的变量位于一个 Cache Line 中。</p> </li> </ul> <h4 id="4-多核-cpu-的缓存以及如何保持缓存一致性">4. 多核 cpu 的缓存以及如何保持缓存一致性</h4> <p>在多核 CPU 环境中，每个 CPU 核心都有自己的高速缓存（Cache），用于加速数据访问。然而，当多个 CPU 核心同时操作同一份数据时，可能会导致数据不一致的问题。为了确保数据的一致性，多核 CPU 使用了一些机制来保持缓存一致性。</p> <ul> <li><strong>缓存一致性问题</strong></li> </ul> <ol> <li><strong>缓存一致性问题</strong>： <ul> <li>当多个 CPU 核心同时读取和写入同一内存地址时，可能会导致缓存中的数据不一致。</li> <li>例如，CPU 核心 A 和 CPU 核心 B 都有一个变量 <code class="language-plaintext highlighter-rouge">x</code> 的缓存副本。如果 CPU 核心 A 修改了 <code class="language-plaintext highlighter-rouge">x</code> 的值，而 CPU 核心 B 仍然使用旧的缓存值，就会导致数据不一致。</li> </ul> </li> </ol> <ul> <li><strong>缓存一致性协议</strong></li> </ul> <p>为了保持缓存一致性，多核 CPU 使用了缓存一致性协议。以下是一些常见的缓存一致性协议：</p> <ol> <li> <p><strong>MESI 协议</strong>：</p> <ul> <li>MESI 协议是最常见的缓存一致性协议之一。MESI 是四个状态的缩写：Modified（修改）、Exclusive（独占）、Shared（共享）和 Invalid（无效）。</li> <li>每个缓存行都有一个状态，表示该缓存行的当前状态。</li> </ul> </li> <li> <p><strong>MESI 协议的工作原理</strong>：</p> <ul> <li><strong>Modified（修改）</strong>：缓存行的数据已被修改，与主内存中的数据不一致。只有一个 CPU 核心可以持有该状态的缓存行。</li> <li><strong>Exclusive（独占）</strong>：缓存行的数据与主内存中的数据一致，且只有一个 CPU 核心持有该缓存行。</li> <li><strong>Shared（共享）</strong>：缓存行的数据与主内存中的数据一致，且多个 CPU 核心可以持有该缓存行。</li> <li><strong>Invalid（无效）</strong>：缓存行的数据无效，不能使用。</li> </ul> </li> <li> <p><strong>缓存一致性操作</strong>：</p> <ul> <li><strong>读取操作</strong>：当一个 CPU 核心读取一个缓存行时，如果该缓存行的状态是 Invalid，则需要从主内存或其他 CPU 核心的缓存中获取最新的数据。</li> <li><strong>写入操作</strong>：当一个 CPU 核心写入一个缓存行时，需要通知其他 CPU 核心将该缓存行的状态设置为 Invalid。</li> </ul> </li> </ol> <h4 id="5-什么是虚假唤醒为什么会有虚假唤醒可以避免虚假唤醒吗">5. 什么是虚假唤醒？为什么会有虚假唤醒？可以避免虚假唤醒吗？</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cond</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">queue</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">dequeue</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
    <span class="n">cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="err">，</span> <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>  <span class="c1">// 使用 lambda 表达式检查条件</span>
    <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">top</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dequeue2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>  <span class="c1">// 不能用 if，必须用 while，避免虚假唤醒</span>
        <span class="n">cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">top</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dequeue3</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>  <span class="c1">// 使用 if 判断，可能会出现虚假唤醒</span>
        <span class="n">cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">top</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在多线程编程中，使用条件变量（Condition Variable）进行线程同步时，可能会遇到虚假唤醒的问题。以下是对虚假唤醒及其处理方法的详细解释：</p> <ul> <li> <p><strong>什么是虚假唤醒？</strong> 虚假唤醒（Spurious Wakeup）是指线程在等待条件变量时，即使没有任何线程调用 <code class="language-plaintext highlighter-rouge">notify_one</code> 或 <code class="language-plaintext highlighter-rouge">notify_all</code>，也会被唤醒的情况，即<code class="language-plaintext highlighter-rouge">wait</code>的时候被唤醒了。这种现象在某些操作系统和硬件平台上可能会发生。</p> </li> <li> <p><strong>为什么会有虚假唤醒？</strong> 虚假唤醒的原因可能包括：</p> <ol> <li><strong>操作系统的调度策略</strong>：</li> </ol> <ul> <li>操作系统可能会出于各种原因唤醒等待的线程，例如资源重新分配或优先级调整。</li> </ul> <ol> <li><strong>硬件中断</strong>：</li> </ol> <ul> <li>硬件中断可能会导致等待的线程被唤醒。</li> </ul> <ol> <li><strong>其他系统级别的事件</strong>：</li> </ol> <ul> <li>系统级别的事件（如信号处理）也可能导致线程被唤醒。</li> </ul> </li> <li> <p><strong>如何处理虚假唤醒？</strong> 为了正确处理虚假唤醒，通常在一个 <code class="language-plaintext highlighter-rouge">while</code> 循环中调用 <code class="language-plaintext highlighter-rouge">.wait()</code> 方法，而不是使用 <code class="language-plaintext highlighter-rouge">if</code> 判断。这样可以多次检验条件，确保条件满足后才继续执行。</p> </li> <li> <p><strong>总结</strong></p> <ul> <li><strong>虚假唤醒</strong>：虚假唤醒是指线程在等待条件变量时，即使没有任何线程调用 <code class="language-plaintext highlighter-rouge">notify_one</code> 或 <code class="language-plaintext highlighter-rouge">notify_all</code>，也会被唤醒的情况。</li> <li><strong>原因</strong>：虚假唤醒可能由操作系统的调度策略、硬件中断或其他系统级别的事件引起。</li> <li><strong>处理方法</strong>：为了正确处理虚假唤醒，通常在一个 <code class="language-plaintext highlighter-rouge">while</code> 循环中调用 <code class="language-plaintext highlighter-rouge">.wait()</code> 方法，确保每次被唤醒时都重新检查条件是否满足。</li> </ul> </li> </ul> <h4 id="6-如果函数返回一个-future对这个-future-不调用-get会发生什么">6. 如果函数返回一个 future，对这个 future 不调用 get()，会发生什么</h4> <ul> <li> <p><strong>1. <code class="language-plaintext highlighter-rouge">std::async</code> 的返回值</strong></p> <ul> <li><strong>临时 <code class="language-plaintext highlighter-rouge">std::future</code> 对象</strong>： <ul> <li>如果你调用 <code class="language-plaintext highlighter-rouge">std::async</code> 但不将返回值存储在一个 <code class="language-plaintext highlighter-rouge">std::future</code> 对象中，一个临时的 <code class="language-plaintext highlighter-rouge">std::future</code> 对象会被创建。</li> <li>这个临时对象会在表达式结束时被销毁，销毁时会阻塞等待异步任务完成。</li> <li>因此，如果你不想阻塞当前线程，不能简单地忽略 <code class="language-plaintext highlighter-rouge">std::async</code> 的返回值。你需要将返回的 <code class="language-plaintext highlighter-rouge">std::future</code> 对象存储在某个地方，以便在适当的时候等待任务完成。</li> </ul> </li> </ul> </li> <li> <p><strong>2. <code class="language-plaintext highlighter-rouge">std::future</code> 的析构行为</strong></p> <ul> <li><strong>阻塞等待异步任务完成</strong>： <ul> <li>如果你创建了一个 <code class="language-plaintext highlighter-rouge">std::future</code> 对象，但没有调用 <code class="language-plaintext highlighter-rouge">get()</code> 方法，那么在 <code class="language-plaintext highlighter-rouge">std::future</code> 对象被销毁时，如果关联的异步操作（例如 <code class="language-plaintext highlighter-rouge">std::async</code>）还没有完成，程序会阻塞，直到异步操作完成。</li> <li>这是因为 <code class="language-plaintext highlighter-rouge">std::future</code> 的析构函数会检查关联的异步操作是否已经完成。如果没有完成，析构函数会阻塞，直到异步操作完成。这是为了确保异步操作能够安全地完成，而不会在还没有完成的情况下被强制停止。</li> </ul> </li> </ul> </li> <li> <p><strong>3. 避免阻塞的方法</strong></p> <ul> <li><strong>使用 <code class="language-plaintext highlighter-rouge">std::future::detach()</code></strong>： <ul> <li>如果你不想在 <code class="language-plaintext highlighter-rouge">std::future</code> 对象被销毁时阻塞，可以调用 <code class="language-plaintext highlighter-rouge">std::future::detach()</code> 方法。这将使 <code class="language-plaintext highlighter-rouge">std::future</code> 对象与其关联的异步操作分离，这样，即使 <code class="language-plaintext highlighter-rouge">std::future</code> 对象被销毁，异步操作也会继续运行。</li> <li>需要注意的是，如果你没有调用 <code class="language-plaintext highlighter-rouge">get()</code> 方法，那么你将无法获取异步操作的结果。此外，<code class="language-plaintext highlighter-rouge">get()</code> 方法只能被调用一次，因为调用 <code class="language-plaintext highlighter-rouge">get()</code> 方法后，<code class="language-plaintext highlighter-rouge">std::future</code> 对象会变为无效状态。</li> </ul> </li> </ul> </li> <li> <p><strong>4. 函数返回值的处理</strong></p> <ul> <li><strong>函数返回值的析构</strong>： <ul> <li>函数的返回值即使没有用变量接收，实际上也是存在的，并且在外部函数结束时会被析构。</li> <li>而 <code class="language-plaintext highlighter-rouge">std::future</code> 的析构又要确保 <code class="language-plaintext highlighter-rouge">get()</code> 方法完成，所以如果不接收返回值，就会产生阻塞。</li> </ul> </li> </ul> </li> <li> <p><strong>总结</strong> 在使用 <code class="language-plaintext highlighter-rouge">std::async</code> 和 <code class="language-plaintext highlighter-rouge">std::future</code> 时，需要注意以下几点：</p> <ul> <li>将 <code class="language-plaintext highlighter-rouge">std::async</code> 的返回值存储在 <code class="language-plaintext highlighter-rouge">std::future</code> 对象中，以避免临时对象销毁时阻塞当前线程。</li> <li>在 <code class="language-plaintext highlighter-rouge">std::future</code> 对象被销毁前，调用 <code class="language-plaintext highlighter-rouge">get()</code> 方法等待异步任务完成，或使用 <code class="language-plaintext highlighter-rouge">detach</code> 方法分离异步操作。</li> <li>理解 <code class="language-plaintext highlighter-rouge">std::future</code> 的析构行为，确保异步操作能够安全地完成。</li> </ul> </li> </ul> <h4 id="7-对于单次事件通信使用atomic-mutex-promise的比较">7. 对于单次事件通信使用atomic， mutex， promise的比较</h4> <p>这段文本讨论了在多线程编程中，如何有效地进行单次事件通信。具体来说，它比较了使用标志位、线程锁和<code class="language-plaintext highlighter-rouge">std::promise</code>三种不同的方法来实现线程间的同步和通信。</p> <ol> <li> <p><strong>使用标志位(flag)</strong>:</p> <ul> <li>代码示例中没有直接展示，但提到了一种常见的做法，即在一个线程中使用<code class="language-plaintext highlighter-rouge">while(!flag){}</code>循环等待另一个线程改变<code class="language-plaintext highlighter-rouge">flag</code>的值。这种方法简单，但它会导致忙等待（busy-waiting），浪费 CPU 资源，因为等待的线程会持续检查<code class="language-plaintext highlighter-rouge">flag</code>而不做任何有用的工作。</li> </ul> </li> <li> <p><strong>使用线程锁</strong>:</p> <ul> <li>文本提到可以使用线程锁来代替标志位，以避免忙等待。示例代码中，<code class="language-plaintext highlighter-rouge">std::lock_guard&lt;std::mutex&gt;</code>用于自动管理互斥锁，但示例似乎有误，因为它没有展示如何正确使用互斥锁来等待某个条件。正确的做法通常涉及到<code class="language-plaintext highlighter-rouge">std::condition_variable</code>，它可以与互斥锁一起使用，让线程在条件不满足时休眠，直到条件被另一个线程改变并通知。</li> </ul> </li> <li> <p><strong>使用<code class="language-plaintext highlighter-rouge">std::promise</code></strong>:</p> <ul> <li>最后，文本推荐使用<code class="language-plaintext highlighter-rouge">std::promise</code>来进行单次事件通信。<code class="language-plaintext highlighter-rouge">std::promise</code>是一种同步机制，可以在一个线程中存储一个值或异常，然后在另一个线程中通过与之对应的<code class="language-plaintext highlighter-rouge">std::future</code>对象来检索这个值或异常。示例中，<code class="language-plaintext highlighter-rouge">detect</code>函数创建了一个线程<code class="language-plaintext highlighter-rouge">t</code>，这个线程会等待<code class="language-plaintext highlighter-rouge">std::promise</code>对象<code class="language-plaintext highlighter-rouge">p</code>的状态被设置。当<code class="language-plaintext highlighter-rouge">detect</code>函数调用<code class="language-plaintext highlighter-rouge">p.set_value()</code>时，<code class="language-plaintext highlighter-rouge">p</code>的状态被设置，<code class="language-plaintext highlighter-rouge">t</code>中的等待操作完成，<code class="language-plaintext highlighter-rouge">react</code>函数随后被执行。这种方法避免了忙等待，且只适用于一次性通信，但需要注意的是，它可能涉及到堆内存的使用。</li> </ul> </li> </ol> <p>总的来说，这段文本强调了在设计多线程程序时，应该避免使用忙等待策略，而应该考虑使用更高级的同步机制，如<code class="language-plaintext highlighter-rouge">std::promise</code>，来高效地进行线程间的单次事件通信。</p> <h4 id="12-cas非阻塞同步乐观锁">12. CAS，非阻塞同步（乐观锁）</h4> <p>随着硬件指令集的发展，出现了基于冲突检测的乐观并发策略。通俗地说，<strong>乐观锁</strong>的思想是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施（最常见的补偿措施是不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为<strong>非阻塞同步</strong>。</p> <ul> <li> <p><strong>CAS 指令</strong></p> <ul> <li><strong>定义</strong>： <ul> <li>CAS 指令需要有 3 个操作数，分别是内存地址（在 Java 中理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。</li> <li>CAS 指令执行时，当且仅当 V 处的值符合旧预期值 A 时，处理器用 B 更新 V 处的值，否则它就不执行更新。</li> <li>无论是否更新了 V 处的值，都会返回 V 的旧值。上述的 CAS 指令是一个原子操作。</li> </ul> </li> </ul> </li> <li> <p><strong>CAS 的 ABA 问题</strong></p> <ul> <li> <p><strong>定义</strong>：</p> <ul> <li>因为 CAS 需要在操作值的时候检查值有没有发生变化，如果没有发生变化则更新。但是一个值原来是 A，变成了 B，又变成了 A，那么使用 CAS 进行检查时会发现它的值没有发生变化，但实际上却变化了。</li> <li>CAS 只关注了比较前后的值是否改变，而无法清楚在此过程中变量的变更明细，这就是所谓的 ABA 问题。</li> </ul> </li> <li> <p><strong>解决思路</strong>：</p> <ul> <li>使用版本号（如 MySQL 的 MVCC）。在变量前面追加版本号，每次变量更新的时候把版本号加一，那么 A-B-A 就变成了 1A-2B-3A，从而解决 ABA 问题。</li> </ul> </li> </ul> </li> </ul> <h4 id="13-什么是析构竞态">13. 什么是析构竞态？</h4> <ul> <li> <p><strong>可能出现的竞态条件</strong></p> <ol> <li><strong>对象即将析构时</strong>：</li> </ol> <ul> <li>如何确定是否有其他线程正在执行该对象的成员函数？</li> <li>如果在析构对象时，另一个线程正在调用该对象的成员函数，可能会导致未定义行为。</li> </ul> <ol> <li><strong>执行成员函数期间</strong>：</li> </ol> <ul> <li>如何保证在执行成员函数期间，对象不会在另一个线程被析构？</li> <li>如果对象在执行成员函数期间被析构，可能会导致程序崩溃或数据损坏。</li> </ul> <ol> <li><strong>调用成员函数之前</strong>：</li> </ol> <ul> <li>如何得知对象在调用成员函数之前还活着？</li> <li>如果对象的析构函数正在执行，调用成员函数可能会导致未定义行为。</li> </ul> </li> <li> <p><strong>解决方法</strong> 为了避免析构竞态，可以使用以下方法：</p> <ol> <li> <p><strong>智能指针</strong>：</p> <ul> <li>使用 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 和 <code class="language-plaintext highlighter-rouge">std::weak_ptr</code> 来管理对象的生命周期。</li> <li><code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 会自动管理对象的引用计数，当引用计数为零时，自动销毁对象。</li> <li><code class="language-plaintext highlighter-rouge">std::weak_ptr</code> 可以安全地访问 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> 管理的对象，而不会影响对象的生命周期。</li> </ul> </li> <li> <p><strong>互斥锁</strong>：</p> <ul> <li>使用互斥锁（如 <code class="language-plaintext highlighter-rouge">std::mutex</code>）来保护对象的访问和析构操作。</li> <li>在访问对象的成员函数时，先获取锁，确保对象在访问期间不会被析构。</li> </ul> </li> </ol> </li> </ul> <h4 id="14-如何从构造函数实现线程安全">14. 如何从构造函数，实现线程安全？</h4> <p>要确保对象构造期间的线程安全，关键在于避免在构造函数中泄露 <code class="language-plaintext highlighter-rouge">this</code> 指针。具体来说：</p> <ol> <li> <p><strong>不要在构造函数中注册任何回调</strong>：</p> <ul> <li>在构造函数中注册回调可能会导致 <code class="language-plaintext highlighter-rouge">this</code> 指针泄露，从而使得其他线程在对象尚未完全构造完成时访问它。</li> </ul> </li> <li> <p><strong>不要在构造函数中把 <code class="language-plaintext highlighter-rouge">this</code> 传给跨线程的对象</strong>：</p> <ul> <li>在构造函数中将 <code class="language-plaintext highlighter-rouge">this</code> 传递给其他线程的对象可能会导致这些线程在对象尚未完全构造完成时访问它。</li> </ul> </li> <li> <p><strong>即便在构造函数的最后一行也不行</strong>：</p> <ul> <li>即使在构造函数的最后一行将 <code class="language-plaintext highlighter-rouge">this</code> 传递给其他线程的对象也可能导致竞态条件，因为对象的构造尚未完全完成。</li> </ul> </li> </ol> <h4 id="15-为什么线程安全的析构函数这么麻烦">15. 为什么线程安全的，析构函数这么麻烦？</h4> <p>线程安全的析构函数复杂的原因主要在于析构过程中需要销毁互斥锁，同时确保没有其他线程在使用该对象。具体来说：</p> <ol> <li> <p><strong>确保所有线程都已经停止使用对象</strong>：</p> <ul> <li>在销毁对象之前，必须确保没有任何线程还在使用或可能会使用该对象。这通常需要使用同步机制（如条件变量或 <code class="language-plaintext highlighter-rouge">std::future</code>）来等待所有线程完成。</li> </ul> </li> <li> <p><strong>使用智能指针管理资源</strong>：</p> <ul> <li>在 C++ 中，可以使用智能指针（如 <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> 或 <code class="language-plaintext highlighter-rouge">std::shared_ptr</code>）来管理对象。当没有任何指针指向对象时，对象会被自动销毁。这可以避免手动管理内存和资源的复杂性。</li> </ul> </li> </ol> <p>你将从本书中获得从进程与线程的关系，再到常用的线程同步原语的区别与使用场景，再到线程池以及基于生产者消费者模型的消息队列，以及对协程思想介绍的相关知识。</p> <p>掌握了常见的多线程同步原语之后，接下来可以找一些带多线程的项目去学习一下，不管是否带 UI的都行。 我推荐的一种方式是，使用 gdb 或者 Visual Studio 调试器将你需要学习的多线程程序中断下来，在多线程面板，看看这个进程一共有多少个正在运行的线程，分析每个线程的作用，然后研究下这些线程在何时何地创建的，为什么需要创建新的线程。</p> <h4 id="16-thread里面的变量是独立于主线程的">16. thread里面的变量是独立于主线程的</h4> <ul> <li>如果传递的是指针，要注意主线程析构之后，子线程无法访问</li> <li>如果子线程要求传递的是引用，因为thread的构造函数不知道要传递引用，所以要用ref</li> <li>如果子线程要求运行的是某个实例的成员函数也是可以的。</li> </ul> <p>简单来说，参数都是先被拷贝到thread，再到函数的。 因为创建thread的时候，也不能提前预知函数要什么类型的。 那这个过程中，传递参数如果是可以隐式转换的，那thread可能就传不对了。 而如果传递的是引用的话，thread也不知道，只当成是一个指针，再到函数就傻眼了。</p>]]></content><author><name></name></author><category term="language"/><category term="cpp"/><category term="并发编程"/><category term="multiThread"/><summary type="html"><![CDATA[c++的多线程]]></summary></entry><entry><title type="html">磁盘结构</title><link href="https://marco-hmc.github.io/blog/2025/2_io.md/" rel="alternate" type="text/html" title="磁盘结构"/><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/2_io.md</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/2_io.md/"><![CDATA[<h1 id="磁盘结构">磁盘结构</h1> <ul> <li>硬盘工作原理 <ul> <li><a href="https://www.youtube.com/watch?v=svhIPM2VT8U">video-硬盘工作原理-硬盘如何存储数据</a></li> <li><a href="https://www.youtube.com/watch?v=UNLEvvmcyWA">video-硬盘工作原理-硬盘如何存储数据2</a></li> <li>简单来说，硬盘是以一个页进行读取的</li> </ul> </li> </ul> <ul> <li><a href="#磁盘结构">磁盘结构</a></li> <li><a href="#磁盘调度算法">磁盘调度算法</a> <ul> <li><a href="#1-先来先服务">1. 先来先服务</a></li> <li><a href="#2-最短寻道时间优先">2. 最短寻道时间优先</a></li> <li><a href="#3-电梯算法">3. 电梯算法</a></li> </ul> </li> </ul> <blockquote> <p><a href="https://github.com/CyC2018/CS-Notes">转载自</a></p> </blockquote> <ul> <li>盘面（Platter）：一个磁盘有多个盘面；</li> <li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li> <li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li> <li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li> <li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li> <li>主轴（Spindle）：使整个盘面转动。</li> </ul> <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/014fbc4d-d873-4a12-b160-867ddaed9807.jpg"/> </div> <p><br/></p> <h1 id="磁盘调度算法">磁盘调度算法</h1> <p>读写一个磁盘块的时间的影响因素有：</p> <ul> <li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li> <li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li> <li>实际的数据传输时间</li> </ul> <p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p> <h2 id="1-先来先服务">1. 先来先服务</h2> <blockquote> <p>FCFS, First Come First Served</p> </blockquote> <p>按照磁盘请求的顺序进行调度。</p> <p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p> <h2 id="2-最短寻道时间优先">2. 最短寻道时间优先</h2> <blockquote> <p>SSTF, Shortest Seek Time First</p> </blockquote> <p>优先调度与当前磁头所在磁道距离最近的磁道。</p> <p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p> <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4e2485e4-34bd-4967-9f02-0c093b797aaa.png"/> </div> <p><br/></p> <h2 id="3-电梯算法">3. 电梯算法</h2> <blockquote> <p>SCAN</p> </blockquote> <p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p> <p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p> <p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>]]></content><author><name></name></author><category term="计算机组成"/><summary type="html"><![CDATA[磁盘结构]]></summary></entry><entry><title type="html">进程</title><link href="https://marco-hmc.github.io/blog/2025/2_process.md/" rel="alternate" type="text/html" title="进程"/><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/2_process.md</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/2_process.md/"><![CDATA[<h2 id="进程">进程</h2> <h3 id="2-多进程的概念">2. 多进程的概念</h3> <ul> <li> <p><strong>什么是进程：</strong> 进程是操作系统进行资源分配和调度的基本单位,是应用程序在操作系统中的一次运行过程.进程拥有自己独立的内存空间,每个进程中都有至少一个线程.进程之间的通信需要使用特殊的进程间通信机制.</p> <ul> <li>优点： <ul> <li>进程是互相独立的，不涉及锁什么之类的，代码编写方便，调试方便</li> <li>进程是独立的，所以稳定性更高，一个进程挂了，其他也不会挂；</li> </ul> </li> <li>缺点： <ul> <li>进程创建慢，占用内存多，进程的上下文切换代价高昂</li> <li>进程之间通信麻烦且慢，常用且好的多进程通信机制一般为socket，所以通信内容一般为指令而非数据</li> </ul> </li> </ul> </li> <li> <p><strong>进程的 ID</strong></p> <ul> <li><strong>PID</strong>： <ul> <li>进程的唯一标识。对于多线程的进程而言，所有线程调用 <code class="language-plaintext highlighter-rouge">getpid</code> 函数会返回相同的值。</li> </ul> </li> <li><strong>PGID</strong>： <ul> <li>进程组 ID。每个进程都会有进程组 ID，表示该进程所属的进程组。默认情况下，新创建的进程会继承父进程的进程组 ID。</li> </ul> </li> <li><strong>SID</strong>： <ul> <li>会话 ID。每个进程也都有会话 ID。默认情况下，新创建的进程会继承父进程的会话 ID。</li> </ul> </li> </ul> </li> </ul> <h4 id="21-守护进程概念">2.1 守护进程概念</h4> <ul> <li><strong>守护进程</strong> <ul> <li><strong>定义</strong>： <ul> <li>守护进程是后台运行的、不与任何终端关联的进程，无法通过终端进行输入输出。它们通常用于周期性地执行某种任务或等待处理特定的事件。</li> </ul> </li> <li><strong>实现思路</strong>： <ul> <li>将普通进程改造为守护进程的过程。不同版本的 Unix 系统其实现机制不同，BSD 和 Linux 下的实现细节有所不同。</li> </ul> </li> </ul> </li> </ul> <h4 id="22-后台进程概念">2.2 后台进程概念</h4> <p>后台进程是指在终端中启动后，不会阻塞终端，可以在终端中继续执行其他命令的进程。后台进程通常通过在命令末尾加上 &amp; 符号来启动。后台进程在执行时，用户可以继续在终端中输入其他命令，而不需要等待后台进程完成。 后台进程其实和守护进程是非常类似的，只是严格意义下，后台进程一般还是和终端程序挂钩，而守护进程是与终端进程挂钩的。</p> <h4 id="23-孤儿进程和僵尸进程">2.3 孤儿进程和僵尸进程</h4> <p>在操作系统中，进程的管理和状态是非常重要的。以下是对孤儿进程和僵尸进程的详细解释及其处理方法。</p> <ul> <li> <p><strong>孤儿进程</strong></p> <ul> <li><strong>定义</strong>： <ul> <li>孤儿进程是指一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</li> <li>孤儿进程将被 <code class="language-plaintext highlighter-rouge">init</code> 进程（进程号为 1）所收养，并由 <code class="language-plaintext highlighter-rouge">init</code> 进程对它们完成状态收集工作。</li> </ul> </li> <li><strong>特点</strong>： <ul> <li>孤儿进程不会对系统造成危害，因为 <code class="language-plaintext highlighter-rouge">init</code> 进程会负责它们的状态收集和资源释放。</li> </ul> </li> </ul> </li> <li> <p><strong>僵尸进程</strong></p> <ul> <li><strong>定义</strong>： <ul> <li>僵尸进程是指一个进程使用 <code class="language-plaintext highlighter-rouge">fork</code> 创建子进程，如果子进程退出，而父进程没有调用 <code class="language-plaintext highlighter-rouge">wait</code> 或 <code class="language-plaintext highlighter-rouge">waitpid</code> 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</li> </ul> </li> <li><strong>特点</strong>： <ul> <li>任何一个子进程（<code class="language-plaintext highlighter-rouge">init</code> 除外）在 <code class="language-plaintext highlighter-rouge">exit()</code> 之后，并非马上就消失，而是留下一个称为僵尸进程（Zombie）的数据结构，等待父进程处理。</li> <li>僵尸进程的进程号会一直被占用，系统所能使用的进程号是有限的，如果大量产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</li> </ul> </li> <li><strong>危害</strong>： <ul> <li>僵尸进程会占用系统的进程号资源，如果不及时处理，可能导致系统无法创建新的进程。</li> </ul> </li> <li><strong>解决办法</strong>： <ul> <li>子进程退出时向父进程发送 <code class="language-plaintext highlighter-rouge">SIGCHLD</code> 信号，父进程处理 <code class="language-plaintext highlighter-rouge">SIGCHLD</code> 信号，在处理函数中调用 <code class="language-plaintext highlighter-rouge">wait</code> 或 <code class="language-plaintext highlighter-rouge">waitpid</code>。</li> </ul> </li> </ul> </li> <li> <p><strong>僵尸进程的危害场景</strong></p> <ul> <li><strong>场景描述</strong>： <ul> <li>例如有个进程，它定期产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了。因此这个子进程的生命周期很短。</li> <li>但是，父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问。这样，系统运行一段时间之后，系统中就会存在很多的僵尸进程。如果用 <code class="language-plaintext highlighter-rouge">ps</code> 命令查看的话，就会看到很多状态为 <code class="language-plaintext highlighter-rouge">Z</code> 的进程。</li> </ul> </li> <li><strong>根本原因</strong>： <ul> <li>严格地来说，僵尸进程并不是问题的根源，罪魁祸首是产生出大量僵尸进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵尸进程时，答案就是把产生大量僵尸进程的那个元凶进程终止掉（通过 <code class="language-plaintext highlighter-rouge">kill</code> 发送 <code class="language-plaintext highlighter-rouge">SIGTERM</code> 或者 <code class="language-plaintext highlighter-rouge">SIGKILL</code> 信号）。</li> </ul> </li> <li><strong>处理方法</strong>： <ul> <li>终止元凶进程之后，它产生的僵尸进程就变成了孤儿进程，这些孤儿进程会被 <code class="language-plaintext highlighter-rouge">init</code> 进程接管，<code class="language-plaintext highlighter-rouge">init</code> 进程会 <code class="language-plaintext highlighter-rouge">wait()</code> 这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程就能被清理掉。</li> </ul> </li> </ul> </li> <li> <p><strong>总结</strong> 简单来说孤儿进程是死了父进程，但是父进程还是会将孤儿进程委托给收养院。因此孤儿能健康长大；而僵尸进程则是被父进程遗弃了，父进程不处理子进程了。因此这个时候子进程就不能健康长大，就有危险了。</p> </li> </ul> <h3 id="3-进程和线程篇">3. 进程和线程篇</h3> <ul> <li><strong><em>什么是进程和线程?</em></strong> <ul> <li><strong>进程</strong>:<strong>进程是程序在某个数据集合上的一次运行活动,也是操作系统进行资源分配和保护的基本单位</strong>.通俗来说,<strong>‘进程就是程序的一次执行过程’</strong>,程序是静态的,它作为系统中的一种资源是永远存在的.而进程是动态的,它是动态的产生,变化和消亡的,拥有其自己的生命周期</li> <li><strong>进程:</strong>线程是独立调度的基本单位.一个进程中可以有多个线程,它们共享进程资源</li> </ul> </li> <li><strong><em>如何保证线程安全?</em></strong></li> <li><strong><em>什么是协程?</em></strong></li> </ul> <h1 id="进程管理">进程管理</h1> <h2 id="进程和线程">进程和线程</h2> <ul> <li> <p><strong>进程的概念</strong>：<strong>进程是程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位</strong>。通俗来说，<strong>「进程就是程序的一次执行过程」</strong>，程序是静态的，它作为系统中的一种资源是永远存在的。而进程是动态的，它是动态的产生，变化和消亡的，拥有其自己的生命周期</p> </li> <li> <p>进程的组成</p> <ul> <li><strong>进程控制块 PCB</strong>。包含如下几个部分： <ul> <li>进程描述信息，如pid，gid</li> <li>进程控制和管理信息，如进程状态，优先级，未决信号集，信号屏蔽字</li> <li>资源分配清单，如页表，打开文件列表</li> <li>CPU 相关信息，如寄存器，状态寄存器，堆栈指针</li> </ul> </li> <li><strong>数据段</strong>。即进程运行过程中各种数据（比如程序中定义的变量）</li> <li><strong>程序段</strong>。就是程序的代码（指令序列）</li> </ul> </li> <li> <p>进程上下文切换</p> <ul> <li>首先，将进程 A 的运行环境信息存入 PCB，这个运行环境信息就是进程的上下文（Context）</li> <li>然后，将 PCB 移入相应的进程队列</li> <li>选择另一个进程 B 进行执行，并更新其 PCB 中的状态为运行态</li> <li>当进程 A 被恢复运行的时候，根据它的 PCB 恢复进程 A 所需的运行环境</li> </ul> </li> <li> <p>线程的概念：线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源</p> </li> <li> <p>线程的实现可以分为两类：</p> <ul> <li>用户级线程：不需要内核支持而在<strong>用户程序中实现的线程</strong>，其不依赖于操作系统核心，在语言层面利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。<strong>不需要用户态/内核态切换，速度快，操作系统内核不知道多线程的存在，因此一个线 程阻塞将使得整个进程（包括它的所有线程）阻塞</strong>。由于这里的<strong>处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少</strong></li> <li>内核线线程：又称为内核支持的线程或轻量级进程，所以线程切换时需要进入到内核态</li> </ul> </li> <li><strong>同一进程中线程资源共享情况</strong> <ul> <li>线程共享的资源包括：<strong>进程代码段、进程的公有数据</strong>(利用这些共享的数据，线程很容易的实现相互之间的通讯)、<strong>进程打开的文件描述符</strong>、<strong>信号的处理函数</strong>、<strong>进程的当前目录和进程用户ID与进程组ID</strong></li> <li>线程不共享的资源包括： <ul> <li><strong>线程ID</strong>：每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程</li> <li><strong>寄存器组的值</strong>：由于线程间是并发运行的，<strong>每个线程有自己不同的运行线索</strong>，当从一个线程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复</li> <li><strong>线程的堆栈</strong>：堆栈是保证线程独立运行所必须的。线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响</li> <li><strong>错误返回码(errno)</strong>：由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。所以，不同的线程应该拥有自己的错误返回码变量</li> <li><strong>线程的信号屏蔽码</strong>：由于<strong>每个线程所感兴趣的信号不同</strong>，所以<strong>线程的信号屏蔽码应该由线程自己管理</strong>。<strong>但所有的线程都共享同样的信号处理器</strong></li> <li><strong>线程的优先级</strong>：由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级</li> </ul> </li> </ul> </li> <li> <p>线程的优缺点</p> <ul> <li>优点： <ul> <li>一个进程中可以同时存在多个线程，这些线程共享该进程的资源。<strong>进程间的通信必须请求操作系统服务</strong>（因为 CPU 要切换到内核态），开销很大。而同进程下的线程间通信，无需操作系统干预，开销更小。不过，需要注意的是：<strong>从属于不同进程的线程间通信，也必须请求操作系统服务</strong></li> <li><strong>线程间的并发比进程的开销更小</strong>，<strong>系统并发性提升</strong>。同样，需要注意的是：<strong>从属于不同进程的线程间切换，它是会导致进程切换的，所以开销也大</strong></li> </ul> </li> <li>缺点： <ul> <li>当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃。举个例子，<strong>对于游戏的用户设计，就不应该使用多线程的方式，否则一个用户挂了，会影响其他同个进程的线程</strong></li> </ul> </li> </ul> </li> <li><strong>进程和线程的区别</strong> <ul> <li>拥有资源 <ul> <li>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源</li> </ul> </li> <li>调度 <ul> <li>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换</li> </ul> </li> <li>系统开销 <ul> <li>进程在创建、切换和销毁时开销比较大，而线程比较小。进程创建的时候需要分配系统资源，而销毁的的时候需要释放系统资源。<strong>进程切换需要分两步</strong>：<strong>切换页目录、刷新TLB以使用新的地址空间</strong>；<strong>切换内核栈和硬件上下文（寄存器）</strong>；<strong>而同一进程的线程间逻辑地址空间是一样的，线程切换时不需要切换页目录、刷新TLB，只需保存和设置少量寄存器内容、堆栈指针，开销较小</strong></li> <li><strong>进程在创建、销毁时开销比较大，而线程比较小</strong>。进程创建的时候需要分配<strong>虚拟地址空间、IO设备</strong>等系统资源，而<strong>销毁的的时候需要释放系统资源</strong>；线程只需要<strong>创建栈，栈指针，程序计数器，通用目的寄存器和条件码</strong>等，<strong>不需要创建独立的虚拟地址空间</strong>等系统资源</li> </ul> </li> <li>通信方面 <ul> <li><strong>线程间可以通过直接读写同一进程中的数据进行通信</strong>，但是进程通信需要借助 IPC</li> </ul> </li> </ul> </li> <li>高并发 <ul> <li>高并发指的是是一种系统运行过程中遇到的一种“<strong>短时间内遇到大量操作请求</strong>”的情况，主要发生在web系统集中大量访问或者socket端口集中性收到大量请求（例如：12306的抢票情况；天猫双十一活动）。该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。如果高并发处理不好，不仅仅降低了用户的体验度（请求响应时间过长），同时可能导致系统宕机，严重的甚至导致OOM异常，系统停止工作等</li> </ul> </li> </ul> <h2 id="同步互斥">同步互斥</h2> <h2 id="死锁">死锁</h2> <ul> <li> <p><strong>产生死锁的四大必要条件</strong></p> <ul> <li><strong>资源互斥/资源不共享</strong>：每个资源要么已经分配给了一个进程，要么是可用的，只有这两种状态，资源不可以被共享使用，所以所谓的互斥是指：资源不共享，如果被使用，只能被一个进程使用</li> <li><strong>占有和等待/请求并保持</strong>：已经得到资源的进程还能继续请求新的资源</li> <li><strong>资源不可剥夺</strong>：当一个资源分配给了一个进程后，其它需要该资源的进程不能强制性获得该资源，除非该资源的当前占有者显示地释放该资源</li> <li><strong>环路等待</strong>：死锁发生时，系统中一定有由两个或两个以上的进程组成的一条环路，环路上的每个进程都在等待下一个进程所占有的资源</li> </ul> </li> <li> <p>编程中避免死锁：</p> <ul> <li>避免多次锁定。<strong>尽量避免同一个线程对多个 Lock 进行锁定</strong>。例如上面的死锁程序，主线程要对 A、B 两个对象的 Lock 进行锁定，副线程也要对 A、B 两个对象的 Lock 进行锁定，这就埋下了导致死锁的隐患。</li> <li><strong>具有相同的加锁顺序</strong>。如果多个线程需要对多个 Lock 进行锁定，则应该保证它们以相同的顺序请求加锁。比如上面的死锁程序，主线程先对 A 对象的 Lock 加锁，再对 B 对象的 Lock 加锁；而副线程则先对 B 对象的 Lock 加锁，再对 A 对象的 Lock 加锁。这种加锁顺序很容易形成嵌套锁定，进而导致死锁。如果让主线程、副线程按照相同的顺序加锁，就可以避免这个问题。</li> <li><strong>使用定时锁</strong>。程序在调用 acquire() 方法加锁时可指定 timeout 参数，该参数指定超过 timeout 秒后会自动释放对 Lock 的锁定，这样就可以解开死锁了。</li> <li>死锁检测。死锁检测是一种依靠算法机制来实现的死锁预防机制，它主要是针对那些不可能实现按序加锁，也不能使用定时锁的场景的。</li> <li><strong>无锁编程</strong>：cas、原子变量、原子操作等</li> </ul> </li> <li> <p>预防死锁</p> <ul> <li>预防死锁的发生<strong>只需破坏死锁产生的四个必要条件之一</strong>即可</li> <li>下面的方法开销非常之大，目前没有一个操作系统可以实现 <ul> <li><strong>破坏互斥条件</strong>：如果允许系统资源都能共享使用，则系统不会进入死锁状态； <strong>缺点</strong>：有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，<strong>破坏互斥条件而预防死锁的方法不太可行</strong>，而且在有的场合应该保护这种互斥性</li> <li><strong>破坏请求并保持条件</strong>：釆用<strong>预先静态分配</strong>方法，即<strong>进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行</strong>。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。<strong>缺点</strong>：<strong>系统资源被严重浪费</strong>，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会<strong>导致“饥饿”</strong>现象，<strong>当由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行</strong></li> <li><strong>破坏不可剥夺条件</strong>：当一个已保持了某些不可剥夺资源的进程，<strong>请求新的资源而得不到满足时</strong>，它<strong>必须释放已经保持的所有资源，待以后需要时再重新申请</strong>。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。<strong>缺点</strong>：该策略<strong>实现起来比较复杂</strong>，<strong>释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量</strong>。这种方法<strong>常用于状态易于保存和恢复的资源</strong>，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源</li> <li><strong>破坏循环等待条件</strong>：为了<strong>破坏循环等待条件</strong>，可釆用<strong>顺序资源分配法</strong>。首先<strong>给系统中的资源编号</strong>，规定每个进程，必须<strong>按编号递增的顺序请求资源，同类资源一次申请完</strong>。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。<strong>缺点</strong>： 这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种<strong>按规定次序申请资源的方法，也必然会给用户的编程带来麻烦</strong></li> </ul> </li> <li>因此，目前使用的方法是避免死锁，而不是预防死锁</li> </ul> </li> <li> <p>避免死锁的算法</p> <ul> <li> <p>判断“<strong>系统安全状态</strong>”法：<strong>在进行系统资源分配之前，先计算此次资源分配的安全性</strong>。若此次分配不会导致系统进入不安全状态，则将资源分配给<strong>进程； 否则，让进程</strong>等待</p> <p><img src="imgs/os/safe_status.png" alt="safe_status"/></p> <ul> <li><strong>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数</strong>。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得<strong>所有进程都能成功运行</strong>，因此可以称图 a 所示的状态是安全的</li> <li>定义：<strong>如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的</strong></li> <li>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比</li> </ul> </li> <li> <p>银行家算法</p> <ul> <li>申请的贷款额度不能超过银行现有的资金总额</li> <li>分批次向银行提款，但是贷款额度不能超过一开始最大需求量的总额</li> <li>暂时不能满足客户申请的资金额度时，在有限时间内给予贷款</li> <li>客户要在规定的时间内还款</li> </ul> </li> <li> <p>单个资源银行家算法</p> <ul> <li> <p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，<strong>算法要做的是判断对请求的满足是否会进入不安全状态</strong>，如果是，就拒绝请求；否则予以分配</p> <p><img src="imgs/os/bank.png" alt="bank"/></p> <p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态</p> </li> </ul> </li> <li> <p>多个资源银行家算法</p> <p><img src="imgs/os/multi_bank.png" alt="multi_bank"/></p> <ul> <li>上图中有<strong>五个进程，四个资源</strong>。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：<strong>总资源、已分配资源以及可用资源</strong>，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0</li> <li>检查一个状态是否安全的算法如下： <ul> <li><strong>查找右边的矩阵是否存在一行小于等于向量 A</strong>。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的</li> <li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中</li> <li>重复以上两步，直到所有进程都标记为终止，则状态是安全的</li> </ul> </li> <li>如果一个状态不是安全的，需要拒绝进入这个状态</li> </ul> </li> </ul> </li> </ul> <h2 id="cas技术">CAS技术</h2> <ul> <li> <p>概念</p> <ul> <li>比较并交换(compare and swap, CAS)，是原子操作的一种。<strong>在多线程没有锁的状态下，可以保证多个线程对同一个值的更新</strong>。CAS可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性，产生的数据不一致问题。该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值</li> </ul> </li> <li> <p>原理</p> <ul> <li>执行函数：CAS(V，E，N) ，CAS有3个操作数，内存值<code class="language-plaintext highlighter-rouge">V</code>，旧的期望值 <code class="language-plaintext highlighter-rouge">E</code>，要修改的新值 <code class="language-plaintext highlighter-rouge">N</code>。当且仅当预期值<code class="language-plaintext highlighter-rouge">E</code>和内存值<code class="language-plaintext highlighter-rouge">V</code>相同时（比较），它就认为这个期间没有人来访问过这个贡献资源，所以就把<code class="language-plaintext highlighter-rouge">V</code>值改为新值<code class="language-plaintext highlighter-rouge">N</code>（交换）</li> <li><strong>如果多个线程同时使用CAS操作一个变量的时候，只有一个线程能够修改成功。其余的线程提供的期望值已经与共享变量的值不一样了，所以均会失败</strong></li> <li>由于CAS操作属于乐观派，它总是认为自己能够操作成功，所以操作失败的线程将会再次发起操作，而不是被OS挂起。所以说，即使CAS操作没有使用同步锁，其它线程也能够知道对共享变量的影响</li> <li>因为其它线程没有被挂起，并且将会再次发起修改尝试，所以无锁操作即CAS操作天生免疫死锁</li> <li><strong>CAS是系统原语，CAS操作是一条CPU的原子指令（cmpxchg），这个指令是给数据总线进行加锁，所以不会有线程安全问题</strong></li> </ul> </li> <li> <p>特点</p> <ul> <li>CAS结合<code class="language-plaintext highlighter-rouge">volatile</code>可以实现无锁并发，<strong>适用于线程数少，多核CPU场景下</strong>(线程数不要超过CPU核数)</li> <li>CAS是<strong>基于乐观锁实现</strong>（本身并无锁，区别于synchronized）</li> <li>CAS体现的是<strong>无锁并发、无阻塞并发</strong> <ul> <li>CAS的原子性 + <code class="language-plaintext highlighter-rouge">volatile</code>的可见性，不断的【比较与交换】保证线程安全</li> <li>没有用锁来保证线程安全，所以不会阻塞</li> <li>如果竞争激烈，会导致<strong>重试</strong>频繁发生，效率下降</li> </ul> </li> </ul> </li> <li> <p>自旋–比较和交换</p> <ul> <li><strong>自旋：</strong> 就是不停的判断比较，看能否将值交换</li> <li>多个线程在访问共享资源的时候，会产生同步问题，所以需要加锁来保证安全。但是，一旦加了锁，同一时刻只能有一个线程获取锁对象，效率自然变低了</li> <li> <p>不加锁的情况下来修改值，CAS是怎么自旋如下图</p> <p><img src="imgs/os/cas.png" alt="cas" style="zoom: 67%;"/></p> </li> <li> <p>现在<code class="language-plaintext highlighter-rouge">Data</code>中存放的是<code class="language-plaintext highlighter-rouge">num=0</code>，线程A将<code class="language-plaintext highlighter-rouge">num=0</code>拷贝到自己的工作内存中计算（做+1操作）<code class="language-plaintext highlighter-rouge">E=0</code>，计算的结果为<code class="language-plaintext highlighter-rouge">V=1</code></p> </li> <li> <p>由于是在多线程不加锁的场景下操作，所以可能此时<code class="language-plaintext highlighter-rouge">num</code>会被别的线程修改为其他值。此时需要再次读取<code class="language-plaintext highlighter-rouge">num</code>看其是否被修改，记再次读取的值为<code class="language-plaintext highlighter-rouge">N</code></p> </li> <li> <p>如果被修改，即<code class="language-plaintext highlighter-rouge">E != N</code>，说明被其他线程修改过。那么此时工作内存中的E已经和主存中的<code class="language-plaintext highlighter-rouge">num</code>不一致了，根据EMSI协议，保证安全需要重新读取<code class="language-plaintext highlighter-rouge">num</code>的值。直到<code class="language-plaintext highlighter-rouge">E = N</code>才能修改</p> </li> <li>如果没被修改，即<code class="language-plaintext highlighter-rouge">E = N</code>，说明没被其他线程修改过。那么将工作内存中的<code class="language-plaintext highlighter-rouge">E=0</code>改为<code class="language-plaintext highlighter-rouge">E=1</code>，同时写回主存。将<code class="language-plaintext highlighter-rouge">num=0</code>改为<code class="language-plaintext highlighter-rouge">num=1</code></li> </ul> </li> <li> <p>CAS三大问题</p> <ul> <li><strong>ABA问题</strong> <ul> <li>CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。这就是CAS的ABA问题</li> <li>常见的解决思路是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么<code class="language-plaintext highlighter-rouge">A-B-A</code> 就会变成<code class="language-plaintext highlighter-rouge">1A-2B-3A</code>，由于每个过程值都会有对应的版本，所以我们在修改过程中需要传入期望版本和当前的值，数据库的多版本并发控制也类似</li> <li>添加时间戳：添加世时间戳也可以解决。查询的时候把时间戳一起查出来，对的上才修改并且更新值的时候一起修改更新时间，这样也能保证，方法很多但是跟版本号都是异曲同工之妙</li> </ul> </li> <li>无限循环问题（自旋） <ul> <li>如果CAS不成功，则会原地自旋，如果长时间自旋会<strong>给CPU带来非常大且没必要的开销</strong></li> <li>可以使用java8中的LongAdder，分段CAS和自动分段迁移</li> <li>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率</li> </ul> </li> <li><strong>只能保证一个共享变量的原子操作</strong> <ul> <li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是<strong>把多个共享变量合并成一个共享变量来操作</strong>。比如有两个共享变量 i=2，j=a，合并一下 ij=2a，然后用CAS来操作</li> <li>可以用AtomicReference (java)，这个是封装自定义对象的，多个变量可以放一个自定义对象里，然后他会检查这个对象的引用是不是同一个。如果多个线程同时对一个对象变量的引用进行赋值，用AtomicReference的CAS操作可以解决并发冲突问题</li> </ul> </li> </ul> </li> </ul> <h2 id="ipc"><a href="https://mp.weixin.qq.com/s/b6HLr348-v7ibntuWs1yRA">IPC</a></h2> <ul> <li>进程间通信(IPC)，<a href="https://www.cnblogs.com/zgq0/p/8780893.html">详见</a></li> </ul> <h3 id="管道">管道</h3> <ul> <li> <p>通常指无名管道，是 UNIX 系统IPC最古老的形式</p> </li> <li>它是<strong>半双工</strong>的（即数据只能在一个方向上流动），具有固定的读端和写端</li> <li>它只能用于<strong>具有亲缘关系的进程之间的通信</strong>（也是父子进程或者兄弟进程之间）</li> <li>它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并<strong>不属于其他任何文件系统</strong>，并且<strong>只存在于内存</strong>中</li> <li>原型</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">unistd</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="mi">2</span> <span class="kt">int</span> <span class="nf">pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>    <span class="c1">// 返回值：若成功返回0，失败返回-1</span>
</code></pre></div></div> <h3 id="fifo">FIFO</h3> <ul> <li> <p>也称为命名管道，它是一种文件类型</p> </li> <li>FIFO可以在无关的进程之间交换数据，与无名管道不同</li> <li>FIFO有路径名与之相关联，它以一种<strong>特殊设备文件形式存在于文件系统</strong>中</li> <li>FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。<strong>在数据读出时，FIFO管道中同时清除数据，并且“先进先出”</strong></li> <li>原型</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">stat</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="mi">2</span> <span class="c1">// 返回值：成功返回0，出错返回-1</span>
<span class="mi">3</span> <span class="kt">int</span> <span class="nf">mkfifo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>
</code></pre></div></div> <ul> <li> <p>其中的<code class="language-plaintext highlighter-rouge">mode</code>参数与<code class="language-plaintext highlighter-rouge">open</code>函数中的 <code class="language-plaintext highlighter-rouge">mode </code>相同。一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它</p> <ul> <li>当 open 一个FIFO时，是否设置非阻塞标志（<code class="language-plaintext highlighter-rouge">O_NONBLOCK</code>）的区别： <ul> <li>若没有指定<code class="language-plaintext highlighter-rouge">O_NONBLOCK</code>（默认），只读 open 要阻塞到某个其他进程为写而打开此 FIFO。类似的，只写 <code class="language-plaintext highlighter-rouge">open</code> 要阻塞到某个其他进程为读而打开它</li> <li>若指定了<code class="language-plaintext highlighter-rouge">O_NONBLOCK</code>，则只读<code class="language-plaintext highlighter-rouge">open</code>立即返回。而只写<code class="language-plaintext highlighter-rouge">open</code>将出错返回 -1 如果没有进程已经为读而打开该 FIFO，其<code class="language-plaintext highlighter-rouge">errno</code>置<code class="language-plaintext highlighter-rouge">ENXIO</code>。</li> </ul> </li> </ul> </li> </ul> <h3 id="消息队列">消息队列</h3> <ul> <li> <p><strong>是消息的链接表，存放在内核中</strong>。一个消息队列由一个标识符（即队列ID）来标识</p> </li> <li> <p>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级</p> <ul> <li>消息队列独立于发送与接收进程。<strong>进程终止时，消息队列及其内容并不会被删除</strong></li> <li><strong>消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取,也可以按消息的类型读取</strong></li> <li>原型</li> </ul> </li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/msg.h&gt;</span><span class="cp">
</span><span class="c1">// 创建或打开消息队列：成功返回队列ID，失败返回-1</span>
<span class="kt">int</span> <span class="nf">msgget</span><span class="p">(</span><span class="n">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fslag</span><span class="p">);</span>
<span class="c1">// 添加消息：成功返回0，失败返回-1</span>
<span class="kt">int</span> <span class="nf">msgsnd</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="c1">// 读取消息：成功返回消息数据的长度，失败返回-1</span>
<span class="kt">int</span> <span class="nf">msgrcv</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">long</span> <span class="n">type</span><span class="p">,</span><span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="c1">// 控制消息队列：成功返回0，失败返回-1</span>
<span class="kt">int</span> <span class="nf">msgctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msqid_ds</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
</code></pre></div></div> <ul> <li> <p>在以下两种情况下，<code class="language-plaintext highlighter-rouge">msgget</code>将创建一个新的消息队列：</p> <ul> <li>如果没有与键值key相对应的消息队列，并且flag中包含了<code class="language-plaintext highlighter-rouge">IPC_CREAT</code>标志位。</li> <li> <p>key参数为<code class="language-plaintext highlighter-rouge">IPC_PRIVATE</code>。</p> </li> <li>函数<code class="language-plaintext highlighter-rouge">msgrcv</code>在读取消息队列时，<code class="language-plaintext highlighter-rouge">type</code>参数有下面几种情况： <ul> <li><code class="language-plaintext highlighter-rouge">type == 0</code>，返回队列中的第一个消息</li> <li><code class="language-plaintext highlighter-rouge">type &gt; 0</code>，返回队列中消息类型为 <code class="language-plaintext highlighter-rouge">type</code> 的第一个消息</li> <li><code class="language-plaintext highlighter-rouge">type &lt; 0</code>，返回队列中消息类型值小于或等于<code class="language-plaintext highlighter-rouge">type</code>绝对值的消息，如果有多个，则取类型值最小的消息</li> </ul> </li> <li>可以看出，type值非 0 时用于以非先进先出次序读消息。也可以把<code class="language-plaintext highlighter-rouge"> type</code> 看做优先级的权值</li> </ul> </li> </ul> <h3 id="信号signal"><a href="https://blog.csdn.net/h___q/article/details/84245317">信号(signal)</a></h3> <ul> <li> <p>信号是一种比较复杂的通信方式，<strong>用于通知接收进程某个事件已经发生</strong></p> </li> <li> <p>程序不可捕获、阻塞或忽略的信号有：<strong>SIGKILL(9)，SIGSTOP(19)</strong></p> <ul> <li>它们向超级用户提供一种使进程终止或停止的可靠方法</li> <li>如果忽略某些由硬件异常产生的信号（例如非法存储访问或除以0），则进程的行为是未定义的</li> </ul> </li> <li> <p>常见信号表</p> <p><img src="imgs/os/signal_tab.png" alt="signal_tab"/></p> </li> <li> <p>信号产生方式</p> <ul> <li> <p><a href="https://www.jianshu.com/p/e4ce1f6488af">信号可以通过六个函数产生</a>:</p> <ul> <li><strong>kill函数</strong></li> <li><strong>raise函数</strong></li> <li><strong>sigqueue函数</strong></li> <li><strong>alarm函数</strong></li> <li><strong>setitimer函数</strong></li> <li><strong>abort函数</strong></li> </ul> </li> <li> <p>键盘产生</p> <ul> <li>如ctrl+c，ctrl+z，ctrl+/等</li> </ul> </li> <li> <p>程序异常</p> <ul> <li>除0错误。除0错误会导致硬件错误</li> <li>core dumped（核心转储）：<strong>当进程异常退出时，操作系统会将该进程发生异常退出之前在内存中的数据存储至硬盘上</strong></li> <li><strong>2、9号信号不会产生core文件</strong></li> </ul> </li> <li> <p>使用kill命令</p> <ul> <li><strong>kill 在无指定时默认发送2号信号，可将指定程序终止</strong>。若仍无法终止该程序，可使用 SIGKILL(9) 信息尝试强制删除程序。程序或工作的编号可利用 ps 指令或 jobs 指令查看</li> </ul> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">kill</span> <span class="o">[</span><span class="nt">-s</span> &lt;信息名称或编号&gt;][程序]　或　
<span class="nb">kill</span> <span class="o">[</span><span class="nt">-l</span> &lt;信息编号&gt;]

<span class="nt">-l</span> &lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则 <span class="nt">-l</span> 参数会列出全部的信息名称
<span class="nt">-s</span> &lt;信息名称或编号&gt; 　指定要送出的信息
<span class="o">[</span>程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号

最常用的信号是：
1 <span class="o">(</span>HUP<span class="o">)</span>：重新加载进程
9 <span class="o">(</span>KILL<span class="o">)</span>：杀死一个进程
15 <span class="o">(</span>TERM<span class="o">)</span>：正常停止一个进程
</code></pre></div> </div> </li> <li> <p>通过系统调用接口给特定进程发送信号</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">kill</span><span class="p">(</span><span class="n">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>
<span class="c1">//向特定进程发送特定信号;成功返回0;失败返回-1</span>

<span class="kt">int</span> <span class="nf">raise</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>
<span class="c1">//向当前进程发送特定信号;成功返回0;失败返回-1</span>

<span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="kt">void</span> <span class="nf">abort</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="c1">//使当前进程收到信号而异常终止；就像exit()函数一样，abort()函数总是会成功的，所以没有返回值</span>
</code></pre></div> </div> </li> <li> <p>由软件条件发送信号</p> <ul> <li>SIGPIPE：SIGPIPE是一种由软件条件产生的信号，<strong>当一个管道的读端被关闭时，这时候操作系统就会检测到该管道中写入的数据不会在有人来管道内读文件了，操作系统会认为该管道的存在会造成内存资源的极大浪费，则操作系统就会向写端对应的目标进程发送SIGPIPE信号</strong></li> <li> <p>定时器</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">alarm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">seconds</span><span class="p">);</span>
<span class="c1">//调用alarm函数可以对当前进程设置一个闹钟，也就是告诉操作系统在seconds秒之后对当前进程发送SIGALRM信号，该信号的默认处理动作是终止当前进程</span>
</code></pre></div> </div> </li> </ul> </li> </ul> </li> <li> <p><strong>信号集操作函数</strong></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span>
<span class="c1">//注意：在使用sigset_t类型的变量前，一定要调用sigemptyset或sigfillset进行初始化，使信号集处于某种确定的状态，初始化之后就可以调用sigaddset或sigdelset在信号集中添加或删除某种有效信号</span>

<span class="kt">int</span> <span class="nf">sigemptyset</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="c1">//初始化set所指向的信号集，使其中所有信号对应的比特位清零，表示该信号集不包含任何信号</span>

<span class="kt">int</span> <span class="nf">sigfillset</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="c1">//初始化set所指向的信号集，将其中所有信号对应的比特位置1，表示该信号集的有效信号包括系统支持的所有信号</span>

<span class="kt">int</span> <span class="nf">sigaddset</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>
<span class="c1">//表示将set所指向的信号集中的signo信号置1</span>

<span class="kt">int</span> <span class="nf">sigdelset</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>
<span class="c1">//表示将set所指向的信号集中的signo信号清零</span>

<span class="kt">int</span> <span class="nf">sigismember</span><span class="p">(</span><span class="k">const</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">);</span>
<span class="c1">//用来判断set所指向的信号集的有效信号中是否包含signo信号，包含返回1，不包含返回0，出错返回-1</span>

<span class="kt">int</span> <span class="nf">sigpending</span><span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">);</span>
<span class="c1">// 获取进程的pending信号集</span>
<span class="c1">// 成功返回0；失败返回-1</span>
</code></pre></div> </div> </li> <li> <p><strong>设置/修改进程的信号屏蔽字（block表）</strong></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">sigprocmask</span><span class="p">(</span><span class="kt">int</span> <span class="n">how</span><span class="p">,</span> <span class="k">const</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="n">sigset_t</span> <span class="o">*</span><span class="n">oset</span><span class="p">);</span>

<span class="cm">/*
  int how：
      SIG_BLOCK：set包含了用户希望添加到当前信号屏蔽字的信号，即就是在老的信号屏蔽字中添加上新的信号。相当于：mask=mask|set
      SIG_UNBLOCK：set包含了用户希望从当前信号屏蔽字中解除阻塞的信号，即就是在老的信号屏蔽字中取消set表中的信号。相当于：mask=mask&amp;~set
      SIG_SETMASK：设置当前进程的信号屏蔽字为set所指向的信号集。相当于：mask=set
  const sigset_t *set：
      将要设置为进程block表的信号集
  sigset_t *oset：
      用来保存进程旧的block表
      若无需保存进程旧的block表，传递空指针即可
*/</span>
</code></pre></div> </div> </li> <li> <p><strong>自定义信号处理方式</strong></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">sigaction</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sa_handler</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>	<span class="c1">//指向信号处理对应的函数</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sa_sigaction</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="n">siginfo_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
    <span class="n">sigset_t</span> <span class="n">sa_mask</span><span class="p">;</span> <span class="c1">//当在处理所收到信号时，想要附带屏蔽的其他普通信号，当不需要屏蔽其他信号时，需要使用sigemptyset初始化sa_mask</span>
    <span class="kt">int</span> <span class="n">sa_flags</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">sa_restorer</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">sigaction</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">sigaction</span> <span class="o">*</span><span class="n">act</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">sigaction</span> <span class="o">*</span><span class="n">oact</span><span class="p">);</span>
<span class="cm">/*
int signo：
  指定的信号编号
const struct sigaction *act：
  若该act指针非空，则根据act指针来修改进程收到signo信号的处理动作
struct sigaction *oact：
  若oact指针非空，则使用oact来保存信号旧的处理动作
*/</span>
</code></pre></div> </div> </li> <li> <p><strong>信号处理过程</strong></p> <p><img src="imgs/os/sig_cap.png" alt="sig_cap" style="zoom:80%;"/></p> </li> <li> <p>信号接收</p> <ul> <li><strong>接收信号的任务是由内核代理的，但内核接收到信号后，会将其放到对应进程的PCB的未决信号集中，同时向进程发送一个中断，使其陷入内核态</strong></li> </ul> </li> <li><strong>此时信号只是在未决信号集中，对进程来说是不知道信号到来的</strong></li> <li> <p>信号的检测</p> <ul> <li>进程陷入内核后，<strong>有两种场景会对信号集进行检测</strong>： <ul> <li>进程<strong>从内核态返回到用户态前进行信号检测</strong></li> <li>进程在内核态中，<strong>从睡眠状态被唤醒的时候进行信号检测</strong></li> </ul> </li> <li>当发现有新信号后，便会进入下一步，信号处理</li> </ul> </li> <li> <p>信号的处理</p> <ul> <li>如果用户<strong>未注册信号处理函数</strong>，则内核按照信号的<strong>默认处理方式</strong>处理</li> <li><strong>如果用户注册了信号处理函数，则信号处理函数是运行在用户态的</strong>，调用处理函数前，<strong>内核会将当前内核栈的内容备份拷贝到用户栈上，并且修改指令寄存器(eip)将其指向信号处理函数</strong></li> <li><strong>接下来进程返回到用户态中，执行相应的信号处理函数</strong></li> <li><strong>信号处理函数执行完成后，还需要返回内核态，检查是否还有其他信号未处理</strong></li> <li><strong>如果所有信号都处理完成了，就会将内核栈回复(从用户栈的备份拷贝回来)，同时恢复指令寄存器(eip)将其指向中断前的运行位置，最后回到用户态继续执行进程</strong></li> <li>如果同时有多个信号到达，处理流程为上面1，2，3，4步骤间重复进行，直到所有信号处理完毕</li> </ul> </li> <li> <p><strong>处理信号的时机</strong></p> <ul> <li>进程收到一个信号时，<strong>并不会立即就去处理这个信号，而是先将收到的信号保存下来，并在合适的时候对信号进行处理</strong>，<strong>操作系统会在进程进入了内核态并从内核态返回用户态时，检测进程中可以进行处理的信号，并进行处理</strong></li> </ul> </li> <li> <p>用户写好的代码会在什么情况下进入内核态呢？</p> <ul> <li>调用系统调用接口</li> <li>异常</li> <li>中断</li> </ul> </li> </ul> <h3 id="信号量">信号量</h3> <ul> <li> <p>与已经介绍过的 IPC 结构不同，它是<strong>一个计数器</strong>。信号量<strong>用于实现进程间的互斥与同步，而不是用于存储进程间通信数据</strong></p> </li> <li> <p>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存</p> <ul> <li>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作</li> <li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数</li> <li>支持信号量组</li> <li> <p>原型</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/sem.h&gt;</span><span class="cp">
</span><span class="c1">// 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1</span>
<span class="kt">int</span> <span class="nf">semget</span><span class="p">(</span><span class="n">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_sems</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sem_flags</span><span class="p">);</span>
<span class="c1">// 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1</span>
<span class="kt">int</span> <span class="nf">semop</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">semoparray</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">numops</span><span class="p">);</span>
<span class="c1">// 控制信号量的相关信息</span>
<span class="kt">int</span> <span class="nf">semctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sem_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...);</span>
</code></pre></div> </div> </li> </ul> </li> <li> <p>当<code class="language-plaintext highlighter-rouge">semget</code>创建新的信号量集合时，必须指定集合中信号量的个数（即<code class="language-plaintext highlighter-rouge">num_sems</code>），通常为1； 如果是引用一个现有的集合，则将<code class="language-plaintext highlighter-rouge">num_sems</code>指定为 0 。在<code class="language-plaintext highlighter-rouge">semop</code>函数中，<code class="language-plaintext highlighter-rouge">sembuf</code>结构的定义如下：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct sembuf
{
    short sem_num; // 信号量组中对应的序号，0～sem_nums-1
    short sem_op;  // 信号量值在一次操作中的改变量
    short sem_flg; // IPC_NOWAIT, SEM_UNDO
}
</code></pre></div> </div> </li> <li> <p>其中<code class="language-plaintext highlighter-rouge"> sem_op</code> 是一次操作中的信号量的改变量：</p> <ul> <li> <p>若<code class="language-plaintext highlighter-rouge">sem_op &gt; 0</code>，表示进程释放相应的资源数，将 sem_op 的值加到信号量的值上。如果有进程正在休眠等待此信号量，则换行它们</p> <ul> <li>若<code class="language-plaintext highlighter-rouge">sem_op &lt; 0</code>，请求 <code class="language-plaintext highlighter-rouge">sem_op </code>的绝对值的资源 <ul> <li>如果相应的资源数可以满足请求，则将该信号量的值减去sem_op的绝对值，函数成功返回。</li> <li>当相应的资源数不能满足请求时，这个操作与<code class="language-plaintext highlighter-rouge">sem_flg</code>有关 <ul> <li><code class="language-plaintext highlighter-rouge">sem_flg </code>指定<code class="language-plaintext highlighter-rouge">IPC_NOWAIT</code>，则semop函数出错返回<code class="language-plaintext highlighter-rouge">EAGAIN</code></li> <li><code class="language-plaintext highlighter-rouge">sem_flg</code> 没有指定<code class="language-plaintext highlighter-rouge">IPC_NOWAIT</code>，则将该信号量的<code class="language-plaintext highlighter-rouge">semncnt</code>值加1，然后进程挂起直到下述情况发生： <ol> <li>当相应的资源数可以满足请求，此信号量的<code class="language-plaintext highlighter-rouge">semncnt</code>值减1，该信号量的值减去sem_op的绝对值。成功返回；</li> <li>此信号量被删除，函数<code class="language-plaintext highlighter-rouge">smeop</code>出错返回<code class="language-plaintext highlighter-rouge">EIDRM</code>；</li> <li>进程捕捉到信号，并从信号处理函数返回，此情况下将此信号量的<code class="language-plaintext highlighter-rouge">semncnt</code>值减1，函数<code class="language-plaintext highlighter-rouge">semop</code>出错返回<code class="language-plaintext highlighter-rouge">EINTR</code></li> </ol> </li> </ul> </li> </ul> </li> <li>若<code class="language-plaintext highlighter-rouge">sem_op == 0</code>，进程阻塞直到信号量的相应值为0： <ul> <li>当信号量已经为0，函数立即返回。</li> <li>如果信号量的值不为0，则依据<code class="language-plaintext highlighter-rouge">sem_flg</code>决定函数动作： <ul> <li><code class="language-plaintext highlighter-rouge">sem_flg</code>指定<code class="language-plaintext highlighter-rouge">IPC_NOWAIT</code>，则出错返回<code class="language-plaintext highlighter-rouge">EAGAIN</code>。</li> <li><code class="language-plaintext highlighter-rouge">sem_flg</code>没有指定<code class="language-plaintext highlighter-rouge">IPC_NOWAIT</code>，则将该信号量的<code class="language-plaintext highlighter-rouge">semncnt</code>值加1，然后进程挂起直到下述情况发生： <ol> <li>信号量值为0，将信号量的<code class="language-plaintext highlighter-rouge">semzcnt</code>的值减1，函数<code class="language-plaintext highlighter-rouge">semop</code>成功返回；</li> <li>此信号量被删除，函数<code class="language-plaintext highlighter-rouge">smeop</code>出错返回<code class="language-plaintext highlighter-rouge">EIDRM</code>；</li> <li>进程捕捉到信号，并从信号处理函数返回，在此情况将此信号量的<code class="language-plaintext highlighter-rouge">semncnt</code>值减1，函数<code class="language-plaintext highlighter-rouge">semop</code>出错返回<code class="language-plaintext highlighter-rouge">EINTR</code></li> </ol> </li> </ul> </li> </ul> </li> </ul> </li> <li> <p>在<code class="language-plaintext highlighter-rouge">semctl</code>函数中的命令有多种，这里就说两个常用的：</p> <ul> <li><code class="language-plaintext highlighter-rouge">SETVAL</code>：用于初始化信号量为一个已知的值。所需要的值作为联合<code class="language-plaintext highlighter-rouge">semun</code>的<code class="language-plaintext highlighter-rouge">val</code>成员来传递。在信号量第一次使用之前需要设置信号量。</li> <li><code class="language-plaintext highlighter-rouge">IPC_RMID</code>：删除一个信号量集合。如果不删除信号量，它将继续在系统中存在，即使程序已经退出，它可能在你下次运行此程序时引发问题，而且信号量是一种有限的资源。</li> </ul> </li> </ul> </li> </ul> <h3 id="共享内存">共享内存</h3> <ul> <li> <p>指两个或多个进程共享一个给定的存储区</p> </li> <li> <p><strong>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取</strong></p> </li> <li> <p><strong>因为多个进程可以同时操作，所以需要进行同步</strong></p> </li> <li> <p><strong>信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</strong></p> </li> <li> <p><strong>共享内存实现原理</strong>：共享内存是通过<strong>把同一块内存分别映射到不同的进程空间</strong>中实现进程间通信。而共享内存本身不带任何互斥与同步机制，但当多个进程同时对同一内存进行读写操作时会破坏该内存的内容，所以，在实际中，同步与互斥机制需要用户来完成</p> </li> <li> <p>在<strong>/proc/sys/kernel/</strong>目录下，记录着共享内存的一些限制，如一个共享内存区的<strong>最大字节数shmmax</strong>，系统范围内最大共享内存区标识符数shmmni等，可以手工对其调整，但不推荐这样做</p> </li> <li> <p>共享内存使用</p> <ul> <li>进程必须首先分配它</li> <li>随后需要访问这个共享内存块的每一个进程都必须将这个共享内存绑定到自己的地址空间中</li> <li>当完成通信之后，所有进程都将脱离共享内存，并且由一个进程释放该共享内存块</li> </ul> </li> <li> <p>原型</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/shm.h&gt;</span><span class="cp">
</span><span class="c1">// 创建或获取一个共享内存：成功返回共享内存ID，失败返回-1</span>
<span class="kt">int</span> <span class="nf">shmget</span><span class="p">(</span><span class="n">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="c1">// 连接共享内存到当前进程的地址空间：成功返回指向共享内存的指针，失败返回-1</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">shmat</span><span class="p">(</span><span class="kt">int</span> <span class="n">shm_id</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="c1">// 断开与共享内存的连接：成功返回0，失败返回-1</span>
<span class="kt">int</span> <span class="nf">shmdt</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="c1">// 控制共享内存的相关信息：成功返回0，失败返回-1</span>
<span class="kt">int</span> <span class="nf">shmctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">shm_id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">shmid_ds</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p>当用<code class="language-plaintext highlighter-rouge">shmget</code>函数创建一段共享内存时，必须指定其 size；而如果引用一个已存在的共享内存，则将 size 指定为0</p> <ul> <li><strong>当一段共享内存被创建以后，它并不能被任何进程访问。必须使用<code class="language-plaintext highlighter-rouge">shmat</code>函数连接该共享内存到当前进程的地址空间，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问</strong></li> <li><code class="language-plaintext highlighter-rouge">shmdt</code>函数是用来断开<code class="language-plaintext highlighter-rouge">shmat</code>建立的连接的。注意，<strong>这并不是从系统中删除该共享内存，只是当前进程不能再访问该共享内存而已</strong></li> <li><code class="language-plaintext highlighter-rouge">shmctl</code>函数可以对共享内存执行多种操作，根据参数 cmd 执行相应的操作。常用的是<code class="language-plaintext highlighter-rouge">IPC_RMID</code>（从系统中删除该共享内存）</li> </ul> </li> <li> <p><strong>mmap实现共享内存</strong></p> <ul> <li>mmap系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，<strong>当然mmap()实现共享内存也是其主要应用之一</strong></li> <li><strong>mmap系统调用使得进程之间通过映射同一个普通文件实现共享内存</strong>。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。</li> <li>mmap并不分配空间，只是<strong>将文件映射到调用进程的地址空间里</strong>，然后你就可以用memcpy等操作写文件，而不用write()了。写完后用msync()同步一下，你所写的内容就保存到文件里了。 <strong>不过这种方式没办法增加文件的长度</strong>，<strong>因为要映射的长度在调用mmap()的时候就决定了</strong></li> <li>简单说就是把一个文件的内容在内存里面做一个映像，内存比磁盘快些</li> </ul> </li> </ul> <h4 id="24-forkvforkclone">2.4 fork，vfork，clone</h4> <p>守护进程怎么创建</p> <h3 id="line">line—–</h3> <h2 id="cc中多进程编程">c/c++中多进程编程</h2> <h3 id="1-基本概念">1. 基本概念</h3> <ul> <li> <p><strong><em>多进程如何实现？</em></strong></p> <ul> <li> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]){</span>
    <span class="c1">//fork函数使用</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"before fork</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">pid_t</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"after fork</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"error</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"fork success,this is son process</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">){</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"this is son process,i=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"fork success,this is father process,son process id is %d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">pid</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">){</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"this is father process,i=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 断点运行结果，因此才是子进程运行完，再人为控制跑完父进程。</span>
before fork
after fork
fork success,this is son process
this is son process,i<span class="o">=</span>1
this is son process,i<span class="o">=</span>2
this is son process,i<span class="o">=</span>3
this is son process,i<span class="o">=</span>4
this is son process,i<span class="o">=</span>5
after fork
fork success,this is father process,son process <span class="nb">id </span>is 9983
this is father process,i<span class="o">=</span>2
this is father process,i<span class="o">=</span>4
this is father process,i<span class="o">=</span>6
</code></pre></div> </div> </li> <li> <p>只需要注意注意一次before fork，这说明子进程是从fork()之后开始的，所以子进程不会因为这样有孙进程。但是有两个fork()的话，还是会有孙进程的。理性告诉我要避免多个fork()的代码，因为子进程再fork()返回的也是0，所以父进程判断变得很难控制。</p> </li> <li> <p>所以说fork()函数是一次调用，两次返回，对于父进程返回的是子进程的pid，对于子进程返回的是0。</p> </li> <li>而fork()之前的变量，进程是复制拷贝了一份的。</li> </ul> </li> </ul> <h3 id="2-补充">2. 补充</h3> <ul> <li> <p><strong><em>除了fork()之外还有其他多进程编程api吗？</em></strong></p> <p>​ 除了fork()之外，还有wait()用于阻塞父进程直到子进程完成，还有exec()、spawn()等等，说实话exec()和spawn()也是很少见，资料很少，了解不多，待我有进一步了解再考虑更新。</p> </li> <li> <p><strong><em>小测试</em></strong></p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="err">　</span><span class="p">){</span>
     <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
     <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
        <span class="k">if</span><span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
            <span class="c1">//do something</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">//do something</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// do somthing,sleep</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 总共有多少个进程？ 答案是32个，读者自行思考</span>
</code></pre></div> </div> </li> </ul> <hr/> <hr/> <p>title: “多进程管理(转载)” layout: post author: “Marco” header-style: text hidden: true tags:</p> <ul> <li>计算机系统</li> <li>多线程</li> </ul> <hr/> <blockquote> <p><a href="https://github.com/CyC2018/CS-Notes">转载自</a></p> </blockquote> <ul> <li><a href="#进程管理">进程管理</a> <ul> <li><a href="#进程和线程">进程和线程</a></li> <li><a href="#协程">协程</a></li> <li><a href="#同步互斥">同步互斥</a></li> <li><a href="#死锁">死锁</a></li> <li><a href="#cas技术">CAS技术</a></li> <li><a href="#ipc">IPC</a> <ul> <li><a href="#管道">管道</a></li> <li><a href="#fifo">FIFO</a></li> <li><a href="#消息队列">消息队列</a></li> <li><a href="#信号signal">信号(signal)</a></li> <li><a href="#信号量">信号量</a></li> <li><a href="#共享内存">共享内存</a> <ul> <li><a href="#24-forkvforkclone">2.4 fork，vfork，clone</a></li> </ul> </li> <li><a href="#line-----">line—–</a></li> </ul> </li> <li><a href="#cc中多进程编程">c/c++中多进程编程</a> <ul> <li><a href="#1-基本概念">1. 基本概念</a></li> <li><a href="#2-补充">2. 补充</a></li> </ul> </li> </ul> </li> <li><a href="#进程与线程">进程与线程</a> <ul> <li><a href="#1-进程">1. 进程</a></li> <li><a href="#2-线程">2. 线程</a></li> <li><a href="#3-区别">3. 区别</a></li> </ul> </li> <li><a href="#进程状态的切换">进程状态的切换</a></li> <li><a href="#进程调度算法">进程调度算法</a> <ul> <li><a href="#1-批处理系统">1. 批处理系统</a></li> <li><a href="#2-交互式系统">2. 交互式系统</a></li> <li><a href="#3-实时系统">3. 实时系统</a></li> </ul> </li> <li><a href="#进程同步">进程同步</a> <ul> <li><a href="#1-临界区">1. 临界区</a></li> <li><a href="#2-同步与互斥">2. 同步与互斥</a></li> <li><a href="#3-信号量">3. 信号量</a></li> <li><a href="#4-管程">4. 管程</a></li> </ul> </li> <li><a href="#经典同步问题">经典同步问题</a> <ul> <li><a href="#1-哲学家进餐问题">1. 哲学家进餐问题</a></li> <li><a href="#2-读者-写者问题">2. 读者-写者问题</a></li> </ul> </li> <li><a href="#进程通信">进程通信</a> <ul> <li><a href="#1-管道">1. 管道</a></li> <li><a href="#2-fifo">2. FIFO</a></li> <li><a href="#3-消息队列">3. 消息队列</a></li> <li><a href="#4-信号量">4. 信号量</a></li> <li><a href="#5-共享存储">5. 共享存储</a></li> <li><a href="#6-信号">6. 信号</a></li> <li><a href="#7-套接字">7. 套接字</a> - <a href="#3-进程控制块pcb">3. 进程控制块PCB</a> </li> </ul> </li> </ul> <h1 id="进程状态的切换">进程状态的切换</h1> <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" width="500"/> </div> <p><br/></p> <ul> <li>就绪状态（ready）：等待被调度</li> <li>运行状态（running）</li> <li>阻塞状态（waiting）：等待资源</li> </ul> <p>应该注意以下内容：</p> <ul> <li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li> <li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li> </ul> <h1 id="进程调度算法">进程调度算法</h1> <p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p> <h2 id="1-批处理系统">1. 批处理系统</h2> <p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p> <p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p> <p>非抢占式的调度算法，按照请求的顺序进行调度。</p> <p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p> <p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p> <p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p> <p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p> <p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p> <p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p> <h2 id="2-交互式系统">2. 交互式系统</h2> <p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p> <p><strong>2.1 时间片轮转</strong></p> <p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p> <p>时间片轮转算法的效率和时间片的大小有很大关系：</p> <ul> <li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li> <li>而如果时间片过长，那么实时性就不能得到保证。</li> </ul> <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8c662999-c16c-481c-9f40-1fdba5bc9167.png"/> </div> <p><br/></p> <p><strong>2.2 优先级调度</strong></p> <p>为每个进程分配一个优先级，按优先级进行调度。</p> <p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p> <p><strong>2.3 多级反馈队列</strong></p> <p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p> <p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p> <p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p> <p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p> <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png"/> </div> <p><br/></p> <h2 id="3-实时系统">3. 实时系统</h2> <p>实时系统要求一个请求在一个确定时间内得到响应。</p> <p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p> <h1 id="进程同步">进程同步</h1> <h2 id="1-临界区">1. 临界区</h2> <p>对临界资源进行访问的那段代码称为临界区。</p> <p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p> <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// entry section // critical section; // exit section
</code></pre></div></div> <h2 id="2-同步与互斥">2. 同步与互斥</h2> <ul> <li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li> <li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li> </ul> <h2 id="3-信号量">3. 信号量</h2> <p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p> <ul> <li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li> <li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li> </ul> <p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p> <p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">int</span> <span class="n">semaphore</span><span class="p">;</span>
<span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">P1</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="c1">// 临界区</span>
    <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">P2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="c1">// 临界区</span>
    <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <font size="3"> **使用信号量实现生产者-消费者问题** </font> <p>&lt;/br&gt;</p> <p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p> <p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p> <p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p> <p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define N 100
</span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">semaphore</span><span class="p">;</span>
<span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">semaphore</span> <span class="n">empty</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
<span class="n">semaphore</span> <span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">produce_item</span><span class="p">();</span>
        <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>
        <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">insert_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full</span><span class="p">);</span>
        <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">remove_item</span><span class="p">();</span>
        <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">empty</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="4-管程">4. 管程</h2> <p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p> <p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p> <div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">monitor</span> <span class="n">ProducerConsumer</span>
    <span class="kt">integer</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">condition</span> <span class="n">c</span><span class="p">;</span>

    <span class="k">procedure</span> <span class="n">insert</span><span class="p">();</span>
    <span class="k">begin</span>
        <span class="c1">// ...
</span>    <span class="k">end</span><span class="p">;</span>

    <span class="k">procedure</span> <span class="n">remove</span><span class="p">();</span>
    <span class="k">begin</span>
        <span class="c1">// ...
</span>    <span class="k">end</span><span class="p">;</span>
<span class="k">end</span> <span class="n">monitor</span><span class="p">;</span>
</code></pre></div></div> <p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p> <p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p> <font size="3"> **使用管程实现生产者-消费者问题** </font> <p><br/></p> <div class="language-pascal highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 管程
</span><span class="n">monitor</span> <span class="n">ProducerConsumer</span>
    <span class="n">condition</span> <span class="n">full</span><span class="p">,</span> <span class="n">empty</span><span class="p">;</span>
    <span class="kt">integer</span> <span class="n">count</span> <span class="p">:=</span> <span class="m">0</span><span class="p">;</span>
    <span class="n">condition</span> <span class="n">c</span><span class="p">;</span>

    <span class="k">procedure</span> <span class="n">insert</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="kt">integer</span><span class="p">);</span>
    <span class="k">begin</span>
        <span class="k">if</span> <span class="n">count</span> <span class="p">=</span> <span class="n">N</span> <span class="k">then</span> <span class="n">wait</span><span class="p">(</span><span class="n">full</span><span class="p">);</span>
        <span class="n">insert_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="n">count</span> <span class="p">:=</span> <span class="n">count</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">count</span> <span class="p">=</span> <span class="m">1</span> <span class="k">then</span> <span class="n">signal</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span>
    <span class="k">end</span><span class="p">;</span>

    <span class="k">function</span> <span class="n">remove</span><span class="p">:</span> <span class="kt">integer</span><span class="p">;</span>
    <span class="k">begin</span>
        <span class="k">if</span> <span class="n">count</span> <span class="p">=</span> <span class="m">0</span> <span class="k">then</span> <span class="n">wait</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span>
        <span class="n">remove</span> <span class="p">=</span> <span class="n">remove_item</span><span class="p">;</span>
        <span class="n">count</span> <span class="p">:=</span> <span class="n">count</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">count</span> <span class="p">=</span> <span class="n">N</span> <span class="p">-</span><span class="m">1</span> <span class="k">then</span> <span class="n">signal</span><span class="p">(</span><span class="n">full</span><span class="p">);</span>
    <span class="k">end</span><span class="p">;</span>
<span class="k">end</span> <span class="n">monitor</span><span class="p">;</span>

<span class="c1">// 生产者客户端
</span><span class="k">procedure</span> <span class="n">producer</span>
<span class="k">begin</span>
    <span class="k">while</span> <span class="nb">true</span> <span class="k">do</span>
    <span class="k">begin</span>
        <span class="n">item</span> <span class="p">=</span> <span class="n">produce_item</span><span class="p">;</span>
        <span class="n">ProducerConsumer</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">end</span><span class="p">;</span>

<span class="c1">// 消费者客户端
</span><span class="k">procedure</span> <span class="n">consumer</span>
<span class="k">begin</span>
    <span class="k">while</span> <span class="nb">true</span> <span class="k">do</span>
    <span class="k">begin</span>
        <span class="n">item</span> <span class="p">=</span> <span class="n">ProducerConsumer</span><span class="p">.</span><span class="n">remove</span><span class="p">;</span>
        <span class="n">consume_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">end</span><span class="p">;</span>
</code></pre></div></div> <h1 id="经典同步问题">经典同步问题</h1> <p>生产者和消费者问题前面已经讨论过了。</p> <h2 id="1-哲学家进餐问题">1. 哲学家进餐问题</h2> <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg"/> </div> <p><br/></p> <p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p> <p>下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define N 5
</span>
<span class="kt">void</span> <span class="nf">philosopher</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">think</span><span class="p">();</span>
        <span class="n">take</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>       <span class="c1">// 拿起左边的筷子</span>
        <span class="n">take</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">N</span><span class="p">);</span> <span class="c1">// 拿起右边的筷子</span>
        <span class="n">eat</span><span class="p">();</span>
        <span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">put</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">N</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>为了防止死锁的发生，可以设置两个条件：</p> <ul> <li>必须同时拿起左右两根筷子；</li> <li>只有在两个邻居都没有进餐的情况下才允许进餐。</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define N 5
#define LEFT (i + N - 1) % N // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
</span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">semaphore</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">state</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>                <span class="c1">// 跟踪每个哲学家的状态</span>
<span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>         <span class="c1">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span>
<span class="n">semaphore</span> <span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>              <span class="c1">// 每个哲学家一个信号量</span>

<span class="kt">void</span> <span class="nf">philosopher</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">think</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">take_two</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">eat</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">put_two</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">take_two</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">HUNGRY</span><span class="p">;</span>
    <span class="n">check</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 只有收到通知之后才可以开始吃，否则会一直等下去</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">put_two</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">THINKING</span><span class="p">;</span>
    <span class="n">check</span><span class="p">(</span><span class="n">LEFT</span><span class="p">);</span> <span class="c1">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span>
    <span class="n">check</span><span class="p">(</span><span class="n">RIGHT</span><span class="p">);</span>
    <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">eat</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">EATING</span><span class="p">;</span>
    <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span>
<span class="kt">void</span> <span class="nf">check</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">HUNGRY</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="p">[</span><span class="n">LEFT</span><span class="p">]</span> <span class="o">!=</span> <span class="n">EATING</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="p">[</span><span class="n">RIGHT</span><span class="p">]</span> <span class="o">!=</span><span class="n">EATING</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">EATING</span><span class="p">;</span>
        <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="2-读者-写者问题">2. 读者-写者问题</h2> <p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p> <p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">int</span> <span class="n">semaphore</span><span class="p">;</span>
<span class="n">semaphore</span> <span class="n">count_mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">semaphore</span> <span class="n">data_mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">reader</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">count_mutex</span><span class="p">);</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_mutex</span><span class="p">);</span> <span class="c1">// 第一个读者需要对数据进行加锁，防止写进程访问</span>
        <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">count_mutex</span><span class="p">);</span>
        <span class="n">read</span><span class="p">();</span>
        <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">count_mutex</span><span class="p">);</span>
        <span class="n">count</span><span class="o">--</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_mutex</span><span class="p">);</span>
        <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">count_mutex</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">writer</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">TRUE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_mutex</span><span class="p">);</span>
        <span class="n">write</span><span class="p">();</span>
        <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_mutex</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>以下内容由 <a href="https://github.com/yugandharbandi">@Bandi Yugandhar</a> 提供。</p> <p>The first case may result Writer to starve. This case favous Writers i.e no writer, once added to the queue, shall be kept waiting longer than absolutely necessary(only when there are readers that entered the queue before the writer).</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">readcount</span><span class="p">,</span> <span class="n">writecount</span><span class="p">;</span>                   <span class="c1">//(initial value = 0)</span>
<span class="n">semaphore</span> <span class="n">rmutex</span><span class="p">,</span> <span class="n">wmutex</span><span class="p">,</span> <span class="n">readLock</span><span class="p">,</span> <span class="n">resource</span><span class="p">;</span> <span class="c1">//(initial value = 1)</span>

<span class="c1">//READER</span>
<span class="kt">void</span> <span class="nf">reader</span><span class="p">()</span> <span class="p">{</span>
<span class="o">&lt;</span><span class="n">ENTRY</span> <span class="n">Section</span><span class="o">&gt;</span>
 <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readLock</span><span class="p">);</span>                 <span class="c1">//  reader is trying to enter</span>
 <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmutex</span><span class="p">);</span>                  <span class="c1">//   lock to increase readcount</span>
  <span class="n">readcount</span><span class="o">++</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">readcount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
   <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource</span><span class="p">);</span>              <span class="c1">//if you are the first reader then lock  the resource</span>
 <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmutex</span><span class="p">);</span>                  <span class="c1">//release  for other readers</span>
 <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readLock</span><span class="p">);</span>                 <span class="c1">//Done with trying to access the resource</span>

<span class="o">&lt;</span><span class="n">CRITICAL</span> <span class="n">Section</span><span class="o">&gt;</span>
<span class="c1">//reading is performed</span>

<span class="o">&lt;</span><span class="n">EXIT</span> <span class="n">Section</span><span class="o">&gt;</span>
 <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmutex</span><span class="p">);</span>                  <span class="c1">//reserve exit section - avoids race condition with readers</span>
 <span class="n">readcount</span><span class="o">--</span><span class="p">;</span>                       <span class="c1">//indicate you're leaving</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">readcount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>          <span class="c1">//checks if you are last reader leaving</span>
   <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource</span><span class="p">);</span>              <span class="c1">//if last, you must release the locked resource</span>
 <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rmutex</span><span class="p">);</span>                  <span class="c1">//release exit section for other readers</span>
<span class="p">}</span>

<span class="c1">//WRITER</span>
<span class="kt">void</span> <span class="nf">writer</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">&lt;</span><span class="n">ENTRY</span> <span class="n">Section</span><span class="o">&gt;</span>
  <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wmutex</span><span class="p">);</span>                  <span class="c1">//reserve entry section for writers - avoids race conditions</span>
  <span class="n">writecount</span><span class="o">++</span><span class="p">;</span>                <span class="c1">//report yourself as a writer entering</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">writecount</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>         <span class="c1">//checks if you're first writer</span>
   <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readLock</span><span class="p">);</span>               <span class="c1">//if you're first, then you must lock the readers out. Prevent them from trying to enter CS</span>
  <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wmutex</span><span class="p">);</span>                  <span class="c1">//release entry section</span>

<span class="o">&lt;</span><span class="n">CRITICAL</span> <span class="n">Section</span><span class="o">&gt;</span>
 <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource</span><span class="p">);</span>                <span class="c1">//reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource</span>
  <span class="c1">//writing is performed</span>
 <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">resource</span><span class="p">);</span>                <span class="c1">//release file</span>

<span class="o">&lt;</span><span class="n">EXIT</span> <span class="n">Section</span><span class="o">&gt;</span>
  <span class="n">down</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wmutex</span><span class="p">);</span>                  <span class="c1">//reserve exit section</span>
  <span class="n">writecount</span><span class="o">--</span><span class="p">;</span>                <span class="c1">//indicate you're leaving</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">writecount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>         <span class="c1">//checks if you're the last writer</span>
   <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readLock</span><span class="p">);</span>               <span class="c1">//if you're last writer, you must unlock the readers. Allows them to try enter CS for reading</span>
  <span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wmutex</span><span class="p">);</span>                  <span class="c1">//release exit section</span>
<span class="p">}</span>
</code></pre></div></div> <p>We can observe that every reader is forced to acquire ReadLock. On the otherhand, writers doesn’t need to lock individually. Once the first writer locks the ReadLock, it will be released only when there is no writer left in the queue.</p> <p>From the both cases we observed that either reader or writer has to starve. Below solutionadds the constraint that no thread shall be allowed to starve; that is, the operation of obtaining a lock on the shared data will always terminate in a bounded amount of time.</p> <pre><code class="language-source-c">int readCount;                  // init to 0; number of readers currently accessing resource

// all semaphores initialised to 1
Semaphore resourceAccess;       // controls access (read/write) to the resource
Semaphore readCountAccess;      // for syncing changes to shared variable readCount
Semaphore serviceQueue;         // FAIRNESS: preserves ordering of requests (signaling must be FIFO)

void writer()
{
    down(&amp;serviceQueue);           // wait in line to be servicexs
    // &lt;ENTER&gt;
    down(&amp;resourceAccess);         // request exclusive access to resource
    // &lt;/ENTER&gt;
    up(&amp;serviceQueue);           // let next in line be serviced

    // &lt;WRITE&gt;
    writeResource();            // writing is performed
    // &lt;/WRITE&gt;

    // &lt;EXIT&gt;
    up(&amp;resourceAccess);         // release resource access for next reader/writer
    // &lt;/EXIT&gt;
}

void reader()
{
    down(&amp;serviceQueue);           // wait in line to be serviced
    down(&amp;readCountAccess);        // request exclusive access to readCount
    // &lt;ENTER&gt;
    if (readCount == 0)         // if there are no readers already reading:
        down(&amp;resourceAccess);     // request resource access for readers (writers blocked)
    readCount++;                // update count of active readers
    // &lt;/ENTER&gt;
    up(&amp;serviceQueue);           // let next in line be serviced
    up(&amp;readCountAccess);        // release access to readCount

    // &lt;READ&gt;
    readResource();             // reading is performed
    // &lt;/READ&gt;

    down(&amp;readCountAccess);        // request exclusive access to readCount
    // &lt;EXIT&gt;
    readCount--;                // update count of active readers
    if (readCount == 0)         // if there are no readers left:
        up(&amp;resourceAccess);     // release resource access for all
    // &lt;/EXIT&gt;
    up(&amp;readCountAccess);        // release access to readCount
}

</code></pre> <h1 id="进程通信">进程通信</h1> <p>进程同步与进程通信很容易混淆，它们的区别在于：</p> <ul> <li>进程同步：控制多个进程按一定顺序执行；</li> <li>进程通信：进程间传输信息。</li> </ul> <p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p> <h2 id="1-管道">1. 管道</h2> <p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</code></pre></div></div> <p>它具有以下限制：</p> <ul> <li>只支持半双工通信（单向交替传输）；</li> <li>只能在父子进程或者兄弟进程中使用。</li> </ul> <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png"/> </div> <p><br/></p> <h2 id="2-fifo">2. FIFO</h2> <p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">mkfifo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">mkfifoat</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">mode_t</span> <span class="n">mode</span><span class="p">);</span>
</code></pre></div></div> <p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p> <div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png"/> </div> <p><br/></p> <h2 id="3-消息队列">3. 消息队列</h2> <p>相比于 FIFO，消息队列具有以下优点：</p> <ul> <li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li> <li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li> <li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li> <li>匿名管道是跟随进程的,消息队列是跟随内核的,也就是说进程结束之后,匿名管道就死了,但是消息队列还会存在(除非显示调用函数销毁).</li> <li>管道是文件,存放在磁盘上,访问速度慢,消息队列是数据结构,存放在内存,访问速度快.</li> <li>管道是数据流式存取,消息队列是数据块式存取.</li> </ul> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/ipc.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/msg.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">msgget</span><span class="p">(</span><span class="n">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">msgflg</span><span class="p">);</span>

</code></pre></div></div> <h2 id="4-信号量">4. 信号量</h2> <p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。 信号量多用于进程间的同步和互斥.</p> <p>信号量的工作机制,它可以直接理解成计数器,信号量会有初值(&gt;0),每当有进程申请使用信号量,通过一个P操作来对信号量进行-1操作,当计数器减到0的时候就说明没有资源了,其他进程要想访问就必须等待(比如忙等待或者睡眠),当该进程执行完这段工作(我们称之为临界区)之后,就会执行V操作来对信号量进行+1操作.</p> <p>进程AB利用信号量通信,A创建信号量/初始化信号量;B用同样的key创建信号量;然后它们就可以利用信号量进行通信了.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/ipc.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/sem.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">semget</span><span class="p">(</span><span class="n">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nsems</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semflg</span><span class="p">);</span> <span class="c1">// 信号量的创建:</span>
<span class="kt">int</span> <span class="nf">semop</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span><span class="n">sops</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nsops</span><span class="p">);</span> <span class="c1">// 信号量操作:P/V操作通过一个函数实现</span>
</code></pre></div></div> <h2 id="5-共享存储">5. 共享存储</h2> <p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p> <p>需要使用信号量用来同步对共享存储的访问。</p> <p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p> <h2 id="6-信号">6. 信号</h2> <p>信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生.</p> <p>信号可以在任何时候发送给某一进程,而无须知道该进程的状态.如果该进程未处于执行状态,则该信号就由内核保存起来,直到该进程恢复执行并传递给它为止.如果一个信号被进程设置为阻塞,则该信号的传递被延迟,直到其阻塞被取消时才被传递给进程.</p> <p>Linux提供了几十种信号,分别代表着不同的意义.信号之间依靠他们的值来区分,但是通常在程序中使用信号的名字来表示一个信号.通常程序中直接包含<signal.h>就好.</signal.h></p> <p>信号是在软件层次上对中断机制的一种模拟,是一种异步通信方式,信号可以在用户空间进程和内核之间直接交互.内核也可以利用信号来通知用户空间的进程.</p> <p>信号的来源:</p> <p>硬件来源,例如按下了cltr+C,通常产生中断信号sigint. 软件来源,例如使用系统调用或者命令发出信号.最常用的发送信号的系统函数是kill,raise,setitimer,sigation,sigqueue函数.软件来源还包括一些非法运算等操作. 一旦有信号产生,用户进程对信号产生的相应有三种方式:</p> <p>执行默认操作,linux对每种信号都规定了默认操作. 捕捉信号,定义信号处理函数,当信号发生时,执行相应的处理函数. 忽略信号,当不希望接收到的信号对进程的执行产生影响,而让进程继续执行时,可以忽略该信号,即不对信号进程作任何处理. 但是有两个信号SIGKILL和SEGSTOP是应用进程无法捕捉和忽略的,这是为了使系统管理员能在任何时候中断或结束某一特定的进程.</p> <h2 id="7-套接字">7. 套接字</h2> <p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p> <h3 id="3-进程控制块pcb">3. 进程控制块PCB</h3> <p>​ PCB是操作系统中的一个数据结构描述,它是对系统的进程进行管理的重要依据,和进程管理相关的操作无一不用到PCB中的内容.一般情况下,PCB中包含以下内容:</p> <p>(1)进程标识符(内部,外部) (2)处理机的信息(通用寄存器,指令计数器,PSW,用户的栈指针). (3)进程调度信息(进程状态,进程的优先级,进程调度所需的其它信息,事件) (4)进程控制信息(程序的数据的地址,资源清单,进程同步和通信机制,链接指针)</p> <p>​ 不同操作系统PCB的具体实现可能会略有不同.</p> <h4 id="4-进程之间的通信方法有哪几种-重点">(4) 进程之间的通信方法有哪几种 (重点)</h4> <p>进程之间的通信方式主要有六种,包括<strong>管道,信号量,消息队列,信号,共享内存,套接字</strong>.</p> <ul> <li> <p>管道:管道是半双工的,双方需要通信的时候,需要建立两个管道.管道的实质是一个内核缓冲区,进程以先进先出的方式从缓冲区存取数据:管道一端的进程顺序地将进程数据写入缓冲区,另一端的进程则顺序地读取数据,该缓冲区可以看做一个循环队列,读和写的位置都是自动增加的,一个数据只能被读一次,读出以后再缓冲区都不复存在了.当缓冲区读空或者写满时,有一定的规则控制相应的读进程或写进程是否进入等待队列,当空的缓冲区有新数据写入或慢的缓冲区有数据读出时,就唤醒等待队列中的进程继续读写.管道是最容易实现的 <img src="fig/管道通信.png" alt="fig/管道通信.png"/></p> <p>匿名管道pipe和命名管道除了建立,打开,删除的方式不同外,其余都是一样的.匿名管道只允许有亲缘关系的进程之间通信,也就是父子进程之间的通信,命名管道允许具有非亲缘关系的进程间通信.</p> <p>管道的底层实现 https://segmentfault.com/a/1190000009528245</p> </li> <li> <p>信号量:信号量是一个计数器,可以用来控制多个进程对共享资源的访问.信号量只有等待和发送两种操作.等待(P(sv))就是将其值减一或者挂起进程,发送(V(sv))就是将其值加一或者将进程恢复运行.</p> </li> <li> <p>信号:信号是Linux系统中用于进程之间通信或操作的一种机制,信号可以在任何时候发送给某一进程,而无须知道该进程的状态.如果该进程并未处于执行状态,则该信号就由内核保存起来,知道该进程恢复执行并传递给他为止.如果一个信号被进程设置为阻塞,则该信号的传递被延迟,直到其阻塞被取消时才被传递给进程. 信号是开销最小的</p> </li> <li> <p>共享内存:共享内存允许两个或多个进程共享一个给定的存储区,这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中,就像由malloc()分配的内存一样使用.一个进程写入共享内存的信息,可以被其他使用这个共享内存的进程,通过一个简单的内存读取读出,从而实现了进程间的通信.共享内存的效率最高,缺点是没有提供同步机制,需要使用锁等其他机制进行同步.</p> </li> <li> <p>消息队列:消息队列就是一个消息的链表,是一系列保存在内核中消息的列表.用户进程可以向消息队列添加消息,也可以向消息队列读取消息. 消息队列与管道通信相比,其优势是对每个消息指定特定的消息类型,接收的时候不需要按照队列次序,而是可以根据自定义条件接收特定类型的消息. 可以把消息看做一个记录,具有特定的格式以及特定的优先级.对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息,对消息队列有读权限的进程可以从消息队列中读取消息.</p> </li> <li> <p>套接字:套接口也是一种进程间通信机制,与其他通信机制不同的是,它可用于不同设备及其间的进程通信.</p> </li> </ul> <h4 id="5-进程调度方法详细介绍">(5) 进程调度方法详细介绍</h4> <p>https://blog.csdn.net/u011080472/article/details/51217754</p> <p>https://blog.csdn.net/leex_brave/article/details/51638300</p> <ul> <li>先来先服务 (FCFS first come first serve):按照作业到达任务队列的顺序调度 FCFS是非抢占式的,易于实现,效率不高,性能不好,有利于长作业(CPU繁忙性)而不利于短作业(I/O繁忙性).</li> <li>短作业优先 (SHF short job first):每次从队列里选择预计时间最短的作业运行.SJF是非抢占式的,优先照顾短作业,具有很好的性能,降低平均等待时间,提高吞吐量.但是不利于长作业,长作业可能一直处于等待状态,出现饥饿现象;完全未考虑作业的优先紧迫程度,不能用于实时系统.</li> <li>最短剩余时间优先 该算法首先按照作业的服务时间挑选最短的作业运行,在该作业运行期间,一旦有新作业到达系统,并且该新作业的服务时间比当前运行作业的剩余服务时间短,则发生抢占;否则,当前作业继续运行.该算法确保一旦新的短作业或短进程进入系统,能够很快得到处理.</li> <li>高响应比优先调度算法(Highest Reponse Ratio First, HRRF)是非抢占式的,主要用于作业调度.基本思想:每次进行作业调度时,先计算后备作业队列中每个作业的响应比,挑选最高的作业投入系统运行.响应比 = (等待时间 + 服务时间) / 服务时间 = 等待时间 / 服务时间 + 1.因为每次都需要计算响应比,所以比较耗费系统资源.</li> <li>时间片轮转 用于分时系统的进程调度.基本思想:系统将CPU处理时间划分为若干个时间片(q),进程按照到达先后顺序排列.每次调度选择队首的进程,执行完1个时间片q后,计时器发出时钟中断请求,该进程移至队尾.以后每次调度都是如此.该算法能在给定的时间内响应所有用户的而请求,达到分时系统的目的.</li> <li>多级反馈队列(Multilevel Feedback Queue)</li> </ul> <h4 id="16-说一下pcb说一下进程地址空间">(16) 说一下PCB/说一下进程地址空间/</h4> <p>https://blog.csdn.net/qq_38499859/article/details/80057427</p> <p>PCB就是进程控制块,是操作系统中的一种数据结构,用于表示进程状态,操作系统通过PCB对进程进行管理.</p> <p>PCB中包含有:进程标识符,处理器状态,进程调度信息,进程控制信息</p> <h4 id="9-daemon-进程和僵尸进程">9. Daemon 进程和僵尸进程</h4> <ul> <li> <p><strong>Daemon 进程</strong>：后台运行的服务进程，无控制终端。</p> <ul> <li><strong>产生方法</strong>：通过 <code class="language-plaintext highlighter-rouge">fork</code> 创建子进程，父进程退出，子进程成为 Daemon 进程。</li> </ul> </li> <li> <p><strong>僵尸进程</strong>：子进程退出后，父进程未调用 <code class="language-plaintext highlighter-rouge">wait</code> 系统调用回收子进程资源。</p> <ul> <li><strong>消除方法</strong>：父进程调用 <code class="language-plaintext highlighter-rouge">wait</code> 系统调用回收子进程资源。</li> </ul> </li> </ul> <p>什么是守护进程？ 如何查看守护进程？ 什么是僵尸进程？ 如何查看僵尸进程？ 创建进程的步骤？ 进程切换发生的原因？ 处理进程切换的步骤？</p>]]></content><author><name></name></author><category term="language"/><category term="cpp"/><category term="并发编程"/><category term="multiProcess"/><summary type="html"><![CDATA[进程]]></summary></entry><entry><title type="html">coroutine了解</title><link href="https://marco-hmc.github.io/blog/2025/3_coroutine.md/" rel="alternate" type="text/html" title="coroutine了解"/><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/3_coroutine.md</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/3_coroutine.md/"><![CDATA[<h2 id="coroutine了解">coroutine了解</h2> <h3 id="1-基础概念">1. 基础概念</h3> <ul> <li>函数怎么提前返回？</li> <li>怎么手动模拟函数调用？</li> <li>函数参数到底怎么传？</li> <li>函数如何能跨调用层次返回？</li> <li>怎么能获取 EIP/RIP？</li> <li>函数怎么跳转到特定地址执行？</li> <li>函数怎么保存上下文？</li> <li>汇编中为什么要保存寄存器？</li> <li>汇编中怎么恢复栈？</li> <li>汇编怎么平衡栈？</li> <li>什么是 <code class="language-plaintext highlighter-rouge">__stdcall</code> 和 <code class="language-plaintext highlighter-rouge">__cdecl</code>？</li> </ul> <h4 id="01-什么是协程什么是纤程">0.1 什么是协程？什么是纤程？</h4> <ul> <li><strong>什么是协程：</strong> 协程(Coroutine)是一种用户态的轻量级线程,协程的调度完全由用户控制.协程有点类似于线程,但协程避免了无意义的调度,而且提供了方便的协作式多任务处理能力.协程在某些场景下,如IO密集型任务,可以提高程序的执行效率.</li> </ul> <p>协程和纤程都是一种比线程更加轻量级的并发单元。两者的调度都不是由操作系统决定，而是由用户决定。两者都允许在一个函数执行过程中暂停执行，并在稍后恢复执行，从而实现非阻塞的并发操作。</p> <p>两者的实现原理也是相同的，本质上都是以下几点：</p> <ol> <li><strong>记住上下文信息</strong>：无论是纤程还是协程，都需要记住当前的执行上下文，包括寄存器状态、栈指针等。</li> <li><strong>切换执行位置</strong>：在需要时，切换到另一个执行位置，继续执行其他任务。</li> <li><strong>还原上下文信息</strong>：在切换回原来的执行位置时，还原之前保存的上下文信息，继续执行。</li> </ol> <table> <thead> <tr> <th>特性</th> <th>纤程（Fiber）</th> <th>协程（Coroutine）</th> </tr> </thead> <tbody> <tr> <td>平台依赖</td> <td>Windows 特定实现</td> <td>跨平台</td> </tr> <tr> <td>内存共享</td> <td>共享线程栈</td> <td>共享进程内存空间</td> </tr> <tr> <td>实现复杂度</td> <td>依赖操作系统 API</td> <td>可以通过库或语言特性实现</td> </tr> </tbody> </table> <h4 id="02-协程的原理是什么">0.2 协程的原理是什么？</h4> <p>协程实现的基础：C/C++ 函数调用过程，执行过程，返回过程。</p> <ul> <li><strong>记住离开的位置</strong>：一个函数离开时能记住离开的位置。在 Windows 平台下，这意味着要能记住 EIP/RIP 寄存器的值，因为 EIP/RIP 指示了下一条指令要执行的地址。</li> <li><strong>恢复现场</strong>：再次进入时能恢复现场。这要求能够保存当时函数栈内存和寄存器的值，并在恢复时恢复栈内存和寄存器的值。后面我们会详细说明并手动完成这个过程，这要求我们对函数调用有深入的理解。</li> </ul> <h4 id="11-协程是什么">1.1 协程是什么？</h4> <p>协程（Coroutine）是一种比线程更轻量级的并发单元。与线程不同，协程不依赖于操作系统的线程调度，而是由程序自身控制的。协程可以在一个线程内实现多任务的切换，避免了线程上下文切换的开销。协程的主要特点是可以在执行过程中暂停，并在稍后恢复执行。</p> <h4 id="12-协程有什么用">1.2 协程有什么用？</h4> <p>协程主要用于实现并发编程，特别是在 I/O 密集型任务中。以下是协程的一些主要用途：</p> <ol> <li><strong>异步编程</strong>：协程可以在等待 I/O 操作（如网络请求、文件读写）时暂停执行，释放 CPU 资源给其他任务，从而提高程序的并发性能。</li> <li><strong>生成器</strong>：协程可以用作生成器，逐步生成数据，而不是一次性生成所有数据。这对于处理大数据集或流式数据非常有用。</li> <li><strong>协作多任务</strong>：协程可以在多个任务之间切换，模拟多任务处理，而不需要多线程或多进程的开销。</li> <li><strong>简化代码</strong>：协程可以使异步代码看起来像同步代码，简化了编写和维护异步代码的复杂性。</li> </ol> <p>通过这些用途，协程在现代编程中变得越来越重要，特别是在需要高并发和高性能的应用程序中。</p> <p>生成器的恢复执行由用户显式调用来决定。 异步函数的恢复执行由后台线程来决定。</p> <h4 id="13-协程的优缺点是什么">1.3 协程的优缺点是什么？</h4> <p>优点</p> <ul> <li>轻量级：协程比线程更轻量级，创建和切换的开销更小。</li> <li>无锁并发：协程可以避免多线程编程中的锁和竞态条件问题。</li> <li>简化异步编程：协程可以使异步代码看起来像同步代码，简化了编写和维护异步代码的复杂性。 缺点</li> <li>不适用于多核并行：协程在单个线程内运行，不能利用多核 CPU 的并行计算能力。</li> <li>手动调度：协程的调度需要手动管理，增加了编程复杂性。</li> <li>栈大小限制：协程的栈大小通常是固定的，可能会限制递归深度和局部变量的使用。</li> </ul> <h4 id="14-协程的应用场景">1.4 协程的应用场景</h4> <p>网络编程（当成异步使用，提高可读性）：协程可以简化异步网络编程，使代码更易读。 数据处理（生成器，逐步处理数据）：协程可以用于处理大数据集，逐步生成和处理数据。 用户界面（ui协程和业务协程切换）：协程可以用于实现响应式用户界面，避免界面卡顿。</p> <h4 id="15-协程实现的基本原理是什么">1.5 协程实现的基本原理是什么？</h4> <p>协程的实现的关键在于上下文切换。 而上下文切换涉及到三个过程：保存状态、切换上下文、恢复状态。</p> <p>保存状态主要涉及保存当前协程的执行上下文，包括以下内容：</p> <ul> <li>程序计数器（PC）：指示当前执行的指令地址。</li> <li>栈指针（SP）：指示当前栈顶的位置。</li> <li>寄存器：保存当前协程的寄存器状态，包括通用寄存器和特殊寄存器。</li> </ul> <p>恢复状态是指将之前保存的执行上下文恢复到当前协程中，使其能够继续执行。恢复状态的过程包括：</p> <ul> <li>恢复程序计数器：将程序计数器恢复到保存时的值。</li> <li>恢复栈指针：将栈指针恢复到保存时的值。</li> <li>恢复寄存器：将寄存器恢复到保存时的状态。</li> </ul> <p>而切换上下文就是保存当前协程状态，恢复到目标协程状态。</p> <h3 id="2-协程使用的一般例子">2. 协程使用的一般例子</h3> <h4 id="21-协程的切换">2.1 协程的切换</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;boost/coroutine/coroutine.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">coroutine_function</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">coroutines</span><span class="o">::</span><span class="n">coroutine</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">push_type</span> <span class="o">&amp;</span><span class="n">yield</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from coroutine!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">yield</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Back in coroutine!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">coroutines</span><span class="o">::</span><span class="n">coroutine</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;::</span><span class="n">pull_type</span> <span class="n">source</span><span class="p">(</span><span class="n">coroutine_function</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from main!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">source</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Back in main!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
Hello from coroutine!
Hello from main!
Back in coroutine!
Back in main!
*/</span>
</code></pre></div></div> <ul> <li>push_type和pull_type怎么理解？ <ul> <li>push_type 定义：push_type 是一个类型，用于将控制权推送到协程中。 作用：在协程函数中，push_type 对象用于暂停协程的执行并返回到调用者。它通常作为协程函数的参数传递。 使用场景：当协程需要暂停执行并返回到主程序或其他协程时，使用 push_type 对象的 operator() 来实现这一点。</li> <li>pull_type 定义：pull_type 是一个类型，用于从协程中拉取控制权。 作用：在主程序或调用者中，pull_type 对象用于启动和恢复协程的执行。它通常在主程序中创建，并与协程函数关联。 使用场景：当主程序或其他协程需要启动或恢复协程的执行时，使用 pull_type 对象的 operator() 来实现这一点。</li> </ul> </li> </ul> <h4 id="22-带返回值的协程">2.2 带返回值的协程</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;boost/coroutine2/all.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">coroutine_function</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">coroutines2</span><span class="o">::</span><span class="n">coroutine</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">push_type</span> <span class="o">&amp;</span><span class="n">yield</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Coroutine yields: "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">yield</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">coroutines2</span><span class="o">::</span><span class="n">coroutine</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">pull_type</span> <span class="n">source</span><span class="p">(</span><span class="n">coroutine_function</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">source</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Main received: "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">source</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="98-习题">98. 习题</h3> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;boost/coroutine2/all.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">coroutines2</span><span class="o">::</span><span class="n">coroutine</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">pull_type</span> <span class="n">source</span><span class="p">(</span>
      <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">boost</span><span class="o">::</span><span class="n">coroutines2</span><span class="o">::</span><span class="n">coroutine</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">push_type</span> <span class="o">&amp;</span><span class="n">sink</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">second</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">sink</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
        <span class="n">sink</span><span class="p">(</span><span class="n">second</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="kt">int</span> <span class="n">third</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">second</span><span class="p">;</span>
          <span class="n">first</span> <span class="o">=</span> <span class="n">second</span><span class="p">;</span>
          <span class="n">second</span> <span class="o">=</span> <span class="n">third</span><span class="p">;</span>
          <span class="n">sink</span><span class="p">(</span><span class="n">third</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">});</span>

  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">source</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-yield_type和call_type是什么和push_type还有pull_type的联系是什么">1. yield_type和call_type是什么？和push_type还有pull_type的联系是什么？</h4> <p>yield_type 和 call_type 是旧版本 Boost.Coroutine 库中的类型，而 push_type 和 pull_type 是新的 Boost.Coroutine2 库中的类型。 它们在功能和目的上有相似之处，都是用于在协程中暂停执行并返回到调用者，但它们的内部实现和对外使用方式有所不同。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;boost/coroutine/coroutine.hpp&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">coroutine_function</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">coroutines</span><span class="o">::</span><span class="n">yield_type</span> <span class="o">&amp;</span><span class="n">yield</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from coroutine!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">yield</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Back in coroutine!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">coroutines</span><span class="o">::</span><span class="n">call_type</span> <span class="n">coroutine</span><span class="p">(</span><span class="n">coroutine_function</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from main!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">coroutine</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Back in main!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="2-什么是对称协程什么是非对称协程">2. 什么是对称协程？什么是非对称协程？</h4> <p>非对称协程：</p> <ul> <li>使用 boost::coroutines2::asymmetric_coroutine 实现。</li> <li>非对称协程只能从主程序或调度器中启动和恢复，而不能直接相互调用。</li> <li>非对称协程能知道其调用方，调用一些方法能让出当前的控制回到调用方手上。</li> </ul> <p>对称协程：</p> <ul> <li>使用 boost::coroutines2::coroutine 实现。</li> <li>对称协程允许协程之间相互切换，而不需要返回到主调度器。</li> <li>对程协程都是平等的，一个对程协程能把控制让给任意一个协程，因此，当对称协程让出控制的时候，必须指定被让出的协程是哪一个。</li> </ul> <p>对称协程可以当成非对称协程使用。对称协程提供了更灵活的控制流，可以在协程之间相互切换，但也可以像非对称协程一样，从主程序中启动和恢复协程。 具体什么时候建议使用非对称协程欢迎补充。</p> <h4 id="3-有栈协程和无栈协程的实现是什么">3. 有栈协程和无栈协程的实现是什么？</h4> <p>协程的实现的关键在于上下文切换。 而上下文切换涉及到三个过程：保存状态、切换上下文、恢复状态。 而有栈协程实现和无栈协程的实现区别就在于状态保存在哪里。 有栈实现：每一个协程有一个独立的栈空间。受到栈空间大小约束，有空间损耗 无栈实现：将协程的状态存储在堆（Heap）空间中，通过状态机的方式去管理。不受栈空间大小约束，没有空间损耗。实现麻烦。</p> <p>而协程的状态包含以下三个方面</p> <ul> <li>程序计数器（PC）：指示当前执行的指令地址。</li> <li>栈指针（SP）：指示当前栈顶的位置。</li> <li> <p>寄存器：保存当前协程的寄存器状态，包括通用寄存器和特殊寄存器。</p> </li> <li>boost的是有栈协程</li> <li>c++20的是无栈协程</li> </ul> <p>协程的实现涉及到底层的上下文切换和状态保存，这些操作通常需要使用汇编语言来直接操作寄存器和栈指针。高级语言通常不直接提供这些底层接口，因此实现协程通常依赖于库（调用一些其他类似接口去模拟）或语言特性（编译器层面直接操作）。</p> <h4 id="4-堆空间和栈空间概念">4. 堆空间和栈空间概念</h4> <p>不同线程：</p> <ul> <li>栈空间：每个线程都有自己的栈空间，用于存储该线程的局部变量、函数调用的参数、返回地址等。这意味着栈空间是线程私有的。</li> <li>堆空间：同一进程内的所有线程共享同一个堆空间。这意味着线程之间可以通过指针或引用共享堆上分配的数据。</li> </ul> <p>不同进程：</p> <ul> <li>栈空间：每个进程都有自己的虚拟地址空间，其中包括独立的栈空间。进程间的栈空间是完全隔离的。</li> <li>堆空间：每个进程也有自己独立的堆空间。进程间的堆空间不共享，因此进程之间不能直接访问对方的堆数据。</li> </ul> <h3 id="3-ques">3. ques</h3> <h4 id="31-c的协程的实现原理是什么">3.1 C++的协程的实现原理是什么?</h4> <p>C++的协程是一种特殊的函数,它可以在执行过程中暂停和恢复.协程的实现原理涉及到两个关键概念:生成器和状态机.</p> <p>生成器是协程的基础,它是一个可以产生多个值的函数.在C++中,生成器使用<code class="language-plaintext highlighter-rouge">yield</code>语句来暂停执行并返回一个值,然后可以通过调用生成器来恢复执行并继续生成下一个值.生成器的实现通常使用状态机来跟踪函数的执行状态.</p> <p>状态机是一个用于管理协程执行状态的机制.它可以记录协程的当前状态,并根据不同的状态执行相应的操作.在C++中,状态机通常使用有限状态机(FSM)来实现.FSM由一组状态和状态之间的转换组成.每个状态都对应着协程的不同执行阶段,而状态之间的转换则由协程的控制流决定.</p> <p>在C++中,协程的实现依赖于协程支持库,如Boost.Coroutine或C++20中引入的标准库中的协程.这些库提供了协程的底层实现,包括生成器和状态机的机制.通过使用这些库,我们可以更方便地编写和管理协程.</p> <p>总结一下,C++的协程实现原理涉及生成器和状态机的概念.生成器用于产生多个值并支持暂停和恢复执行,而状态机用于管理协程的执行状态和控制流.通过使用协程支持库,我们可以更轻松地编写和管理协程.</p> <h4 id="32">3.2</h4> <p>我的理解是协程只有两个主要功能，一个是保存上下文信息，一个是灵活的控制流。 协程是用来代替传统的异步编程的. 通过保存上下文和灵活的控制流操作，允许开发者以同步的方式编写代码，同时在执行阻塞操作时让出CPU，从而实现类似异步的非阻塞行为。这种方式简化了异步编程的复杂性，使得代码更易于理解和维护。</p> <p>协程就是为了代替异步用的. 比如说你说在后端异步加载信息的时候，不想用异步，异步编程比较麻烦. 开了异步也要切换线程，也有消耗， 想用同步的方式去写，而且不阻塞的话. 这个时候的选择就是开协程.</p> <p>去执行其他任务，从而提高程序的并发效率。 但它本质上是在单线程内通过协作式的调度来实现异步，适合处理大量 I/O 密集型任务场景。 然而，对于那些需要真正并行执行的计算密集型任务，比如复杂的数学计算等，仅靠 async 并不能充分利用多核 CPU 的优势来实现真正的并行加速。</p> <h2 id="协程">协程</h2> <ul> <li> <p>基本概念：<strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程</p> <p><img src="imgs/os/corotines.png" alt="corotines" style="zoom:60%;"/></p> </li> <li> <p>进程，线程，协程的上下文切换</p> <ul> <li>进程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户是无感知的。进程的切换内容包括<strong>页全局目录、内核栈、硬件上下文，切换内容保存在内存</strong>中。进程切换过程是由“<strong>用户态到内核态到用户态</strong>”的方式，<strong>切换效率低</strong></li> <li>线程的切换者是操作系统，切换时机是根据操作系统自己的切换策略，用户无感知。线程的切换内容<strong>包括内核栈和硬件上下文</strong>。线程切换内容保存在内核栈中。线程切换过程是由“用户态到内核态到用户态”， <strong>切换效率中等</strong></li> <li>协程的切换者是用户（编程者或应用程序），<strong>切换时机是用户自己的程序所决定的</strong>。协程的<strong>切换内容是硬件上下文</strong>，<strong>切换内存保存在用户自己的变量</strong>（用户栈或堆）中。<strong>协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高</strong></li> <li><strong>协程是轻量级线程，拥有自己的寄存器上下文和栈</strong>。<strong>协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈</strong></li> <li>协程能保留上一次调用时的状态，即所有局部状态的一个特定组合，每次过程重入时，就相当于进入上一次调用的状态</li> </ul> </li> <li> <p>协程相比进程和线程的优势</p> <ul> <li>协程拥有极高的执行效率。因为<strong>子程序切换不是线程切换，协程不是被操作系统内核所管理，而是由程序自身完全控制(完全运行在用户态)，因此，没有线程切换的开销</strong>，和多线程比，线程数量越多，协程的性能优势就越明显</li> <li>不需要多线程的锁机制，因为<strong>只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多</strong></li> </ul> </li> <li> <p>协程分类：</p> <ul> <li> <p><strong>按照控制传递机制</strong></p> <ul> <li> <p><strong>非对称式协程</strong>：通过yield, 将控制权返回给调用方, 如达夫设备 就是一种非对称式协程，这种协程更像是一个可以返回多次的子例程(函数)，因此代码可读性会较高</p> </li> <li> <p><strong>对称式协程</strong>：通过resum, 将控制权交给任意协程, 这种协程更像goto 可以任意的跳转 返回，如果滥用会导致代码可读性较低</p> </li> </ul> </li> <li> <p><strong>按调实现分类</strong></p> <ul> <li> <p><strong>stackfull 有栈协程</strong>：<strong>每个协程都拥有自己的栈，协程上下文保存在自己的栈中</strong>，切换协程就是切换栈然后恢复栈中的上下文，这种方法实现的协程更像是用户态的线程</p> </li> <li> <p><strong>stackcopy 共享栈协程</strong>：stackfull 的缺点显而易见，<strong>十分浪费内存，当协程数量过多时会导致内存开销过大</strong>。stackcopy 就是用来解决此问题的，<strong>所有协程公用一个运行栈，当协程发生切换的时候，将协程数据copy到自身的独立栈中，独立栈可以进行动态的扩充</strong></p> </li> <li> <p><strong>stackless 无栈协程</strong>：stackless 协程公用一个栈，但是与stackcopy 不同，<strong>协程切换的时候仅会将所需的上下文保存在堆中</strong>, 可以将部分无用局部变量提前释放，通常这需要编译器的支持。stackless 协程通常只有顶层例程可以被挂起</p> </li> </ul> </li> </ul> </li> <li> <p><strong>应用场景</strong></p> <ul> <li>I/O 密集型任务 <ul> <li>这一点与多线程有些类似，<strong>但协程调用是在一个线程内进行的，是单线程，切换的开销小，因此效率上略高于多线程</strong></li> <li>当程序在执行 I/O 时操作时，CPU 是空闲的，此时可以充分利用 CPU 的时间片来处理其他任务。在单线程中，一个函数调用，一般是从函数的第一行代码开始执行，结束于 return 语句、异常或者函数执行（也可以认为是隐式地返回了 None ）</li> <li><strong>有了协程，我们在函数的执行过程中，如果遇到了耗时的 I/O 操作，函数可以临时让出控制权，让 CPU 执行其他函数，等 I/O 操作执行完毕以后再收回控制权</strong></li> </ul> </li> <li>当今无数的 Web 服务和互联网服务，<strong>本质上大部分都是 IO 密集型服务</strong>，什么是 IO 密集型服务？意思是处理的任务大多是和<strong>网络连接或读写相关的高耗时任务</strong>，高耗时是相对 CPU 计算逻辑处理型任务来说，两者的处理时间差距不是一个数量级的 <ul> <li><strong>IO 密集型服务的瓶颈不在 CPU 处理速度，而在于尽可能快速的完成高并发、多连接下的数据读写</strong></li> </ul> </li> <li><strong>以前有两种解决方案：</strong> <ul> <li>如果用多线程，<strong>高并发场景的大量 IO 等待会导致多线程被频繁挂起和切换</strong>，非常消耗系统资源，同时多线程访问共享资源存在竞争问题</li> <li>如果用多进程，不仅存在频繁调度切换问题，同时还会存在每个进程资源不共享的问题，需要<strong>额外引入进程间通信机制来解决</strong></li> </ul> </li> <li><strong>协程出现给高并发和 IO 密集型服务开发提供了另一种选择。</strong>当然，世界上没有技术银弹，在这里我想把协程这把钥匙交到你手中，但是它也不是万能钥匙，最好的解决方案是贴合自身业务类型做出最优选择，不一定就选择一种模型，有时候是几种模型的组合，比如<strong>多线程搭配协程是常见的组合</strong></li> </ul> </li> <li> <p>因为协程是在一个线程执行，那怎么利用多核CPU呢？最简单的方法是<strong>多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能</strong></p> </li> <li> <p>python协程完成生产者-消费者问题例子（Python对协程的支持还非常有限，用在generator中的<strong>yield</strong>可以一定程度上实现协程）</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">time</span>


<span class="k">def</span> <span class="nf">consumer</span><span class="p">():</span>
    <span class="n">r</span> <span class="o">=</span> <span class="sh">""</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">r</span>  <span class="c1"># 使用 yield 接收生产者发送的数据并返回结果
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">[CONSUMER] Consuming %s...</span><span class="sh">"</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="sh">"</span><span class="s">200 OK</span><span class="sh">"</span>


<span class="k">def</span> <span class="nf">produce</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
    <span class="n">c</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>  <span class="c1"># 启动 consumer 协程
</span>    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">[PRODUCER] Producing %s...</span><span class="sh">"</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># 发送数据给 consumer 并接收结果
</span>        <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">[PRODUCER] Consumer return: %s</span><span class="sh">"</span> <span class="o">%</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">c</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="nf">consumer</span><span class="p">()</span>
    <span class="nf">produce</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

</code></pre></div> </div> <p>注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：</p> <ol> <li>首先调用c.next()启动生成器；</li> <li>然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</li> <li>consumer通过yield拿到消息，处理，又通过yield把结果传回；</li> <li>produce拿到consumer处理的结果，继续生产下一条消息；</li> <li>produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</li> </ol> <p>整个流程<strong>无锁</strong>，由一个线程执行，produce和consumer<strong>协作完成任务</strong>，所以称为“协程”，而非线程的抢占式多任务</p> </li> <li> <p>支持协程的编程语言</p> <ul> <li><strong>Lua语言</strong></li> <li><strong>Python语言</strong></li> <li><strong>Go语言</strong></li> <li><strong>Java语言(Kilim框架)</strong></li> </ul> </li> </ul>]]></content><author><name></name></author><category term="language"/><category term="cpp"/><category term="并发编程"/><category term="coroutine"/><summary type="html"><![CDATA[coroutine了解]]></summary></entry><entry><title type="html">总线</title><link href="https://marco-hmc.github.io/blog/2025/3_%E6%80%BB%E7%BA%BF.md/" rel="alternate" type="text/html" title="总线"/><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/3_%E6%80%BB%E7%BA%BF.md</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/3_%E6%80%BB%E7%BA%BF.md/"><![CDATA[<h2 id="总线">总线</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>计算机中总线概念
├── 导言
│   ├── 总线的基本概念
│   └── 总线的作用和重要性
├── 总线的工作原理
│   ├── 总线仲裁（Bus Arbitration）
│   ├── 总线周期（Bus Cycle）
│   └── 总线传输（Bus Transfer）
</code></pre></div></div> <p>你提到的“交换机”概念在总线系统中有一定的相似性，但实际上它的工作原理和传统交换机有所不同。我们可以从几个方面来理解这个问题：</p> <h3 id="1-传统总线结构的工作原理">1. <strong>传统总线结构的工作原理</strong></h3> <p>在传统的总线架构中，CPU、内存和其他设备通过共享的总线连接。总线是由多个信号线（如数据线、地址线和控制线）组成的，这些信号线用于传输不同类型的信息。多个设备通过同一条总线传输数据时，会发生信号冲突或竞争，这样可能导致所谓的“堵塞”问题。</p> <h3 id="2-避免冲突的机制">2. <strong>避免冲突的机制</strong></h3> <p>为了避免设备之间的数据传输冲突，计算机系统通常采用以下几种机制：</p> <ul> <li> <p><strong>时间分割</strong>（时分复用）：在总线传输中，CPU和其他设备并不是同时发送数据，而是按照某种协议轮流占用总线，这样就避免了多个设备同时传输数据而发生冲突。比如，在经典的 <strong>总线仲裁机制</strong> 中，使用一个仲裁器来决定哪个设备可以使用总线。</p> </li> <li> <p><strong>总线仲裁</strong>：在多设备的系统中，可能会有一个专门的模块来决定哪个设备能够占用总线。常见的总线仲裁方法有轮询式仲裁、优先级仲裁和请求-应答仲裁等。</p> </li> </ul> <h3 id="3-交换式总线">3. <strong>交换式总线</strong></h3> <p>现代计算机架构中，传统的共享总线被更高效的“交换式总线”所取代。交换式总线类似于交换机的概念，它允许每个设备之间建立独立的通道进行通信，从而避免了资源争用和冲突的问题。</p> <ul> <li> <p><strong>点对点连接</strong>：比如 <strong>PCI Express（PCIe）</strong> 总线采用了点对点连接的方式，设备之间不再共享同一条总线，而是通过多条并行的通道来连接。这些通道是独立的，因此可以并行处理多个数据传输任务，避免了传统总线结构中可能发生的拥堵和冲突。</p> </li> <li> <p><strong>交换式机制</strong>：对于多个设备之间的高效通信，交换式总线可以动态分配带宽和通道，类似于网络中的交换机工作原理，确保每个设备都能高效地与其他设备通信。</p> </li> </ul> <h3 id="4-多层次的总线架构">4. <strong>多层次的总线架构</strong></h3> <p>在复杂的计算机系统中，可能会有多层次的总线架构来管理不同设备之间的通信。例如，一些系统使用高速的专用总线（如CPU与内存之间的总线）和较低速的共享总线（如输入输出设备和外部设备之间的总线）。不同层次的总线可以在不同的速度下工作，从而避免堵塞和提高整体效率。</p> <h3 id="总结">总结</h3> <p>虽然总线系统并不完全等同于交换机，但在现代系统中，尤其是采用交换式总线的情况下，设备之间的通信就像网络交换机一样，避免了传统总线架构中的拥堵问题。总线的设计目标是通过合理的仲裁、分时复用、甚至引入交换式架构，来保证各个设备的高效通信。</p> <h3 id="计算机中总线概念章节目录">计算机中总线概念章节目录</h3> <h4 id="1-导言">1. 导言</h4> <ul> <li>总线的基本概念</li> <li>总线的作用和重要性</li> </ul> <h4 id="2-总线的基本组成">2. 总线的基本组成</h4> <ul> <li>地址总线（Address Bus）</li> <li>数据总线（Data Bus）</li> <li>控制总线（Control Bus）</li> </ul> <h4 id="3-总线的工作原理">3. 总线的工作原理</h4> <ul> <li>总线仲裁（Bus Arbitration）</li> <li>总线周期（Bus Cycle）</li> <li>总线传输（Bus Transfer）</li> </ul> <h4 id="4-总线的类型">4. 总线的类型</h4> <ul> <li>系统总线（System Bus）</li> <li>I/O 总线（I/O Bus）</li> <li>存储总线（Memory Bus）</li> </ul> <h4 id="5-总线的结构">5. 总线的结构</h4> <ul> <li>单总线结构（Single Bus Architecture）</li> <li>双总线结构（Dual Bus Architecture）</li> <li>多总线结构（Multiple Bus Architecture）</li> </ul> <h4 id="6-总线的性能指标">6. 总线的性能指标</h4> <ul> <li>带宽（Bandwidth）</li> <li>延迟（Latency）</li> <li>吞吐量（Throughput）</li> </ul> <h4 id="7-总线的协议">7. 总线的协议</h4> <ul> <li>PCI 总线（Peripheral Component Interconnect）</li> <li>USB 总线（Universal Serial Bus）</li> <li>SATA 总线（Serial ATA）</li> </ul> <h4 id="8-总线的应用">8. 总线的应用</h4> <ul> <li>总线在计算机系统中的应用</li> <li>总线在嵌入式系统中的应用</li> </ul> <h4 id="9-总线的未来发展">9. 总线的未来发展</h4> <ul> <li>高速总线技术</li> <li>光纤总线技术</li> </ul> <h3 id="计算机中总线概念结构图">计算机中总线概念结构图</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>计算机中总线概念
├── 导言
│   ├── 总线的基本概念
│   └── 总线的作用和重要性
├── 总线的基本组成
│   ├── 地址总线（Address Bus）
│   ├── 数据总线（Data Bus）
│   └── 控制总线（Control Bus）
├── 总线的工作原理
│   ├── 总线仲裁（Bus Arbitration）
│   ├── 总线周期（Bus Cycle）
│   └── 总线传输（Bus Transfer）
├── 总线的类型
│   ├── 系统总线（System Bus）
│   ├── I/O 总线（I/O Bus）
│   └── 存储总线（Memory Bus）
├── 总线的结构
│   ├── 单总线结构（Single Bus Architecture）
│   ├── 双总线结构（Dual Bus Architecture）
│   └── 多总线结构（Multiple Bus Architecture）
├── 总线的性能指标
│   ├── 带宽（Bandwidth）
│   ├── 延迟（Latency）
│   └── 吞吐量（Throughput）
├── 总线的协议
│   ├── PCI 总线（Peripheral Component Interconnect）
│   ├── USB 总线（Universal Serial Bus）
│   └── SATA 总线（Serial ATA）
├── 总线的应用
│   ├── 总线在计算机系统中的应用
│   └── 总线在嵌入式系统中的应用
├── 总线的未来发展
│   ├── 高速总线技术
│   └── 光纤总线技术
</code></pre></div></div> <h3 id="解释">解释</h3> <ul> <li><strong>导言</strong>：介绍总线的基本概念及其在计算机系统中的重要性。</li> <li><strong>总线的基本组成</strong>：详细描述地址总线、数据总线和控制总线的功能和作用。</li> <li><strong>总线的工作原理</strong>：解释总线仲裁、总线周期和总线传输的工作机制。</li> <li><strong>总线的类型</strong>：介绍系统总线、I/O 总线和存储总线的不同类型及其应用。</li> <li><strong>总线的结构</strong>：描述单总线结构、双总线结构和多总线结构的特点和区别。</li> <li><strong>总线的性能指标</strong>：讨论带宽、延迟和吞吐量等总线性能指标。</li> <li><strong>总线的协议</strong>：介绍常见的总线协议，如 PCI、USB 和 SATA。</li> <li><strong>总线的应用</strong>：探讨总线在计算机系统和嵌入式系统中的具体应用。</li> <li><strong>总线的未来发展</strong>：展望高速总线技术和光纤总线技术的发展前景。</li> </ul> <p>通过这个章节目录和结构图，可以全面了解计算机中总线的概念及其相关的主要知识点和内容。</p> <h3 id="1-导言-1">1. 导言</h3> <ul> <li><strong>总线是什么做什么，有什么用？</strong></li> <li><strong>缓存的组成是怎么样的？</strong></li> <li><strong>缓存的是如何工作的？</strong></li> </ul> <p>本文从上面这些角度出发，希望能够让读者知道总线的作用以及原理。</p> <h3 id="2-总线是什么">2. 总线是什么</h3> <ul> <li> <p><strong><em>总线是什么，有什么用？</em></strong></p> <p>现代计算机是从冯若伊曼计算机发展起来的。其组成部分有存储器、运算器、控制器、输入设备、输出设备，在现代计算机中，人们将运算器与控制器封装起来成为CPU（中央处理单元）。计算机的各种部件想要进行数据交互，就必须让这些部件形成一定的连接关系，以便数据交互的进行。</p> </li> <li> <p><strong><em>不同部件是怎么连接的？</em></strong></p> <blockquote> <p>IO设备，指输入输出等外设。</p> <p>分时：同一时刻只允许一个部件向总线发送信息</p> <p>共享：同一时刻多个部件可以从总线接收相同的信息</p> </blockquote> <p>假设有CPU、存储设备、外设等，他们是可以以全连接的方式连接，但是这种方式未免太过繁琐和复杂。弊端不可一一而说。这时候就有一个很朴素的想法，线路复用，有线路复用的线路就可以叫做总线，因此总线的严格定义是一组能为多个部件分时共享的公共信息传送线路。但本质上就是复用嘛。</p> </li> </ul> <h3 id="3-总线有哪些呢">3. 总线有哪些呢？</h3> <h4 id="31-总线的结构">3.1 总线的结构</h4> <ul> <li> <p><strong>单总线结构</strong></p> <p><img src="img/1669960879103.png" alt="1669960879103"/></p> <p>单总线结构将 CPU、主存、I/O 设备（通过I/O接口）都挂在一组总线上，允许I/O 设备之间、I/O设备与主存之间直接交换信息，如图6.1 所示。CPU 与主存、CPU与外设之间可直接进行信息交换，而无须经过中间设备的干预。</p> <ul> <li>注意：单总线并不是指只有一根信号线，系统总线按传送信息的不同可细分为地址总线、数据总线和控制总线。</li> <li>优点∶结构简单，成本低，易于接入新的设备。</li> <li>缺点∶带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作。</li> </ul> </li> <li> <p><strong>双总线结构</strong></p> <p><img src="img/1669961040111.png" alt="1669961040111"/></p> <p>双总线结构有两条总线∶一条是主存总线，用于在 CPU、主存和通道之间传送数据;另一条是 I/O 总线，用于在多个外部设备与通道之间传送数据，如图所示。</p> <ul> <li>优点：将低速 I/O 设备从单总线上分离出来，实现了存储器总线和I/O 总线分离。</li> <li>缺点：需要增加通道等硬件设备。</li> </ul> </li> </ul> <h4 id="32-总线的分类">3.2 总线的分类</h4> <blockquote> <p>同步：指只有一个时钟源。</p> <p>异步：指有多个是时钟源。</p> </blockquote> <ul> <li>按数据传输格式： <ul> <li>串行总线</li> <li>并行总线</li> </ul> </li> <li>按功能（即连接的部件）： <ul> <li>片内总线：它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线。</li> <li>系统总线：系统总线是计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线。 <ul> <li>数据总线</li> <li>地址总线</li> <li>控制总线</li> </ul> </li> <li>通信总线</li> </ul> </li> <li>按时序控制方式： <ul> <li>同步总线</li> <li>异步总线</li> </ul> </li> </ul> <h4 id="33-总线锁">==3.3 总线锁==</h4> <ul> <li>总线锁：在多CPU下，当其中一个处理器要对共享内存进行操作的时候，在总线上发出一个LOCK信号，使得其他处理器无法访问共享数据，开销很大，如果我们能够控制锁的粒度就能减少开销，从而引入了缓存锁。</li> <li>缓存锁：只要保证多个CPU缓存的同一份数据是一致的就可以了，相比总线锁，缓存锁即降低了锁的力度。核心机制是基于缓存一致性协议来实现的。</li> </ul> <h3 id="4-总线的工作原理">4. 总线的工作原理</h3> <ul> <li><strong>总线传输的四个阶段：</strong> <ol> <li>申请分配阶段：分配下一周期的总线使用权，包括传输请求、总线仲裁。</li> <li>寻址阶段：取得主模块要访问的从模块的地址和命令。</li> <li>传输阶段：主模块和从模块进行数据交换，单向或双向。</li> <li>结束阶段：信息从总线撤除，让出总线使用权。</li> </ol> </li> <li><strong><em>==异步总线，是如何完成传输的？特别是如果一个高频的向一个低频的发起很多数据写任务呢？==</em></strong></li> </ul>]]></content><author><name></name></author><category term="计算机组成"/><summary type="html"><![CDATA[总线]]></summary></entry><entry><title type="html">c++ guideline</title><link href="https://marco-hmc.github.io/blog/2025/0_cpp_guideLine.md/" rel="alternate" type="text/html" title="c++ guideline"/><published>2025-05-04T00:00:00+00:00</published><updated>2025-05-04T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/0_cpp_guideLine.md</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/0_cpp_guideLine.md/"><![CDATA[<h2 id="c-guideline">c++ guideline</h2> <p><strong>代码的静态检查能力很重要</strong>。 本地支持静态检查时非常重要的，c++推荐用<code class="language-plaintext highlighter-rouge">clang-tidy</code>。 本文是《effective c++》《more effective c++》作为常规静态代码检查的补充，或者个人觉得常规代码静态检查有可值得额外留意之处，便在这里记录。</p> <h3 id="1-多线程">1. 多线程</h3> <ul> <li>对于业务开发来说，一般不太需要</li> <li>很多人误认为使用锁会让程序变慢，但实际上影响性能的不是锁本身，而是锁争用（多个线程同时竞争同一个锁）。</li> <li>需要学会在程序的复杂度和性能之间取得平衡，并考虑机器扩容的可能性。</li> </ul> <h3 id="2-内存安全">2. 内存安全</h3> <p>访问越界数组不一定会导致段错误（segmentation fault），但在某些情况下确实可能会发生。段错误通常发生在程序试图访问未分配或受保护的内存区域时。以下是一些可能导致段错误的情况，以及为什么访问越界数组不一定总是会导致段错误。</p> <p>什么时候会有段错误？</p> <ol> <li><strong>访问未分配的内存</strong>： <ul> <li>当程序试图访问未分配的内存区域时，操作系统会检测到并触发段错误。例如，访问一个指针指向的内存地址，但该地址未被分配。</li> </ul> </li> <li><strong>访问受保护的内存</strong>： <ul> <li>当程序试图访问受保护的内存区域（如只读内存或内核空间）时，操作系统会触发段错误。</li> </ul> </li> <li><strong>访问已经释放的内存</strong>： <ul> <li>当程序试图访问已经通过 <code class="language-plaintext highlighter-rouge">free</code> 或 <code class="language-plaintext highlighter-rouge">delete</code> 释放的内存时，可能会触发段错误。</li> </ul> </li> </ol> <p>访问越界数组不一定会有段错误的原因</p> <ol> <li><strong>越界访问在已分配的内存范围内</strong>： <ul> <li>如果越界访问的内存地址仍然在程序已分配的内存范围内，可能不会立即触发段错误。例如，访问数组的越界元素，但该元素在同一个内存块中。</li> </ul> </li> <li><strong>未触发内存保护机制</strong>： <ul> <li>如果越界访问的内存地址未触发操作系统的内存保护机制，可能不会触发段错误。例如，访问堆上的越界元素，但该元素未超出堆的边界。</li> </ul> </li> </ol> <p>访问越界数组不一定会导致段错误，具体取决于越界访问的内存地址是否在已分配的内存范围内，以及是否触发了操作系统的内存保护机制。段错误通常发生在程序试图访问未分配或受保护的内存区域时。为了避免段错误和其他未定义行为，建议在访问数组时进行边界检查。</p> <h3 id="3-原始指针">3. 原始指针</h3> <p>最好不要用原始指针</p> <ol> <li>指针作为返回的时候</li> </ol> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Info</span><span class="o">*</span> <span class="nf">foo</span><span class="p">();</span>
</code></pre></div></div> <ul> <li>用户负责指针指向对象的析构</li> <li>foo()负责指针指向对象的析构</li> <li>指针是能否为空？是不是外部用之前都得判断一下？ 总是会有歧义。 因此如果是foo()内部管理声明周期，可以选择返回引用； 如果是用户负责生命周期，可以选择返回智能指针。 甚至乎其实不返回指针，返回对象实例的时候，因为rvo的存在。其实性能差不多的。 但是rvo在多返回路径的时候没办法支持，这个时候可以考虑使用移动语义。</li> </ul> <h3 id="4-考虑使用-op来取代单独的-op-运算符">4. 考虑使用 op=来取代单独的 op 运算符</h3> <p>operator+ 和 operator+=是不一样的，所以如果想要重载+号，就最好重载+=，那么一个比较好的方法就是把+号用+=来实现，当然如果可以的话，可以使用模板编写：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">const</span> <span class="n">T</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">T</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">const</span> <span class="n">T</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">T</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span> <span class="o">-=</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div> <h3 id="5-release-模式防止变量被优化">5. release 模式防止变量被优化</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>volatile
</code></pre></div></div> <h3 id="6-通过引用捕获异常">6. 通过引用捕获异常</h3> <p>使用指针方式捕获异常：不需要拷贝对象，是最快的,但是，程序员很容易忘记写 static，如果忘记写 static 的话，会导致异常在抛出后，因为离开了作用域而失效：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void someFunction(){
    static exception ex;
    throw &amp;ex;
}
void doSomething(){
    try{
        someFunction();
    }
    catch(exception *ex){...}
}
</code></pre></div></div> <p>创建堆对象抛出异常：new exception 不会出现异常失效的问题，但是会出现在捕捉以后是否应该删除他们接受的指针，在哪一个层级删除指针的问题 通过值捕获异常：不会出现上述问题，但是会在被抛出时系统将异常对象拷贝两次，而且会出现派生类和基类的 slicing problem，即派生类的异常对象被作为基类异常对象捕获时，会把派生类的一部分切掉，例如：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class exception{
public:
    virtual const char *what() throw();
};
class runtime_error : public exception{...};
void someFunction(){
    if(true){
        throw runtime_error();
    }
}
void doSomething(){
    try{
        someFunction();
    }
    catch(exception ex){
        cerr &lt;&lt; ex.what(); //这个时候调用的就是基类的what而不是runtime_error里面的what了，而这个并不是我们想要的
    }
}
</code></pre></div></div> <p>通过引用捕获异常：可以避免上面所有的问题，异常对象也只会被拷贝一次：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void someFunction(){...} //和上面一样
void doSomething(){
    try{...}             //和上面一样
    catch(exception&amp; ex){
        cerr &lt;&lt; ex.what(); //这个时候就是调用的runtime_error而不是基类的exception::what()了，其他和上面其实是一样的
    }
}
</code></pre></div></div> <p>这段文字讨论了在 C++ 中抛出异常、传递参数和调用虚函数之间的不同点，特别是它们在处理方式和行为上的差异。以下是对这段文字的详细解释：</p> <h3 id="7-传递参数和捕获异常的相同点和不同点">7. 传递参数和捕获异常的相同点和不同点</h3> <ul> <li><strong>相同点</strong></li> </ul> <p>传递参数和捕获异常的方式可以是传值、传引用或者传指针。例如：</p> <ul> <li> <p>传递参数的函数：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="n">Widget</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p>捕获异常的 [<code class="language-plaintext highlighter-rouge">catch</code>]子句：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">catch</span><span class="p">(</span><span class="n">Widget</span> <span class="n">w</span><span class="p">)...</span>
</code></pre></div> </div> </li> </ul> <p>这两种方式都可以通过传值、传引用或传指针来进行参数传递或异常捕获。</p> <ul> <li> <p><strong>不同点</strong></p> </li> <li><strong>控制权的返回</strong>： <ul> <li>调用函数时，程序的控制权会返回到函数的调用处。</li> <li>抛出异常时，控制权永远不会回到抛出异常的地方。</li> </ul> </li> <li><strong>三种捕获异常的方法</strong></li> </ul> <ol> <li> <p><strong>传值捕获</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">catch</span><span class="p">(</span><span class="n">Widget</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div> </div> <ul> <li>捕获异常对象的副本。</li> </ul> </li> <li> <p><strong>传引用捕获</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">catch</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div> </div> <ul> <li>捕获异常对象的引用。</li> </ul> </li> <li> <p><strong>传常量引用捕获</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">);</span>
</code></pre></div> </div> <ul> <li>捕获异常对象的常量引用。</li> </ul> </li> </ol> <ul> <li> <p><strong>捕获异常的注意事项</strong></p> </li> <li>一个被抛出的对象可以通过普通的引用捕获，不需要通过指向 [<code class="language-plaintext highlighter-rouge">const</code>]对象的引用捕获。</li> <li>在函数调用中，不允许传递一个临时对象到一个非 [<code class="language-plaintext highlighter-rouge">const</code>]引用类型的参数中。</li> <li> <p>异常抛出时实际上是抛出对象创建的临时对象的拷贝。</p> </li> <li><strong>类型转换</strong></li> </ul> <p>在 [<code class="language-plaintext highlighter-rouge">try</code>]语句块中，抛出的异常不会进行类型转换（除了继承类和基类之间的类型转换，以及类型化指针转变成无类型指针的转换）。例如：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="n">value</span><span class="p">;</span> <span class="c1">// value 可以是 int 也可以是 double 等其他类型的值</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 这里只处理 double 类型的异常，如果遇到 int 或者其他类型的异常则不予理会</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>在这个例子中，[<code class="language-plaintext highlighter-rouge">catch</code>]子句只处理 [<code class="language-plaintext highlighter-rouge">double</code>]类型的异常，如果抛出的是 [<code class="language-plaintext highlighter-rouge">int</code>]类型的异常，则不会被捕获。</p> <ul> <li><strong>捕获异常的顺序</strong></li> </ul> <p>异常捕获是按照顺序进行的。如果有多个 [<code class="language-plaintext highlighter-rouge">catch</code>]子句，程序会优先进入第一个匹配的 [<code class="language-plaintext highlighter-rouge">catch</code>]子句。例如：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span> <span class="p">{</span>
    <span class="c1">// 可能抛出异常的代码</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 捕获 std::exception 类型的异常</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(...)</span> <span class="p">{</span>
    <span class="c1">// 捕获所有类型的异常</span>
<span class="p">}</span>
</code></pre></div></div> <p>在这个例子中，如果抛出的是 <code class="language-plaintext highlighter-rouge">std::exception</code> 类型的异常，会优先进入第一个 [<code class="language-plaintext highlighter-rouge">catch</code>]子句。如果没有匹配的 [<code class="language-plaintext highlighter-rouge">catch</code>]子句，则会进入第二个捕获所有类型异常的 [<code class="language-plaintext highlighter-rouge">catch</code>]子句。</p> <ul> <li> <p><strong>总结</strong></p> </li> <li><strong>传递参数和捕获异常的方式</strong>：可以是传值、传引用或传指针。</li> <li><strong>控制权的返回</strong>：函数调用会返回控制权，异常抛出不会。</li> <li><strong>捕获异常的方法</strong>：可以通过传值、传引用或传常量引用捕获异常。</li> <li><strong>类型转换</strong>：异常抛出时不会进行类型转换，除了继承类和基类之间的类型转换。</li> <li><strong>捕获顺序</strong>：异常捕获是按照顺序进行的，优先进入第一个匹配的 [<code class="language-plaintext highlighter-rouge">catch</code>]子句。</li> </ul> <p>通过理解这些差异，可以更好地编写和调试 C++ 程序，确保异常处理机制的正确性和有效性。</p>]]></content><author><name></name></author><category term="程序设计"/><category term="开发规范"/><summary type="html"><![CDATA[c++ guideline]]></summary></entry><entry><title type="html">内存的链接方式</title><link href="https://marco-hmc.github.io/blog/2025/1_%E5%86%85%E5%AD%98%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%86%85%E5%AD%98%E8%A3%85%E5%85%A5.md/" rel="alternate" type="text/html" title="内存的链接方式"/><published>2025-05-04T00:00:00+00:00</published><updated>2025-05-04T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/1_%E5%86%85%E5%AD%98%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%86%85%E5%AD%98%E8%A3%85%E5%85%A5.md</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/1_%E5%86%85%E5%AD%98%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%86%85%E5%AD%98%E8%A3%85%E5%85%A5.md/"><![CDATA[<h2 id="内存的链接方式">内存的链接方式</h2> <p>内存的链接方式主要有三种：静态链接、装入时动态链接和运行时动态链接。</p> <h3 id="1-静态链接">1. 静态链接</h3> <p>静态链接是在程序运行之前，将各目标模块及它们所需的库函数链接成一个完整的可执行文件（装入模块），即得到完整的逻辑地址，之后不再拆开。这种方式的优点是执行效率高，因为所有的模块都已经链接好了，缺点是浪费内存空间，因为即使程序只使用了部分模块，整个可执行文件也会被全部装入内存。 <img src="imgs/image-3.png" alt="Alt text"/></p> <h3 id="2-装入时动态链接">2. 装入时动态链接</h3> <p>装入时动态链接是在程序运行时，边装入边链接的链接方式。这种方式的优点是可以节省内存空间，因为只有在程序需要使用某个模块时，才会将该模块装入内存并进行链接，缺点是会增加程序的启动时间，因为在程序启动时需要进行链接操作。 <img src="imgs/image-4.png" alt="Alt text"/></p> <h3 id="3-运行时动态链接">3. 运行时动态链接</h3> <p>运行时动态链接是在程序运行时，需要用到哪个模块才对它进行链接，用不到的模块不需要装入内存。这种方式的优点是可以进一步节省内存空间，因为只有在程序需要使用某个模块时，才会将该模块装入内存并进行链接，缺点是会增加程序的运行时开销，因为在程序运行时需要进行链接操作。</p> <p><img src="imgs/image-5.png" alt="Alt text"/></p> <p>运行时动态链接的实现需要操作系统的支持，通常是通过动态链接库（DLL）来实现的。在 Windows 系统中，DLL 是一种可执行文件，它包含了一些可以被多个程序共享的代码和数据。当程序需要使用 DLL 中的函数或数据时，操作系统会将 DLL 加载到内存中，并将程序的调用重定向到 DLL 中的相应函数或数据。</p> <h3 id="4-总结">4. 总结</h3> <p>三种内存链接方式各有优缺点，选择哪种方式取决于程序的需求和运行环境。静态链接适用于对执行效率要求高、内存资源充足的场景；装入时动态链接适用于对启动时间要求不高、内存资源有限的场景；运行时动态链接适用于对内存资源要求极高、程序运行时需要动态加载模块的场景。</p> <h2 id="内存的装入方式">内存的装入方式</h2> <h3 id="1-什么是内存的装入">1 什么是内存的装入</h3> <p>内存的装入是指将程序或数据从磁盘加载到内存中的过程。这是程序运行的一个重要步骤，因为 CPU 只能直接访问内存中的数据，不能直接访问磁盘中的数据。</p> <p>在装入过程中，操作系统通常会进行以下操作：</p> <ol> <li><strong>分配内存</strong>：操作系统会为程序分配足够的内存空间。这个空间通常包括代码段（用于存放程序的指令）、数据段（用于存放程序的全局变量）和堆栈段（用于存放局部变量和函数调用的信息）。</li> <li><strong>加载程序</strong>：操作系统会将程序的代码和数据从磁盘读取到内存中。</li> <li><strong>重定位</strong>：如果程序不能被加载到它预期的内存地址，操作系统会进行重定位，修改程序的地址信息，使得程序可以在实际加载的地址上正确运行。</li> <li><strong>启动程序</strong>：操作系统会将 CPU 的控制权交给程序，开始执行程序的指令。</li> </ol> <p>请注意，以上描述的是一种简化的装入过程。在实际的操作系统中，装入过程可能会更复杂，包括动态链接、虚拟内存管理等操作。</p> <h3 id="2-绝对装入">2 绝对装入</h3> <p>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。这种方式只适用于单道程序环境。</p> <h3 id="3-可重定位装入静态装入">3 可重定位装入（静态装入）</h3> <p>又称可重定位装入。编译、链接后的装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“重定位”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。</p> <h3 id="4-动态运行时装入动态装入">4 动态运行时装入（动态装入）</h3> <p>又称动态运行时装入。编译、链接后的装入模块的地址都是从 0 开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。采用动态重定位时允许程序在内存中发生移动。</p> <h3 id="总结">总结</h3> <p>内存的装入方式主要有绝对装入、可重定位装入和动态运行时装入。不同的装入方式适用于不同的环境和需求。绝对装入适用于单道程序环境，可重定位装入和动态运行时装入则适用于多道程序环境，其中动态运行时装入更加灵活，允许程序在内存中移动。</p> <p>所以内存链接和内存装入的关系是什么？</p>]]></content><author><name></name></author><category term="计算机系统"/><category term="内存"/><summary type="html"><![CDATA[内存的链接方式]]></summary></entry><entry><title type="html">计算机系统中的开发需知</title><link href="https://marco-hmc.github.io/blog/2025/0_os.md/" rel="alternate" type="text/html" title="计算机系统中的开发需知"/><published>2025-05-03T00:00:00+00:00</published><updated>2025-05-03T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/0_os.md</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/0_os.md/"><![CDATA[<h2 id="计算机系统中的开发需知">计算机系统中的开发需知</h2> <ul> <li>操作系统的本质上是一种运行环境，也可以进一步理解为一种状态机模型。操作系统与硬件密切相关，它负责管理和控制计算机的硬件资源，为程序提供一个稳定、高效的运行平台。作为运行环境，操作系统为程序提供了多种服务，包括但不限于资源管理（如内存、CPU、I/O 设备等）、进程管理、文件管理等；作为状态机模型，操作系统会根据各种事件（如用户输入、硬件中断、系统调用等）在不同状态之间转换，实现对系统资源的高效管理和系统的稳定运行。无论是运行环境，还是状态机模型，都凸显了操作系统在计算机系统中的重要地位。</li> </ul> <blockquote> <p>可以看成是一种运行环境的理解是这样的，首先是一个单核机器，如果一个程序陷入了死循环，那么这个机器还能接收信号吗？比如说鼠标、键盘等中断信号。是可以的，因为程序的运行本来就是依托于 os 这个运行环境的，程序死循环运行也还是在这个运行环境内。这个运行环境本来就有被中断信号打断的能力，并且在处理中断时，操作系统会保存程序的当前状态（如程序计数器和寄存器的值），以便在处理完中断后能正确恢复程序的执行，因此即使单核机器死循环了，也不代表着无法处理中断信号。</p> </blockquote> <h3 id="1-基本概念">1. 基本概念</h3> <h4 id="11-用户态和内核态">1.1 用户态和内核态</h4> <ul> <li>用户态和内核态的区别 <ul> <li>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同</li> <li>用户态拥有最低的特权级，内核态拥有较高的特权级</li> <li><strong>运行在用户态的程序不能直接访问操作系统内核数据结构和程序</strong></li> <li>操作系统的<strong>数据都是存放于系统空间的</strong>，<strong>用户进程的数据是存放于用户空间的</strong>。 分开来存放，就让系统的数据和用户的数据<strong>互不干扰</strong>，<strong>保证系统的稳定性</strong></li> <li>分开存放，管理上很方便，而更重要的是，<strong>将用户的数据和系统的数据隔离开</strong>，就可以<strong>对两部分的数据的访问进行控制</strong>。这样就可以确保用户程序不能随便操作系统的数据，这样<strong>防止用户程序误操作或者是恶意破坏系统</strong></li> </ul> </li> <li><a href="http://blog.chinaunix.net/uid-26611973-id-3190018.html">用户态和内核态可以通过指针传递数据吗？</a> <ul> <li><strong>用户态不能访问内核态的指针</strong> <ul> <li>为了实现内存的保护，<strong>防止越界访问而造成受保护内存的被非法修改</strong>，甚至造成系统的崩溃，这种直接传递数据指针来传递数据的方式是被禁止的。</li> </ul> </li> <li>内核态可以访问用户态的指针(<strong>有前提</strong>) <ul> <li><strong>必须保证用户态虚拟空间的指针</strong>（虚拟空间的地址），<strong>已经分配物理地址</strong>，<strong>否则指针传入内核态中将不会引发缺页异常而报错</strong></li> </ul> </li> <li><strong>内核中访问用户进程的地址的时候用 copy_from_user，而不是用 memcpy 直接拷贝</strong>(或者说使用用户态指针) <ul> <li>copy_from_user 主要是这个函数提供了两个功能 <ul> <li>对用户进程传过来的地址范围进行合法性检查</li> <li>当用户传来的地址没有分配物理地址时，定义了缺页处理后的异常发生地址，保证程序顺利执行</li> <li><strong>对于用户进程访问虚拟地址，如果还未分配物理地址，就会触发内核缺页异常，接着内核会负责分配物理地址，并修改映射页表</strong>。这个过程对于用户进程是完全透明的。<strong>但是在内核空间发生缺页时，必须显式处理，否则会导致内核出现错误</strong></li> </ul> </li> <li>直接使用 memcpy 时为什么没有出现异常 <ul> <li><strong>只有用户传来的地址空间没有分配对应的物理地址时才会进行修复，如果用户进程之前已经使用过这段空间，代表已经分配了物理地址，自然不会发生缺页异常</strong></li> </ul> </li> </ul> </li> </ul> </li> <li><strong>两种状态转换</strong> <ul> <li><strong>系统调用</strong> <ul> <li>用户进程<strong>主动要求切换</strong>到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作</li> </ul> </li> <li><strong>异常</strong> <ul> <li>当 CPU 在执行运行在用户态的程序时，发现了<strong>某些事件不可知的异常</strong>，这是会<strong>触发由当前运行进程切换到处理此异常的内核相关程序</strong>中，也就到了内核态，比如缺页异常</li> </ul> </li> <li><strong>外围设备中断</strong> <ul> <li>当外围设备完成用户请求的操作之后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序</li> <li>比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等</li> </ul> </li> </ul> </li> <li> <p>当发生用户态到内核态的切换时，会发生如下过程（本质上是从“用户程序”切换到“内核程序”）</p> <ul> <li>trap 指令设置处理器至内核态</li> <li>保存当前寄存器（栈指针、程序计数器、通用寄存器）</li> <li>将栈指针设置指向内核栈地址(用户栈切换为内核栈)</li> <li>将程序计数器设置为一个事先约定的地址上，该地址上存放的是<strong>系统调用处理程序的起始(入口)地址</strong></li> </ul> <p>而之后从内核态返回用户态时，又会进行类似的工作</p> </li> <li>如何避免频繁切换</li> </ul> <p>用户态和内核态之间的切换有一定的开销，如果频繁发生切换势必会带来很大的开销，所以要想尽一切办法来减少切换。这也是面试常考的问题。</p> <ul> <li> <p>减少线程切换：因为线程的切换会导致用户态和内核态之间的切换，所以减少线程切换也会减少用户态和内核态之间的切换</p> </li> <li>无锁并发编程。多线程竞争锁时，加锁、释放锁会导致比较多的上下文切换</li> <li>CAS 算法。使用 CAS 避免加锁，避免阻塞线程</li> <li>使用最少的线程。避免创建不需要的线程</li> <li>协程。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换</li> <li> <p>使用用户进程缓冲区：buffer，减少系统调用的调用次数</p> </li> <li> <p>用户进程缓冲区和内核缓冲区</p> <ul> <li> <p>用户进程缓冲区</p> <ul> <li>你看一些程序在读取文件时，会先申请一块内存数组，称为 buffer，然后每次调用 read，读取设定字节长度的数据，写入 buffer。之后的程序都是从 buffer 中获取数据，当 buffer 使用完后，在进行下一次调用，填充 buffer。所以说：用户缓冲区的目的就是是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。除了在进程中设计缓冲区，内核也有自己的缓冲区。</li> </ul> </li> <li> <p>内核缓冲区</p> <ul> <li>当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，当然不同的 IO 模型，在调度和使用内核缓冲区的方式上有所不同</li> </ul> </li> </ul> </li> <li>程序计数器 PC 和指令指针寄存器 IP <ul> <li>程序计数器 PC <ul> <li>用指令事先编好的程序连续存放在内存程序区中，靠地址+1 的方法连续取指执行”。在八位机 8080CPU 中是采用先取指后执行的串行操作的原理，而其中执行地址+1 指令寻址的部件就是程序计数器 PC。那么在程序的执行过程中，PC 始终是指向下一条要执行的指令</li> <li>结论：PC 中的地址就是需要转移、循环、调用子程序和中断子程序等操作时的断点</li> </ul> </li> <li>指令指针寄存器 IP <ul> <li>在向上兼容的十六位机 8086CPU 中首先分为两个功能部件，即总线接口部件 BIU 和执行部件 EU，BIU 负责取指令，EU 负责译码执行。并且当 BIU 执行指令排队栈中的六个字节装满后，（8088CPU 是 4 个字节），EU 开始从指令排队栈的出栈口，取指令进行译码执行，同时 BIU 并行操作向入栈口补充一条取指令命令</li> <li>指令指针 IP 则是指向下个条要取指的指令，而不是 EU 要执行的指令。而断点则应该是要执行的指令内存地址，而不是 IP 内的下一条要取指的指令地址</li> </ul> </li> <li><strong>PC 是模型机中的概念，IP 是实际使用的，调试时我们发现，IP 实现的就是 PC 的功能</strong></li> </ul> </li> </ul> <h4 id="11-系统调用">1.1 系统调用</h4> <ul> <li> <p>什么是系统调用</p> <p>OS 提供给用户编程时的一些公共子程序，一般为函数或方法</p> </li> <li> <p>为什么要使用系统调用？</p> <p>OS <strong>为了安全的管理计算机软硬件资源，不允许程序员直接操作系统资源</strong>，比如（进程、内存、I/O、文件），但是用户可以通过系统调用向 OS 请求相关资源的服务，比如：I/O 的请求和释放、设备启动、文件的创建、读写、删除、进程的创建、撤销、阻塞、唤醒进程间的消息传递、内存的配备和回收等</p> </li> <li> <p>程序员如何使用系统调用，OS 如何响应？</p> <p>程序员在代码中首先传递系统调用参数，然后由陷入（trap）指令负责将用户态转换为核心态，从用户栈切换到内核栈，并将返回地址压栈备用，然后 CPU 执行相应的内核服务程序，最后返回用户态</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">int 0x80</code>指令会让 cpu 陷入中断，执行对应的 0x80 中断处理函数。不过在这之前，cpu 还需要进行<strong>栈切换</strong></p> <p>因为在 linux 中，<strong>用户态和内核态使用的是不同的栈</strong>（可以看看这篇<a href="https://blog.csdn.net/yangkuanqaz85988/article/details/52403726">文章</a>），两者负责各自的函数调用，互不干扰。在执行<code class="language-plaintext highlighter-rouge">int $0x80</code>时，程序需要由用户态切换到内核态，所以程序当前栈也要<strong>从用户栈切换到内核栈</strong>。与之对应，当中断程序执行结束返回时，当前栈要<strong>从内核栈切换回用户栈</strong></p> <p>这里说的当前栈指的就是 ESP 寄存器的值所指向的栈。ESP 的值位于用户栈的范围，那程序的当前栈就是用户栈，反之亦然。此外寄存器 SS 的值指向当前栈所在的页。因此，将用户栈切换到内核栈的过程是：</p> <ol> <li>将当前 ESP、SS 等寄存器的值存到内核栈上</li> <li>将 ESP、SS 等值设置为内核栈的相应值</li> </ol> <p>反之，从内核栈切换回用户栈的过程：恢复 ESP、SS 等寄存器的值，也就是用保存在内核栈的原 ESP、SS 等值设置回对应寄存器</p> </li> <li> <p>为什么需要单独的进程内核栈？</p> <p>所有进程运行的时候，都可能通过系统调用陷入内核态继续执行。假设第一个进程 A 陷入内核态执行的时候，需要等待读取网卡的数据，主动调用 schedule() 让出 CPU；此时调度器唤醒了另一个进程 B，碰巧进程 B 也需要系统调用进入内核态。那问题就来了，如果内核栈只有一个，那进程 B 进入内核态的时候产生的压栈操作，必然会破坏掉进程 A 已有的内核栈数据；一但进程 A 的内核栈数据被破坏，很可能导致进程 A 的内核态无法正确返回到对应的用户态了</p> </li> </ul> <h4 id="11-中断">1.1 中断</h4> <ul> <li> <p>操作系统一般是通过中断来从用户态切换到内核态</p> </li> <li>中断一般有两个属性，一个是<strong>中断号</strong>，一个是<strong>中断处理程序</strong>。不同的中断有不同的中断号，每个中断号都对应了一个中断处理程序。在内核中有一个叫<strong>中断向量表</strong>的数组来映射这个关系。当中断到来时，cpu 会暂停正在执行的代码，根据中断号去中断向量表找出对应的中断处理程序并调用。中断处理程序执行完成后，会继续执行之前的代码</li> <li>中断分为硬件中断和软件中断，我们这里说的是软件中断，软件中断通常是一条指令，使用这条指令用户可以手动触发某个中断。例如在 i386 下，对应的指令是 int，在 int 指令后指定对应的中断号，如 int 0x80 代表你调用第 0x80 号的中断处理程序</li> <li> <p>中断号是有限的，所有不会用一个中断来对应一个系统调用（系统调用有很多）。<strong>Linux 下用 int 0x80 触发所有的系统调用</strong>，那如何区分不同的调用呢？<strong>对于每个系统调用都有一个系统调用号，在触发中断之前，会将系统调用号放入到一个固定的寄存器，0x80 对应的中断处理程序会读取该寄存器的值，然后决定执行哪个系统调用的代码</strong></p> </li> <li> <p><strong><em>什么是计算机系统?</em></strong></p> <p>​ 操作系统(Operating System, OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的程序集合。计算机操作系统是随着计算机研究和应用的发展逐步形成并发展起来的，它是计算机系统中最基本的系统软件。</p> </li> <li> <p><strong><em>计算机系统主要研究什么?</em></strong></p> <p>​ 计算机系统是硬件以及应用软件之间的一个桥梁，相关的内存/文件/输入输出等硬件都由计算机系统负责，除此之外，为了提高 CPU 的利用率，计算机系统也研究多进程和多线程等提高 CPU/内存等资源利用的方法。</p> <p>​ 具体来说，操作系统主要研究以下几个方面:</p> <ul> <li><strong>线程/进程管理</strong></li> <li><strong>内存管理/磁盘管理</strong></li> <li><strong>网络</strong></li> <li><strong>I/O 设备管理(外设管理)</strong></li> <li>文件系统</li> <li>错误检测以及处理</li> <li>命令解释系统(Command Interprter System)</li> </ul> </li> <li> <p><strong><em>计算机系统的发展史</em></strong></p> </li> <li>裸机时代 主要是人工操作，程序员将对应用程序和数据的已穿孔的纸带(或卡片)装入输入机，然后启动输入机把程序和数据输入计算机内存，接着通过控制台开关启动程序针对数据运行;计算完毕，打印机输出计算结果;用户取走结果并卸下纸带(或卡片)后，才让下一个用户上机。 <ul> <li>单道批处理系统 特点是一次只能运行一个进程，只有运行完毕后才能将下一个进程加载到内存里面，所以进程的数据都是直接放在物理内存上的，因此 CPU 是直接操作内存的物理地址，这个时候不存在虚拟逻辑地址，因为一次只能运行一个程序。</li> <li>多道批处理系统 到后来发展出了多道程序系统，它要求在计算机中存在着多个进程，处理器需要在多个进程间进行切换，当一道程序因 I/O 请求而暂停运行时，CPU 便立即转去运行另一道程序。 问题来了，这么多进程，内存不够用怎么办，各个进程同时运行时内存地址互相覆盖怎么办? 这时候就出现问题了，链接器在链接一个可执行文件的时候，总是默认程序的起始地址为 0x0,但物理内存上只有一个 0x0 的地址呀?也许你会说:”没关系，我们可以在程序装入内存的时候再次动态改变它的地址。”好吧我忍了。但如果我的物理内存大小只有 1G,而现在某一个程序需要超过 1G 的空间怎么办呢?你还能用刚才那句话解释吗? 操作系统的发展，包括后面的分时系统，其实都是在解决协调各个环节速度不匹配的矛盾。</li> </ul> </li> </ul> <h3 id="2-cpu内核篇">2. CPU/内核篇</h3> <ul> <li> <p><strong><em>应用软件层是可以对硬件进行任何操作吗?</em></strong></p> <p>​ 虽然前面说了，计算机系统是硬件以及应用软件之间的一个桥梁。但是应用软件并不是享有对硬件所有资源使用权限的，否则软件程序因可能因为误操作/或者恶意软件给系统带来破坏。为此区分了用户态和内核态。</p> </li> <li> <p><strong><em>什么是用户态和内核态，区别是什么?</em></strong></p> <ul> <li>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同</li> <li>用户态拥有最低的特权级，内核态拥有较高的特权级</li> <li><strong>运行在用户态的程序不能直接访问操作系统内核数据结构和程序</strong></li> <li>操作系统的<strong>数据都是存放于系统空间的</strong>,<strong>用户进程的数据是存放于用户空间的</strong>. 分开来存放，就让系统的数据和用户的数据<strong>互不干扰</strong>,<strong>保证系统的稳定性</strong></li> <li>分开存放，管理上很方便，而更重要的是，<strong>将用户的数据和系统的数据隔离开</strong>,就可以<strong>对两部分的数据的访问进行控制</strong>.这样就可以确保用户程序不能随便操作系统的数据，这样<strong>防止用户程序误操作或者是恶意破坏系统</strong></li> </ul> </li> <li> <p><strong><em>那应用软件可以进入内核态吗?</em></strong></p> <p>​ 应用软件在两种情况下可以进入内核态。</p> <ul> <li>系统调用:应用软件只可以通过系统封装好的 API,即以系统调用的方式进入内核态。以此限制应用软件对内核态恶意的操作。</li> <li>异常:当 CPU 在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此异常的内核相关程序中，也就到了内核态，比如缺页异常。</li> </ul> </li> <li> <p><strong><em>用户态切换到内核态的时候发生了什么?</em></strong></p> <ul> <li>trap 指令设置处理器至内核态</li> <li>保存当前寄存器(栈指针/程序计数器/通用寄存器)</li> <li>将栈指针设置指向内核栈地址(用户栈切换为内核栈)</li> <li>将程序计数器设置为一个事先约定的地址上，该地址上存放的是<strong>系统调用处理程序的起始(入口)地址</strong></li> </ul> <blockquote> <p>每次用户态和内核态的切换是有一定开销的</p> </blockquote> </li> <li> <p><strong><em>如何避免用户态和内核态频繁切换带来的开销?</em></strong></p> <ul> <li> <p>减少线程切换:因为线程的切换会导致用户态和内核态之间的切换，所以减少线程切换也会减少用户态和内核态之间的切换</p> </li> <li>无锁并发编程。多线程竞争锁时，加锁/释放锁会导致比较多的上下文切换</li> <li>CAS 算法。使用 CAS 避免加锁，避免阻塞线程</li> <li>使用最少的线程。避免创建不需要的线程</li> <li>协程。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换</li> <li>使用用户进程缓冲区:buffer,减少系统调用的调用次数</li> </ul> </li> </ul> <h2 id="操作系统的定义">操作系统的定义</h2> <p>操作系统为计算机设备提供了一个运行环境，并对硬件进行控制。 操作系统通过指令集与硬件交互，管理进程、内存、文件系统和设备。 操作系统可以被看作是一个基于硬件的复杂状态机，状态机的状态存在于寄存器和内存中，CPU 通过读取这些状态执行相应的操作。通过这些机制，操作系统能够高效地管理和调度计算机资源，确保系统的稳定和安全。</p> <p>如果是从计算机的角度出发. 我感觉可以这么理解. 计算机 = 程序+硬件 现代计算机 = 程序+硬件+操作系统</p> <p>操作系统（OS）是管理计算机硬件和软件资源的系统软件，为计算机程序提供一个运行环境。操作系统的主要功能包括：</p> <ol> <li> <p><strong>进程管理</strong>：</p> <ul> <li>创建、调度和终止进程。</li> <li>提供进程间通信和同步机制。</li> </ul> </li> <li> <p><strong>内存管理</strong>：</p> <ul> <li>分配和释放内存。</li> <li>管理虚拟内存和物理内存。</li> </ul> </li> <li> <p><strong>文件系统管理</strong>：</p> <ul> <li>提供文件和目录的创建、删除、读写等操作。</li> <li>管理文件系统的结构和存储。</li> </ul> </li> <li> <p><strong>设备管理</strong>：</p> <ul> <li>管理输入输出设备，如键盘、鼠标、显示器、磁盘等。</li> <li>提供设备驱动程序，处理设备的中断和请求。</li> </ul> </li> <li> <p><strong>用户接口</strong>：</p> <ul> <li>提供命令行界面（CLI）或图形用户界面（GUI），供用户与系统交互。</li> </ul> </li> </ol> <h3 id="操作系统对硬件的控制">操作系统对硬件的控制</h3> <p>操作系统能够对计算机设备的所有硬件进行控制，这种控制能力来源于指令集架构（ISA）。指令集是处理器支持的指令的集合，操作系统通过这些指令与硬件进行交互。</p> <h4 id="指令执行过程">指令执行过程</h4> <ol> <li> <p><strong>获取指令</strong>：</p> <ul> <li>指令可以通过输入输出（IO）设备获取，或者在程序运行时将指令加载到内存中，从内存读取指令。</li> </ul> </li> <li> <p><strong>指令译码</strong>：</p> <ul> <li>CPU 从内存中读取指令，并对指令进行译码，确定需要执行的操作。</li> </ul> </li> <li> <p><strong>执行操作</strong>：</p> <ul> <li>CPU 根据译码结果，调用相关硬件资源（如寄存器、算术逻辑单元等）执行操作。</li> </ul> </li> <li> <p><strong>写回结果</strong>：</p> <ul> <li>执行操作的结果写回到目标地址（寄存器或内存）。</li> </ul> </li> </ol> <h3 id="操作系统的运行环境">操作系统的运行环境</h3> <p>操作系统为程序提供了一个完善的运行环境，控制流程如下：</p> <ol> <li> <p><strong>指令存储</strong>：</p> <ul> <li>操作系统将指令存储在内存的特定区域，称为代码段（Code Segment）。程序运行时，指令加载到代码段中，实现了可编程性。</li> </ul> </li> <li> <p><strong>事件中断</strong>：</p> <ul> <li>当发生事件中断时，操作系统将中断信号插入到指令流中，实现交互操作。中断处理程序会处理中断事件，并恢复正常执行。</li> </ul> </li> <li> <p><strong>内存管理</strong>：</p> <ul> <li>操作系统负责内存的分配和释放，标记内存的使用状态。当程序需要申请内存时，操作系统会处理内存请求，并分配适当的内存区域。</li> </ul> </li> </ol> <h3 id="操作系统的状态机模型">操作系统的状态机模型</h3> <p>操作系统可以被看作是一个基于硬件的复杂状态机。状态机的状态存在于计算机设备的各个寄存器和内存中，CPU 会读取这些状态并执行相应的操作。</p> <h4 id="状态机的状态">状态机的状态</h4> <ol> <li> <p><strong>寄存器状态</strong>：</p> <ul> <li>寄存器保存当前指令的执行状态、程序计数器、堆栈指针等信息。</li> </ul> </li> <li> <p><strong>内存状态</strong>：</p> <ul> <li>内存保存程序的代码段、数据段、堆栈段等信息。</li> </ul> </li> <li> <p><strong>设备状态</strong>：</p> <ul> <li>输入输出设备的状态，如键盘缓冲区、显示器状态等。</li> </ul> </li> </ol> <ul> <li> <p><strong><em>什么是用户态和系统态?</em></strong></p> <p>​ 由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 – 用户态和内核态.</p> <p>​ 一句话,线程在CPU的运行状态分为两种,用户态和系统态.其中系统态较用户态享有更高级的指令权限.</p> </li> </ul> <p>​</p> <p>​</p> <ul> <li>深入理解计算机系统 第3版（CSAPP） <ul> <li>先看<strong>深入理解计算机系统</strong>，操作系统方面的神书，内容非常经典，而且比较通俗易懂，适合入门，软件的话建议先学习第二部分和第三部分，再根据个人情况学习第一部分。</li> </ul> </li> <li>《程序员自我修养》 <ul> <li>如果想对<strong>编译链接</strong>的原理进行深入学习，可以参考<strong>程序员的自我修养</strong>，这本书非常详细的讲解了程序编译过程中的具体细节。</li> </ul> </li> <li>操作系统 精髓与设计原理 第8版 <ul> <li>然后再学习<strong>操作系统 精髓与设计原理</strong>，这本书比现代操作系统更通俗易懂，可以结合CSAPP一起看，两本书的知识点相互有所弥补。</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="计算机系统"/><category term="kernel"/><summary type="html"><![CDATA[计算机系统中的开发需知]]></summary></entry><entry><title type="html">引用</title><link href="https://marco-hmc.github.io/blog/2025/1_reference.md/" rel="alternate" type="text/html" title="引用"/><published>2025-05-03T00:00:00+00:00</published><updated>2025-05-03T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/1_reference.md</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/1_reference.md/"><![CDATA[<h2 id="引用">引用</h2> <p>C++ 引用概念 ├── 引言 │ ├── 引用的定义 │ └── 引用的基本语法 ├── 左值引用（Lvalue References） │ ├── 左值引用的定义 │ ├── 左值引用的初始化 │ ├── 左值引用的使用场景 │ └── 左值引用的常见错误 ├── 右值引用（Rvalue References） │ ├── 右值引用的定义 │ ├── 右值引用的初始化 │ ├── 右值引用的使用场景 │ ├── 右值引用与移动语义 │ └── 右值引用与完美转发 ├── 常量引用（Const References） │ ├── 常量引用的定义 │ ├── 常量引用的初始化 │ ├── 常量引用的使用场景 │ └── 常量引用的常见错误 ├── 引用折叠（Reference Collapsing） │ ├── 引用折叠的规则 │ ├── 引用折叠的应用场景 │ └── 引用折叠与模板编程 ├── 引用的应用 │ ├── 引用作为函数参数 │ ├── 引用作为函数返回值 │ ├── 引用与类成员 │ └── 引用与容器 ├── 引用的高级用法 │ ├── 引用与多态 │ ├── 引用与智能指针 │ └── 引用与标准库 ├── 引用的常见问题 │ ├── 引用的生命周期 │ ├── 引用的悬挂问题 │ └── 引用的初始化问题</p> <h3 id="1-引言">1. 引言</h3> <h4 id="11-引用的定义">1.1 引用的定义</h4> <ul> <li> <p><strong>什么是引用？和指针的区别是什么？</strong> <strong>引用（Reference）</strong>：</p> <ul> <li>引用是一个别名，它必须在声明时初始化，并且一旦绑定到一个对象，就不能再改变绑定。</li> <li>引用不占用额外的内存空间，它只是一个现有变量的别名。</li> </ul> <p><strong>指针（Pointer）</strong>：</p> <ul> <li>指针是一个变量，它存储另一个变量的内存地址。</li> <li>指针可以在声明后进行重新赋值，指向不同的对象。</li> <li>指针使用符号 <code class="language-plaintext highlighter-rouge">*</code> 来声明，并且可以进行算术运算（如递增、递减）。</li> <li>指针占用内存空间，因为它存储的是地址。</li> </ul> <p><strong>区别</strong>：</p> <ul> <li>引用必须在声明时初始化，而指针可以在声明后初始化。</li> <li>引用一旦绑定到一个对象，就不能再改变绑定，而指针可以指向不同的对象。</li> <li>引用不占用额外的内存空间，而指针占用内存空间。</li> <li>引用不能为 <code class="language-plaintext highlighter-rouge">null</code>，而指针可以为 <code class="language-plaintext highlighter-rouge">null</code>。</li> </ul> </li> <li> <p><strong>什么是右值引用？是解决什么问题的？</strong> <strong>右值引用（Rvalue Reference）</strong>：</p> <ul> <li>右值引用使用符号 <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> 来声明。</li> <li>右值引用可以绑定到右值（临时对象）上，而不能绑定到左值（持久对象）上。</li> <li>右值引用的主要目的是实现移动语义和完美转发。</li> </ul> <p><strong>解决的问题</strong>：</p> <ul> <li><strong>移动语义</strong> 通过移动而不是复制对象来提升性能，避免了不必要的深拷贝，减少了内存分配和释放的开销。</li> <li><strong>完美转发</strong> 是指在函数模板中，将参数完美地传递给另一个函数，保持参数的左值或右值属性，提高了代码的复用性和灵活性。</li> </ul> </li> <li> <p><strong>总结</strong> <strong>引用</strong> 是变量的别名，可以用于节省传参时的拷贝操作等。编译器内部通常通过指针方式实现引用。也就是使用指针和使用引用生成的汇编代码很多时候可能是一样的。 <strong>右值引用（Rvalue Reference）</strong> 是为了提升临时变量传参性能而引入的概念。通过右值引用，可以避免在传入函数时进行不必要的拷贝构造。右值引用表示对临时变量的别名。通过<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>表示右值。</p> <ul> <li><strong>完美转发</strong> 是为了区分是临时变量需要使用移动操作，还是左值变量是传引用操作而提出的概念。完美转发通过一种统一的方式识别是右值还是左值，并将参数完美地传递给另一个函数，保持参数的左值或右值属性。通过<code class="language-plaintext highlighter-rouge">std::forward()</code>表示传入</li> <li>完美转发和引用坍缩是同一个功能下的两个相关概念。完美转发依赖于引用坍缩来实现参数的正确传递。以下是对完美转发和引用坍缩的详细解释和补充：</li> </ul> <p><strong>完美转发（Perfect Forwarding）</strong> 是为了区分是临时变量需要使用移动操作，还是左值变量是传引用操作而提出的概念。完美转发通过一种统一的方式识别是右值还是左值，并将参数完美地传递给另一个函数，保持参数的左值或右值属性。通过 <code class="language-plaintext highlighter-rouge">std::forward()</code> 实现完美转发。 <strong>引用坍缩（Reference Collapsing）</strong> 是 C++11 引入的一种规则，用于处理模板参数中的引用类型。当模板参数涉及到引用时，引用坍缩规则决定了最终的引用类型。</p> </li> </ul> <h4 id="12-引用的概念">1.2 引用的概念</h4> <h3 id="2-左值引用">2. 左值引用</h3> <h3 id="3-右值引用">3. 右值引用</h3> <p>│ ├── 右值引用的定义 │ ├── 右值引用的初始化 │ ├── 右值引用的使用场景 │ ├── 右值引用与移动语义 │ └── 右值引用与完美转发</p> <ul> <li><strong>移动语义</strong>：C++11 引入的特性，用于优化资源管理。</li> </ul> <p>右值引用（<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>）只能绑定到右值。右值包括字面值（pure rvalue）和临时变量（xvalue）。如果将左值传递给右值引用参数，编译器将产生错误。为了在这种情况下进行类型转换，我们使用 <code class="language-plaintext highlighter-rouge">std::move</code>。</p> <p><code class="language-plaintext highlighter-rouge">std::move</code> 是一个标准库函数，实际上并不执行移动操作，而是将其参数转换为右值引用，通常用于启用移动语义。</p> <p>示例：<code class="language-plaintext highlighter-rouge">std::move</code> 和强制类型转换</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">jc</span> <span class="p">{</span>

<span class="c1">// 定义自定义的 move 函数，效果与 std::move 相同</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// 接受左值引用</span>
<span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// 接受右值引用</span>

<span class="p">}</span>  <span class="c1">// namespace jc</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span>

  <span class="c1">// 调用左值版本的 f</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">jc</span><span class="o">::</span><span class="n">f</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
  <span class="c1">// 调用右值版本的 f</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">jc</span><span class="o">::</span><span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{})</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>

  <span class="c1">// 强制类型转换为右值引用，调用右值版本</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">jc</span><span class="o">::</span><span class="n">f</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
  <span class="c1">// 使用 std::move 进行转换</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">jc</span><span class="o">::</span><span class="n">f</span><span class="p">(</span><span class="n">jc</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">jc</span><span class="o">::</span><span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// 与 std::move 等效</span>
<span class="p">}</span>
</code></pre></div></div> <p>在这个例子中：</p> <ul> <li><code class="language-plaintext highlighter-rouge">jc::f(s)</code> 调用了左值版本的 <code class="language-plaintext highlighter-rouge">f</code>。</li> <li><code class="language-plaintext highlighter-rouge">jc::f(std::string{})</code> 调用了右值版本的 <code class="language-plaintext highlighter-rouge">f</code>，因为 <code class="language-plaintext highlighter-rouge">std::string{}</code> 是一个临时对象。</li> <li><code class="language-plaintext highlighter-rouge">jc::f(static_cast&lt;std::string&amp;&amp;&gt;(s))</code> 强制将 <code class="language-plaintext highlighter-rouge">s</code> 转换为右值引用，从而调用右值版本的 <code class="language-plaintext highlighter-rouge">f</code>。</li> <li> <p><code class="language-plaintext highlighter-rouge">jc::f(jc::move(s))</code> 和 <code class="language-plaintext highlighter-rouge">jc::f(std::move(s))</code> 调用了右值版本的 <code class="language-plaintext highlighter-rouge">f</code>，因为 <code class="language-plaintext highlighter-rouge">std::move(s)</code> 实际上是将 <code class="language-plaintext highlighter-rouge">s</code> 转换为右值引用。</p> </li> <li><strong>右值引用（<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>）</strong> 是 C++11 引入的一个重要特性，它允许编译器识别右值并进行高效的资源转移，通常与 <strong>移动构造函数</strong> 和 <strong>移动赋值运算符</strong> 配合使用。</li> <li><code class="language-plaintext highlighter-rouge">std::move</code> 不是一个执行移动操作的函数，它只是将一个对象转化为右值引用，以便允许其资源的移动。</li> <li><strong>移动语义</strong> 可以极大地提升性能，尤其是在涉及大量临时对象和容器的场景中，通过避免不必要的深拷贝。</li> </ul> <h3 id="4-常量引用">4. 常量引用</h3> <h3 id="5-转发引用万能引用">5. 转发引用（万能引用）</h3> <ul> <li><strong>转发引用（俗称万能引用）</strong>：C++11 引入的特性，用于完美转发。</li> </ul> <h3 id="6-引用折叠">6. 引用折叠</h3> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-引用可以绑定到临时对象吗">1. 引用可以绑定到临时对象吗？</h4> <ul> <li><strong>引用绑定到临时对象的规则</strong> <strong>右值引用</strong>：当使用右值引用（<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>）绑定到返回的右值（例如函数返回的临时对象）时，编译器会延长右值的生命周期，使得引用继续有效。 <strong>常量左值引用</strong>：常量左值引用（<code class="language-plaintext highlighter-rouge">const T&amp;</code>）也可以绑定到临时对象。编译器会延长临时对象的生命周期，使得引用继续有效。 <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LargeObject</span><span class="o">&amp;&amp;</span> <span class="n">rvalueRef</span> <span class="o">=</span> <span class="n">createLargeObject</span><span class="p">();</span> <span class="c1">// 右值引用绑定到临时对象</span>
<span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">constRef</span> <span class="o">=</span> <span class="n">getTemporary</span><span class="p">();</span>  <span class="c1">// const 引用绑定到临时对象</span>
</code></pre></div> </div> </li> </ul> <h4 id="2-什么时候需要用move">2. 什么时候需要用move</h4> <ul> <li><strong>对于 callback 函数来说</strong>：使用 <code class="language-plaintext highlighter-rouge">std::move</code> 可以避免不必要的拷贝操作，提高性能。</li> <li><strong>对于将对象插入到容器来说</strong>：使用 <code class="language-plaintext highlighter-rouge">std::move</code> 可以直接将对象的资源移动到容器中，避免深拷贝。</li> <li><strong>交换两个对象</strong>：使用 <code class="language-plaintext highlighter-rouge">std::move</code> 可以高效地交换对象的资源，而不需要进行深拷贝。</li> </ul> <h4 id="3-为什么对于stdforward的auto形参使用decltype">3. 为什么对于std::forward的auto&amp;&amp;形参使用decltype？</h4> <ul> <li><strong>为什么对于 <code class="language-plaintext highlighter-rouge">std::forward</code> 的 <code class="language-plaintext highlighter-rouge">auto&amp;&amp;</code> 形参使用 <code class="language-plaintext highlighter-rouge">decltype</code></strong></li> </ul> <p>在 C++ 中，<code class="language-plaintext highlighter-rouge">std::forward</code> 是一个用于实现完美转发的工具。完美转发允许函数模板将参数完美地传递给另一个函数，保持参数的左值或右值属性。为了实现这一点，<code class="language-plaintext highlighter-rouge">std::forward</code> 需要知道参数的实际类型，这就是为什么需要使用 <code class="language-plaintext highlighter-rouge">decltype</code>。</p> <ul> <li> <p><strong>主要原因：</strong></p> <ol> <li><strong>保持参数的左值或右值属性</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">decltype</code> 可以获取参数的实际类型，包括它是左值引用还是右值引用。</li> <li>通过 <code class="language-plaintext highlighter-rouge">decltype</code>，<code class="language-plaintext highlighter-rouge">std::forward</code> 可以正确地将参数转发为左值或右值，从而避免不必要的拷贝或移动操作。</li> </ul> </li> <li><strong>实现完美转发</strong>： <ul> <li>完美转发的目标是将参数完美地传递给另一个函数，保持其原始的左值或右值属性。</li> <li>使用 <code class="language-plaintext highlighter-rouge">decltype</code> 可以确保 <code class="language-plaintext highlighter-rouge">std::forward</code> 能够正确地识别参数的类型，并进行相应的转发。</li> </ul> </li> </ol> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">std::forward</code> 的内部实现</strong> <code class="language-plaintext highlighter-rouge">std::forward</code> 的实现依赖于模板和 <code class="language-plaintext highlighter-rouge">decltype</code>，它根据参数的类型来决定是返回左值引用还是右值引用。以下是 <code class="language-plaintext highlighter-rouge">std::forward</code> 的典型实现：</p> </li> <li> <p><strong>示例代码：</strong></p> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="c1">// std::forward 的实现</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="s">"bad forward call"</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 普通函数</span>
<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Lvalue reference: "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Rvalue reference: "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 模板函数，使用完美转发</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">forwarder</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">process</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">forwarder</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>        <span class="c1">// 转发左值</span>
    <span class="n">forwarder</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>       <span class="c1">// 转发右值</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li> <p><strong>解释：</strong></p> </li> <li><strong><code class="language-plaintext highlighter-rouge">std::remove_reference&lt;T&gt;::type</code></strong>：这个类型萃取（type trait）用于移除类型 <code class="language-plaintext highlighter-rouge">T</code> 的引用部分，以便在 <code class="language-plaintext highlighter-rouge">forward</code> 函数中正确处理左值和右值。</li> <li><strong><code class="language-plaintext highlighter-rouge">static_cast&lt;T&amp;&amp;&gt;(t)</code></strong>：根据 <code class="language-plaintext highlighter-rouge">T</code> 的类型，将参数 <code class="language-plaintext highlighter-rouge">t</code> 转换为左值引用或右值引用。</li> <li> <p><strong><code class="language-plaintext highlighter-rouge">static_assert</code></strong>：在第二个 <code class="language-plaintext highlighter-rouge">forward</code> 函数模板中，使用 <code class="language-plaintext highlighter-rouge">static_assert</code> 确保 <code class="language-plaintext highlighter-rouge">T</code> 不是左值引用，以防止错误的转发调用。</p> </li> <li> <p><strong>总结</strong></p> </li> <li><strong>保持参数属性</strong>：使用 <code class="language-plaintext highlighter-rouge">decltype</code> 可以获取参数的实际类型，包括它是左值引用还是右值引用，从而确保 <code class="language-plaintext highlighter-rouge">std::forward</code> 能够正确地将参数转发为左值或右值。</li> <li><strong>实现完美转发</strong>：通过 <code class="language-plaintext highlighter-rouge">decltype</code> 和 <code class="language-plaintext highlighter-rouge">std::forward</code>，可以实现完美转发，保持参数的原始属性，避免不必要的拷贝或移动操作。</li> <li><strong><code class="language-plaintext highlighter-rouge">std::forward</code> 的内部实现</strong>：<code class="language-plaintext highlighter-rouge">std::forward</code> 通过模板和类型萃取来决定是返回左值引用还是右值引用，从而实现完美转发。</li> </ul> <p>通过使用 <code class="language-plaintext highlighter-rouge">decltype</code> 和 <code class="language-plaintext highlighter-rouge">std::forward</code>，可以提高代码的性能和灵活性，确保参数在传递过程中保持其原始的左值或右值属性。</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">auto&amp;&amp;</code></strong>：在 lambda 表达式中使用 <code class="language-plaintext highlighter-rouge">auto&amp;&amp;</code> 可以使参数 <code class="language-plaintext highlighter-rouge">x</code> 具有通用引用（universal reference）的性质，这样可以接受左值和右值。</li> <li><strong><code class="language-plaintext highlighter-rouge">std::forward&lt;decltype(x)&gt;(x)</code></strong>：使用 <code class="language-plaintext highlighter-rouge">decltype(x)</code> 可以获取参数 <code class="language-plaintext highlighter-rouge">x</code> 的实际类型，然后通过 <code class="language-plaintext highlighter-rouge">std::forward</code> 将其完美转发给 <code class="language-plaintext highlighter-rouge">normalize</code> 函数。这样可以保持参数的左值或右值属性，避免不必要的拷贝或移动操作。</li> </ul> <h4 id="4-一次浅拷贝和一次移动相比较性能有很大差距吗">4. 一次浅拷贝和一次移动相比较，性能有很大差距吗？</h4> <p>一次浅拷贝（Shallow Copy）和一次移动（Move）操作在性能上通常存在显著差异，尤其是在涉及到大量数据或资源密集型对象时。这种性能差异主要源于它们处理对象数据和资源的方式。</p> <ul> <li> <p><strong>浅拷贝</strong></p> <ul> <li><strong>浅拷贝</strong> 仅复制对象的非静态成员变量的值，对于指针类型的成员变量，浅拷贝只复制指针值（地址），而不复制指针所指向的数据。</li> <li>如果对象包含对动态分配内存的引用，浅拷贝可能导致多个对象指向同一内存地址，从而在析构时可能引发重复释放同一资源的问题（double free）。</li> <li>浅拷贝的性能开销通常较低，因为它不涉及新内存的分配和数据的复制。但在处理复杂对象或资源管理时，可能会引起问题。</li> </ul> </li> <li> <p><strong>移动操作</strong></p> <ul> <li><strong>移动操作</strong> 是 C++11 引入的，它通过转移一个对象的资源（如动态分配的内存）到另一个对象，而不是复制资源。</li> <li>移动操作通常涉及修改原对象的指针或资源句柄，并将其置于一个有效但未定义的状态，这样就避免了不必要的资源复制，从而大大减少了开销。</li> <li>对于包含大量数据或昂贵资源（如大型数组、容器、文件句柄等）的对象，移动操作的性能优势尤为明显。</li> </ul> </li> <li> <p><strong>性能差距</strong></p> <ul> <li>在处理大型对象或资源密集型对象时，移动操作的性能通常远超过浅拷贝，因为它避免了数据的复制，只是简单地转移了资源的所有权。</li> <li>对于小型或简单的对象，这两者之间的性能差异可能不那么明显，但移动操作仍然提供了更安全和高效的资源管理方式。 总结来说，移动操作相比于浅拷贝，在性能上通常有显著优势，尤其是在涉及大量数据或资源密集型对象时。此外，移动操作还提高了代码的安全性和资源管理的效率。</li> </ul> </li> </ul> <h4 id="7-如果都是值类型的那浅拷贝和移动有区别吗">7. 如果都是值类型的，那浅拷贝和移动有区别吗？</h4> <p>如果都是值类型的，浅拷贝和移动操作在性能上没有区别。只有在处理引用类型时，浅拷贝和移动操作的性能才会有所不同，但它们的资源管理方式不同。</p> <ul> <li><strong>主要区别：</strong> <ul> <li><strong>浅拷贝</strong>：复制对象的非静态成员变量的值，对于指针类型的成员变量，只复制指针值（地址），而不复制指针所指向的数据。</li> <li><strong>移动操作</strong>：转移对象的资源（如动态分配的内存）到另一个对象，避免不必要的资源复制。</li> <li><strong>浅拷贝</strong> 和 <strong>移动操作</strong> 在处理大型对象或资源密集型对象时，性能差异显著。移动操作通过转移资源，避免了不必要的复制，从而提高了性能。</li> <li>对于值类型，浅拷贝和移动操作在性能上没有区别，但在处理引用类型时，移动操作提供了更高效的资源管理方式。</li> </ul> </li> </ul> <h4 id="4-理解stdmove和stdforward">4. 理解std::move和std::forward</h4> <p>首先move不move任何东西，forward也不转发任何东西，在运行时，不产生可执行代码，这两个只是执行转换的函数（模板），std::move无条件的将他的参数转换成一个右值，forward只有当特定的条件满足时才会执行他的转换，下面是std::move的伪代码：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template&lt;typename T&gt;
typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; param){
    using ReturnType = typename remove_reference&lt;T&gt;::type&amp;&amp;; //see Item 9
    return static_cast&lt;ReturnType&gt;(param);
}
</code></pre></div></div> <h4 id="5-区别通用引用和右值引用">5. 区别通用引用和右值引用</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void f(Widget&amp;&amp; param);       //rvalue reference
Widget&amp;&amp; var1 = Widget();     //rvalue reference
auto&amp;&amp; var2 = var1;           //not rvalue reference
template&lt;typename T&gt;
void f(std::vector&lt;T&gt;&amp;&amp; param) //rvalue reference
template&lt;typename T&gt;
void f(T&amp;&amp; param);             //not rvalue reference
</code></pre></div></div> <ul> <li>如果一个函数的template parameter有着T&amp;&amp;的格式，且有一个deduce type T.或者一个对象被生命为auto&amp;&amp;,那么这个parameter或者object就是一个universal reference.</li> <li>如果type的声明的格式不完全是type&amp;&amp;,或者type deduction没有发生，那么type&amp;&amp;表示的是一个rvalue reference.</li> <li>universal reference如果被rvalue初始化，它就是rvalue reference.如果被lvalue初始化，他就是lvaue reference.</li> </ul> <h4 id="6-对于右值引用使用stdmove对于通用引用使用stdforward">6. 对于右值引用使用std::move，对于通用引用使用std::forward</h4> <p>右值引用仅会绑定在可以移动的对象上，如果形参类型是右值引用，则他绑定的对象应该是可以移动的</p> <ul> <li>通用引用在转发的时候，应该进行向右值的有条件强制类型转换（用std::forward）</li> <li>右值引用在转发的时候，应该使用向右值的无条件强制类型转换（用std::move)</li> <li>如果上面两个方法使用反的话，可能会导致很麻烦的事情（代码冗余或者运行期错误）</li> </ul> <p>在书中一直在强调“move”和”copy”两个操作的区别，因为move在一定程度上会效率更高一些</p> <p>但是在局部对象中这种想法是错误的：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Widget MakeWidget(){
    Widget w;
    return w; //复制，需要调用一次拷贝构造函数
}

Widget MakeWidget(){
    Widget w;
    return std::move(w);//错误！！！！！！！会造成负优化
}
</code></pre></div></div> <p>因为在第一段代码中，编译器会启用返回值优化（return value optimization RVO）,这个优化的启动需要满足两个条件：</p> <ul> <li>局部对象类型和函数的返回值类型相同</li> <li>返回的就是局部对象本身</li> </ul> <p>而下面一段代码是不满足RVO优化的，所以会带来负优化</p> <p>所以：如果局部对象可以使用返回值优化的时候，不应该使用std::move 和std:forward</p> <h4 id="7-避免重载通用引用">7. 避免重载通用引用</h4> <p>主要是因为通用引用（特别是模板），会产生和调用函数精确匹配的函数，例如现在有一个：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template&lt;typename T&gt;
void log(T&amp;&amp; name){}

void log(int name){}

short a;
log(a);
</code></pre></div></div> <p>这个时候如果调用log的话，就会产生精确匹配的log方法，然后调用模板函数</p> <p>而且在重载过程当中，通用引用模板还会和拷贝构造函数，复制构造函数竞争（这里其实有太多种情况了），只举书上的一个例子：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Person{
public:
    template&lt;typename T&gt; explicit Person(T&amp;&amp; n): name(std::forward&lt;T&gt;(n)){} //完美转发构造函数
    explicit Person(int idx); //形参为int的构造函数

    Person(const Person&amp; rhs) //默认拷贝构造函数（编译器自动生成）
    Person(Person&amp;&amp; rhs); //默认移动构造函数（编译器生成）
};

Person p("Nancy");
auto cloneOfP(p);  //会编译失败，因为p并不是const的，所以在和拷贝构造函数匹配的时候，并不是最优解，而会调用完美转发的构造函数
</code></pre></div></div> <h4 id="8-熟悉重载通用引用的替代品">8. 熟悉重载通用引用的替代品</h4> <p>这一条主要是为了解决26点的通用引用重载问题提的几个观点，特别是对构造函数（完美构造函数）进行解决方案</p> <ul> <li>放弃重载，采用替换名字的方案</li> <li>用传值来替代引用（可以提升性能但却不用增加一点复杂度</li> <li> <p>采用impl方法：</p> <p>template<typename T=""> void logAndAdd(T&amp;&amp; name){ logAndAddImpl( std::forward<T>(name), std::is_integral&lt;typename std::remove_reference<T>::type&gt;() //这一句只是为了区分是否是整形 ); }</T></T></typename></p> </li> <li>对通用引用模板加以限制（使用enable_if） class Person{ public: template&lt;typename T, typename = typename std::enable_if<condition>::type&gt;//这里的condition只是一个代号，condition可以是：!std::is_same&lt;Person, typename std::decay<T>::type&gt;::value,或者是：!std::is_base_of&lt;Person, typename std::decay<T>::type&gt;::value&amp;&amp;!std::is_integral&lt;std::remove_reference_t<T>&gt;::value explicit Person(T&amp;&amp; n); } //说实话这个代码的可读性emmmmmmmm，大概还是我太菜了。。。。</T></T></T></condition></li> </ul> <h4 id="9-理解引用折叠">9. 理解引用折叠</h4> <p>在实参传递给函数模板的时候，推导出来的模板形参会把实参是左值还是右值的信息编码到结果里面：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template&lt;typename T&gt;
void func(T&amp;&amp; param);

Widget WidgetFactory() //返回右值
Widget w;

func(w);               //T的推到结果是左值引用类型，T的结果推倒为Widget&amp;
func(WidgetFactory);   //T的推到结果是非引用类型（注意这个时候不是右值），T的结果推到为Widget
</code></pre></div></div> <p>C++中，“引用的引用”是违法的，但是上面T的推到结果是Widget&amp;时，就会出现 void func(Widget&amp; &amp;&amp; param);左值引用+右值引用</p> <p>所以事实说明，编译器自己确实会出现引用的引用（虽然我们并不能用），所以会有一个规则（我记得C++ primer note里面也讲到过）</p> <ul> <li>如果任一引用是左值引用，则结果是左值引用，否则就是右值引用</li> <li>引用折叠会在四种语境中发生：模板实例化，auto类型生成、创建和运用typedef和别名声明，以及decltype</li> </ul> <p><strong>29. 认识移动操作的缺点</strong></p> <ul> <li>假设移动操作不存在，成本高，未使用</li> <li>对于那些类型或对于移动语义的支持情况已知的代码，则无需做上述假定</li> </ul> <p>原因在于C++11以下的move确实是低效的，但是C++11及以上的支持让move操作快了一些，但是更多时候编写代码并不知道代码对C++版本的支持，所以要做以上假定</p> <h4 id="10-熟悉完美转发失败的情况">10. 熟悉完美转发失败的情况</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>template&lt;typename T&gt;
void fwd(T&amp;&amp; param){           //接受任意实参
    f(std::forward&lt;T&gt;(param)); //转发该实参到f
}

template&lt;typename... Ts&gt;
void fwd(Ts&amp;&amp;... param){        //接受任意变长实参
    f(std::forward&lt;Ts&gt;(param)...);
}
</code></pre></div></div> <p>完美转发失败的情况：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>（大括号初始化物）
f({1, 2, 3}); //没问题，{1, 2, 3}会隐式转换成std::vector&lt;int&gt;
fwd({1, 2, 3}) //错误，因为向为生命为std::initializer_list类型的函数模板形参传递了大括号初始化变量，但是之前说如果是auto的话，会推到为std::initializer_list,就没问题了。。。

（0和NULL空指针）
（仅仅有声明的整形static const 成员变量）：
class Widget{
public:
    static const std::size_t MinVals = 28; //仅仅给出了声明没有给出定义
};
fwd(Widget::MinVals);      //错误，应该无法链接，因为通常引用是当成指针处理的，而也需要指定某一块内存来让指针指涉

（重载的函数名字和模板名字）
void f(int (*fp)(int));
int processValue(int value);
int processValue(int value, int priority);
fwd(processVal); //错误，光秃秃的processVal并没有类型型别

（位域）
struct IPv4Header{
    std::uint32_t version:4,
    IHL:4,
    DSCP:6,
    ECN:2,
    totalLength:16;
};

void f(std::size_t sz); IPv4Header h;
fwd(h.totalLength); //错误
</code></pre></div></div> <ul> <li>最后，所有的失败情形实际上都归结于模板类型推到失败，或者推到结果是错误的。</li> </ul>]]></content><author><name></name></author><category term="language"/><category term="cpp"/><category term="grammar"/><category term="pointer"/><summary type="html"><![CDATA[引用]]></summary></entry></feed>