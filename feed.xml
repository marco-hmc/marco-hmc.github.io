<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="cn"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://marco-hmc.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://marco-hmc.github.io/" rel="alternate" type="text/html" hreflang="cn"/><updated>2025-05-27T16:51:03+00:00</updated><id>https://marco-hmc.github.io/feed.xml</id><title type="html">Marco’s blog</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">（一）C++对象内存模型那些事儿：基本概念</title><link href="https://marco-hmc.github.io/blog/2025/0_cppMemModel/" rel="alternate" type="text/html" title="（一）C++对象内存模型那些事儿：基本概念"/><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/0_cppMemModel</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/0_cppMemModel/"><![CDATA[<h2 id="一c对象内存模型那些事儿基本概念">（一）C++对象内存模型那些事儿：基本概念</h2> <h3 id="0-concepts">0. concepts</h3> <ul> <li><strong>什么是对象？为什么要有对象？</strong></li> </ul> <p>在长期的 C/C++开发过程中，逐渐形成了三种主要的开发范式：</p> <ul> <li>面向过程编程</li> </ul> <p>面向过程编程是一种较为基础的编程范式，以 C 语言为典型代表。在这种范式下，程序被看作是一系列函数的集合，重点在于执行的过程和步骤。它对数据结构的强调相对较少，最多只是利用<code class="language-plaintext highlighter-rouge">struct</code>来封装一些成员变量。例如，实现一个简单的计算两个整数之和的程序：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="c1">// 计算两数之和的函数</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">num1</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="n">num1</span><span class="p">,</span> <span class="n">num2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"两数之和为: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在这个例子中，数据（<code class="language-plaintext highlighter-rouge">num1</code>和<code class="language-plaintext highlighter-rouge">num2</code>）与操作它们的函数（<code class="language-plaintext highlighter-rouge">add</code>）是分离的，没有形成紧密的关联。</p> <ul> <li>抽象数据类型模型（ADT）</li> </ul> <p>随着业务逻辑的逐渐复杂，面向过程编程的局限性逐渐显现。抽象数据类型模型（ADT）应运而生，它提供了封装和抽象的能力。ADT 将数据结构和对该数据结构进行操作的函数封装在一起，形成一个独立的单元，对外隐藏其内部实现细节，只提供必要的接口。以一个简单的栈数据结构为例：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Stack</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">topIndex</span><span class="p">;</span>

<span class="nl">public:</span>
    <span class="n">Stack</span><span class="p">()</span> <span class="o">:</span> <span class="n">topIndex</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">topIndex</span> <span class="o">&lt;</span> <span class="mi">99</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">[</span><span class="o">++</span><span class="n">topIndex</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">topIndex</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">topIndex</span><span class="o">--</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 表示栈为空的错误情况</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Stack</span> <span class="n">stack</span><span class="p">;</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"弹出元素: "</span> <span class="o">&lt;&lt;</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在这个栈的 ADT 实现中，数据（<code class="language-plaintext highlighter-rouge">data</code>数组和<code class="language-plaintext highlighter-rouge">topIndex</code>）和操作它们的函数（<code class="language-plaintext highlighter-rouge">push</code>和<code class="language-plaintext highlighter-rouge">pop</code>）被封装在<code class="language-plaintext highlighter-rouge">Stack</code>类中，使用者无需了解栈的内部实现细节，只需通过提供的接口进行操作。</p> <ul> <li>面向对象模型</li> </ul> <p>面向对象模型是在 ADT 的基础上进一步发展而来，增加了继承和多态的特性。继承允许一个类从另一个类获取属性和行为，多态则使得不同类的对象可以对相同的消息做出不同的响应。C++通过<code class="language-plaintext highlighter-rouge">class</code>的指针（<code class="language-plaintext highlighter-rouge">pointers</code>）和引用（<code class="language-plaintext highlighter-rouge">references</code>）来支持多态。例如：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"动物发出声音"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Dog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"汪汪汪"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cat</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">speak</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"喵喵喵"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">makeSound</span><span class="p">(</span><span class="n">Animal</span><span class="o">&amp;</span> <span class="n">animal</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">animal</span><span class="p">.</span><span class="n">speak</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Dog</span> <span class="n">dog</span><span class="p">;</span>
    <span class="n">Cat</span> <span class="n">cat</span><span class="p">;</span>

    <span class="n">makeSound</span><span class="p">(</span><span class="n">dog</span><span class="p">);</span>
    <span class="n">makeSound</span><span class="p">(</span><span class="n">cat</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上述代码中，<code class="language-plaintext highlighter-rouge">Dog</code>和<code class="language-plaintext highlighter-rouge">Cat</code>类继承自<code class="language-plaintext highlighter-rouge">Animal</code>类，并各自重写了<code class="language-plaintext highlighter-rouge">speak</code>函数，实现了多态。通过<code class="language-plaintext highlighter-rouge">makeSound</code>函数，根据传入对象的实际类型调用相应的<code class="language-plaintext highlighter-rouge">speak</code>函数，展示了面向对象编程的灵活性。</p> <p>这三种范式的演进反映了随着业务需求的变化，对数据结构的不同要求。面向过程编程适用于简单的程序逻辑，随着业务复杂度增加，ADT 通过封装和抽象提升了代码的可维护性和复用性，而面向对象编程则在 ADT 的基础上，通过继承和多态进一步增强了代码的灵活性和扩展性，更好地应对复杂的业务场景。</p> <p>封装，继承和多态实际上都是为了适应变化快，业务复杂的场景下逐渐总结出来的一种范式。作为一种范式，他并不是一种普适的、强制的规定。但这种范式的变化，还是足以说明 OOP 对于业务开发的重要性。至于，新的编程范式，其实又逐渐不提倡继承，而是提倡组合，多态则通过组合接口类的方式去实现，如新的<code class="language-plaintext highlighter-rouge">Go</code>和<code class="language-plaintext highlighter-rouge">rust</code>皆是如此。但体会不深，就不在展开。</p> <p>本文将以 c++切入，讲述编译器为了支持 OOP，或者说为了支持封装、继承和多态需要在背后做什么。</p> <p>这三种编程范式的演进，充分反映了随着业务需求的不断变化，对数据结构的要求也在相应改变。面向过程编程因其简单直接的特点，适用于处理较为简单的程序逻辑。例如，编写一个简单的文件读取并统计行数的程序，通过按顺序编写读取文件、逐行计数等函数，就能轻松实现功能。</p> <p>然而，当业务复杂度逐渐增加时，面向过程编程在代码维护和复用方面的局限性就凸显出来。此时，ADT 通过封装和抽象提升了代码的可维护性和复用性。以实现一个简单的队列数据结构为例，ADT 将队列的数据存储（如数组或链表）以及对队列进行操作的函数（如入队、出队等）封装在一起，形成一个独立的单元。使用者无需关心队列内部是如何存储数据的，只需要通过提供的接口来操作队列，这大大提高了代码的模块化程度和复用性。</p> <p>面向对象编程则是在 ADT 的基础上，进一步增加了继承和多态的特性，从而增强了代码的灵活性和扩展性，使其能够更好地应对复杂的业务场景。例如，在一个游戏开发项目中，存在各种角色类，如战士、法师、刺客等，它们都继承自一个通用的角色类。每个具体角色类可以重写通用角色类中的某些方法（如攻击方法），以实现不同的攻击效果，这就是多态的体现。通过继承和多态，代码可以更灵活地适应不同角色的特性，同时也便于代码的扩展和维护。</p> <p>封装、继承和多态实际上是在应对变化快速、业务复杂的场景过程中，逐渐总结出来的编程范式。作为一种范式，它并非是一种普遍适用且强制遵循的规定。但这种范式的演变，足以证明 OOP 在业务开发中的重要性。</p> <p>虽说在新的编程范式中，逐渐不提倡继承，而是更倾向于使用组合的方式，多态则通过组合接口类的方式来实现。例如在 Go 语言中，没有传统意义上的继承，而是通过结构体嵌套和接口实现多态。假设有一个图形绘制的场景，定义一个<code class="language-plaintext highlighter-rouge">Shape</code>接口，包含<code class="language-plaintext highlighter-rouge">Draw</code>方法，然后不同的图形结构体（如<code class="language-plaintext highlighter-rouge">Circle</code>、<code class="language-plaintext highlighter-rouge">Rectangle</code>）实现这个接口。在使用时，通过组合不同的图形结构体来构建复杂的图形系统，而不是通过继承关系。又如 Rust 语言，通过<code class="language-plaintext highlighter-rouge">trait</code>来实现类似多态的功能，并且在结构体组合方面也有独特的设计，使得代码更加灵活和安全。</p> <p>但目前我就对 C++比较熟悉，因此本文将以 C++ 为切入点，深入讲述编译器为了支持 OOP，即支持封装、继承和多态，在背后所做的工作。</p> <h3 id="1-对象内存模型的设计">1. 对象内存模型的设计</h3> <p>C++对象内存模型的设计，聚焦于如何以零抽象成本达成封装、继承与多态。这一设计重任主要落在 C++编译器层面。C++编译器的主要功能是将 C++代码转换为汇编语言，而汇编语言直接与硬件交互，主要涉及对内存和寄存器的读写操作，以及利用 CPU 进行计算。</p> <p>具体而言，从满足 C++对象的特性需求出发，要实现零抽象成本的对象，需从编译器（或等效的汇编操作，即对寄存器和算术逻辑单元 ALU 等硬件组件的操作）角度，深入考量以下几个关键方面：</p> <p>鉴于 C++的零抽象成本语言目的，OOP 是通过零抽象成本达成封装、继承与多态的。而 C++是一种编译型语言，C++需要经由编译成汇编语言，才能运行。如此理解 OOP 是如何零成本实现的，实际上就是站在编译器层面、站在汇编层面去理解如何实现下列要求：</p> <ul> <li>成员变量和成员函数的存储</li> <li>成员函数的使用</li> <li>静态成员变量和静态成员函数的存储以及使用</li> <li>继承对象的存储和实现</li> <li>多态的实现</li> </ul> <h4 id="11-成员变量和成员函数的存储">1.1 成员变量和成员函数的存储？</h4> <ul> <li>成员变量的存储</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在这个例子中，<code class="language-plaintext highlighter-rouge">foo</code>是<code class="language-plaintext highlighter-rouge">Foo</code>类的一个对象实例，通常存储在栈上（若在函数内部定义）。对于编译器而言，<code class="language-plaintext highlighter-rouge">foo</code>在栈上有特定的地址。<code class="language-plaintext highlighter-rouge">Foo</code>类中的成员变量<code class="language-plaintext highlighter-rouge">a</code>和<code class="language-plaintext highlighter-rouge">b</code>按照其声明顺序依次存储在<code class="language-plaintext highlighter-rouge">foo</code>对象所占据的内存空间内。基于<code class="language-plaintext highlighter-rouge">foo</code>对象所在的地址，编译器会根据<code class="language-plaintext highlighter-rouge">a</code>在类中的布局位置，计算出一个特定的偏移值。当需要读取<code class="language-plaintext highlighter-rouge">a</code>的值时，编译器会按照<code class="language-plaintext highlighter-rouge">int</code>类型的大小，从<code class="language-plaintext highlighter-rouge">foo</code>对象地址加上该偏移值的位置去读取数据，从而得到<code class="language-plaintext highlighter-rouge">a</code>的值。</p> <ul> <li>访问限制符号</li> </ul> <p>C++中的访问限制符号<code class="language-plaintext highlighter-rouge">public</code>、<code class="language-plaintext highlighter-rouge">private</code>和<code class="language-plaintext highlighter-rouge">protected</code>用于控制类成员的访问权限。然而，在汇编层面并不存在这些概念。这些访问控制实际上是由编译器来实现对函数和成员变量访问的限制。</p> <p>当编译器识别到代码在类的外部尝试调用<code class="language-plaintext highlighter-rouge">private</code>修饰的函数或访问<code class="language-plaintext highlighter-rouge">private</code>成员变量时，会导致编译错误，阻止程序继续编译。需要强调的是，理论上如果深入研究编译器的内存布局规则，通过计算偏移值可以在内存层面获取到<code class="language-plaintext highlighter-rouge">private</code>成员变量的数据的。但这种做法严重违反了 C++的访问控制机制，在正常的 C++编程中是不被允许的，也不应该这样做，因为这破坏了代码的封装性和安全性（事实上，存在一种通过模板技巧，可以在不修改原有类的前提下，能够安全取<code class="language-plaintext highlighter-rouge">private</code>函数和变量的方法）。</p> <h4 id="12-成员函数如何存储和使用">1.2 成员函数如何存储和使用？</h4> <ul> <li>成员函数的存储</li> </ul> <p>考虑以下 C++代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">func1</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">func2</span><span class="p">();</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">func1</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在 C++中，一般成员函数主要起到封装逻辑的作用。从编译器角度看，成员函数与非成员函数的处理有相似之处，但存在关键区别。成员函数并非为每个对象实例单独存储一份副本，而是所有对象共享同一份代码，这些代码存储在程序的代码段中。</p> <p>成员函数调用时，会隐式携带一个<code class="language-plaintext highlighter-rouge">this</code>指针。例如，调用<code class="language-plaintext highlighter-rouge">foo.func1()</code>实际上等价于调用经过编译器特殊处理的类似非成员函数形式，如<code class="language-plaintext highlighter-rouge">_Z3foo4func1EP3Foo</code>（这里<code class="language-plaintext highlighter-rouge">_Z3foo4func1EP3Foo</code>是编译器为支持函数重载及标识函数所属类而生成的修饰后的函数名，不同编译器生成规则不同，<code class="language-plaintext highlighter-rouge">EP3Foo</code>表示指向<code class="language-plaintext highlighter-rouge">Foo</code>类对象的指针，即<code class="language-plaintext highlighter-rouge">this</code>指针）。编译器在处理函数重载时，会对函数名进行修饰，添加类名、参数类型等信息，以确保同名函数在符号表中的唯一性。</p> <p>当成员函数内部访问成员变量时，编译器利用<code class="language-plaintext highlighter-rouge">this</code>指针来确定要操作的具体对象实例的成员变量。具体来说，编译器根据<code class="language-plaintext highlighter-rouge">this</code>指针所指向的对象地址，结合成员变量在类中的偏移量，实现对成员变量的读写操作。例如，若<code class="language-plaintext highlighter-rouge">func1</code>函数内部访问成员变量<code class="language-plaintext highlighter-rouge">a</code>，编译器会将其转换为通过<code class="language-plaintext highlighter-rouge">this</code>指针偏移获取<code class="language-plaintext highlighter-rouge">a</code>的操作，即<code class="language-plaintext highlighter-rouge">(*this).a</code>，从而准确访问到<code class="language-plaintext highlighter-rouge">foo</code>对象中的<code class="language-plaintext highlighter-rouge">a</code>变量。这种机制使得成员函数能够对不同对象实例的数据进行独立操作，同时保证了代码的封装性和复用性。</p> <p>因此，对于没有使用内部成员变量的成员函数，其实 C++是建议使用 static 去修饰的。这个时候的函数形参不会带上<code class="language-plaintext highlighter-rouge">this</code>指针。</p> <h4 id="13-静态成员变量和静态成员函数的存储和使用">1.3 静态成员变量和静态成员函数的存储和使用</h4> <ul> <li> <p>静态成员变量静态成员变量与普通静态变量非常相似性，它们都存放在静态存储区。只是静态成员变量的作用域、访问方式不同而已。静态成员变量是类的成员变量，但它们不属于类的某个具体对象，而是属于整个类本身。所有对象共享同一个静态成员变量，这使得它们在内存中只占用一份空间。</p> </li> <li> <p>静态成员函数将静态成员函数与普通静态函数其实也比较相似。静态函数的<code class="language-plaintext highlighter-rouge">static</code>表示的是静态函数的作用域被限制在定义它的源文件内，其他源文件无法访问该函数。</p> <p>而静态成员函数的<code class="language-plaintext highlighter-rouge">static</code>表明的是，函数在这个类的内部，但是不会传 this 指针的。注意的是，因为静态成员函数在内部，所以其实这个函数是可以访问私有成员的。</p> </li> </ul> <h4 id="14-继承的实现">1.4 继承的实现</h4> <p>在 C++的继承体系中，对于基类的成员变量，基类的数据成员会直接放置在派生类对象中。这意味着派生类对象的内存布局包含了基类成员变量的空间，就如同派生类自身的成员变量一样。</p> <p>对于基类的非虚成员函数，在派生类中也没有特别的额外操作。派生类对象可以直接调用这些非虚成员函数，其调用机制与普通成员函数调用类似，遵循常规的函数调用规则。</p> <p>然而，在菱形继承场景下，会出现一些问题。例如：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">virtual</span> <span class="n">A</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">virtual</span> <span class="n">A</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span><span class="p">,</span> <span class="k">public</span> <span class="n">C</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>如果不使用虚继承，从<code class="language-plaintext highlighter-rouge">B</code>和<code class="language-plaintext highlighter-rouge">C</code>继承而来的<code class="language-plaintext highlighter-rouge">A</code>类子对象会在<code class="language-plaintext highlighter-rouge">D</code>类对象中存在两份，这不仅浪费内存，还可能导致访问<code class="language-plaintext highlighter-rouge">A</code>类成员时的歧义。为了解决菱形继承问题，使基类不管被派生多少次，都只存在一个子对象实例，C++引入了虚继承。</p> <p>当使用虚继承时（如上述代码中<code class="language-plaintext highlighter-rouge">B</code>和<code class="language-plaintext highlighter-rouge">C</code>对<code class="language-plaintext highlighter-rouge">A</code>的虚继承），派生类（<code class="language-plaintext highlighter-rouge">B</code>和<code class="language-plaintext highlighter-rouge">C</code>）会添加一个虚基类指针（<code class="language-plaintext highlighter-rouge">vbptr</code>），该指针指向一个虚基类表（<code class="language-plaintext highlighter-rouge">vbtable</code>），通过这个表再指向虚基类（<code class="language-plaintext highlighter-rouge">A</code>）的数据。在<code class="language-plaintext highlighter-rouge">D</code>类对象中，只有一个指向虚基类<code class="language-plaintext highlighter-rouge">A</code>数据的<code class="language-plaintext highlighter-rouge">vbptr</code>。</p> <p>虚基类表（<code class="language-plaintext highlighter-rouge">vbtable</code>）记录了虚基类相对于派生类对象起始地址的偏移量等信息。当访问<code class="language-plaintext highlighter-rouge">D</code>类对象中的虚基类成员（如<code class="language-plaintext highlighter-rouge">D.a</code>）时，编译器会根据<code class="language-plaintext highlighter-rouge">vbptr</code>找到对应的虚基类表（<code class="language-plaintext highlighter-rouge">vbtable</code>），然后依据表中的偏移量信息，准确地定位到虚基类<code class="language-plaintext highlighter-rouge">A</code>的成员变量<code class="language-plaintext highlighter-rouge">a</code>在<code class="language-plaintext highlighter-rouge">D</code>类对象内存中的位置，从而实现对虚基类成员的正确访问。这种机制保证了在菱形继承结构中，虚基类子对象的唯一性，避免了数据冗余和访问歧义问题。</p> <h4 id="15-多态的实现">1.5 多态的实现</h4> <p>在 C++中，类的多态性主要通过虚函数来实现。以下面的代码为例：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="p">();</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>当编译器处理这段代码时，会为包含虚函数的类（如<code class="language-plaintext highlighter-rouge">A</code>类）创建虚函数表（<code class="language-plaintext highlighter-rouge">virtual function table</code>，简称<code class="language-plaintext highlighter-rouge">vtable</code>）。在类<code class="language-plaintext highlighter-rouge">A</code>中，由于<code class="language-plaintext highlighter-rouge">foo</code>函数被声明为虚函数，编译器会在<code class="language-plaintext highlighter-rouge">A</code>类对应的虚函数表中为<code class="language-plaintext highlighter-rouge">foo</code>函数分配一个条目，记录其函数地址。对于派生类<code class="language-plaintext highlighter-rouge">B</code>，编译器同样会为其生成虚函数表，并且因为<code class="language-plaintext highlighter-rouge">B</code>重写了<code class="language-plaintext highlighter-rouge">A</code>中的虚函数<code class="language-plaintext highlighter-rouge">foo</code>，<code class="language-plaintext highlighter-rouge">B</code>的虚函数表中对应<code class="language-plaintext highlighter-rouge">foo</code>函数条目的地址将指向<code class="language-plaintext highlighter-rouge">B::foo</code>的实现。</p> <p>当执行<code class="language-plaintext highlighter-rouge">A* b = new B();</code>时，<code class="language-plaintext highlighter-rouge">new B()</code>按照<code class="language-plaintext highlighter-rouge">B</code>类的构造函数进行对象构造，此时<code class="language-plaintext highlighter-rouge">b</code>指针虽然声明为<code class="language-plaintext highlighter-rouge">A*</code>类型，但实际指向的是<code class="language-plaintext highlighter-rouge">B</code>类对象。<code class="language-plaintext highlighter-rouge">B</code>类对象的内存布局中包含一个指向<code class="language-plaintext highlighter-rouge">B</code>类虚函数表的指针（通常称为虚函数表指针，<code class="language-plaintext highlighter-rouge">vptr</code>）。</p> <p>当调用<code class="language-plaintext highlighter-rouge">b-&gt;foo();</code>时，编译器首先根据<code class="language-plaintext highlighter-rouge">b</code>指针找到<code class="language-plaintext highlighter-rouge">B</code>类对象，进而通过对象中的<code class="language-plaintext highlighter-rouge">vptr</code>找到<code class="language-plaintext highlighter-rouge">B</code>类的虚函数表（<code class="language-plaintext highlighter-rouge">vtable</code>）。由于编译器在编译阶段就确定了虚函数<code class="language-plaintext highlighter-rouge">foo</code>在虚函数表中的索引位置（假设为 0），所以<code class="language-plaintext highlighter-rouge">b-&gt;foo()</code>的调用过程实际上类似于通过<code class="language-plaintext highlighter-rouge">b</code>指针找到<code class="language-plaintext highlighter-rouge">B</code>类对象的虚函数表指针<code class="language-plaintext highlighter-rouge">vptr</code>，再由<code class="language-plaintext highlighter-rouge">vptr</code>找到<code class="language-plaintext highlighter-rouge">B</code>类的虚函数表<code class="language-plaintext highlighter-rouge">vtable</code>，然后根据索引 0 获取到<code class="language-plaintext highlighter-rouge">B::foo</code>函数的地址，即<code class="language-plaintext highlighter-rouge">vtable[0]</code>，最后调用该函数，也就是执行<code class="language-plaintext highlighter-rouge">vtable[0]()</code>。</p> <h4 id="16-类对象所占的空间">1.6 类对象所占的空间</h4> <ol> <li><code class="language-plaintext highlighter-rouge">成员函数</code>：无论是静态成员函数还是非静态成员函数，它们的代码存储在程序的代码段，并不占用类对象本身的空间。成员函数通过对象的地址（<code class="language-plaintext highlighter-rouge">this</code>指针）来操作对象的数据成员，其代码的共享实现节省了内存空间。</li> <li> <p><code class="language-plaintext highlighter-rouge">静态成员变量</code>：静态成员变量为类的所有对象所共享，它的存储与类对象分离，不占用单个类对象的空间。其内存位置通常在程序的静态存储区，通过类名来访问，与具体的对象实例无关。</p> </li> <li><code class="language-plaintext highlighter-rouge">虚函数</code>：当类中包含虚函数时，类对象会持有一个虚函数表指针（<code class="language-plaintext highlighter-rouge">vptr</code>），该指针指向基于类的虚函数表（<code class="language-plaintext highlighter-rouge">vtbl</code>）。虚函数表存储了类中虚函数的地址。无论类中有多少个虚函数，类对象只需要一个<code class="language-plaintext highlighter-rouge">vptr</code>来指向虚函数表，因此虚函数相关部分仅占用一个指针大小的空间，虚函数表本身并不直接计入类对象的空间大小。</li> <li><code class="language-plaintext highlighter-rouge">非静态成员变量</code>：非静态成员变量是类对象的组成部分，它们占用类对象的空间。每个类对象都有自己独立的非静态成员变量副本，其空间大小取决于成员变量的类型和数量。</li> <li><code class="language-plaintext highlighter-rouge">字节对齐</code>：如果类中有多个非静态数据成员，为了提高内存访问速度和性能，编译器会对数据成员进行字节对齐。字节对齐是指按照特定的规则调整数据成员在内存中的存储位置，使得每个数据成员的地址都满足其自身类型的对齐要求。例如，某些系统中要求<code class="language-plaintext highlighter-rouge">int</code>类型数据从 4 字节对齐的地址开始存储。这可能会导致类对象占用的空间比所有成员变量实际大小之和要大。</li> <li><code class="language-plaintext highlighter-rouge">虚继承</code>：在虚继承的情况下，为了确保虚基类在派生类对象中只有一个实例，派生类对象会额外增加一个指针。这个指针通常称为虚基类指针（<code class="language-plaintext highlighter-rouge">vbptr</code>），它指向一个包含虚基类偏移信息的表（虚基类表，<code class="language-plaintext highlighter-rouge">vbtable</code>），通过该表可以正确定位虚基类子对象在派生类对象内存中的位置。因此，使用虚继承会使类对象多占用一个指针大小的空间。</li> </ol> <p><img src="./imgs/3_class_image.png" alt="alt text"/></p> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-class-和-struct-的区别">1. class 和 struct 的区别</h4> <p><code class="language-plaintext highlighter-rouge">struct</code> 的默认访问修饰符是 public；而 <code class="language-plaintext highlighter-rouge">class</code> 的默认访问修饰符是 private。除此之外使用时没有区别。</p> <p>但是他们背后直接承载的设计意义有一定区别。 <code class="language-plaintext highlighter-rouge">class</code> 它还会引入它所支持的封装和继承的哲学，是 oop 概念的。而 <code class="language-plaintext highlighter-rouge">struct</code> 作为 c 语言的关键字，更多时候是作为纯粹数据类型集合而存在的，C 语言的 <code class="language-plaintext highlighter-rouge">struct</code> 没有继承，也没有成员函数。因此 C++中的<code class="language-plaintext highlighter-rouge">struct</code>尽管有继承多态、甚至有模板，但一般都不会用，而是类似于 C 中纯粹数据类型集合的存在。</p> <h4 id="2-空类对象所占的空间是多少为什么">2. 空类对象所占的空间是多少，为什么？</h4> <p>1byte。这是为了确保每个空类对象都有一个唯一的地址，从而使得不同的空类对象在内存中是可区分的。</p> <h4 id="3-空对象也可以运行成员函数吗">3. 空对象也可以运行成员函数吗？</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">bar</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bar method called."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">*&gt;</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这个代码是可以运行的，但值得注意的是，这种使用容易触发一些 ub 行为。我见过的一种 ub 行为，就是比如说在<code class="language-plaintext highlighter-rouge">bar()</code>函数里面增加一段<code class="language-plaintext highlighter-rouge">if(this)</code>相关的判断的时候，编译器会基于这是一个非静态函数的原因，直接把<code class="language-plaintext highlighter-rouge">if(this)</code>的判断给干掉。</p>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><category term="class"/><summary type="html"><![CDATA[（一）C++对象内存模型那些事儿：基本概念]]></summary></entry><entry><title type="html">迈向 c++语言律师之路</title><link href="https://marco-hmc.github.io/blog/2025/0_cppQuiz/" rel="alternate" type="text/html" title="迈向 c++语言律师之路"/><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/0_cppQuiz</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/0_cppQuiz/"><![CDATA[<h2 id="迈向-c语言律师之路">迈向 c++语言律师之路</h2> <h3 id="1-trivial-grammar">1. trivial grammar</h3> <h4 id="11-attribute">1.1 attribute</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[[</span><span class="n">deprecated</span><span class="p">(</span><span class="s">"This function is deprecated. Use newFunction() instead."</span><span class="p">)]]</span>
<span class="kt">void</span> <span class="nf">oldFunction</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"This is the old function."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="kt">int</span> <span class="nf">calculate</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div> <p>这段代码展示了 C++17 标准中引入的两个新属性：<code class="language-plaintext highlighter-rouge">[[deprecated]]</code>和<code class="language-plaintext highlighter-rouge">[[nodiscard]]</code>。</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">[[deprecated]]</code>属性用于标记已经被废弃的函数。当你试图使用被<code class="language-plaintext highlighter-rouge">[[deprecated]]</code>标记的函数时，编译器会生成一个警告，告诉你这个函数已经被废弃，你应该使用其他函数代替。在这个例子中，<code class="language-plaintext highlighter-rouge">oldFunction</code>函数被标记为废弃，所以在<code class="language-plaintext highlighter-rouge">main</code>函数中调用<code class="language-plaintext highlighter-rouge">oldFunction</code>时，编译器会生成一个警告。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">[[nodiscard]]</code>属性用于标记那些返回值不应该被忽略的函数。如果你调用了被<code class="language-plaintext highlighter-rouge">[[nodiscard]]</code>标记的函数，但没有使用它的返回值，编译器会生成一个警告。在这个例子中，<code class="language-plaintext highlighter-rouge">calculate</code>函数被标记为<code class="language-plaintext highlighter-rouge">[[nodiscard]]</code>，所以在<code class="language-plaintext highlighter-rouge">main</code>函数中调用<code class="language-plaintext highlighter-rouge">calculate</code>但没有使用它的返回值时，编译器会生成一个警告。</p> </li> </ul> <p>除了<code class="language-plaintext highlighter-rouge">[[deprecated]]</code>和<code class="language-plaintext highlighter-rouge">[[nodiscard]]</code>，C++还有其他的属性，如<code class="language-plaintext highlighter-rouge">[[maybe_unused]]</code>（用于标记可能未被使用的变量，以避免编译器生成未使用变量的警告）、<code class="language-plaintext highlighter-rouge">[[likely]]</code>和<code class="language-plaintext highlighter-rouge">[[unlikely]]</code>（用于给编译器提供分支预测的提示，这两个属性在 C++20 中引入）等。</p> <h4 id="12-ref-qualified-member-functions">1.2 Ref-qualified member functions</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Bar</span> <span class="p">{</span>
<span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="n">Bar</span> <span class="n">getBar</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="k">return</span> <span class="n">bar</span><span class="p">;</span> <span class="p">}</span>
<span class="n">Bar</span> <span class="n">getBar</span><span class="p">()</span> <span class="k">const</span><span class="o">&amp;</span> <span class="p">{</span> <span class="k">return</span> <span class="n">bar</span><span class="p">;</span> <span class="p">}</span>
<span class="n">Bar</span> <span class="nf">getBar</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span> <span class="p">}</span>
<span class="n">Bar</span> <span class="n">getBar</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;&amp;</span> <span class="p">{</span> <span class="p">...;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
<span class="n">Bar</span> <span class="n">bar</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Foo</span> <span class="n">foo</span><span class="p">{};</span>
<span class="n">Bar</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">getBar</span><span class="p">();</span> <span class="c1">// foo is left value, thus calls `Bar getBar() &amp;`</span>

<span class="k">const</span> <span class="n">Foo</span> <span class="n">foo2</span><span class="p">{};</span>
<span class="n">Bar</span> <span class="n">bar2</span> <span class="o">=</span> <span class="n">foo2</span><span class="p">.</span><span class="n">getBar</span><span class="p">();</span> <span class="c1">// foo2 is const left value , thus calls `Bar Foo::getBar() const&amp;`</span>

<span class="c1">// it's all right value</span>
<span class="n">Foo</span><span class="p">{}.</span><span class="n">getBar</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">foo</span><span class="p">).</span><span class="n">getBar</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">foo2</span><span class="p">).</span><span class="n">getBar</span><span class="p">();</span>
</code></pre></div></div> <h4 id="13-placement-new">1.3 placement new</h4> <p>placement new 是 C++ 中的一种特殊的 new 运算符，用于在指定的内存位置上构造对象，而不分配新的内存。它的意义在于提供了对内存管理的精细控制，允许程序员在预先分配的内存块上构造对象。这在某些高性能、内存受限或需要自定义内存管理的场景中非常有用。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">union</span> <span class="n">ComplexData</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">intValue</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">floatValue</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">strValue</span><span class="p">;</span>

    <span class="n">ComplexData</span><span class="p">()</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">ComplexData</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ComplexData</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">.</span><span class="n">strValue</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"Hello, Complex Union"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"data.strValue: "</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">strValue</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">data</span><span class="p">.</span><span class="n">strValue</span><span class="p">.</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::~</span><span class="n">string</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="14-尾回归类型">1.4 尾回归类型</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
1. **返回类型依赖于参数**
    当返回类型需要根据函数参数推导时，尾置返回类型可以访问参数列表中的类型。最典型的例子是模板函数中使用`auto`结合`decltype`：
    这里，`decltype(t + u)`需要知道`t`和`u`的类型，而传统返回类型语法无法在函数名前访问参数列表。
*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">U</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
2. **复杂返回类型简化可读性**
    对于复杂的返回类型（如嵌套模板或函数指针），尾置语法可以使函数头部更清晰：
*/</span>
<span class="k">auto</span> <span class="nf">createAdder</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
<span class="p">}</span>

<span class="cm">/*
3. **lambda表达式的显式返回类型**
    当lambda表达式的返回类型需要显式指定时，必须使用尾置语法：
*/</span>

<span class="k">auto</span> <span class="n">lambda</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">double</span> <span class="p">{</span> <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.5</span><span class="p">;</span> <span class="p">};</span>

<span class="cm">/*
4. **元编程与类型推导**
    在模板元编程中，尾置返回类型常用于结合`decltype`进行复杂的类型推导：
*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Container</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">getElement</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="15-adl">1.5 ADL</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="cm">/*
    模板编程通过类型可以找到对应的函数(如不同命名空间下的，这个就叫做ADL.
    下面这个例子展示了如何通过模板编程和ADL，使得模板函数能够在不知道具体类型的情况下，利用参数的类型在相应的命名空间中查找相应的函数。
*/</span>

<span class="k">namespace</span> <span class="n">MyNamespace</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">MyType</span> <span class="p">{};</span>

    <span class="kt">void</span> <span class="nf">someFunction</span><span class="p">(</span><span class="n">MyType</span> <span class="n">myArg</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Function in MyNamespace called"</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">myTemplateFunction</span><span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">someFunction</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span> <span class="c1">// 依赖于ADL查找someFunction</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyNamespace</span><span class="o">::</span><span class="n">MyType</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">myTemplateFunction</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span> <span class="c1">// 调用myTemplateFunction</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="16-向量化是什么意思">1.6 向量化是什么意思?</h4> <p>向量化的特性需要编译器和 CPU 都支持吗，让我们先来简单的了解一下向量化是如何工作的。假设我们有一个非常大的<code class="language-plaintext highlighter-rouge">vector</code>。简单的实现可以写成如下的方式:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span> <span class="cm">/*...*/</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)};</span>
</code></pre></div></div> <p>编译器将会生成一个对<code class="language-plaintext highlighter-rouge">accumulate</code>调用的循，其可能与下面代码类似:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">sum</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <p>从这点说起，当编译器开启向量化时，就会生成类似如下的代码。每次循环会进行 4 次累加，这样循环次数就要比之前减少 4 倍。为了简单说明问题，我们这里没有考虑不为 4 倍数个元素的情况:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sum</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">sum</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>
<span class="c1">// if v.size() / 4 has a remainder,</span>
<span class="c1">// real code has to deal with that also.</span>
</code></pre></div></div> <p>为什么要这样做呢？因为 CPU 指令能支持一个指令执行这种<code class="language-plaintext highlighter-rouge">sum += v[i] + v[i+1] + v[i+2] + v[i+3];</code>，而不是调用4个<code class="language-plaintext highlighter-rouge">add</code>指令。使用尽可能少的指令完成尽可能多的操，这样就能加速程序的运行。</p> <p>自动向量化非常困，因为编译器需非常了解我们的程序，这样才能进行加速的情况，不让程序的结果出错。至少可以通过使用标准算法来帮助编译器。因为这样能让编译器更加了解哪些数据流能够并，而不是从复杂的循环中对数据流的依赖进行分析。</p> <h4 id="17-c的-cast-有几种分别在什么时候用">1.7 c++的 cast 有几种？分别在什么时候用？</h4> <p>C++提供了四种类型转换操作符，分别用于不同的场景：</p> <ol> <li> <p><strong><code class="language-plaintext highlighter-rouge">static_cast</code></strong>：最常用的类型转换。用于非多态类型的转换。可以用来进行任何隐式转换，比如非 const 转 const，void 指针转具体类型指针，以及任何用户定义的类型转换等。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">// 整型转浮点型</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">dynamic_cast</code></strong>：主要用于处理多态性，安全地将基类指针或引用转换为派生类的指针或引用，而且在转换不成功时能够检测到。只能用于包含虚函数的类之间的转换。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Base</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">;</span>
<span class="n">Derived</span><span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 基类指针转派生类指针</span>
<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* 成功转换 */</span> <span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">const_cast</code></strong>：用于修改类型的 const 或 volatile 属性。最常见的用途是去除对象的 const 性质，以允许对 const 对象的修改。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">modifiable</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ci</span><span class="p">);</span>
<span class="o">*</span><span class="n">modifiable</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// 实际上修改const对象是未定义行为</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">reinterpret_cast</code></strong>：提供了低级别的重新解释类型的能力，可以将任何指针转换成任何其他类型的指针（甚至不相关的类型），也可以将指针转换成足够大的整数类型，反之亦然。使用时需要特别小心，因为它可能会导致平台依赖的代码。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="n">p</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">cp</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span> <span class="c1">// 将long型指针转换为char型指针</span>
</code></pre></div> </div> </li> </ol> <p>但是<code class="language-plaintext highlighter-rouge">dynamic_cast</code>因为是运行时提供一种检查能力去做指针类型转换的，部分性能敏感的代码，可能不允许使用这个。每种类型转换操作符都有其特定的用途，选择合适的转换操作符可以使代码更安全、更清晰。</p> <h3 id="2-inside-cpp">2. inside cpp</h3> <h4 id="21-引用是怎么实现的">2.1 引用是怎么实现的?</h4> <p>在 C++ 中，当我们说”引用”时，我们通常不会说它被”拷贝”，因为引用本身并不占用任何存储空间，它只是一个<code class="language-plaintext highlighter-rouge">别名</code>。当你将一个对象作为引用传递给函数时，实际上并没有发生任何拷贝操作。函数接收的是对原始对象的直接引用，而不是任何形式的拷贝。</p> <p>然而，从底层实现的角度来看，引用在某种程度上可以被视为一个常量指针。当你创建一个引用并将其初始化为一个对象时，编译器会在底层创建一个指向该对象的常量指针。这个指针在初始化后就不能改变，它将一直指向初始化时的那个对象。因此，当你通过引用访问对象时，实际上是通过这个常量指针访问的。</p> <p>但是，这并不意味着引用是通过拷贝指针来实现的。引用的实现细节可能因编译器和平台的不同而不同。</p> <h4 id="22-如果说-a-和-b-都在栈上那怎么取-b-的值呢需要每一次取值都经历出栈和入栈吗">2.2 如果说 a 和 b 都在栈上，那怎么取 b 的值呢？需要每一次取值都经历出栈和入栈吗？</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在函数执行过程中，局部变量 a 和 b 都存储在栈上。栈是一个连续的内存区域，局部变量在栈帧中按顺序分配。取变量 b 的值并不需要每次都经历出栈和入栈操作，而是通过栈帧中的偏移量直接访问。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    main:
    push    ebp             ; 保存调用者的基址指针
    mov     ebp, esp        ; 设置当前栈帧的基址指针
    sub     esp, 8          ; 为局部变量 a 和 b 分配 8 字节的空间

    mov     DWORD PTR [ebp-4], 1  ; 将 1 存储到 a
    mov     DWORD PTR [ebp-8], 2  ; 将 2 存储到 b

    ; 访问 b 的值
    mov     eax, DWORD PTR [ebp-8] ; 将 b 的值加载到 eax 寄存器

    mov     esp, ebp        ; 恢复栈指针
    pop     ebp             ; 恢复基址指针
    ret                     ; 返回调用者
</code></pre></div></div> <h4 id="10-cc是转成汇编语言的-那汇编语言是如何处理自定义类型的">10 c/c++是转成汇编语言的。 那汇编语言是如何处理自定义类型的?</h4> <p>C/C++代码是被转成汇编语言的。那么，汇编语言是如何处理自定义类型的呢？</p> <p>汇编语言本身并没有自定义类型的概念，它只知道字节和地址。当在 C++ 中定义一个类型，例如一个结构体或类时，编译器会根据定义来决定如何在内存中布局数据，以及如何生成对应的汇编代码来访问这些数据。</p> <p>例如，若定义一个包含两个整数的结构体：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">MyStruct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>在大多数现代系统中，一个 <code class="language-plaintext highlighter-rouge">int</code> 需要 4 个字节，所以编译器会知道这个结构体需要 8 个字节的空间。当创建一个 <code class="language-plaintext highlighter-rouge">MyStruct</code> 对象并访问它的成员时，编译器会生成对应的汇编代码来读取或写入这些地址。</p> <p>假设在 x86 - 64 架构下，使用 GCC 编译器，以下是一个简单示例，展示上述结构体在汇编层面的操作（简化示意）：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">MyStruct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyStruct</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>使用 <code class="language-plaintext highlighter-rouge">g++ -S</code> 命令生成汇编代码（部分关键代码如下）：</p> <pre><code class="language-asm">    .file   "test.cpp"
    .text
    .globl  main
    .type   main, @function
main:
.LFB0:
    .cfi_startproc
    subq    $48, %rsp
    .cfi_def_cfa_offset 56
    movl    $5, -8(%rbp) ; 将 5 赋值给 s.a，-8(%rbp) 是 s.a 在栈上的地址
    movl    $10, -4(%rbp) ; 将 10 赋值给 s.b，-4(%rbp) 是 s.b 在栈上的地址
    movl    -8(%rbp), %eax ; 将 s.a 的值加载到 %eax 寄存器
    movl    %eax, %esi
    movl    $.LC0, %edi
    movl    $0, %eax
    call    printf
    movl    -4(%rbp), %eax ; 将 s.b 的值加载到 %eax 寄存器
    movl    %eax, %esi
    movl    $.LC0, %edi
    movl    $0, %eax
    call    printf
    movl    $0, %eax
    addq    $48, %rsp
    .cfi_def_cfa_offset 8
    ret
    .cfi_endproc
.LFE0:
    .size   main, .-main
    .section   .rodata
.LC0:
    .string "%d "
    .ident  "GCC: (Ubuntu 9.4.0 - 1ubuntu1~20.04.1) 9.4.0"
    .section    .note.GNU-stack,"",@progbits
</code></pre> <p>可以看到，汇编代码通过具体的内存地址操作来处理结构体成员。但是，这个过程是由编译器完成的，汇编语言本身并不知道 <code class="language-plaintext highlighter-rouge">MyStruct</code> 这个结构体，它只知道如何处理字节和地址。这就是为什么在汇编语言中，需要手动管理所有的内存布局和数据访问。</p> <h3 id="100-quiz">100. quiz</h3> <h4 id="1-c中-null-和-nullptr-的区别">1. c++中 NULL 和 nullptr 的区别</h4> <p>在 C 语言里，NULL 一般借助宏定义为<code class="language-plaintext highlighter-rouge">#define NULL ((void *)0)</code>。从本质上来说，NULL 代表的是一个空指针。下面这段代码在 C 语言环境中是能够正常编译的：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define NULL ((void *)0)
</span>
<span class="kt">int</span>  <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div></div> <p>这是由于在 C 语言中，当把<code class="language-plaintext highlighter-rouge">void*</code>类型的空指针赋值给<code class="language-plaintext highlighter-rouge">int*</code>或者<code class="language-plaintext highlighter-rouge">char*</code>类型的指针时，会自动进行隐式类型转换，从而将<code class="language-plaintext highlighter-rouge">void*</code>转换为对应的指针类型。不过，如果使用 C++编译器来编译上述代码，就会出现错误。这是因为 C++属于强类型语言，它不允许将<code class="language-plaintext highlighter-rouge">void*</code>类型的指针隐式转换为其他类型的指针。所以，在 C++环境中，编译器提供的头文件对 NULL 的定义进行了调整：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif
</span></code></pre></div></div> <p>然而，把 NULL 定义为 0 会引发函数重载时的类型匹配问题。例如下面的代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>
<span class="n">foo</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// 这里会调用哪个函数呢？</span>
</code></pre></div></div> <p>在 C++里，当执行<code class="language-plaintext highlighter-rouge">foo(NULL)</code>这一调用时，实际上传递的实参是整数 0。因为 NULL 被定义成了 0，所以它会优先匹配参数类型为<code class="language-plaintext highlighter-rouge">int</code>的重载函数，而不是参数类型为<code class="language-plaintext highlighter-rouge">char*</code>的函数。这种情况往往和程序员的预期不符，容易引发隐藏的错误。为了避免这类问题，在 C++11 及后续的版本中，建议使用<code class="language-plaintext highlighter-rouge">nullptr</code>来表示空指针。<code class="language-plaintext highlighter-rouge">nullptr</code>是一种特殊的空指针类型，能够隐式转换为任意类型的指针，而且不会和整数类型产生混淆。使用<code class="language-plaintext highlighter-rouge">nullptr</code>可以让代码的意图更加清晰明确：</p> <h4 id="2-一个通过new创建出来的指针若被delete两次会怎样">2. 一个通过<code class="language-plaintext highlighter-rouge">new</code>创建出来的指针，若被<code class="language-plaintext highlighter-rouge">delete</code>两次会怎样？</h4> <p>如果一个指针被<code class="language-plaintext highlighter-rouge">delete</code>两次，会引发未定义行为（Undefined Behavior）。这是因为在第一次执行<code class="language-plaintext highlighter-rouge">delete</code>之后，该指针所指向的已不再是有效的内存区域。再次尝试对其执行<code class="language-plaintext highlighter-rouge">delete</code>操作，实际上是对无效内存进行操作，这在程序运行规则中是不允许的。</p> <p>未定义行为可能引发多种不良后果，其中包括但不限于以下情况：</p> <ul> <li><strong>程序崩溃</strong>：操作系统或运行时环境检测到非法内存访问，从而强制终止程序运行。</li> <li><strong>数据损坏</strong>：对无效内存的操作可能会改写其他合法数据，导致程序后续逻辑出现错误。</li> <li><strong>出现难以预测和解释的行为</strong>：由于未定义行为不受特定规则约束，程序的运行结果可能在不同的编译环境、运行环境甚至不同的运行时刻都有所不同，给调试和维护带来极大困难。</li> </ul> <p>为了避免此类情况发生，在编写代码时，务必保证每个<code class="language-plaintext highlighter-rouge">new</code>操作都有且仅有一个对应的<code class="language-plaintext highlighter-rouge">delete</code>操作，并且每个<code class="language-plaintext highlighter-rouge">delete</code>操作仅执行一次。在 C++ 代码中，<code class="language-plaintext highlighter-rouge">std::unique_ptr</code>类通过封装<code class="language-plaintext highlighter-rouge">new</code>和<code class="language-plaintext highlighter-rouge">delete</code>操作，实现了对资源的自动管理，有效避免了这种因重复释放指针而引发的问题。</p> <h4 id="3-为什么在-delete-之后通常都会将指针设置为-nullptr">3. 为什么在 delete 之后，通常都会将指针设置为 nullptr</h4> <p>在 C++编程中，当使用<code class="language-plaintext highlighter-rouge">delete</code>释放一个指针所指向的内存后，通常会将该指针设置为<code class="language-plaintext highlighter-rouge">nullptr</code>，这主要基于以下几方面原因：</p> <ol> <li> <p><strong>防止产生悬挂指针</strong>：当使用<code class="language-plaintext highlighter-rouge">delete</code>释放指针所指向的内存后，该指针就成为了悬挂指针（Dangling Pointer）。此时它虽不再指向有效的内存区域，但仍保留着之前的地址值。若后续不小心再次使用这个悬挂指针，就会引发未定义行为，可能导致程序崩溃或出现难以排查的错误。而将指针设置为<code class="language-plaintext highlighter-rouge">nullptr</code>，能有效避免这种情况，因为<code class="language-plaintext highlighter-rouge">nullptr</code>是一个特殊指针值，表示该指针不指向任何对象，使用指向<code class="language-plaintext highlighter-rouge">nullptr</code>的指针进行操作（如解引用）会在大多数情况下引发明确的运行时错误，便于开发者定位问题。</p> </li> <li> <p><strong>安全地重复执行 delete 操作</strong>：在 C++语言规则中，对<code class="language-plaintext highlighter-rouge">nullptr</code>执行<code class="language-plaintext highlighter-rouge">delete</code>操作是安全的，不会产生任何实际效果。因此，若将已释放内存的指针设置为<code class="language-plaintext highlighter-rouge">nullptr</code>，后续即便不小心再次尝试对其执行<code class="language-plaintext highlighter-rouge">delete</code>操作，也不会导致未定义行为，从而增强了程序的健壮性。</p> </li> <li> <p><strong>方便检查指针是否已被释放</strong>：将指针设置为<code class="language-plaintext highlighter-rouge">nullptr</code>后，通过简单检查该指针是否等于<code class="language-plaintext highlighter-rouge">nullptr</code>，就能清晰判断它所指向的内存是否已经被释放。这在复杂的代码逻辑中，对于追踪指针状态、确保内存管理的正确性非常有帮助。</p> </li> </ol> <p>综上所述，在使用<code class="language-plaintext highlighter-rouge">delete</code>释放指针后，将其设置为<code class="language-plaintext highlighter-rouge">nullptr</code>是一种良好的编程习惯，有助于提高程序的安全性与稳定性，减少因内存管理不当而引发的错误。</p> <h4 id="5-静态绑定和虚函数">5. 静态绑定和虚函数</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"A"</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">B</span> <span class="o">:</span> <span class="n">A</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">foo</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"B"</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">A</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="p">;</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span>   <span class="c1">// B1</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="4-通过指针访问和直接访问的区别是什么">4. 通过指针访问和直接访问的区别是什么？</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Point3d</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Point3d</span> <span class="n">origin</span><span class="p">;</span>
<span class="n">Point3d</span><span class="o">*</span> <span class="n">pt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">origin</span><span class="p">;</span>
<span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c1">// (1)</span>
<span class="n">pt</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>    <span class="c1">// (2)</span>
</code></pre></div></div> <p>(1) 和 (2) 这两种方式均用于将 <code class="language-plaintext highlighter-rouge">Point3d</code> 对象 <code class="language-plaintext highlighter-rouge">origin</code> 的 <code class="language-plaintext highlighter-rouge">x</code> 成员值设置为 <code class="language-plaintext highlighter-rouge">0.0</code> 。它们的差异在于访问方式不同，从编译器层面来看：</p> <ul> <li>(1) <code class="language-plaintext highlighter-rouge">origin.x = 0.0;</code> 这种方式是直接借助对象名与成员名来访问并修改成员值。编译器在编译阶段就能确定 <code class="language-plaintext highlighter-rouge">origin</code> 的内存地址，随后依据偏移量定位到 <code class="language-plaintext highlighter-rouge">x</code> 成员的位置，直接在此处写入 <code class="language-plaintext highlighter-rouge">0.0</code> 。</li> <li>(2) <code class="language-plaintext highlighter-rouge">pt-&gt;x = 0.0;</code> 该方式则是通过指向对象的指针来访问与修改成员值。<code class="language-plaintext highlighter-rouge">pt</code> 是指向 <code class="language-plaintext highlighter-rouge">origin</code> 的指针，<code class="language-plaintext highlighter-rouge">pt-&gt;x</code> 代表 <code class="language-plaintext highlighter-rouge">pt</code> 所指向对象的 <code class="language-plaintext highlighter-rouge">x</code> 成员。在编译时，编译器无法确定 <code class="language-plaintext highlighter-rouge">pt</code> 所指向的内存地址，因为这一地址是在运行时由操作系统分配的。所以在运行时，编译器需要先读取 <code class="language-plaintext highlighter-rouge">pt</code> 的值（即 <code class="language-plaintext highlighter-rouge">origin</code> 的地址），接着通过偏移量找到 <code class="language-plaintext highlighter-rouge">x</code> 成员的位置，最后在此处写入 <code class="language-plaintext highlighter-rouge">0.0</code> 。</li> </ul> <p>总体而言，这两种实现效果一致，都能将 <code class="language-plaintext highlighter-rouge">origin</code> 的 <code class="language-plaintext highlighter-rouge">x</code> 成员值设为 <code class="language-plaintext highlighter-rouge">0.0</code> 。但是<code class="language-plaintext highlighter-rouge">(1)</code>会比<code class="language-plaintext highlighter-rouge">(2)</code>要好，<code class="language-plaintext highlighter-rouge">(2)</code>会有运行时开销。</p> <h4 id="6-一般哪些函数可以使用-noexcept">6. 一般哪些函数可以使用 noexcept?</h4> <p>在 C++ 中，<code class="language-plaintext highlighter-rouge">noexcept</code>关键字用于表明一个函数不会抛出任何异常。这对于提升代码的性能与可靠性有着重要意义。以下是几类常见可使用<code class="language-plaintext highlighter-rouge">noexcept</code>的函数：</p> <ol> <li><strong>析构函数</strong>：析构函数一般不应抛出任何异常。这是因为若在析构函数中抛出异常，极有可能致使程序出现未定义行为。例如，当对象被自动销毁或容器中的对象析构时，若析构函数抛出异常，程序的后续行为将无法预测，可能导致崩溃或数据损坏等严重问题。</li> <li><strong>移动构造函数与移动赋值操作符</strong>：这些函数通常应标记为<code class="language-plaintext highlighter-rouge">noexcept</code>。因为它们大多仅涉及指针和基本类型的转移，正常情况下不应抛出异常。而且，标记为<code class="language-plaintext highlighter-rouge">noexcept</code>的移动操作能被标准库容器（如<code class="language-plaintext highlighter-rouge">std::vector</code>）更高效地运用。比如，当<code class="language-plaintext highlighter-rouge">std::vector</code>进行扩容或重新分配内存时，若移动操作标记为<code class="language-plaintext highlighter-rouge">noexcept</code>，<code class="language-plaintext highlighter-rouge">std::vector</code>可以采用更优化的策略，避免不必要的复制操作，从而显著提升性能。</li> <li><strong>交换函数</strong>：像<code class="language-plaintext highlighter-rouge">std::swap</code>这类交换函数，通常也应标记为<code class="language-plaintext highlighter-rouge">noexcept</code>。这是由于它们通常仅涉及指针和基本类型的转移，正常情况下不会抛出异常。例如，在进行两个对象的交换操作时，仅仅是交换它们内部的指针或基本数据成员，这种操作的稳定性较高，不易引发异常。</li> <li><strong>其他不会抛出异常的函数</strong>：倘若你明确知晓某个函数不会抛出异常，那么就应当使用<code class="language-plaintext highlighter-rouge">noexcept</code>关键字。这不仅有助于编译器对代码进行优化，例如，编译器可能会针对<code class="language-plaintext highlighter-rouge">noexcept</code>函数进行特定的优化，生成更高效的机器码；同时也能向其他开发者清晰地表明该函数不会引发异常，使得代码的行为更加明确和可预测。</li> </ol> <h4 id="7-c怎么定义隐式转换规则">7. c++怎么定义隐式转换规则</h4> <p>在 C++ 中，隐式转换（也称为自动类型转换）由编译器自动执行。这些转换规则由 C++ 语言明确规定，例如从 <code class="language-plaintext highlighter-rouge">int</code> 到 <code class="language-plaintext highlighter-rouge">double</code> 的转换，或者从派生类到基类的转换。 然而，你也可以为自定义类型定义隐式转换规则。这可以通过定义转换函数来达成。转换函数是一种特殊的成员函数，它能够将一个类的对象转换为其他类型的对象。 例如，假设你有一个名为 <code class="language-plaintext highlighter-rouge">MyClass</code> 的类，并且希望它能隐式转换为 <code class="language-plaintext highlighter-rouge">int</code> 类型。你可以在 <code class="language-plaintext highlighter-rouge">MyClass</code> 类中定义一个名为 <code class="language-plaintext highlighter-rouge">operator int()</code> 的转换函数，如下所示：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="c1">// 在这里返回一个 int 值</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>随后，你便可以像这样使用它：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MyClass</span> <span class="n">obj</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>  <span class="c1">// 隐式转换</span>
</code></pre></div></div> <p>需要注意的是，尽管隐式转换看似方便，但它可能引发一些意想不到的问题。比如，当函数重载时，隐式转换可能会导致编译器选择错误的函数版本。因此，一般建议尽量避免使用隐式转换，或者至少要确保清楚地知道它何时会发生以及会产生什么效果。</p> <h4 id="8-多态场景下调用哪个方法">8. 多态场景下，调用哪个方法？</h4> <p>在C++中，考虑以下场景：有两个同名函数<code class="language-plaintext highlighter-rouge">func()</code>，一个函数的形参是<code class="language-plaintext highlighter-rouge">Foo</code>类型指针，另一个函数的形参是<code class="language-plaintext highlighter-rouge">Bar</code>类型指针，并且<code class="language-plaintext highlighter-rouge">Bar</code>类型是<code class="language-plaintext highlighter-rouge">Foo</code>类型的派生类。如果有<code class="language-plaintext highlighter-rouge">Foo* bar = new Bar();</code>，然后调用<code class="language-plaintext highlighter-rouge">func(bar)</code>，那么会调用哪个函数呢？</p> <p>答案是会调用形参为<code class="language-plaintext highlighter-rouge">Foo</code>类型指针的<code class="language-plaintext highlighter-rouge">func</code>函数。因为在C++中，这种情况属于函数重载。函数重载是在编译时根据实参的静态类型来确定调用哪个函数版本。在这个例子中，实参<code class="language-plaintext highlighter-rouge">bar</code>的静态类型是<code class="language-plaintext highlighter-rouge">Foo*</code>，所以编译器会选择调用形参为<code class="language-plaintext highlighter-rouge">Foo</code>类型指针的<code class="language-plaintext highlighter-rouge">func</code>函数。</p> <p>需要注意的是，如果想要实现根据对象的实际类型（动态类型）来决定调用哪个函数，即实现多态中的动态绑定，则需要在基类<code class="language-plaintext highlighter-rouge">Foo</code>中将相关函数声明为虚函数，并且在派生类<code class="language-plaintext highlighter-rouge">Bar</code>中重写该虚函数，这样通过基类指针或引用调用虚函数时，才会在运行时根据对象的实际类型来确定调用哪个函数版本。但本题中未提及虚函数相关内容，所以按照函数重载的规则进行匹配。</p> <h4 id="9-不使用-final-怎么实现-final-效果">9. 不使用 final 怎么实现 final 效果</h4> <p>在 C++ 中，如果希望一个类 <code class="language-plaintext highlighter-rouge">B</code> 不可以被继承，可以采用以下方式。首先，定义一个类 <code class="language-plaintext highlighter-rouge">A</code>，将 <code class="language-plaintext highlighter-rouge">A</code> 的构造函数私有化。然后让类 <code class="language-plaintext highlighter-rouge">B</code> 继承自 <code class="language-plaintext highlighter-rouge">A</code>，并声明 <code class="language-plaintext highlighter-rouge">B</code> 是 <code class="language-plaintext highlighter-rouge">A</code> 的友元。这样，<code class="language-plaintext highlighter-rouge">B</code> 能够正常构造，因为作为友元，<code class="language-plaintext highlighter-rouge">B</code> 可以访问 <code class="language-plaintext highlighter-rouge">A</code> 的私有构造函数。然而，当有类 <code class="language-plaintext highlighter-rouge">C</code> 试图继承 <code class="language-plaintext highlighter-rouge">B</code> 时，由于 <code class="language-plaintext highlighter-rouge">C</code> 不是 <code class="language-plaintext highlighter-rouge">A</code> 的友元，不能调用 <code class="language-plaintext highlighter-rouge">A</code> 的私有构造函数，所以 <code class="language-plaintext highlighter-rouge">C</code> 无法继承 <code class="language-plaintext highlighter-rouge">B</code>，从而实现了类似 <code class="language-plaintext highlighter-rouge">final</code> 的阻止类被继承的效果。以下是具体代码示例：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">A</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// A 的构造函数私有化</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">B</span><span class="p">;</span> <span class="c1">// 声明 B 为 A 的友元</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">B</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// B 可以正常构造，因为是 A 的友元</span>
<span class="p">};</span>

<span class="c1">// 尝试继承 B</span>
<span class="c1">// class C : public B {</span>
<span class="c1">// public:</span>
<span class="c1">//     C() {} // 这里会报错，因为 C 不能调用 A 的私有构造函数</span>
<span class="c1">// };</span>
</code></pre></div></div> <p>在上述代码中，若取消对 <code class="language-plaintext highlighter-rouge">class C</code> 定义部分的注释，编译时会报错，提示无法访问 <code class="language-plaintext highlighter-rouge">A</code> 的私有构造函数，从而表明 <code class="language-plaintext highlighter-rouge">C</code> 不能继承 <code class="language-plaintext highlighter-rouge">B</code>，达成了类似 <code class="language-plaintext highlighter-rouge">final</code> 关键字阻止类被继承的效果。</p> <h4 id="10-函数声明陷阱">10. 函数声明陷阱</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">struct</span> <span class="nc">X</span> <span class="p">{</span>
    <span class="n">X</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"X"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="c1">// confusing case: 可能会引起误解</span>
        <span class="n">X</span> <span class="n">x</span><span class="p">();</span>  <span class="c1">// 这是声明了一个名为x，返回类型为X的函数，还是声明了一个名为x，使用默认构造的对象？</span>
    <span class="p">}</span>
    <span class="p">{</span>
        <span class="c1">// 方法1：省略括号（推荐）</span>
        <span class="n">X</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// 正确创建对象x，调用默认构造函数</span>
    <span class="p">}</span>

    <span class="p">{</span>
        <span class="c1">// 方法2：使用统一初始化语法（C++11及以后）</span>
        <span class="n">X</span> <span class="n">x</span><span class="p">{};</span>  <span class="c1">// 同样正确，避免了语法歧义</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="11-黑魔法">11. 黑魔法</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" </span><span class="se">\n</span><span class="s">"</span><span class="p">[</span><span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"===== </span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><category term="grammar"/><summary type="html"><![CDATA[迈向 c++语言律师之路]]></summary></entry><entry><title type="html">指针那些事儿</title><link href="https://marco-hmc.github.io/blog/2025/0_pointer/" rel="alternate" type="text/html" title="指针那些事儿"/><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/0_pointer</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/0_pointer/"><![CDATA[<h2 id="指针那些事儿">指针那些事儿</h2> <h3 id="1-指针的本质">1. 指针的本质</h3> <p>指针的主要目的在于表示内存中的数据。在此，我们先简要回顾内存存储数据的机制。</p> <p>内存由众多单元格组成，每个单元格都被赋予一个唯一的地址。每个单元格的存储容量为一个字节，这恰好与 <code class="language-plaintext highlighter-rouge">char</code> 类型所占的空间大小一致。从硬件层面而言，系统提供了依据地址获取存储数据的方法。一份数据在内存中存储时，可能占用一个单元格，也可能由若干连续的单元格共同存储。</p> <p>那么，若要表示内存中的一份数据，可行的方式有哪些呢？</p> <ol> <li>记录该数据所有单元格对应的地址。</li> <li>基于通常情况下同一份数据的单元格是连续存储这一前提，仅需记录数据存储区域的首地址以及数据的总长度即可。</li> </ol> <p>显然，第二种方式相较于第一种方式具有明显优势。而指针，本质上就是基于第二种方式的一种表达方式。</p> <p>进一步来讲，数据总长度信息与数据类型信息在本质上是等价的。因为一种数据类型实际上就明确了存储该数据所需占用的单元格数量。然而，使用数据总长度来描述数据的存储需求，在表达上可能会引发歧义。因此，在编程中，人们更倾向于使用数据类型来表示数据长度这一概念。</p> <p>再进一步分析，数据类型对于编译器而言，决定了其对首地址数据的解读方式。编译器的主要功能是将 C/C++ 等高级语言转换为汇编语言，而在汇编语言层面，并不存在自定义类型长度的概念。当程序中使用自定义类型时，编译器会对该类型进行解析，明确表示该数据所需的单元格数量。在编译器生成汇编语言代码的过程中，会直接指定按照相应数量的单元格去读取数据。所以，也有人认为，数据类型的重要意义在于告知编译器应采用何种格式去读取特定地址处的数据。</p> <p>综上所述，指针就是数据类型，结合内存地址，来表示一份内存的数据。</p> <h4 id="11-指针的种类有哪些">1.1 指针的种类有哪些</h4> <p>在 C 和 C++编程中，指针是一种强大而灵活的工具，具有多种类型，每种类型都有其特定的用途和特点。以下详细介绍各类指针：</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">基本对象指针</code>：这类指针指向基本数据类型。例如，<code class="language-plaintext highlighter-rouge">int* p;</code> 这条语句定义了一个指针 <code class="language-plaintext highlighter-rouge">p</code>，它专门用于指向整型数据。通过这个指针，程序可以直接访问和操作内存中存储的整型值。</p> </li> <li> <p>``void<code class="language-plaintext highlighter-rouge">指针</code>：<code class="language-plaintext highlighter-rouge">void*</code>是一种特殊的指针类型，它具有通用性，可以指向任何类型的数据。通常在需要存储任意类型地址的场景中使用，比如在编写通用函数时，其参数可能接受不同类型的数据地址，这时就可以使用<code class="language-plaintext highlighter-rouge">void*</code>指针。但需要注意的是，由于<code class="language-plaintext highlighter-rouge">void</code> 指针没有明确的数据类型，在使用它访问所指向的数据时，通常需要进行类型转换，将其转换为具体的数据类型指针，以便编译器能够正确解析和处理数据。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">常量指针与指向常量的指针</code>：这是两个容易混淆但概念截然不同的指针类型，同时还有指向常量的常量指针。</p> <ul> <li><code class="language-plaintext highlighter-rouge">指向常量的指针</code>：以 <code class="language-plaintext highlighter-rouge">const int* p;</code> 为例，这里定义的指针 <code class="language-plaintext highlighter-rouge">p</code> 可以指向一个整型常量。这种指针的特点是，不能通过它来修改所指向的值，这为数据提供了一定的保护机制，防止意外的修改。但指针本身可以指向其他的整型常量或变量。</li> <li><code class="language-plaintext highlighter-rouge">常量指针</code>：如 <code class="language-plaintext highlighter-rouge">int* const p;</code>，此指针 <code class="language-plaintext highlighter-rouge">p</code> 本身是一个常量。一旦初始化后，它所指向的地址就不能再改变，但通过这个指针可以修改其所指向的值。这在一些需要固定指向某个特定内存位置的场景中很有用。</li> <li><code class="language-plaintext highlighter-rouge">指向常量的常量指针</code>：<code class="language-plaintext highlighter-rouge">const int* const p;</code> 定义的指针既不能改变它所指向的地址，也不能通过它修改所指向的值，为数据和指针本身都提供了最高级别的保护。</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">函数指针</code>：函数指针用于指向函数，它存储的是函数在内存中的地址。通过函数指针，可以像调用普通函数一样调用其所指向的函数。例如，<code class="language-plaintext highlighter-rouge">void (*func_ptr)(int);</code> 定义了一个名为 <code class="language-plaintext highlighter-rouge">func_ptr</code> 的指针，它指向一个接受一个整型参数且无返回值的函数。这种机制使得程序在运行时能够根据不同的条件动态选择要执行的函数，增加了程序的灵活性和可扩展性。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">数组指针与指向数组的指针</code>：在数组与指针的关系中，存在数组指针和指向数组的指针这两种概念，需要清晰区分。</p> <ul> <li><code class="language-plaintext highlighter-rouge">数组名与指针的关系</code>：在 C 和 C++中，数组名在很多情况下可以视为指向其首元素的指针。例如，定义 <code class="language-plaintext highlighter-rouge">int arr[10];</code> 后，<code class="language-plaintext highlighter-rouge">int* ptr = arr;</code> 这种赋值是合法的，此时 <code class="language-plaintext highlighter-rouge">ptr</code> 就指向了数组 <code class="language-plaintext highlighter-rouge">arr</code> 的第一个元素。</li> <li><code class="language-plaintext highlighter-rouge">指向数组的指针</code>：可以声明专门指向整个数组的指针，例如 <code class="language-plaintext highlighter-rouge">int (*ptr_to_array)[10];</code>。这里 <code class="language-plaintext highlighter-rouge">ptr_to_array</code> 是一个指针，它指向一个包含 10 个整型元素的数组。与指向数组首元素的指针不同，这种指针在移动时，每次移动的步长是整个数组的大小，而不是单个元素的大小。</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">多级指针</code>：多级指针是指针的指针，例如 <code class="language-plaintext highlighter-rouge">int **ptr;</code> 定义了一个二级指针 <code class="language-plaintext highlighter-rouge">ptr</code>。它指向的是一个指针，而这个指针又指向一个整型数据。通过多级指针，可以构建更复杂的数据结构，并且在处理动态分配的多维数组等场景中非常有用。多级指针的概念可以扩展到更多级别，如三级指针 <code class="language-plaintext highlighter-rouge">int ***ptr;</code> 等，每增加一级，指针所指向的对象就是下一级的指针。</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">成员指针</code>：成员指针专门用于指向类的非静态成员变量。例如，<code class="language-plaintext highlighter-rouge">int MyClass::*ptr;</code> 定义了一个指针 <code class="language-plaintext highlighter-rouge">ptr</code>，它可以指向 <code class="language-plaintext highlighter-rouge">MyClass</code> 类中的某个整型成员。使用成员指针可以在运行时动态地访问类的不同成员变量，这在一些需要灵活操作类成员的场景中非常实用，比如在实现反射机制或某些通用的类操作算法时。</p> </li> </ol> <h4 id="12-指针的大小">1.2 指针的大小</h4> <p>在特定的系统架构中，各类指针在内存中所占据的空间大小通常是一致的。这背后的原因在于，指针的核心功能是存储内存地址，而地址空间的规模是由硬件与操作系统共同确定的，并非取决于指针所指向的数据类型。</p> <p>在常见的 32 位系统里，不管指针指向的是<code class="language-plaintext highlighter-rouge">int</code>类型数据（如<code class="language-plaintext highlighter-rouge">int*</code>）、<code class="language-plaintext highlighter-rouge">char</code>类型数据（如<code class="language-plaintext highlighter-rouge">char*</code>），还是<code class="language-plaintext highlighter-rouge">double</code>类型数据（如<code class="language-plaintext highlighter-rouge">double*</code>）等，指针自身的大小一般为 4 字节，换算成二进制位即 32 位。这是因为 32 位系统的地址总线宽度为 32 位，它所能表示的地址范围决定了指针需占用 4 字节来存储完整的内存地址。</p> <p>而在 64 位系统环境下，情况类似，几乎所有类型的指针，无论其指向何种数据类型，通常大小为 8 字节，也就是 64 位。64 位系统的地址总线更宽，能够处理更大的地址空间，因此需要 8 字节来存储一个内存地址。</p> <p>需要留意的是，尽管上述情况是普遍现象，但在使用特殊编译器选项，或者处于某些特定的虚拟化环境时，即便在 32 位系统中，也存在将指针配置为 64 位的可能性。不过，这种情形相对罕见，在常规的 32 位系统应用开发中，指针大小基本遵循 4 字节的标准。</p> <h4 id="13-总结">1.3 总结</h4> <p>综上所述，指针的本质可归结为类型（与数据长度等价）和地址两个关键要素。</p> <p>在现代计算机系统中，无论指针指向何种数据类型，其自身占用的内存大小通常是固定的，且与计算机的位数相关。以常见情况为例，在 64 位计算机系统中，指针一般占用 8 字节的内存空间。</p> <p>指针类型具有重要作用，它指导编译器如何解读特定地址中的内存内容以及确定该内容的大小。例如，<code class="language-plaintext highlighter-rouge">int*</code> 类型的指针会使编译器按照 <code class="language-plaintext highlighter-rouge">int</code> 类型的长度和格式去解释所指向地址处的内存数据。</p> <p><code class="language-plaintext highlighter-rouge">void*</code> 指针较为特殊，它能够存储一个地址，但由于其未明确所指对象的数据类型，因此无法直接通过它对所指对象进行操作，因为此时无法确定其覆盖的地址空间范围及数据格式。</p> <p>在使用指针进行内存操作时，硬件亲和性是一个不容忽视的重要因素。内存访问并非简单地逐个地址获取数据，实际上，它通常遵循一定的模式，按 “行” 进行操作。例如，当通过指针访问 <code class="language-plaintext highlighter-rouge">int</code> 类型（4 字节数据）的数据时，并非分四次分别访问对应的四个字节地址，而是一次性访问包含这四个字节的一行内存空间。字节对齐机制正是基于这种内存访问模式而产生的。字节对齐能够确保数据在内存中的存储方式符合硬件高效访问的要求，从而显著提升内存访问效率，使基于指针的内存操作更为顺畅和高效。</p> <p>进一步深入分析，内存访问过程通常是先查询高速缓存，若未命中再查询内存。这里提到的 “行” 的大小，实际上由高速缓存决定。综合各种因素考量，目前常见的缓存行大小一般为 64 字节，这相当于 8 个地址长度，或者说能够容纳 16 个 <code class="language-plaintext highlighter-rouge">int</code> 型数据。</p> <p>值得注意的是，当读取非内存对齐的数据时，可能会出现数据读取的原子性问题。例如，若一个数据需要读取两行才能完整获取，在读完第一行后，第二行的数据有可能在读取前被修改。不过，随着计算机硬件技术的不断发展，部分硬件已能够保证此类数据读取的原子性。</p> <p>基于上述内存访问机制与指针操作原理，当面临存储同一类型数据多次且要求连续存储的需求时，应如何实现呢？</p> <h3 id="2-指针和数组">2. 指针和数组</h3> <p>同样，对于连续存储同一类型数据多次的需求，有以下两种常见思路：</p> <ol> <li>记录每个数据的指针。然而，这种方式在实际应用中会带来较高的管理成本，因为需要维护多个指针，增加了内存开销和操作复杂度。</li> <li>依据同一类型数据通常连续存储这一普遍特性，仅需掌握首数据的地址以及连续数据的数量即可。显然，第二种方式更为简洁高效。而数组，本质上正是基于这种方式的一种数据结构表达。</li> </ol> <p>以 C 语言代码为例：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
</code></pre></div></div> <p>在这个数组定义中，<code class="language-plaintext highlighter-rouge">arr</code> 本质上代表了首数据的地址。数组的长度为 4，表示连续存储了 4 个 <code class="language-plaintext highlighter-rouge">int</code> 类型的数据。具体到数组元素的地址计算，<code class="language-plaintext highlighter-rouge">arr</code> 作为数组名，它指向数组的首元素，即首数据地址。对于数组中的其他元素，其地址遵循一定的计算规则：</p> <ul> <li><code class="language-plaintext highlighter-rouge">arr[0]</code> 是数组的首元素，其值为 1，而 <code class="language-plaintext highlighter-rouge">arr</code> 所代表的首数据地址假设为 <code class="language-plaintext highlighter-rouge">0x0001</code>（这里仅为示例）。</li> <li><code class="language-plaintext highlighter-rouge">arr[1]</code> 的地址为 <code class="language-plaintext highlighter-rouge">首数据地址 + 类型长度 * 序数</code>，由于 <code class="language-plaintext highlighter-rouge">int</code> 类型通常占 4 字节，所以 <code class="language-plaintext highlighter-rouge">arr[1]</code> 的地址为 <code class="language-plaintext highlighter-rouge">0x0001 + 4 * 1 = 0x0005</code>。</li> <li>同理，<code class="language-plaintext highlighter-rouge">arr[2]</code> 的地址为 <code class="language-plaintext highlighter-rouge">0x0001 + 4 * 2 = 0x0009</code>。</li> <li><code class="language-plaintext highlighter-rouge">arr[3]</code> 的地址为 <code class="language-plaintext highlighter-rouge">0x0001 + 4 * 3 = 0x000D</code>。</li> </ul> <p>由此可见，数组可以看作是由首数据指针和数组长度构成。进一步而言，数组是对指针概念的一种封装和抽象。它通过简洁的语法和特定的内存布局，为开发者提供了一种方便的方式来管理和操作连续存储的同类型数据集合。例如，数组隐藏了指针运算的细节，使得对数据的访问更加直观和安全。同时，数组还提供了边界检查等机制（虽然在 C 语言中这种检查并不严格），相比直接使用指针，减少了因指针操作不当导致的错误。</p> <p>当我们讨论数组时，高维数组是一种常见且重要的扩展形式。那么，什么是高维数组，它又有哪些实际用途呢？</p> <h3 id="3-高维数组">3. 高维数组</h3> <p>首先明确高维数组的定义。数组用于存储多个同一类型的数据，如果这个“同一类型”本身就是一个数组，那么就构成了高维数组。以二维数组为例，如以下 C 语言代码：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>在这个例子中，<code class="language-plaintext highlighter-rouge">arr</code> 是一个二维数组，它可以看作是由两个元素组成的数组，而每个元素又是一个包含两个 <code class="language-plaintext highlighter-rouge">int</code> 类型数据的数组。</p> <p>为了更深入理解高维数组的结构，我们需要引入“降维”的概念。对于 <code class="language-plaintext highlighter-rouge">int arr[2][2]</code>，可以借助类型定义来辅助理解，例如：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 其实typedef int[2] type可能更好理解，但parse解析规则不是这样的</span>
<span class="c1">// 但理解是一个意思即可</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">TYPE</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">TYPE</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>这里将 <code class="language-plaintext highlighter-rouge">int[2]</code> 定义为 <code class="language-plaintext highlighter-rouge">TYPE</code> 类型，<code class="language-plaintext highlighter-rouge">arr</code> 就是一个由两个 <code class="language-plaintext highlighter-rouge">TYPE</code> 类型元素组成的数组，这样从结构上更清晰地展示了二维数组的构成。</p> <p>再通过一个具体的内存空间示例进一步说明：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">tab</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="p">};</span>
</code></pre></div></div> <p>从内存空间角度来看，计算机内存是按顺序线性排列的，假设起始地址为 <code class="language-plaintext highlighter-rouge">0x7ffc5c78b530</code>，每个 <code class="language-plaintext highlighter-rouge">int</code> 类型数据占 4 字节（在 32 位系统下），则内存布局如下：</p> <table> <thead> <tr> <th>Address</th> <th>type</th> <th>length</th> <th>Value</th> <th>Interpretation</th> </tr> </thead> <tbody> <tr> <td>0x7ffc5c78b530</td> <td>int[2]</td> <td>8</td> <td>0x7ffc5c78b530</td> <td><code class="language-plaintext highlighter-rouge">tab</code> 的地址，即 <code class="language-plaintext highlighter-rouge">tab[0]</code> 的地址</td> </tr> <tr> <td>0x7ffc5c78b538</td> <td>int[2]</td> <td>8</td> <td>0x7ffc5c78b538</td> <td><code class="language-plaintext highlighter-rouge">tab[1]</code> 的地址</td> </tr> <tr> <td>0x7ffc5c78b530</td> <td>int</td> <td>4</td> <td>1</td> <td><code class="language-plaintext highlighter-rouge">tab[0][0]</code> 的值</td> </tr> <tr> <td>0x7ffc5c78b534</td> <td>int</td> <td>4</td> <td>2</td> <td><code class="language-plaintext highlighter-rouge">tab[0][1]</code> 的值</td> </tr> <tr> <td>0x7ffc5c78b538</td> <td>int</td> <td>4</td> <td>3</td> <td><code class="language-plaintext highlighter-rouge">tab[1][0]</code> 的值</td> </tr> <tr> <td>0x7ffc5c78b53c</td> <td>int</td> <td>4</td> <td>4</td> <td><code class="language-plaintext highlighter-rouge">tab[1][1]</code> 的值</td> </tr> </tbody> </table> <p>在这个布局中，<code class="language-plaintext highlighter-rouge">tab</code> 作为二维数组名，代表数组首地址，即 <code class="language-plaintext highlighter-rouge">tab[0]</code> 的地址 <code class="language-plaintext highlighter-rouge">0x7ffc5c78b530</code>。<code class="language-plaintext highlighter-rouge">tab[0]</code> 又指向第一行的首元素 <code class="language-plaintext highlighter-rouge">tab[0][0]</code>，其值为 1。<code class="language-plaintext highlighter-rouge">tab + 1</code> 则指向第二行的首地址 <code class="language-plaintext highlighter-rouge">tab[1]</code>，即 <code class="language-plaintext highlighter-rouge">0x7ffc5c78b538</code>，<code class="language-plaintext highlighter-rouge">tab[1]</code> 指向第二行首元素 <code class="language-plaintext highlighter-rouge">tab[1][0]</code>，其值为 3。</p> <p>从二维数组的逻辑角度理解，它可以看作是一个表格，有行和列的概念：</p> <table> <thead> <tr> <th> </th> <th>col: 0</th> <th>col: 1</th> </tr> </thead> <tbody> <tr> <td>row: 0</td> <td>1</td> <td>2</td> </tr> <tr> <td>row: 1</td> <td>3</td> <td>4</td> </tr> </tbody> </table> <p>本质上，高维数组在内存中也是按顺序一个单元挨着一个单元存储的，和一维数组并无区别。例如 <code class="language-plaintext highlighter-rouge">int tab[2][2]</code> 与 <code class="language-plaintext highlighter-rouge">int row[4]</code> 在物理存储上是类似的，都是连续存储 4 个 <code class="language-plaintext highlighter-rouge">int</code> 类型的数据。然而，<code class="language-plaintext highlighter-rouge">int tab[2][2]</code> 这种高维数组的表示形式提供了更为便捷的访问方式。比如，要访问第二行的所有数据，可以通过 <code class="language-plaintext highlighter-rouge">tab[1]</code> 获取第二行的首地址，进而遍历该行数据；要访问第二行第一列的数据，即第三个数据，可以表示为 <code class="language-plaintext highlighter-rouge">tab[1][0]</code>。这种按行和列的逻辑访问方式，使得处理具有行列结构的数据（如矩阵等）更加直观和高效。</p> <h3 id="4-多级指针">4. 多级指针</h3> <h4 id="41-多级指针在参数传递中的应用">4.1 多级指针在参数传递中的应用</h4> <p>首先明确在函数参数传递场景中多级指针的作用。当我们需要在函数中传递一个指针进来或者出去时，多级指针就能发挥重要作用。例如，假设我们有一个函数需要返回一个动态分配的数组，同时返回数组的长度，并且用一个状态值表示操作是否成功。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="c1">// 假设ID是一个自定义类型，这里简单用int代替</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">ID</span><span class="p">;</span>

<span class="c1">// 函数声明</span>
<span class="n">bool</span> <span class="nf">getArr</span><span class="p">(</span><span class="n">ID</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">cnt</span><span class="p">,</span> <span class="kt">int</span><span class="o">**</span> <span class="n">arr</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ID</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">isSuccess</span> <span class="o">=</span> <span class="n">getArr</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isSuccess</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">free</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">getArr</span><span class="p">(</span><span class="n">ID</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">cnt</span><span class="p">,</span> <span class="kt">int</span><span class="o">**</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 这里简单模拟获取数组的逻辑</span>
    <span class="o">*</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="o">*</span><span class="n">cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">arr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">arr</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上述代码中，<code class="language-plaintext highlighter-rouge">getArr</code> 函数接受一个 <code class="language-plaintext highlighter-rouge">ID</code> 类型的参数 <code class="language-plaintext highlighter-rouge">id</code>，以及两个指针参数 <code class="language-plaintext highlighter-rouge">cnt</code> 和 <code class="language-plaintext highlighter-rouge">arr</code>。<code class="language-plaintext highlighter-rouge">cnt</code> 是一个 <code class="language-plaintext highlighter-rouge">int*</code> 类型的指针，用于传出数组的长度；<code class="language-plaintext highlighter-rouge">arr</code> 是一个 <code class="language-plaintext highlighter-rouge">int**</code> 类型的指针，用于传出动态分配的数组的地址。通过这种方式，函数可以返回多个值。</p> <p>从内存空间角度来看，在 <code class="language-plaintext highlighter-rouge">main</code> 函数中，<code class="language-plaintext highlighter-rouge">arr</code> 最初是一个空指针，<code class="language-plaintext highlighter-rouge">&amp;arr</code> 传递给 <code class="language-plaintext highlighter-rouge">getArr</code> 函数。在 <code class="language-plaintext highlighter-rouge">getArr</code> 函数内部，<code class="language-plaintext highlighter-rouge">*arr</code> 被分配内存并填充数据。这里的二级指针 <code class="language-plaintext highlighter-rouge">arr</code> 就像是一个“桥梁”，连接了函数内外，使得函数可以修改外部指针变量的值，从而达到传递指针出去的目的。</p> <p>简单来说，如果需要传指针到函数进去修改，就会多一级指针。如果本身是二级指针，就会变成三级指针。</p> <h4 id="42-多级指针等价于高维数组">4.2 多级指针等价于高维数组</h4> <p>除了用于函数传参，需要增加一级指针，还有一种常见的多级指针的场景就是高维数组。数组在传参的时候，会退化为多级指针。 todo:</p> <h3 id="98-example">98. example</h3> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">Node</span> <span class="o">=</span> <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="nc">Node</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="nf">insertNodeAtHead</span><span class="p">(</span><span class="n">Node</span><span class="o">***</span> <span class="n">headRef</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newNode</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">**</span><span class="n">headRef</span><span class="p">;</span>
    <span class="o">**</span><span class="n">headRef</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>  <span class="c1">// 修改原始头指针</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">**</span> <span class="n">headPtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head</span><span class="p">;</span>          <span class="c1">// 指向头指针的指针</span>
    <span class="n">insertNodeAtHead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">headPtr</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>  <span class="c1">// 传递三级指针</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-数组退化为指针是什么意思">1. 数组退化为指针是什么意思？</h4> <p>数组退化为指针是指在某些情况下，数组名会被编译器自动转换为指向数组第一个元素的指针。这种情况通常发生在数组作为函数参数传递时。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">printArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
    <span class="n">printArray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>  <span class="c1">// array 退化为指针</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在这个例子中，<code class="language-plaintext highlighter-rouge">array</code> 作为参数传递给 <code class="language-plaintext highlighter-rouge">printArray</code> 函数时，退化为指向 <code class="language-plaintext highlighter-rouge">array</code> 第一个元素的指针。正如前面说的，数组的本质是是首元素指针+数组长度</p> <h4 id="2-数组的内存安全如何保证越界风险如何避免">2. 数组的内存安全如何保证？越界风险如何避免？</h4> <p>数组的内存安全是指在使用数组时，确保不访问数组边界之外的内存，以避免越界访问。越界访问可能导致程序崩溃或意外行为。</p> <ol> <li><strong>使用数组长度</strong>：在访问数组元素时，始终使用数组的长度进行边界检查。</li> <li><strong>使用标准库函数</strong>：使用标准库函数（如 <code class="language-plaintext highlighter-rouge">memcpy</code>、<code class="language-plaintext highlighter-rouge">memset</code> 等）时，确保传递的长度参数正确。</li> <li><strong>使用动态数组</strong>：使用动态数组（如 <code class="language-plaintext highlighter-rouge">std::vector</code>）可以自动管理数组的大小和边界检查。</li> <li><strong>启用编译器警告</strong>：启用编译器的警告和错误检查选项，可以帮助发现潜在的越界访问问题。</li> </ol>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><summary type="html"><![CDATA[指针那些事儿]]></summary></entry><entry><title type="html">（一）模板那些事儿：是什么？</title><link href="https://marco-hmc.github.io/blog/2025/0_template_introduction/" rel="alternate" type="text/html" title="（一）模板那些事儿：是什么？"/><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/0_template_introduction</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/0_template_introduction/"><![CDATA[<h2 id="一模板那些事儿是什么">（一）模板那些事儿：是什么？</h2> <ol> <li><strong>模板基础</strong>：介绍模板的基本概念和语法，包括函数模板和类模板的定义和使用。</li> <li><strong>模板参数</strong>：详细讲解模板参数的类型，包括类型模板参数、非类型模板参数和模板模板参数。</li> <li><strong>模板实例化</strong>：解释模板实例化的概念和时机，包括显式实例化和隐式实例化。</li> <li><strong>模板特化</strong>：介绍模板特化的概念和应用场景，包括部分特化和全特化。</li> </ol> <h3 id="1-模板基础">1. 模板基础</h3> <h4 id="11-什么是模板">1.1 什么是模板</h4> <p>从应用层次来看，C++中的模板堪称一种极为强大的泛型编程工具，它使得编写与类型无关的代码成为可能。借助模板，只需完成一次代码编写，就能在各种不同场景中重复运用，无需针对每种类型都另行编写代码。</p> <p>从概念层面来讲，对于编译器而言，模板可看作是一种基于类型的编程模式，也可称之为面向类型编程。模板的值对象涵盖类型与常量。模板特化类似于针对类型进行条件判断，它允许针对特定类型提供专门的模板实现。例如，当模板在处理多种不同类型时，如果对某些特定类型存在特殊需求，便可借助模板特化来予以满足。而模板递归则是通过持续不断地实例化模板来逐步展开。这表明模板具备类似于变量、条件判断（if - else）以及循环（loop）的能力，只不过这些能力的实现方式与常规 C++开发存在差异。正因如此，不少人觉得 C++的模板近乎一门独立的语言，基于此的编程方式便被称作模板元编程。</p> <ul> <li><strong>狭义泛型编程层面</strong>：如前文所述，由于编写的是与类型无关的代码，一旦声明具体类型并完成模板实例化，代码即可实现复用。例如，编写一个简单的交换函数模板：</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>然而，这种实现并非尽善尽美，它无法处理指针类型的交换。为解决此问题，可以利用模板特化来实现针对指针类型的交换函数。在这个例子中，仅需对指针类型这一个例子进行特化。但倘若需要对具有某种性质的一类类型进行特化，情况又当如何呢？</p> <p>例如，对于一个容器类型的<code class="language-plaintext highlighter-rouge">clear()</code>函数，POD 类型（Plain Old Data，即具有平凡构造函数、平凡析构函数、平凡拷贝构造函数且为标准布局的数据类型，像 C++中的基本数据类型<code class="language-plaintext highlighter-rouge">int</code>、<code class="language-plaintext highlighter-rouge">char</code>等以及满足特定条件的自定义结构体和类都属于 POD 类型）和自定义类型的实现要求便有所不同。POD 类型通常不涉及复杂的资源管理，其析构函数的概念相对薄弱，在<code class="language-plaintext highlighter-rouge">clear()</code>函数中直接使用<code class="language-plaintext highlighter-rouge">memset(0)</code>来清理内存即可；而自定义类型可能涉及资源管理，调用<code class="language-plaintext highlighter-rouge">clear()</code>时需要逐个调用元素的析构函数。此时，模板的条件判断能力就显得至关重要。那该如何通过模板特化来实现呢？</p> <p>实际上，一般模板特化的实现更近似于<code class="language-plaintext highlighter-rouge">switch - case</code>的形式，只能有一个特化的实现，而无法达成类似于<code class="language-plaintext highlighter-rouge">if - else</code>的多重特化。为解决这一难题，C++11 引入了<code class="language-plaintext highlighter-rouge">std::enable_if</code>，它允许在模板参数中运用条件表达式，进而实现更为灵活的模板特化。通过这种方式，能够依据类型的特性来选择不同的实现。</p> <ul> <li><strong>模板内容划分</strong> 关于模板的内容我会从两方面展开讲，简单划分为入门内容（语法层面），进阶内容（模板元编程层面）展开。具体如下：</li> </ul> <ol> <li> <p><strong>入门使用-简单泛型编程（Generic Programming）</strong>：</p> <ul> <li><strong>函数模板</strong>：函数模板允许编写与类型无关的函数，通过类型参数化实现函数的泛型。例如，<code class="language-plaintext highlighter-rouge">std::sort</code> 可以对任何类型的容器进行排序。</li> <li><strong>类模板</strong>：类模板允许编写与类型无关的类，通过类型参数化实现类的泛型。例如，<code class="language-plaintext highlighter-rouge">std::map&lt;Key, Value&gt;</code> 可以存储任何类型的键值对。</li> <li><strong>变量模板</strong>：主要是用于模板元编程，类型特征那套，也可以用于表示<code class="language-plaintext highlighter-rouge">pi</code>在不同类型下的大小吧，比如说精度要求不高，可以<code class="language-plaintext highlighter-rouge">float</code>和<code class="language-plaintext highlighter-rouge">double</code>各定义一个<code class="language-plaintext highlighter-rouge">pi</code>吧。</li> <li><strong>模板参数</strong>：模板允许编写与类型无关的代码，通过类型参数化实现代码复用。例如，<code class="language-plaintext highlighter-rouge">std::vector&lt;T&gt;</code> 可以存储任何类型的元素。</li> <li><strong>模板特化</strong>：模板特化允许为特定类型提供特殊的实现，从而优化特定类型的操作。例如，<code class="language-plaintext highlighter-rouge">std::hash</code> 可以为不同类型提供不同的哈希函数。</li> </ul> </li> <li> <p><strong>进阶使用-模板元编程（Template Metaprogramming）</strong>：</p> <ul> <li><strong>类型特征（Type Traits）</strong>：通过模板元编程，可以实现类型特征，用于在编译期检查和操作类型。进一步地，可以认为是一种函数。其参数为类型或者字面量。例如，<code class="language-plaintext highlighter-rouge">std::is_integral</code> 可以用于检查一个类型是否是整型。</li> <li><strong>递归模板</strong>：模板元编程通常使用递归模板来实现复杂的编译期计算。例如，计算编译期常量、生成类型列表等。</li> <li><strong>条件编译</strong>：通过模板元编程，可以实现条件编译，根据不同的模板参数生成不同的代码。而 SAFINAE 是模板元编程，利用 type traits 实现条件编译的一种常见手段。</li> </ul> </li> <li> <p><strong>模板实践</strong></p> <ul> <li>不定长参数</li> <li>类型擦除</li> <li>表达式模板</li> </ul> </li> </ol> <h4 id="12-模板的基本语法">1.2 模板的基本语法</h4> <p>模板的基本语法包括模板声明、模板定义和模板实例化。模板声明和定义使用 <code class="language-plaintext highlighter-rouge">template</code> 关键字，后跟模板参数列表。模板参数列表可以包含类型参数和非类型参数。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="c1">// 函数模板</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="n">T</span> <span class="n">functionName</span><span class="p">(</span><span class="n">T</span> <span class="n">parameter</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="p">{</span>
    <span class="c1">// 类模板</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">ClassName</span> <span class="p">{</span>
      <span class="nl">public:</span>
        <span class="n">T</span> <span class="n">memberFunction</span><span class="p">(</span><span class="n">T</span> <span class="n">parameter</span><span class="p">)</span> <span class="p">{}</span>

      <span class="k">private</span><span class="o">:</span>
        <span class="n">T</span> <span class="n">memberVariable</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="p">{</span>

    <span class="c1">// C++14（变量模板）</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kr">inline</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">is_integral_v</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_integral</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="p">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">fib</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="o">+</span> <span class="n">fib</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">fib</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">fib</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">fib</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span> <span class="o">==</span> <span class="mi">55</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h5 id="121-注入类名">1.2.1 注入类名</h5> <p>在 C++中，类模板的注入类名（Injected class name）是指在类模板内部，类模板名可以被用作一个类型名，并且这个名字会隐式地被替换为当前实例化的模板类型。下面详细介绍其含义和使用场景。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// ctor里面的MyClass能直接使用，不需要再考虑模板实例化，这个就是注入类名</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Copy constructor called."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 模板又实例化一次是多余的。</span>
    <span class="n">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="n">MyClass</span> <span class="nf">createInstance</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">MyClass</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

</code></pre></div></div> <h5 id="122-依赖名称">1.2.2 依赖名称</h5> <ul> <li><strong>依赖名称和 typename</strong></li> </ul> <p>依赖名称是模板定义中，其含义依赖于模板参数的名称。这些名称的类型或值，需在模板实例化时才能确定。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Container</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Iterator print"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="n">Iterator</span> <span class="nf">getIterator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Iterator</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Container&lt;T&gt;是依赖名称，因为其具体类型依赖于模板参数T</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Container&lt;T&gt;::Iterator同样是依赖名称，其具体类型也依赖于模板参数T</span>
    <span class="k">typename</span> <span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">container</span><span class="p">.</span><span class="n">getIterator</span><span class="p">();</span>
    <span class="n">it</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <ul> <li>依赖名称不仅包括依赖于模板参数实例化的类型，还可能涉及函数名等其他名称，只要其含义依赖于模板参数，均属于依赖名称。</li> <li>当编译器解析到<code class="language-plaintext highlighter-rouge">Container&lt;T&gt;::Iterator</code>时，由于模板尚未实例化，它无法确定这是一个类型。</li> <li>因此，需使用<code class="language-plaintext highlighter-rouge">typename</code>关键字显式告知编译器，<code class="language-plaintext highlighter-rouge">Container&lt;T&gt;::Iterator</code>是一个类型。</li> <li> <p>在函数模板的参数列表中，对于依赖类型名称，<code class="language-plaintext highlighter-rouge">typename</code>关键字通常是可选的，因为编译器能通过上下文推断类型。但在函数返回类型中，如果涉及依赖类型名称，一般必须使用<code class="language-plaintext highlighter-rouge">typename</code> 关键字来明确表明其为类型。而在声明变量时，为避免编译器将依赖名称误解为其他实体（如成员函数），必须加上<code class="language-plaintext highlighter-rouge">typename</code>关键字。</p> </li> <li><strong>依赖名称和 template</strong></li> </ul> <p>在 C++模板编程中，当处理嵌套模板结构时，<code class="language-plaintext highlighter-rouge">template</code> 关键字具有特殊的用途。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Container</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// 定义了一个嵌套的模板函数 print</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">U</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Value: "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="n">Container</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 此处 c.print&lt;int&gt;(42); 这样的写法编译器无法识别 print 是一个模板函数。</span>
    <span class="c1">// 因为编译器在解析代码时，对于依赖于模板参数 T 的表达式 c.print，</span>
    <span class="c1">// 它无法预先知道 print 是一个模板。</span>
    <span class="c1">// 使用 c.template print&lt;int&gt;(42); 明确告诉编译器，print 是一个模板函数，</span>
    <span class="c1">// 这样编译器才能正确地实例化这个嵌套的模板函数。</span>
    <span class="n">c</span><span class="p">.</span><span class="k">template</span> <span class="n">print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="mi">42</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Container</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">test</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在 <code class="language-plaintext highlighter-rouge">test</code> 函数中，由于 <code class="language-plaintext highlighter-rouge">Container&lt;T&gt;</code> 是依赖于模板参数 <code class="language-plaintext highlighter-rouge">T</code> 的类型，对于 <code class="language-plaintext highlighter-rouge">c.print</code> 这样的表达式，编译器在解析时无法自动识别 <code class="language-plaintext highlighter-rouge">print</code> 是一个模板函数。使用 <code class="language-plaintext highlighter-rouge">template</code> 关键字（即 <code class="language-plaintext highlighter-rouge">c.template print&lt;int&gt;(42);</code>），能够明确告知编译器 <code class="language-plaintext highlighter-rouge">print</code> 是一个模板函数，以便编译器正确地对其进行实例化。这确保了在处理复杂模板结构时，编译器能够准确理解代码意图，避免潜在的编译错误。</p> <h3 id="2-模板参数">2. 模板参数</h3> <h4 id="21-类型模板参数">2.1 类型模板参数</h4> <p>类型模板参数是指在模板定义中，以类型作为参数的一种机制。通过类型模板参数，我们可以让模板适应不同的数据类型，从而提高代码的通用性。例如，在常见的 <code class="language-plaintext highlighter-rouge">std::vector</code> 模板中，<code class="language-plaintext highlighter-rouge">typename T</code> 就是类型模板参数，使得 <code class="language-plaintext highlighter-rouge">std::vector</code> 可以存储各种不同类型的数据，如 <code class="language-plaintext highlighter-rouge">std::vector&lt;int&gt;</code>、<code class="language-plaintext highlighter-rouge">std::vector&lt;double&gt;</code> 等。在模板定义中，通常使用 <code class="language-plaintext highlighter-rouge">typename</code> 或 <code class="language-plaintext highlighter-rouge">class</code> 关键字来声明类型模板参数，二者在这种场景下语义相同。</p> <h4 id="22-非类型模板参数">2.2 非类型模板参数</h4> <p>非类型模板参数是模板参数的一种特殊形式，它用于在模板定义中指定常量值。与类型模板参数不同，非类型模板参数代表的是具体的常量，而非数据类型。这些常量可以是整数、枚举、指针或引用等。</p> <p>使用非类型模板参数能够在编译期确定一些值，从而增强代码的灵活性和效率。例如，我们可以定义一个固定大小的数组模板，通过非类型模板参数指定数组的大小：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">FixedSizeArray</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">data</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
<span class="nl">public:</span>
    <span class="n">FixedSizeArray</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>这里的 <code class="language-plaintext highlighter-rouge">int size</code> 就是非类型模板参数，在实例化模板时，必须提供一个常量值来确定数组的大小，如 <code class="language-plaintext highlighter-rouge">FixedSizeArray&lt;int, 10&gt; arr;</code> 就创建了一个大小为 10 的 <code class="language-plaintext highlighter-rouge">int</code> 类型数组。</p> <h4 id="23-模板模板参数">2.3 模板模板参数</h4> <p>模板模板参数允许我们编写接受其他模板作为参数的模板，这进一步提升了代码的灵活性和重用性。它为模板提供了一种更高层次的抽象，使得我们可以基于不同的模板容器实现通用的功能。</p> <p>例如，假设有一个 <code class="language-plaintext highlighter-rouge">Container</code> 类模板用于存储数据：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="c1">// 类模板示例</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Container</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 模板参数还是模板的示例</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">ContainerType</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Wrapper</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">container</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">container</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">ContainerType</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">container</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">Container</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">intWrapper</span><span class="p">;</span>
    <span class="n">intWrapper</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">intWrapper</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上述代码中，<code class="language-plaintext highlighter-rouge">template &lt;typename&gt; class ContainerType</code> 就是模板模板参数，它表示一个接受单个类型参数的模板。<code class="language-plaintext highlighter-rouge">Wrapper</code> 模板可以接受任何符合这种模板形式的容器模板，如 <code class="language-plaintext highlighter-rouge">Container</code>，并对其进行封装，提供统一的接口。</p> <p>实际上，模板也可以看成是一种类型，只不过这种类型是在编译时才能确定的。它为 C++ 提供了强大的元编程能力，使得我们可以在编译期完成一些复杂的计算和代码生成，提高程序的运行效率和灵活性。</p> <h3 id="3-模板实例化">3. 模板实例化</h3> <p>隐式实例化指的是当编译器首次察觉到需要使用某个模板时，会自动为其生成对应的模板实例。也就是说，在代码中首次调用模板函数或创建模板类对象时，编译器根据传入的实际模板参数类型，自动生成具体的函数或类定义。例如：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="c1">// 在此处，由于使用了add函数且传入int类型参数，编译器自动生成int类型的add函数实例，即发生了隐式实例化。</span>

    <span class="kt">double</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">);</span>
    <span class="c1">// 同理，这里传入double类型参数，编译器又会隐式实例化出double类型的add函数实例。</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="32-显式实例化">3.2 显式实例化</h4> <p>显式实例化要求在代码中明确指定模板参数，以此强制编译器生成特定类型的模板实例。其主要应用场景在于优化编译过程，具体表现为：</p> <ul> <li><strong>提高编译速度</strong>：在大型项目中，若某些模板实例会被频繁使用，提前进行显式实例化，可避免在多个编译单元中重复隐式实例化相同的模板，从而减少编译时间。</li> <li><strong>减少代码膨胀</strong>：当模板实例化出的代码量较大且相同类型的实例在多处使用时，显式实例化可确保仅生成一份实例代码，避免因多次隐式实例化导致的代码体积增大。</li> </ul> <p>示例如下：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="nf">add</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 显式实例化add函数模板，明确指定生成int类型和double类型的add函数实例</span>
<span class="k">template</span> <span class="kt">int</span> <span class="n">add</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">template</span> <span class="kt">double</span> <span class="n">add</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">&gt;(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="c1">// 这里直接使用显式实例化生成的int类型的add函数。</span>
    <span class="kt">double</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">);</span>
    <span class="c1">// 同样，使用显式实例化生成的double类型的add函数。</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>需注意，在进行显式实例化时，要确保显式实例化的声明与模板定义在同一作用域内，否则可能导致链接错误。同时，若在同一编译单元中对同一模板进行多次显式实例化，也会引发编译错误。</p> <ul> <li><strong>显式实例化怎么做？</strong></li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* -------- a.hpp --------- */</span>
<span class="cp">#pragma once
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">extern</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">&gt;;</span>         <span class="c1">// 声明 A&lt;int&gt; 的显式实例化</span>
<span class="k">extern</span> <span class="k">template</span> <span class="kt">void</span> <span class="n">A</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">&gt;</span><span class="o">::</span><span class="n">f</span><span class="p">();</span>  <span class="c1">// 声明 A&lt;double&gt;::f() 的显式实例化</span>

<span class="cm">/* -------- a.cpp --------- */</span>
<span class="cp">#include</span> <span class="cpf">"a.hpp"</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="k">template</span> <span class="k">class</span> <span class="nc">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">&gt;;</span>  <span class="c1">// 实例化 A&lt;int&gt;</span>
<span class="k">template</span> <span class="kt">void</span> <span class="n">A</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">&gt;</span><span class="o">::</span><span class="n">f</span><span class="p">();</span>  <span class="c1">// 实例化 A&lt;double&gt;::f()</span>

<span class="cm">/* -------- main.cpp --------- */</span>
<span class="cp">#include</span> <span class="cpf">"a.hpp"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">A</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{}.</span><span class="n">f</span><span class="p">();</span>
  <span class="n">A</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{}.</span><span class="n">f</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="33-模板链接">3.3 模板链接</h4> <h5 id="331-模板实现不能放在cpp">3.3.1 模板实现不能放在.cpp</h5> <p>在C++ 编程中，通常不建议将模板的实现放在 <code class="language-plaintext highlighter-rouge">.cpp</code> 文件中。这是因为模板的实例化是在编译期进行的，编译器需要同时看到模板的声明和定义，才能根据具体的模板参数生成对应的实例化代码。</p> <p>当模板定义在 <code class="language-plaintext highlighter-rouge">.cpp</code> 文件中时，不同的编译单元（通常是不同的 <code class="language-plaintext highlighter-rouge">.cpp</code> 文件及其对应的 <code class="language-plaintext highlighter-rouge">.h</code> 文件）在编译时是相互独立的。如果一个编译单元只包含了模板的声明，而在另一个编译单元的 <code class="language-plaintext highlighter-rouge">.cpp</code> 文件中有模板的实现，那么在链接阶段就可能会出现问题。因为链接器无法找到模板实例化所需的定义，导致链接错误。</p> <p>为了避免这种情况，一般将模板的声明和定义都放在头文件（<code class="language-plaintext highlighter-rouge">.h</code> 或 <code class="language-plaintext highlighter-rouge">.hpp</code>）中，这样所有包含该头文件的编译单元在编译时都能获取到完整的模板信息，从而顺利进行实例化。</p> <h5 id="332-模板不能具有-c-链接">3.3.2 模板不能具有 C 链接</h5> <p>C++ 的模板不能与 C 语言的链接规范（C linkage）一起使用。链接规范决定了编译器如何生成符号以及链接器如何解析这些符号。C语言和C++ 语言的链接规范有所不同，C++ 为了支持函数重载等特性，其符号命名规则更为复杂。</p> <p>模板是 C++ 特有的高级特性，依赖于 C++ 的编译和链接机制。当使用 <code class="language-plaintext highlighter-rouge">extern "C"</code> 来指定 C 链接规范时，它会改变符号的命名规则，使得模板实例化生成的符号无法按照 C++ 的方式被正确解析。例如：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">jc</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="s">"C++"</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">normal</span><span class="p">();</span>  <span class="c1">// 正确：默认 C++ 链接规范，编译器按照 C++ 的符号命名规则处理该模板函数</span>
    <span class="k">extern</span> <span class="s">"C"</span> <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">invalid</span><span class="p">();</span>  <span class="c1">// 错误：不能使用 C 链接，因为 C 链接规范下无法正确处理模板实例化生成的符号</span>
<span class="p">}</span>  <span class="c1">// namespace jc</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div> <p>而使用 <code class="language-plaintext highlighter-rouge">extern "C++"</code> 时，即为默认的 C++ 链接规范，编译器和链接器能够正确处理模板相关的符号。</p> <h5 id="333-模板的外链接与静态链接">3.3.3 模板的外链接与静态链接</h5> <p>在C++ 中，模板通常具有外链接（<strong>external linkage</strong>）特性。这意味着模板的定义在整个程序中是共享的，不同的编译单元可以引用同一个模板实例化生成的代码。当多个编译单元都需要使用某个模板的特定实例时，链接器会确保这些实例是同一个。</p> <p>然而，对于<strong>静态模板函数</strong>（即在模板函数定义前加上 <code class="language-plaintext highlighter-rouge">static</code> 关键字），它会具有内部链接（<strong>internal linkage</strong>）。具有内部链接的实体在当前翻译单元内可见，但在其他翻译单元中不可见。这是因为 <code class="language-plaintext highlighter-rouge">static</code> 关键字改变了模板函数的链接属性，使得每个编译单元都拥有自己独立的该静态模板函数的实例，而不会与其他编译单元共享。例如：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>  <span class="c1">// 外部链接，不同编译单元可共享该模板实例化生成的代码</span>
<span class="kt">void</span> <span class="nf">external</span><span class="p">();</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>  <span class="c1">// 内部链接，每个编译单元都有自己独立的该静态模板函数实例</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">internal</span><span class="p">();</span>

<span class="k">namespace</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span>  <span class="c1">// 匿名命名空间内的模板具有内部链接，同样每个编译单元独立实例化</span>
    <span class="kt">void</span> <span class="n">other_internal</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>  <span class="c1">// 无链接：这种在结构体内部定义的模板不能被重复声明，仅在结构体内部使用</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span> <span class="n">x</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div> <p>理解模板的链接特性对于编写大型项目以及避免链接错误至关重要。在实际编程中，应根据需求合理选择模板的链接方式，以确保代码的正确性和高效性。</p> <h3 id="4-模板特化">4. 模板特化</h3> <h3 id="4-模板特化-1">4. 模板特化</h3> <p>在 C++ 模板编程领域，模板特化（Template Specialization）是一项极为关键的技术。它赋予开发者针对特定的模板参数设定独特实现的能力，进而显著增强代码的灵活性与性能表现。模板特化主要细分为部分特化和全特化两种类型。</p> <p>模板特化在众多实际编程场景中具有不可或缺的作用：</p> <ul> <li><strong>优化特定类型</strong>：当涉及某些特定类型时，为其量身定制优化后的实现，能够有效提升程序性能。例如，在处理 <code class="language-plaintext highlighter-rouge">int</code> 类型数据时，由于其使用频率高且特性明确，可提供特殊实现以加快处理速度。</li> <li><strong>处理特殊情况</strong>：针对特定类型或者特定条件下的特殊状况，模板特化可发挥重要作用。以指针类型为例，因其涉及解引用操作和内存管理等复杂问题，通过为指针类型提供特殊实现，能够更妥善地处理这些情况。</li> <li><strong>实现类型特征</strong>：借助模板特化，能够实现类型特征（type traits），这对于在编译阶段检测类型属性至关重要。比如，通过模板特化实现检查某个类型是否为指针类型、是否为整数类型等功能。</li> </ul> <h4 id="41-模板特化">4.1 模板特化</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">FullSpecialization</span> <span class="p">{</span>
    <span class="c1">// 主模板</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
      <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Primary template"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// 模板特化</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Full specialization for int"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace FullSpecialization</span>

</code></pre></div></div> <h4 id="42-模板偏特化">4.2 模板偏特化</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">PartialSpecialization</span> <span class="p">{</span>
    <span class="c1">// 主模板</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">U</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
      <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Primary template"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">// 偏特化-部分模板参数特化</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">MyClass</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Partial specialization: second parameter is int"</span>
                      <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace PartialSpecialization</span>
</code></pre></div></div> <h4 id="43-特化的推断规则">4.3 特化的推断规则</h4> <p>在C++ 中，当存在多个模板都能匹配给定的模板参数时，编译器会依据偏序规则来选择最合适的模板。若无法明确判断哪个模板更特化，编译器将报出歧义错误。</p> <p>所谓“更特化”，可以这样理解：对于两个模板，如果在所有能使其中一个模板匹配的模板参数实例化情况下，另一个模板也能匹配，并且存在至少一种情况，使得后者匹配而前者不匹配，那么前者就是更特化的模板。换个角度看，如果把模板参数的匹配情况看作集合，更特化的模板所对应的参数匹配集合是另一个模板参数匹配集合的真子集。</p> <p>以下通过代码示例详细说明：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 3</span>
    <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 0 推断为 int，匹配第一个模板</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>

    <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// 两个模板均匹配，第二个模板更特殊。T*是T的真子集</span>

    <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">pp</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 两个模板均匹配，第三个模板更特殊。const T*是T和T*的真子集</span>
<span class="p">}</span>
</code></pre></div></div> <p>通过这样的规则和示例，希望能帮助你更清晰地理解模板特化的推断过程。</p> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-不同源文件都使用了vectorint有没有违反-odr-原则实例化了几次代码里面会有多少vectorint的定义">1. 不同源文件都使用了<code class="language-plaintext highlighter-rouge">vector&lt;int&gt;</code>，有没有违反 odr 原则？实例化了几次？代码里面会有多少<code class="language-plaintext highlighter-rouge">vector&lt;int&gt;</code>的定义？</h4> <p>在 C++ 中，模板实例化的行为取决于编译器和链接器的实现。通常情况下，如果多个源文件都使用了相同的模板实例（例如 vector<int>），编译器会在每个使用该模板实例的源文件中生成一份实例化代码。然而，链接器会负责消除重复的实例化代码，只保留一份最终的实例化代码。</int></p> <p>也就是说不同源文件使用了相同的模板实例就会各自实例化，但是链接器会优化，合并重复实例代码。注意，合并了重复的实例代码，只是减轻了代码生成的体积，实例的开销没办法去掉，所以模板用多了，编译会慢一些，开销在于模板实例化。</p> <h4 id="2-什么是-adl">2. 什么是 ADL？</h4> <p>ADL（Argument - Dependent Lookup，依赖于实参的查找）是 C++ 中一种特殊的函数查找机制。在常规的函数调用中，编译器会在函数调用点的作用域以及包含该函数调用的命名空间中查找函数声明。而 ADL 则额外在实参类型所属的命名空间中查找函数声明，这使得在调用函数时，即使函数不在当前作用域内直接可见，只要它在实参类型相关的命名空间中，也能被找到并调用。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">MyNamespace</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">MyType</span> <span class="p">{};</span>

    <span class="kt">void</span> <span class="nf">someFunction</span><span class="p">(</span><span class="n">MyType</span> <span class="n">myArg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Function in MyNamespace called"</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">myTemplateFunction</span><span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">someFunction</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyNamespace</span><span class="o">::</span><span class="n">MyType</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">myTemplateFunction</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上述代码中，<code class="language-plaintext highlighter-rouge">myTemplateFunction</code> 模板函数内部调用 <code class="language-plaintext highlighter-rouge">someFunction</code> 时，虽然 <code class="language-plaintext highlighter-rouge">someFunction</code> 不在 <code class="language-plaintext highlighter-rouge">myTemplateFunction</code> 的直接作用域内，但因为 <code class="language-plaintext highlighter-rouge">arg</code> 的类型是 <code class="language-plaintext highlighter-rouge">MyNamespace::MyType</code>，ADL 机制会在 <code class="language-plaintext highlighter-rouge">MyNamespace</code> 命名空间中查找 <code class="language-plaintext highlighter-rouge">someFunction</code>，从而成功调用该函数。这展示了 ADL 如何让模板函数在不明确知道具体类型细节的情况下，利用参数类型在相应命名空间中找到合适的函数进行调用。</p> <h4 id="3-下面这些代码的注释处为什么不行">3. 下面这些代码的注释处为什么不行？</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">StringLinkErrorTpl</span> <span class="p">{</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">&gt;</span>
    <span class="k">class</span> <span class="nc">S</span> <span class="p">{</span>
      <span class="nl">public:</span>
        <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>  <span class="c1">// external linked object</span>
    <span class="kt">void</span> <span class="nf">syntax_literal_string_ok_example</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">S</span><span class="o">&lt;</span><span class="n">str</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">i</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">syntax_literal_string_fail_example</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>  <span class="c1">// running linked object</span>
        <span class="c1">// S&lt;str&gt; i; // not ok</span>
        <span class="c1">// i.print();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">task</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">syntax_literal_string_ok_example</span><span class="p">();</span>
        <span class="n">syntax_literal_string_fail_example</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace StringLinkErrorTpl</span>

<span class="k">namespace</span> <span class="n">PtrLinkErrorTpl</span> <span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">*</span> <span class="n">buf</span><span class="p">&gt;</span>
    <span class="k">struct</span> <span class="nc">ArrPtr</span> <span class="p">{};</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fun</span><span class="p">)()&gt;</span>
    <span class="k">struct</span> <span class="nc">FuncPtr</span> <span class="p">{};</span>

    <span class="kt">void</span> <span class="nf">task</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">static</span> <span class="kt">int</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
        <span class="n">ArrPtr</span><span class="o">&lt;</span><span class="n">buffer</span><span class="o">&gt;</span> <span class="n">arrPtr</span><span class="p">;</span>

        <span class="c1">// int buffer2[5] = {1, 2, 3, 4, 5};  // not ok</span>
        <span class="c1">// ArrPtr&lt;buffer2&gt; arrPtr2;</span>

        <span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">};</span>
        <span class="n">FuncPtr</span><span class="o">&lt;</span><span class="n">func</span><span class="o">&gt;</span> <span class="n">funcPtr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace PtrLinkErrorTpl</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><category term="template"/><summary type="html"><![CDATA[（一）模板那些事儿：是什么？]]></summary></entry><entry><title type="html">二进制兼容和 abi 兼容</title><link href="https://marco-hmc.github.io/blog/2025/1_binaryCompatbility/" rel="alternate" type="text/html" title="二进制兼容和 abi 兼容"/><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/1_binaryCompatbility</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/1_binaryCompatbility/"><![CDATA[<h2 id="二进制兼容和-abi-兼容">二进制兼容和 abi 兼容</h2> <h3 id="1-什么是二进制兼容问题">1. 什么是二进制兼容问题?</h3> <p>在升级库文件的时候，不必<strong>重新编译</strong>使用此库的可执行文件或其他库文件，并且程序的功能不被破坏。</p> <h3 id="2-二进制兼容有什么好处">2. 二进制兼容有什么好处?</h3> <p>保持二进制兼容性是为了确保软件的更新和升级过程更加平滑和无缝，以减少对用户和开发者的影响。</p> <ol> <li><strong>减少用户升级的难度:</strong> 如果新版本的程序能够与旧版本的程序兼容，用户在升级时无需重新编译或修改配置。这降低了用户升级的难度和成本。</li> <li><strong>避免破坏性变更:</strong> 破坏性变更可能会导致旧版本的程序无法与新版本的程序一起工作，从而造成功能中断或数据丢失。通过保持二进制兼容性，可以避免这种情况的发生。</li> <li><strong>提高用户信任度:</strong> 如果用户知道他们可以在不受影响的情况下升级软件，他们更有可能愿意使用最新版本的程序，从而提高了用户对软件的信任度。</li> <li><strong>简化发布流程:</strong> 保持二进制兼容性可以使软件发布变得更加简单，因为你不需要为每个新版本都重新构建所有的旧版本二进制文件。</li> <li><strong>降低维护成本:</strong> 如果软件能够保持二进制兼容性，你可以更轻松地维护多个版本，因为不需要重新构建和测试旧版本。</li> </ol> <h3 id="3-实现二进制兼容常见方式-pimplpointer-to-implementation">3. 实现二进制兼容常见方式-pimpl(pointer to implementation)</h3> <p>指针指向实现。简单来说就是将实现和接口分类的一种设计思路。</p> <p>也就是说将一个类分为接口类(外观类/导出类)<code class="language-plaintext highlighter-rouge">Foo</code>，以及实现类。</p> <p>外部使用接口类时，接口类的函数的内存偏移是固定的；而更新内容放在实现类就好了。而接口类通过一个指针，指向实现类，调用实现类的方法。这个指针就称作 D 指针。</p> <h4 id="31-pimpl-还有什么好处">3.1 pimpl 还有什么好处？</h4> <ul> <li> <p>数据隐藏 如果您正在开发一个库，尤其是专有库，则可能不希望公开用于实现库公共接口的其他库/实现技术。 要么是由于知识产权问题，要么是因为您认为用户可能会被诱使对实现进行危险的假设，或者只是通过使用可怕的转换技巧来破坏封装。 PIMPL 解决/缓解了这一难题。</p> </li> <li> <p>编译时间 编译时间减少了，因为当您向 XImpl 类添加/删除字段和/或方法时(仅映射到标准技术中添加私有字段/方法的情况)，仅需要重建 X 的源(实现)文件。 实际上，这是一种常见的操作。</p> <p>使用标准的标头/实现技术(没有 PIMPL)，当您向 X 添加新字段时，曾经重新分配 X(在堆栈或堆上)的每个客户端都需要重新编译，因为它必须调整分配的大小 . 好吧，每个从未分配 X 的客户端也都需要重新编译，但这只是开销(客户端上的结果代码是相同的).</p> </li> </ul> <h4 id="32-pimpl-通用实现范式dq-指针">3.2 pimpl 通用实现范式：D/Q 指针</h4> <p>D/Q 指针则是实现 pimpl 的一种方式。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 接口类</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Foo</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Foo</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">someMethod</span><span class="p">();</span>

<span class="nl">private:</span>
    <span class="k">class</span> <span class="nc">FooImpl</span><span class="p">;</span> <span class="c1">// 前向声明</span>
    <span class="n">FooImpl</span><span class="o">*</span> <span class="n">d</span><span class="p">;</span>    <span class="c1">// D 指针</span>
<span class="p">};</span>

<span class="c1">// 实现类</span>
<span class="k">class</span> <span class="nc">Foo</span><span class="o">::</span><span class="n">FooImpl</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">FooImpl</span><span class="p">(</span><span class="n">Foo</span><span class="o">*</span> <span class="n">q</span><span class="p">)</span> <span class="o">:</span> <span class="n">q</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="nf">someMethodImpl</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Foo</span><span class="o">*</span> <span class="n">q</span><span class="p">;</span> <span class="c1">// Q 指针</span>
<span class="p">};</span>

<span class="n">Foo</span><span class="o">::</span><span class="n">Foo</span><span class="p">()</span> <span class="o">:</span> <span class="n">d</span><span class="p">(</span><span class="k">new</span> <span class="nf">FooImpl</span><span class="p">(</span><span class="k">this</span><span class="p">))</span> <span class="p">{}</span>
<span class="n">Foo</span><span class="o">::~</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">d</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">Foo</span><span class="o">::</span><span class="n">someMethod</span><span class="p">()</span> <span class="p">{</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">someMethodImpl</span><span class="p">();</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">Foo</span><span class="o">::</span><span class="n">FooImpl</span><span class="o">::</span><span class="n">someMethodImpl</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 可以通过 Q 指针访问接口类的方法和成员变量</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">someMethod</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="4-abi-兼容">4. abi 兼容</h3> <p>ABI（Application Binary Interface，应用二进制接口）兼容性和二进制兼容性密切相关，但它们并不是完全相同的概念。</p> <p>ABI 兼容性指的是在二进制级别上，程序或库的不同版本之间能够互操作的能力。具体来说，ABI 兼容性确保了以下方面的一致性：</p> <ol> <li><strong>函数和方法的签名</strong>：参数类型、数量和顺序必须保持一致。</li> <li><strong>数据结构的布局</strong>：结构体和类的成员变量的顺序和对齐方式必须保持一致。</li> <li><strong>类的继承关系</strong>：基类和派生类的关系不能改变。</li> <li><strong>虚函数表（vtable）</strong>：虚函数的顺序和数量不能改变。</li> </ol> <h3 id="5-总结">5. 总结</h3> <p>简单而言，实现二进制兼容就是要分离接口和实现。接口 api 的 abi 是稳定的，以及接口类的内存布局是稳定的。</p> <ul> <li> <p><strong>ABI 兼容性</strong> ABI 兼容性指的是在二进制级别上，程序或库的不同版本之间能够互操作的能力。具体来说，ABI 兼容性确保了以下方面的一致性：</p> <ol> <li><strong>函数和方法的签名</strong>：参数类型、数量和顺序必须保持一致。</li> <li><strong>数据结构的布局</strong>：结构体和类的成员变量的顺序和对齐方式必须保持一致。</li> <li><strong>类的继承关系</strong>：基类和派生类的关系不能改变。</li> <li><strong>虚函数表（vtable）</strong>：虚函数的顺序和数量不能改变。</li> </ol> </li> <li> <p><strong>二进制兼容性</strong></p> </li> </ul> <p>二进制兼容性是一个更广泛的概念，它指的是一个程序的新版本可以使用旧版本的二进制接口（如共享库或对象文件）而不需要重新编译。二进制兼容性依赖于 ABI 兼容性，但还包括其他方面：</p> <ol> <li><strong>操作系统和硬件平台</strong>：二进制兼容性还涉及操作系统和硬件平台的兼容性。</li> <li><strong>编译器和链接器</strong>：不同编译器和链接器生成的二进制文件可能不兼容。</li> <li><strong>运行时环境</strong>：运行时库和环境的变化也可能影响二进制兼容性。</li> </ol> <ul> <li><strong>ABI 兼容性</strong>：主要关注程序或库在二进制级别上的接口一致性，确保不同版本之间能够互操作。</li> <li><strong>二进制兼容性</strong>：是一个更广泛的概念，除了 ABI 兼容性，还包括操作系统、硬件平台、编译器、链接器和运行时环境的兼容性。</li> </ul> <p>在实际开发中，保持 ABI 兼容性是实现二进制兼容性的关键步骤之一，但要实现完全的二进制兼容性，还需要考虑其他因素。</p> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-怎样才可以保证二进制兼容二进制兼容的关键是什么">1. 怎样才可以保证二进制兼容?二进制兼容的关键是什么?</h4> <p>二进制兼容性是指一个程序的新版本可以使用旧版本的二进制接口（如共享库或对象文件）而不需要重新编译。保证二进制兼容性的关键是保持 ABI（Application Binary Interface）的稳定性。</p> <p>以下是一些保证二进制兼容性的方法：</p> <ol> <li> <p><strong>不改变公共函数和方法的签名</strong>：如果你改变了函数或方法的参数类型、数量或顺序，那么二进制接口将会改变，导致二进制不兼容。</p> </li> <li> <p><strong>不改变数据结构的布局</strong>：如果你添加、删除或重新排序结构的成员，那么结构的布局将会改变，导致二进制不兼容。</p> </li> <li> <p><strong>不改变类的继承关系</strong>：如果你改变了类的基类或派生类，那么类的布局和虚函数表将会改变，导致二进制不兼容。</p> </li> <li> <p><strong>保持虚函数表的稳定性</strong>：如果你添加、删除或重新排序虚函数，那么虚函数表将会改变，导致二进制不兼容。</p> </li> </ol> <p>注意，以上的规则只适用于公共接口。你可以自由地改变私有函数、方法和数据成员，而不影响二进制兼容性。</p> <h4 id="2-一般什么情况下特别要求二进制兼容">2. 一般什么情况下特别要求二进制兼容?</h4> <ol> <li> <p><strong>操作系统:</strong> 操作系统的升级通常会涉及到底层的系统组件，保持二进制兼容性可以确保应用程序继续在新版本的操作系统上正常运行。</p> </li> <li> <p><strong>大型应用软件:</strong> 大型应用软件通常会有许多用户，升级可能涉及到大量的用户数据和配置。保持二进制兼容性有助于减少升级的风险。</p> </li> <li> <p><strong>软件库和框架:</strong> 开发人员在开发应用程序时可能会使用各种第三方库和框架，保持这些库和框架的二进制兼容性有助于减少对应用程序的影响。</p> </li> <li> <p><strong>游戏客户端:</strong> 游戏客户端经常需要进行更新和修复，保持二进制兼容性可以确保玩家在更新后继续享受游戏体验。</p> <blockquote> <p>如果是二进制兼容的，弄一个更新包可能就好了，如果不是的话，可能整个软件都要重新安装。</p> </blockquote> </li> </ol> <h4 id="3-stl-的-abi-兼容问题">3. stl 的 abi 兼容问题</h4> <p>STL（标准模板库）的实现确实会针对不同的编译器和编译选项进行优化，这导致了不同编译器和编译器版本之间的实现细节可能有所不同。这些差异可能包括内存布局、对齐方式、函数内联、异常处理等方面。</p> <p>不同的编译选项（如优化级别、调试符号、C++标准等）可能导致不同的二进制布局。 这意味着，如果你在库中使用 STL 容器作为参数，并且这个库需要在不同的编译环境下使用，可能会导致 ABI 不兼容，进而引发内存崩溃或未定义行为。</p> <p>使用接口隔离：通过定义稳定的接口和抽象层来隔离不同编译器实现的差异。 避免跨 DLL 边界使用 STL 容器：尽量避免在 DLL 或共享库的边界上传递 STL 容器，或者确保所有相关组件都使用相同的编译器和编译选项。</p> <blockquote> <p>我在网上看到给出的例子是：VS2010 编的库在 VS2013 上使用就经常会出问题。然后 VS2015 开始进入了长期 ABI 兼容周期，到现在 VS2022 还是与 VS2015 保持 ABI 兼容的。这反而又导致很多优化会被拖延到下一个打破 ABI 的版本。</p> </blockquote> <h4 id="4-静态库和动态库场景下对二进制的兼容">4. 静态库和动态库场景下对二进制的兼容</h4> <p>在使用静态库的时候，保持二进制兼容的意义在于减少编译时间和简化维护过程。 因为使用了静态库，所有代码在编译时就被链接到可执行文件中。</p> <p>而在使用动态库的时候，保持二进制兼容尤为重要，因为它可以简化库的升级过程。 这个时候只需要替换动态库文件（如 .dll、.so）即可，无需重新编译和重新部署应用程序</p>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><summary type="html"><![CDATA[二进制兼容和 abi 兼容]]></summary></entry><entry><title type="html">（二）C++对象内存模型那些事儿：类的继承和多态</title><link href="https://marco-hmc.github.io/blog/2025/1_cppVirtual/" rel="alternate" type="text/html" title="（二）C++对象内存模型那些事儿：类的继承和多态"/><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/1_cppVirtual</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/1_cppVirtual/"><![CDATA[<h2 id="二c对象内存模型那些事儿类的继承和多态">（二）C++对象内存模型那些事儿：类的继承和多态</h2> <h3 id="1-关于多态">1. 关于多态</h3> <p>多态是面向对象编程的一个重要特性，它允许我们使用一个接口来表示多种形态的对象。多态的主要优点是它可以提高代码的可重用性和可扩展性。通过使用多态，我们可以编写出更加通用的代码，这些代码可以处理任何符合特定接口的对象，而不需要关心对象的具体类型。这使得我们可以更容易地添加新的类型，而不需要修改已有的代码。 C++ 实现多态主要有两种途径：静态多态（编译时多态）和动态多态（运行时多态）。</p> <p>而一般来说，只有指针和引用的类型能够实现运行时多态。深层次的直接原因是出于内存安全考虑，虚函数指针不会被拷贝。后面会展开。</p> <h4 id="11-静态多态">1.1 静态多态</h4> <p>静态多态在编译期间就能确定调用哪个函数，也可以叫静态绑定（早绑定），在这个阶段，编译器就能确定所有数据成员的确切类型、大小和内存位置。主要包括以下形式：</p> <ul> <li> <p><strong>函数重载（Function Overloading）：</strong> 允许在同一作用域内使用相同的函数名，但参数列表必须不同（类型、数量或顺序）。编译器根据传入参数的类型和数量来决定调用哪个版本的函数。</p> <p>对于函数和运算符来说，静态多态指的是同名的函数或相同的运算符能够自动选择合适的函数进行调用。一般来说，静态多态强调的是同一个作用域中函数名相同的情况。如果在两个独立的类 A 和 B 中都有 <code class="language-plaintext highlighter-rouge">Foo()</code> 方法，那么 <code class="language-plaintext highlighter-rouge">A::Foo()</code> 和 <code class="language-plaintext highlighter-rouge">B::Foo()</code> 不属于静态多态的概念，因为这两个 <code class="language-plaintext highlighter-rouge">Foo()</code> 函数在不同的作用域下，只需要在各自的作用域中进行符号解析即可匹配。</p> <p>编译器处理函数调用的流程如下：</p> <ol> <li><strong>符号解析</strong>：编译器在解析函数调用时，会根据函数名和参数列表查找所有可能的函数定义。</li> <li><strong>重载决议</strong>：编译器根据参数类型和数量选择最匹配的函数。如果有多个匹配，编译器会根据重载决议规则选择最佳匹配。</li> <li><strong>生成代码</strong>：编译器生成调用选定函数的代码。</li> </ol> <p>函数和运算符的静态多态主要指的是第二阶段的操作，这部分实现只需要编译器会根据参数类型和数量选择最匹配的函数即可。</p> </li> <li> <p><strong>模板（Templates）：</strong> 泛型编程的一种形式，允许编写与类型无关的代码。编译器根据传递给模板的具体类型生成具体的函数或类实例，实现了编译时的多态性。</p> <p>模板的静态多态性体现在编译时通过模板实例化生成具体类型的代码。这种多态性在编译时确定，而不是在运行时，因此被称为静态多态。与函数和运算符的静态多态不完全是同一个概念。函数和运算符的静态多态指的是在同一个作用域下，在编译期间就能找到合适的函数进行调用；而模板的静态多态则是在实例化后，在编译期间就能找到合适的函数进行调用。</p> <p>编译器处理模板函数调用的流程如下：</p> <ol> <li><strong>模板定义</strong>：编译器首先解析模板定义，但不生成代码。</li> <li><strong>模板实例化</strong>：当模板被具体类型使用时，编译器根据具体类型实例化模板，生成相应的代码。</li> <li><strong>类型检查</strong>：编译器在实例化模板时进行类型检查，确保模板代码对具体类型有效。</li> <li><strong>生成代码</strong>：编译器生成实例化后的模板代码。</li> </ol> <p>模板的多态主要指的是第二阶段的过程，只需要知道实现是依赖于编译器对模板实例化即可。</p> </li> </ul> <p>简单来说就是，对于函数重载，编译器能够根据参数列表知道实际调用的是哪一个函数，从而生成正确的汇编代码；对于模板来说，编译器能够根据类型参数知道实际调用的是哪一个函数，从而生成正确的汇编代码。</p> <h4 id="12-动态多态">1.2 动态多态</h4> <h5 id="121-动态多态的形式">1.2.1 动态多态的形式</h5> <p>动态多态则是在程序运行时决定调用哪个函数，也可以叫叫做动态绑定（晚绑定），主要依赖于虚函数机制：在基类中声明函数为虚函数（使用 virtual 关键字），并在派生类中重写（Override）这些函数。通过基类的指针或引用指向派生类对象，调用虚函数时，会根据对象的实际类型动态地调用相应的函数实现。</p> <h5 id="122-动态多态虚函数是如何实现的">1.2.2 动态多态（虚函数）是如何实现的？</h5> <p>在 C++ 中，虚函数的实现主要依赖于虚函数表（也称为 vtable）。每一个有虚函数的类，编译器都会为其生成一个虚函数表，表是一个函数指针数组，表中包含了该类及其基类的所有虚函数地址。每一个该类的对象，都会有一个指向虚函数表的指针（通常称为 vptr）。</p> <p>虚表的构造和虚指针的初始化通常发生在对象构造时。当一个对象被创建时，编译器会自动将该对象的 vptr 初始化为指向该类的虚函数表。</p> <p>当我们通过基类指针调用虚函数时，实际上是通过这个指针找到虚函数表，然后在表中查找并调用对应的函数。编译时就能确定这个虚函数的偏移地址，在运行时的时候，就会去查看当前对象的虚函数指针，根据虚函数指针找到对应的虚函数表，基于编译时确定的偏移地址去调用。</p> <p>如果 Foo 类是父类，Bar1 和 Bar2 是子类，而 func()是 Foo 类非纯虚函数的时候。那么就会有分别对应的三个虚函数表（Foo, Bar1，Bar2 各一个）。对象实例化的时候就会有一个指针指向一个虚函数表，虚函数表里有一个 Foo 类函数地址。这个时候不管静态解析类型是什么，比如说是 Foo 类，但调用 func()方法的时候，因为编译器知道 func()是虚函数方法。就都是通过虚函数指针找到实际调用对象。</p> <h5 id="123-虚函数调用例子">1.2.3 虚函数调用例子</h5> <p>我们定义了一个基类<code class="language-plaintext highlighter-rouge">Shape</code>和一个派生类<code class="language-plaintext highlighter-rouge">Circle</code>。基类中定义了一个虚函数<code class="language-plaintext highlighter-rouge">draw</code>，派生类中重写了这个函数。在<code class="language-plaintext highlighter-rouge">main</code>函数中，我们创建了一个<code class="language-plaintext highlighter-rouge">Circle</code>对象，然后通过一个<code class="language-plaintext highlighter-rouge">Shape</code>类型的指针来调用<code class="language-plaintext highlighter-rouge">draw</code>函数。由于<code class="language-plaintext highlighter-rouge">draw</code>函数是虚函数，所以实际调用的是<code class="language-plaintext highlighter-rouge">Circle</code>类的<code class="language-plaintext highlighter-rouge">draw</code>函数，而不是<code class="language-plaintext highlighter-rouge">Shape</code>类的<code class="language-plaintext highlighter-rouge">draw</code>函数。</p> <p>以下是一个简单的图示，展示了虚函数表的工作原理：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Shape object:    Circle object:    Shape vtable:    Circle vtable:
+-------------+  +-------------+   +-------------+  +-------------+
| vptr        |  | vptr        |   | draw()      |  | draw()      |
| ...         |  | ...         |   | ...         |  | ...         |
+-------------+  +-------------+   +-------------+  +-------------+
  |                |                 |                |
  |                |                 v                v
  |                |               Shape::draw()    Circle::draw()
  |                |
  v                v
Shape::vtable    Circle::vtable
</code></pre></div></div> <p>在这个图示中，<code class="language-plaintext highlighter-rouge">Shape</code>对象和<code class="language-plaintext highlighter-rouge">Circle</code>对象都有一个<code class="language-plaintext highlighter-rouge">vptr</code>，这是一个指向虚函数表的指针。<code class="language-plaintext highlighter-rouge">Shape</code>的<code class="language-plaintext highlighter-rouge">vptr</code>指向<code class="language-plaintext highlighter-rouge">Shape</code>的虚函数表，<code class="language-plaintext highlighter-rouge">Circle</code>的<code class="language-plaintext highlighter-rouge">vptr</code>指向<code class="language-plaintext highlighter-rouge">Circle</code>的虚函数表。虚函数表中存储了虚函数的地址，所以当我们通过<code class="language-plaintext highlighter-rouge">Shape</code>指针调用<code class="language-plaintext highlighter-rouge">draw</code>函数时，实际上是通过<code class="language-plaintext highlighter-rouge">vptr</code>找到虚函数表，然后在表中查找并调用对应的函数。</p> <p>简单来说，</p> <ul> <li>每一个有虚函数的对象下的都会有一个<code class="language-plaintext highlighter-rouge">vtable</code>,如上面的<code class="language-plaintext highlighter-rouge">Shape vtable</code>和<code class="language-plaintext highlighter-rouge">Circle vtable</code>.</li> <li>每一个从有虚函数的对象下来的实例都会有一个<code class="language-plaintext highlighter-rouge">vptr</code>,<code class="language-plaintext highlighter-rouge">vptr</code>指向<code class="language-plaintext highlighter-rouge">vtable</code>, 如上面的<code class="language-plaintext highlighter-rouge">Shape object</code>和<code class="language-plaintext highlighter-rouge">Circle object</code>.</li> <li>当我对某一个<code class="language-plaintext highlighter-rouge">Shape object</code>调用<code class="language-plaintext highlighter-rouge">draw()</code>函数时，查询方式都是通过<code class="language-plaintext highlighter-rouge">vptr</code>找到<code class="language-plaintext highlighter-rouge">vtable</code>的<code class="language-plaintext highlighter-rouge">draw()</code>。</li> </ul> <h5 id="124-动态多态导致类对象的内存布局改变">1.2.4 动态多态导致类对象的内存布局改变</h5> <ul> <li> <p><strong>无动态多态时的内存布局（即当一个类不包含虚函数时）</strong></p> </li> <li>对象头部：通常只包含直接的数据成员。对象的大小直接由其数据成员的总大小决定，加上可能的 padding（用于对齐）。</li> <li> <p>访问速度：因为函数调用是静态绑定的，编译器在编译时期就能确定调用哪个函数，因此访问速度快。</p> </li> <li> <p><strong>含有动态多态时的内存布局</strong> 当一个类包含虚函数或继承自含有虚函数的基类时：</p> </li> <li>虚函数表指针（vptr）：对象内存布局中会额外包含一个指向虚函数表（vtbl）的指针。这个 vptr 通常位于对象的最开始位置，但这也取决于具体的编译器实现。</li> <li>虚函数表（vtbl）：不在对象实例内，而是在类的内存区域。它存储了该类及其基类中所有虚函数的地址。</li> <li>对象大小：由于增加了 vptr，对象的总大小会比无多态时增加（通常是一个指针大小，如 4 字节或 8 字节）。</li> <li>访问速度：虚函数调用需要通过 vptr 间接访问虚函数表，再根据表中地址调用实际函数，因此相对于静态绑定，动态调用会有一定的性能开销。</li> <li>多态行为：通过基类指针或引用来调用虚函数时，能够根据对象的实际类型执行相应的派生类函数，实现了运行时的多态性。</li> </ul> <h5 id="125-指针和引用才能多态">1.2.5 指针和引用才能多态</h5> <p>动态绑定：当使用基类的指针或引用指向派生类对象时，通过这些指针或引用调用虚函数时，实际执行的是派生类中重写的函数。这是因为编译器在运行时根据对象的实际类型（而不是引用或指针的类型）来决定调用哪个函数，这就是所谓的动态绑定或晚期绑定。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kt">void</span> <span class="nf">playSound</span><span class="p">(</span><span class="k">const</span> <span class="n">Animal</span><span class="o">&amp;</span> <span class="n">animal</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">animal</span><span class="p">.</span><span class="n">makeSound</span><span class="p">();</span> <span class="c1">// 动态绑定，调用实际对象的 makeSound 方法</span>
    <span class="p">}</span>

    <span class="n">Animal</span><span class="o">*</span> <span class="n">animalPtr1</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Dog</span><span class="p">();</span>
    <span class="n">animalPtr1</span><span class="o">-&gt;</span><span class="n">makeSound</span><span class="p">();</span> <span class="c1">// 动态绑定，调用 Dog::makeSound</span>
    <span class="n">playSound</span><span class="p">(</span><span class="o">*</span><span class="n">animalPtr1</span><span class="p">);</span> <span class="c1">// 动态绑定，调用 Dog::makeSound</span>

    <span class="n">Animal</span> <span class="n">animalPtr2</span> <span class="o">=</span> <span class="o">*</span><span class="n">animalPtr2</span><span class="p">;</span>
    <span class="n">animalPtr2</span><span class="p">.</span><span class="n">makeSound</span><span class="p">();</span> <span class="c1">//  Animal::makeSound</span>
    <span class="n">playSound</span><span class="p">(</span><span class="o">*</span><span class="n">animalPtr1</span><span class="p">);</span> <span class="c1">// Animal::makeSound</span>
</code></pre></div></div> <h5 id="126-总结">1.2.6 总结</h5> <ul> <li> <p><strong>虚函数表指针与虚函数表</strong></p> <ol> <li>虚函数表指针（vptr）：每个包含至少一个虚函数的类的实例对象中，都会有一个隐含的指针，这个指针称为虚函数表指针。它通常位于对象内存布局的起始位置。这个指针指向该对象所属类的虚函数表。</li> <li>虚函数表：虚函数表是一个存储函数指针的数组，这些函数指针分别指向类中声明为虚的成员函数。这些函数可以是本类定义的，也可以是从基类继承而来并通过虚继承覆盖的。虚函数表中的函数地址按照声明的顺序排列。</li> <li>虚函数地址存储：在编译阶段，编译器会为每个包含虚函数的类生成一个虚函数表，并将这些虚函数的地址填入表中相应的位置。当对象实例化时(对象创建时)，其虚函数表指针会被初始化为指向正确的虚函数表。</li> </ol> </li> <li> <p><strong>虚函数表指针位置</strong> 虚函数表指针位于对象的内存的开头还是末尾取决于编译器的实现。但主流实践和预期是 vptr 位于对象内存的开始位置，如 MSVC 和 g++。</p> </li> <li> <p><strong>虚函数表分析</strong></p> <ol> <li>一个类只有包含虚函数才会存在虚函数表，同属于一个类的实例化对象共享同一个虚函数表。每个对象的 vptr（虚函数表指针），所指向的地址（虚函数表首地址）相同。</li> <li>虚函数表存储在程序的只读数据段（.rodata 段）中。这是因为虚函数表的内容在程序运行期间是不变的，它包含了类中虚函数的地址，这些地址在编译时期就已经确定，并且不会随着程序的运行而改变。将虚函数表置于只读数据段有助于保护其不被意外修改，同时也有利于内存管理，因为这部分内存通常被映射为不可写，提升了程序的安全性。</li> <li>子类会继承父类中的虚函数，即在父类是虚函数，子类不显示声明为虚函数，依然是虚函数。</li> <li>当一个子类继承自一个具有虚函数的父类时，编译器会为子类生成一个新的虚函数表，其中包含父类虚函数的地址（如果没有被子类重写的话）。如果子类重写了父类的某个或某些虚函数，子类的虚函数表中对应项会被更新，指向子类中重写后函数的地址，以确保多态行为能正确实现——即通过基类指针或引用来调用函数时，会调用到子类中实际重写的方法。</li> </ol> </li> </ul> <h3 id="2-关于继承">2. 关于继承</h3> <h4 id="21-一般类成员数据和类成员函数">2.1 一般类成员数据和类成员函数</h4> <p>一般父类的的成员数据和成员函数可以看成就是子类的，无区别，只是一般可能是先父类内存布局，再到子类内存布局这样子。</p> <p>至于<code class="language-plaintext highlighter-rouge">public</code>, <code class="language-plaintext highlighter-rouge">private</code>, <code class="language-plaintext highlighter-rouge">protected</code>都是指导编译器和限制开发者的，实际上无法和汇编底层代码建立直接的抽象。只是访问成员的时候，相当于编译器层面做一下<code class="language-plaintext highlighter-rouge">if-else</code>判断。</p> <h4 id="22-this-调整与切割">2.2 this 调整与切割</h4> <p>“切割”（Object Slicing）问题：当将一个派生类对象赋值给基类对象或以基类对象的方式传递时，派生类特有的部分（即超出基类的部分）将会被“切掉”，因为基类对象没有足够的空间来容纳派生类的额外数据成员。这种现象称为“对象切片”。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="n">Animal</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Animal constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">Animal</span><span class="p">(</span><span class="k">const</span> <span class="n">Animal</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Animal copy constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">eat</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Animal eats"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Dog</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="n">Dog</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dog constructor"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">void</span> <span class="n">eat</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dog eats"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Animal</span> <span class="n">dog</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">();</span>  <span class="c1">// 对象切片，调用 Animal 的拷贝构造函数</span>
    <span class="n">dog</span><span class="p">.</span><span class="n">eat</span><span class="p">();</span>           <span class="c1">// 调用 Animal::eat()</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
1. 为什么调用的是animal::eat()方法？

2. Animal dog = Dog();这个过程发生了什么？
    抛开Dog的构造过程，Animal dog = Dog()，这个过程是拷贝构造，调用了Animal的拷贝构造函数。
    由于 `Animal` 类的拷贝构造函数的形参是 `const Animal&amp;`，因此需要将 `Dog` 对象转换为 `Animal` 对象。
    也就是说dog首先会发生一次隐式转换。
    在这个过程中Dog()的部分会被切掉，只剩下Animal的部分，被拷贝到dog中，
    因为dog在栈上申请内存的时候是按照Animal的大小申请的，dog的内存布局是按照Animal来的。
    所以切掉Dog()的部分，只剩下Animal的部分是显然的。
    这个过程就是对象切片。

    根据结果我们知道，虚函数指针也被切掉了。那为什么虚函数指针也被切掉了呢？

    如果派生类有虚函数指针的时候，父类没有虚函数指针，因此Dog的虚函数指针被切掉了。是很好理解的。
    可如果父类有虚函数指针，为什么不能直接拷贝子类的虚函数指针呢？
    这是为了安全考虑，编译器禁止了这种行为。
    如果子类的虚函数指针被拷贝到父类的对象中，那么在这个对象就可以调用子类的虚函数。
    这个时候子类的虚函数有可能是使用了子类特有的类成员变量的，但是父类的对象中并没有这个成员变量，因此会出现问题的。
    因此编译器在设计的时候，为了避免这个问题，直接将子类的虚函数指针给切掉了。

*/</span>
</code></pre></div></div> <h4 id="23-多继承的时候虚函数怎么处理的">2.3 多继承的时候，虚函数怎么处理的？</h4> <p>在 C++的多继承中，每个基类都有自己的虚函数表。当一个类从多个基类继承时，它会有多个虚函数表指针，每个指针指向一个基类的虚函数表。当我们通过基类指针调用虚函数时，会根据指针的类型找到对应的虚函数表，然后在表中查找并调用对应的函数。</p> <p>一般情况下，如果有多继承，且父类都是有虚函数的话，就会有多个<code class="language-plaintext highlighter-rouge">vptr</code>。编译器生成代码的时候也能够知道用哪个<code class="language-plaintext highlighter-rouge">vptr</code>，忽略编译器额外时间开销的话，多继承和单一继承的虚函数调用开销是一样的。</p> <h3 id="3-关于虚继承">3. 关于虚继承</h3> <h4 id="31-虚继承是什么有什么用">3.1 虚继承是什么？有什么用？</h4> <p>虚继承是 C++中的一种特殊的继承方式，主要用于解决多继承中的菱形继承问题。在菱形继承中，如果不使用虚继承，那么最底层的派生类会继承多份基类的数据和方法，这会导致资源的浪费和访问的歧义。而解决菱形继承的，关键思想在于保证父类数据的唯一。 为了实现父类数据的唯一，派生类都不直接持有父类数据，而是通过一个指针找到父类数据。 这个指针就是 vbptr，父类数据则存储在 vbtable 表中。当出现菱形继承的时候，则会有两个 vbptr 指针。编译器会发现这两个指针指向同一个表地址，就优化为一个指针。 这样子就可以保证数据唯一了。</p> <p>以下是一个不使用虚继承的菱形继承例子，这将导致编译错误：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">Derived1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">Derived2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">MostDerived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Derived1</span><span class="p">,</span> <span class="k">public</span> <span class="n">Derived2</span> <span class="p">{</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MostDerived</span> <span class="n">md</span><span class="p">;</span>
    <span class="n">md</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>  <span class="c1">// 编译错误：MostDerived中有两份Base::x，编译器无法确定应该访问哪一份</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在这个例子中，<code class="language-plaintext highlighter-rouge">Derived1</code>和<code class="language-plaintext highlighter-rouge">Derived2</code>都继承了<code class="language-plaintext highlighter-rouge">Base</code>，所以在<code class="language-plaintext highlighter-rouge">MostDerived</code>中有两份<code class="language-plaintext highlighter-rouge">Base::x</code>。当我们试图访问<code class="language-plaintext highlighter-rouge">md.x</code>时，编译器无法确定我们应该访问哪一份<code class="language-plaintext highlighter-rouge">Base::x</code>，所以会报错。</p> <p>这个问题可以通过使用虚继承来解决。虚继承会让从多个路径继承来的同一个基类，在派生类中只保留一份拷贝。这样，就不会出现上述的编译错误，因为在<code class="language-plaintext highlighter-rouge">MostDerived</code>中只有一份<code class="language-plaintext highlighter-rouge">Base::x</code>。但是如果不调用<code class="language-plaintext highlighter-rouge">md.x</code>，是可以通过的。我猜这个时候，<code class="language-plaintext highlighter-rouge">md</code>是有两份<code class="language-plaintext highlighter-rouge">x</code>未初始数据的。只要不调用<code class="language-plaintext highlighter-rouge">md.x</code>导致编译器无法确定使用哪一个，就没问题。</p> <h4 id="32-虚继承的原理是什么">3.2 虚继承的原理是什么？</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">virtual</span> <span class="n">A</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">virtual</span> <span class="n">A</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">c</span><span class="p">;</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span><span class="p">,</span> <span class="k">public</span> <span class="n">C</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">d</span><span class="p">;</span> <span class="p">};</span>
</code></pre></div></div> <p>对于 B 和 C 来说，因为是虚继承，因此 A 的数据就不直接在 B 和 C 了。</p> <h4 id="33-虚继承下的虚函数">3.3 虚继承下的虚函数</h4> <p>虚继承下的虚函数里涉及复杂的指针调整，浅尝辄止，了解即可。</p> <p>在虚继承场景下，虚函数的调用机制本身并未发生根本性变化，依旧基于 vptr 和 VTable 来实现动态多态。区别在于，虚继承通过引入 vbptr 和 vbtable 来解决继承路径中的共享基类实例问题，这不影响虚函数的调用流程，但影响了基类数据成员的访问和构造/析构过程。理解这一点对于设计和维护复杂的类继承结构至关重要。</p> <h3 id="99-quiz">99 quiz</h3> <h4 id="1-当对象调用一个普通成员函数和调用一个虚函数编译器是怎么区别对待的">1. 当对象调用一个普通成员函数，和调用一个虚函数，编译器是怎么区别对待的？</h4> <p>当对象调用一个普通成员函数和调用一个虚函数时，编译器的处理方式是不同的。</p> <ul> <li>对于普通成员函数，编译器在编译时就能确定函数的地址，所以在生成的汇编代码中，函数调用会直接转换为对应的函数地址。</li> <li>对于虚函数，编译器在编译时不能确定函数的地址，因为虚函数的调用需要在运行时通过虚函数表来确定。所以在生成的汇编代码中，函数调用会转换为通过虚函数表来查找函数地址。</li> </ul> <h4 id="2-调用虚函数的时候是通过-vptr-找到对应的虚函数表再调用实际函数那么虚函数表很大的时候开销会增加吗">2. 调用虚函数的时候，是通过 vptr 找到对应的虚函数表，再调用实际函数。那么虚函数表很大的时候，开销会增加吗？</h4> <p>虽然说调用实际函数是在虚函数表找的，但是这个虚函数在表中的位置是固定的。编译器在编译时已经确定了每个虚函数在虚函数表中的索引。因此运行的时候不需要遍历表找到方法，而是编译期间的时候就能确定确定了。换句话说，同一继承体系下，不同类的相同虚函数在虚函数表的偏移地址都是一样的。运行时都是直接用偏移地址，而不是遍历找到虚函数的。</p> <blockquote> <p>但是虚函数表很大，也许会对编译开销有影响；运行时偏移地址很大，有可能会内存缓存不友好。但这些都相对不重要。可忽略</p> </blockquote> <h4 id="3-怎么理解调用虚函数的开销什么时候需要考虑">3. 怎么理解调用虚函数的开销？什么时候需要考虑？</h4> <p>非内联函数的直接调用大概是 45-90ns 级别。如果是虚函数则大概是 90-180ns 级别。除此之外，一般函数直接调用的时候分支预测和指令预取命中率会更高。虚函数的间接调用是不利于优化的。这部分的开销也需要考虑的。</p> <p>但总的而言，这个开销是固定的，如果一个函数不考虑纳秒级别的优化，就不需要考虑虚函数带来的影响。如果是到了纳秒级别优化的时候，也建议实际测一下开销，测了才能知道虚函数的开销是否不可接受。</p> <h4 id="4-对于非多态类型和多态类型如何获取类型信息type_info">4. 对于非多态类型和多态类型，如何获取类型信息（type_info）？</h4> <ul> <li> <p>对于<strong>非多态类型</strong>（即没有虚函数的类），类型信息（type_info）通常可以通过编译时的类型信息直接获取，不需要通过虚拟表（vtable）来访问。</p> </li> <li> <p>对于<strong>多态类型</strong>（即包含至少一个虚函数的类），每个对象会有一个虚拟表（vtable），其中包含了指向该类型 type_info 对象的指针。这样，可以通过对象的虚拟表在运行时动态地访问到其类型信息。</p> </li> </ul> <h4 id="5-c多继承的时候如何处理同名成员变量同名成员函数">5. C++多继承的时候，如何处理同名成员变量？同名成员函数？</h4> <p>如果两个基类有同名的成员变量或成员函数，那么在派生类中需要通过作用域解析运算符（::）来指定要访问哪个基类的成员。</p> <p>如果是直接对派生类访问两个基类同名的成员变量，就会报错。</p> <h4 id="6-如果一个类多继承且父类都有虚函数那这个类有几个虚表">6. 如果一个类多继承，且父类都有虚函数，那这个类有几个虚表？</h4> <p>一个。</p> <ol> <li>派生类整合所有基类和自己的虚函数到一个单一的虚函数表中。</li> <li>如果存在多重继承，派生类实例在内存中会为每个基类保持一个子对象，这些子对象的起始位置可能包含一个虚函数指针（如果相应的基类有虚函数）。这些不同的虚函数指针虽然都指向同一个虚函数表，但它们在表中的偏移量可能不同，这是因为每个基类的虚函数在表中的排列考虑到了多继承的顺序和各自的虚函数集合。</li> <li>编译器通过这些虚函数指针和潜在的偏移量调整，确保当通过不同基类的指针调用虚函数时，能够正确地定位到派生类中覆写的函数或者基类的函数。</li> </ol> <h4 id="7-继承可以理解为两种接口继承和实现继承">7. 继承可以理解为两种，接口继承和实现继承？</h4> <ul> <li>接口继承：简单来说就是有虚函数，存在多态行为的；</li> <li>实现继承：简单来说就是父类没有虚函数，是通过继承方式做组合的。当通过继承做组合的时候，和普通成员变量做组合的区别在于被组合函数是否需要直接对外。</li> </ul> <h4 id="8-todo-多继承的时候子类指针能转为父类指针吗">8. todo-多继承的时候，子类指针能转为父类指针吗？</h4> <h4 id="9-todo-理解虚函数多重继承虚基类以及-rtti-所带来的开销">9. todo-理解虚函数、多重继承、虚基类以及 RTTI 所带来的开销</h4> <p>C++的特性和编译器会很大程度上影响程序的效率，所以我们有必要知道编译器在一个 C++特性后面做了些什么事情。</p> <p>例如虚函数，指向对象的指针或者引用的类型是不重要的，大多数编译器使用的是 virtual table(vtbl)和 virtual table pointers(vptr)来进行实现</p> <p>vtbl:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class C1{
public:
    C1();
    virtual ~C1();
    virtual void f1();
    virtual int f2(char c)const;
    virtual void f3(const string&amp; s);
    void f4()const
}
</code></pre></div></div> <p>vtbl 的虚拟表类似于下面这样,只有虚函数在里面，非虚函数的 f4 不在里面：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ___
|___| → ~C1()
|___| → f1()
|___| → f2()
|___| → f3()
</code></pre></div></div> <p>如果按照上面的这种，每一个虚函数都需要一个地址空间的话，那么如果拥有大量虚函数的类，就会需要大量的地址存储这些东西，这个 vtbl 放在哪里根据编译器的不同而不同</p> <p>vptr：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> __________
|__________| → 存放类的数据
|__________| → 存放vptr
</code></pre></div></div> <p>每一个对象都只存储一个指针，但是在对象很小的时候，多于的 vptr 将会看起来非常占地方。在使用 vptr 的时候，编译器会先通过 vptr 找到对应的 vtbl，然后通过 vtbl 开始找到指向的函数事实上对于函数：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pC1-&gt;f1();
</code></pre></div></div> <p>他的本质是：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(*pC1-&gt;vptr[i])(pC1);
</code></pre></div></div> <p>在使用多继承的时候，vptr 会占用很大的地方，并且非常恶心，所以不要用多继承</p> <p>RTTI：能够让我们在 runtime 找到对象的类信息，那么就肯定有一个地方存储了这些信息，这个特性也可以使用 vtbl 实现，把每一个对象，都添加一个隐形的数据成员 type_info，来存储这些东西，从而占用很大的空间</p> <p>如果一个函数声明在 A.h 且没有用 inline 修饰，定义在 A.cpp，在 B.cpp 使用。那么这个函数在 B.cpp 使用的时候能否被内联展开优化？</p> <p>如果一个函数声明在 A.h 且使用 inline 修饰，那么在 B.cpp 使用的时候，这个函数在 B.cpp 能否不被内联展开优化？如果能的话，这个函数定义被实际放在哪里？如何实现的？</p> <h4 id="10-todo-使构造函数和非成员函数具有虚函数的行为">10. todo-使构造函数和非成员函数具有虚函数的行为**</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="nc">NewsLetter</span><span class="p">{</span>
    <span class="nl">private:</span>
        <span class="k">static</span> <span class="n">NLComponent</span> <span class="o">*</span><span class="n">readComponent</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
        <span class="k">virtual</span> <span class="n">NLComponent</span> <span class="o">*</span><span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">NewsLetter</span><span class="o">::</span><span class="n">NewsLetter</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">){</span>
        <span class="k">while</span><span class="p">(</span><span class="n">str</span><span class="p">){</span>
            <span class="n">components</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">readComponent</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">class</span> <span class="nc">TextBlock</span><span class="o">:</span> <span class="k">public</span> <span class="n">NLComponent</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="k">virtual</span> <span class="n">TextBlock</span><span class="o">*</span><span class="n">clone</span><span class="p">()</span><span class="k">const</span><span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">TextBlock</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div> <p>在上面那段代码当中，readComponent 就是一个具有构造函数行为（因为能够创建出新的对象）的函数，我们叫做虚拟构造函数</p> <p>clone() 叫做虚拟拷贝构造函数,相当于拷贝一个新的对象</p> <p>通过这种方法，我们上面的 NewsLetter 构造函数就可以这样：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">NewsLetter</span><span class="o">::</span><span class="n">NewsLetter</span><span class="p">(</span><span class="k">const</span> <span class="n">NewsLetter</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
        <span class="k">while</span><span class="p">(</span><span class="n">str</span><span class="p">){</span>
            <span class="k">for</span><span class="p">(</span><span class="n">list</span><span class="o">&lt;</span><span class="n">NLComponent</span><span class="o">*&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span><span class="o">=</span><span class="n">rhs</span><span class="p">.</span><span class="n">component</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span><span class="n">rhs</span><span class="p">.</span><span class="n">component</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="n">it</span><span class="o">++</span><span class="p">){</span>
                <span class="n">components</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="o">*</span><span class="n">it</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><category term="class"/><summary type="html"><![CDATA[（二）C++对象内存模型那些事儿：类的继承和多态]]></summary></entry><entry><title type="html">引用那些事儿</title><link href="https://marco-hmc.github.io/blog/2025/1_reference/" rel="alternate" type="text/html" title="引用那些事儿"/><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/1_reference</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/1_reference/"><![CDATA[<h2 id="引用那些事儿">引用那些事儿</h2> <h3 id="1-引言">1. 引言</h3> <p>在C语言中，函数传参通常采用值传递方式。若要在函数内部修改传入参数的值，则需借助指针。然而，直接操作指针涉及内存地址，这种方式在一些现代编程语言中被认为存在风险，应予以屏蔽。正是基于此，“引用”这一概念应运而生，它对传指针行为进行了抽象。</p> <p>C++在当时的编程环境下，也引入了引用概念，旨在简化和安全化对变量的操作。</p> <p>首先明确引用的语义，引用本质上是原变量的别名。这意味着对引用的任何操作，都等同于对原变量的操作。由于原变量不存在解除引用关系并建立新引用关系的情况，所以引用一旦建立，就不能更改其绑定的对象，它完全等同于原变量。</p> <p>基于引用作为别名的特性，引用必须在定义时进行初始化。因为若不初始化，引用就无从成为某个变量的别名，这在逻辑上是不完整的。</p> <p>同样，引用不能绑定到空对象。从逻辑角度看，对空对象创建别名与对有效对象创建别名的行为逻辑上不应该是一样的，对空对象的操作通常是未定义的，就如同在集合中，对空集的操作往往不具备实际意义。</p> <p>从编译器和汇编层面来看，引用实际上等价于常量指针。例如：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">ref_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">ref</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</code></pre></div></div> <p>这里<code class="language-plaintext highlighter-rouge">ref</code>和<code class="language-plaintext highlighter-rouge">ref_ptr</code>在底层实现上具有相似性。指针<code class="language-plaintext highlighter-rouge">ref_ptr</code>必须指向一个有效的内存地址，同样，引用<code class="language-plaintext highlighter-rouge">ref</code>也必须绑定到一个有效的变量。若尝试让引用绑定到空对象，类似于定义<code class="language-plaintext highlighter-rouge">int* const ref_ptr = nullptr; </code>，这不仅无实际意义，而且与空指针的概念并无本质区别。因此，引用就是不可以绑定到空对象的。通过这个方式，也可以理解引用必须初始化，不能为空。</p> <p>引用与常量指针在经过编译器处理后，我就曾看过汇编代码展开，操作大部分情况都是一样的，。</p> <p>在函数传参过程中，引用作为参数的别名，达成了类似通过传递 <code class="language-plaintext highlighter-rouge">指针值</code> 来传入参数的效果，在部分其他编程语言中，这一方式也被称作引用传递。尽管从底层机制来讲，它本质上依然属于值传递，但经过引用这种抽象处理后，传递的是参数的别名，使得编程体验如同直接传递值。这种方式具备两个显著优势：</p> <p>其一，能够避免拷贝开销。当函数参数为较大对象时，若采用值传递，系统会在栈上创建该对象的副本，这一过程涉及对象成员的逐个拷贝，开销颇大。而引用传递实际上传递的是对象的地址（只不过在语法上更为简洁），并非对象本身，从而无需进行对象拷贝操作，大幅节省了时间与空间开销。</p> <p>其二，通过引用传递，函数能够修改传入参数的值，显著增强了函数对外部变量的操作能力。如此一来，在函数内部可以直接对实参进行修改，为程序设计提供了更大的灵活性。</p> <h3 id="2-临时变量的引用表示与常量引用">2. 临时变量的引用表示与常量引用</h3> <p>在函数通过引用进行传参时，会遇到传入参数为临时变量的情况。需要明确，临时变量是高级语言为方便编程而抽象出的概念。在汇编层面，不存在临时变量这一特定称谓，所有变量本质上都是内存栈区域中的一段数据，通过指针标识其存储位置，以类型确定其数据长度。</p> <p>例如，同样一个接受引用传参的函数<code class="language-plaintext highlighter-rouge">void foo(--接受Bar类型的引用--);</code>，使用<code class="language-plaintext highlighter-rouge">foo(Bar{})</code>和使用<code class="language-plaintext highlighter-rouge">Bar bar; foo(bar);</code>两者是不一样的。这是因为编译器对两者的取地址方式不一样。在<code class="language-plaintext highlighter-rouge">Bar bar; foo(bar);</code>中，<code class="language-plaintext highlighter-rouge">bar</code>是一个具名变量，编译器可以直接获取其地址。而对于临时变量<code class="language-plaintext highlighter-rouge">Bar{}</code>，其地址信息在高级语言层面被屏蔽，编译器需要采用特殊的机制来处理对它的引用传递。也就是说，对于临时变量的引用，和一般变量的引用，编译器有两套的做法。</p> <p>那么，编译器如何判断并处理呢？当我们希望通过引用传递来省略拷贝开销时，若传入参数类型为<code class="language-plaintext highlighter-rouge">const T&amp;</code>，编译器就能够自动推断并合理处理，这也叫<strong>常量引用</strong>。具体来说，编译器会识别出这种情况下对临时变量的引用仅用于读取数据，不会修改其值，因此可以安全地进行处理。</p> <p>然而，若传入参数类型为<code class="language-plaintext highlighter-rouge">T&amp;</code>，虽然编译器理论上能够采用特定方式获取临时变量的地址，但这种做法存在问题。因为临时变量在传入函数后通常不会在其他地方被使用，对其进行修改在逻辑上不合理，这种逻辑上不合理的行为可能为软件工程引入潜在<code class="language-plaintext highlighter-rouge">bug</code>，以及误导开发者。所以，为保证程序的稳定性和正确性，编译器不允许使用<code class="language-plaintext highlighter-rouge">T&amp;</code>引用临时变量进行修改操作。</p> <p>综上，常量引用和一般的引用无特殊区别，只是如果是常量的引用，编译器能特殊处理一下，对于临时变量也能够正确处理。</p> <h3 id="3-所有权的移动与右值引用">3. 所有权的移动与右值引用</h3> <p>在C++编程中，存在一种为实现资源移动而引入的重要机制——右值引用。以<code class="language-plaintext highlighter-rouge">std::thread</code>为例，当为其绑定的函数传递若干参数时，若期望以移动的方式操作这些参数，此时函数的形参需定义为<code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>。</p> <p>这里的<code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>表示右值引用，它向编译器表明，传入的将是一个右值，而右值在大多数情况下是临时变量的数据。使用右值引用的核心意义在于实现数据所有权的转移。与传统的参数值传递和参数引用传递方式不同，右值引用传递着重于资源所有权的移动，而非简单的数据拷贝或对已有数据的引用。</p> <p>例如，在处理动态分配的内存等资源时，通过右值引用，可将资源的所有权从一个对象高效地转移到另一个对象，避免了不必要的拷贝操作，从而提升程序性能。假设我们有一个自定义类<code class="language-plaintext highlighter-rouge">Resource</code>，它管理着一块动态分配的内存：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Resource</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Resource</span><span class="p">()</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">Resource</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 移动构造函数，利用右值引用实现资源移动</span>
    <span class="n">Resource</span><span class="p">(</span><span class="n">Resource</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">other</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>在上述代码中，<code class="language-plaintext highlighter-rouge">Resource</code>类的移动构造函数利用右值引用<code class="language-plaintext highlighter-rouge">Resource&amp;&amp; other</code>，将<code class="language-plaintext highlighter-rouge">other</code>对象的资源（即<code class="language-plaintext highlighter-rouge">data</code>指针所指向的内存）转移到当前对象，同时将<code class="language-plaintext highlighter-rouge">other</code>对象的<code class="language-plaintext highlighter-rouge">data</code>指针置空，确保资源的正确管理和高效转移。</p> <p>这种右值引用传递行为，为C++程序员提供了一种更灵活、高效的资源管理方式，在现代C++编程中具有重要地位。</p> <h3 id="4-完美转发">4. 完美转发</h3> <p>在C++编程中，当涉及函数模板进行参数传递时，如果每次都要手动区分是普通引用传递方式还是右值引用传递行为，确实会显得十分繁琐且容易出错。例如，在一个通用的函数模板中，可能需要根据传入参数的类型（左值或右值）来决定是进行拷贝、引用还是移动操作，手动处理这些情况会使代码变得复杂且难以维护。</p> <p>这时，“完美转发”这一机制就应运而生。完美转发指的是在函数模板中，能够将参数按照其原本的类型（无论是左值还是右值）转发给其他函数，同时保持参数的所有属性（如<code class="language-plaintext highlighter-rouge">const</code>属性等）不变。</p> <p>它主要通过<code class="language-plaintext highlighter-rouge">std::forward</code>这一标准库函数以及函数模板的引用折叠规则来实现。例如，假设有如下代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="c1">// 被转发的目标函数</span>
<span class="kt">void</span> <span class="nf">targetFunction</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"左值被转发到目标函数: "</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">targetFunction</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"右值被转发到目标函数: "</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 用于完美转发的函数模板</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">forwardingFunction</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">targetFunction</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">forwardingFunction</span><span class="p">(</span><span class="n">value</span><span class="p">);</span> <span class="c1">// 传入左值</span>
    <span class="n">forwardingFunction</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>   <span class="c1">// 传入右值</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上述代码中，<code class="language-plaintext highlighter-rouge">forwardingFunction</code>函数模板通过<code class="language-plaintext highlighter-rouge">std::forward&lt;T&gt;(param)</code>将参数<code class="language-plaintext highlighter-rouge">param</code>完美转发给<code class="language-plaintext highlighter-rouge">targetFunction</code>。当传入左值时，<code class="language-plaintext highlighter-rouge">std::forward</code>会将其转发为左值引用传递给<code class="language-plaintext highlighter-rouge">targetFunction</code>；当传入右值时，则转发为右值引用传递。这样，无论传入的是左值还是右值，<code class="language-plaintext highlighter-rouge">targetFunction</code>都能接收到与原始参数类型和属性完全一致的参数，实现了参数的“完美转发”。</p> <p>完美转发的作用非常显著，它使得编写通用的函数模板变得更加简洁高效，能够在不同场景下正确处理各种类型的参数，同时避免了不必要的对象拷贝，提升了程序的性能。在现代C++库的实现中，完美转发被广泛应用，例如在<code class="language-plaintext highlighter-rouge">std::thread</code>的构造函数中，就利用完美转发将参数正确地传递给线程执行函数，确保了线程相关操作的高效性和灵活性。</p> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-什么时候需要用move">1. 什么时候需要用<code class="language-plaintext highlighter-rouge">move</code></h4> <ul> <li><strong>对于callback函数来说</strong>：在使用callback函数时，有时传递的对象可能较大，如果采用传统的拷贝方式传递给callback函数，会带来较大的性能开销，因为拷贝操作需要复制对象的所有数据成员。而使用<code class="language-plaintext highlighter-rouge">std::move</code>，可以将对象的资源所有权直接转移给callback函数，避免了不必要的拷贝操作，显著提高性能。例如，假设有一个包含大量数据的自定义类<code class="language-plaintext highlighter-rouge">BigData</code>，当把<code class="language-plaintext highlighter-rouge">BigData</code>对象作为参数传递给callback函数时：</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">BigData</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">BigData</span><span class="p">()</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">))</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">BigData</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">data</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 为演示方便，省略拷贝和移动构造函数等</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">callbackFunction</span><span class="p">(</span><span class="n">BigData</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 处理数据</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">BigData</span> <span class="n">bd</span><span class="p">;</span>
    <span class="c1">// 使用std::move避免拷贝</span>
    <span class="n">callbackFunction</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bd</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这里使用<code class="language-plaintext highlighter-rouge">std::move</code>的意义在于<code class="language-plaintext highlighter-rouge">BigData data</code>就不是通过拷贝构造函数来创建的，而是通过移动构造函数来创建的，这样就避免了不必要的资源拷贝。 如果<code class="language-plaintext highlighter-rouge">BigData</code>也都还是值类型数据，其实不用<code class="language-plaintext highlighter-rouge">std::move</code>性能也差不了多少，但如果<code class="language-plaintext highlighter-rouge">BigData</code>是一个复杂的对象，包含了动态分配的内存或其他资源，那么使用<code class="language-plaintext highlighter-rouge">std::move</code>就能显著提高性能。</p> <ul> <li><strong>对于将对象插入到容器来说</strong>：当向容器中插入对象时，若对象较大，深拷贝会消耗大量的时间和资源。使用<code class="language-plaintext highlighter-rouge">std::move</code>可以直接将对象的资源移动到容器中，避免深拷贝。例如，向<code class="language-plaintext highlighter-rouge">std::vector</code>中插入自定义对象：</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyClass</span><span class="p">()</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">))</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">MyClass</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">data</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">// 移动构造函数</span>
    <span class="n">MyClass</span><span class="p">(</span><span class="n">MyClass</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">other</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 为演示方便，省略拷贝构造函数等</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
    <span class="n">MyClass</span> <span class="n">obj</span><span class="p">;</span>
    <span class="c1">// 使用std::move将obj的资源直接移动到vec中</span>
    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">obj</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="2-浅拷贝和移动的性能开销上有区别吗">2. 浅拷贝和移动的性能开销上有区别吗？</h4> <p>浅拷贝和移动在性能开销上不存在明显区别，主要区别在于资源管理和对象的所有权转移。</p> <p>浅拷贝只是简单地复制对象中的指针成员，使得多个对象共享同一块资源。虽然这种方式在拷贝过程中速度较快，因为它不涉及资源的重新分配和数据的逐个复制，但它存在资源管理的风险，比如多个对象共享资源可能导致双重释放问题。</p> <p>而移动操作则是将资源的所有权从一个对象转移到另一个对象，源对象不再拥有该资源。在移动过程中，通常只是进行少量的指针操作（如修改指针指向等），避免了深拷贝时对资源的重新分配和数据复制，因此性能开销相对较小。特别是当对象包含大量数据或动态分配的资源时，移动操作的性能优势更为明显。</p> <h4 id="3-区别通用引用和右值引用">3. 区别通用引用和右值引用</h4> <p>在C++编程里，清晰区分通用引用和右值引用意义重大，这对准确运用移动语义、完美转发等关键特性起着决定性作用。</p> <p>通用引用的产生必须同时满足两个条件：</p> <ol> <li>必须处于函数模板内的模板参数推导环境，或者是变量推导的情境。</li> <li>其格式需为 <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>，此处的 <code class="language-plaintext highlighter-rouge">T</code> 是模板参数，既不能是 <code class="language-plaintext highlighter-rouge">const T&amp;</code> 这样的形式，也不能是诸如 <code class="language-plaintext highlighter-rouge">std::vector&lt;T&gt;&amp;&amp;</code> 这类具体类型。</li> </ol> <p>接下来通过具体示例详细阐释两者的区别：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 右值引用示例</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">param</span><span class="p">)</span>

<span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">var1</span> <span class="o">=</span> <span class="n">Widget</span><span class="p">();</span>

<span class="c1">// 通用引用示例</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>

<span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">var2</span> <span class="o">=</span> <span class="n">var1</span><span class="p">;</span>
</code></pre></div></div> <p>深入理解通用引用和右值引用的差异，对合理运用C++的移动语义与完美转发特性极为关键。在实际编程中，右值引用主要用于实现移动语义，能够高效地把临时对象的资源所有权进行转移，从而避免不必要的拷贝操作。而通用引用在实现完美转发过程中扮演着重要角色，它能够依据传入参数实际的类型（左值或者右值），精确地将参数转发给其他函数，同时完整保留参数的所有属性。例如，在一些通用库的设计与实现里，通过合理运用通用引用和右值引用，可以打造出高效且通用的函数模板，显著提升代码的性能以及复用性。</p> <h4 id="4-理解stdmove和stdforward">4. 理解std::move和std::forward</h4> <p>在C++编程世界里，<code class="language-plaintext highlighter-rouge">std::move</code>与<code class="language-plaintext highlighter-rouge">std::forward</code>作为两个关键的函数模板，虽在运行时不生成实际可执行代码，但在类型转换方面发挥着举足轻重的作用，并非直观上的“移动”或“转发”动作。</p> <p><code class="language-plaintext highlighter-rouge">std::move</code>旨在无条件地把参数转换为右值，这一转换为移动语义的实现创造了条件，使得在合适场景下能够高效转移资源所有权，避免不必要的拷贝操作。其实现原理可通过以下伪代码理解：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">move</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ReturnType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>这里，<code class="language-plaintext highlighter-rouge">remove_reference&lt;T&gt;</code>是C++标准库中的类型萃取工具，负责移除类型<code class="language-plaintext highlighter-rouge">T</code>的引用部分。如此，无论<code class="language-plaintext highlighter-rouge">param</code>最初是左值引用还是右值引用，最终都能返回一个右值引用类型，达成将参数转换为右值的目标。</p> <p><code class="language-plaintext highlighter-rouge">std::forward</code>则有所不同，它专为实现完美转发而设计，仅在特定条件满足时执行类型转换。当函数模板需将参数原封不动传递给另一函数，且要保留参数的左值或右值属性时，<code class="language-plaintext highlighter-rouge">std::forward</code>便派上用场。其伪代码如下：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="s">"Can't forward rvalue as lvalue."</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>上述代码中，第一个模板函数处理左值参数，第二个处理右值参数。借助这种方式，<code class="language-plaintext highlighter-rouge">std::forward</code>能依据传入参数实际类型（左值或右值），精准转发至目标函数，确保参数属性不变，实现完美转发。例如在函数模板中，传入左值时，<code class="language-plaintext highlighter-rouge">std::forward</code>以左值引用形式转发；传入右值时，则以右值引用形式转发，满足不同场景下参数传递的精确需求。</p> <p>在实际应用中，右值引用通常绑定到可移动对象（如临时对象）上，若形参为右值引用，其绑定对象应具备可移动性。而通用引用和右值引用在转发时遵循不同规则：</p> <ul> <li>通用引用转发时，需使用<code class="language-plaintext highlighter-rouge">std::forward</code>进行向右值的有条件强制类型转换。因其可能绑定左值或右值，<code class="language-plaintext highlighter-rouge">std::forward</code>可按需将左值按左值转发，右值按右值转发，实现完美转发。</li> <li>右值引用转发时，应使用<code class="language-plaintext highlighter-rouge">std::move</code>进行向右值的无条件强制类型转换。由于右值引用已绑定右值，<code class="language-plaintext highlighter-rouge">std::move</code>可保证资源高效移动。 若将这两种转发方式用反，极可能引发问题，如代码冗余或运行期错误。对通用引用用<code class="language-plaintext highlighter-rouge">std::move</code>，会无条件转为右值，破坏左值特性，导致不必要移动；对右值引用用<code class="language-plaintext highlighter-rouge">std::forward</code>，因条件转换特性，可能无法正确移动资源，造成性能损失或逻辑错误。</li> </ul> <p>通常，“move”操作在资源转移方面比“copy”操作效率更高，但在局部对象返回场景中，这一观点需谨慎对待。例如：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Widget</span> <span class="nf">MakeWidget</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">w</span><span class="p">;</span>
    <span class="c1">// 此情况编译器会启用返回值优化（RVO），看似复制，实际仅调用一次拷贝构造函数</span>
<span class="p">}</span>

<span class="n">Widget</span> <span class="nf">MakeWidget</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
    <span class="c1">// 此代码会导致负优化，因不满足RVO条件</span>
<span class="p">}</span>
</code></pre></div></div> <p>RVO优化启动需满足两个条件：一是局部对象类型与函数返回值类型相同；二是返回的即为局部对象本身。第二段代码因使用<code class="language-plaintext highlighter-rouge">std::move</code>破坏了RVO条件，导致负优化。所以，当局部对象满足RVO条件时，不应使用<code class="language-plaintext highlighter-rouge">std::move</code>和<code class="language-plaintext highlighter-rouge">std::forward</code>，以保障程序性能。 正确理解并运用<code class="language-plaintext highlighter-rouge">std::move</code>、<code class="language-plaintext highlighter-rouge">std::forward</code>以及它们与通用引用、右值引用的关系，对编写高效、可靠的C++代码至关重要。</p> <h4 id="7-避免重载通用引用">7. 避免重载通用引用</h4> <p>在C++编程中，应尽量避免重载通用引用，主要原因在于通用引用（尤其是在模板中）可能引发一些难以预料的匹配问题。</p> <p>以如下代码为例：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">log</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="nf">log</span><span class="p">(</span><span class="kt">int</span> <span class="n">name</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">short</span> <span class="n">a</span><span class="p">;</span>
<span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</code></pre></div></div> <p>在此例中，当调用<code class="language-plaintext highlighter-rouge">log(a)</code>时，会出现精确匹配的情况。由于通用引用<code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>能够匹配各种类型，包括<code class="language-plaintext highlighter-rouge">short</code>类型，所以它会与<code class="language-plaintext highlighter-rouge">void log(int name)</code>函数竞争。在这种情况下，编译器通常会优先选择模板函数<code class="language-plaintext highlighter-rouge">log(T&amp;&amp; name)</code>。这是因为模板函数的匹配规则相对灵活，只要类型能够推导成功就会参与匹配，从而导致调用了并非开发者预期的函数。</p> <p>此外，在重载过程中，通用引用模板还会与拷贝构造函数、移动构造函数竞争，产生复杂的情况。以下面的<code class="language-plaintext highlighter-rouge">Person</code>类为例：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="k">explicit</span> <span class="n">Person</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="p">{}</span> <span class="c1">// 完美转发构造函数</span>

    <span class="k">explicit</span> <span class="nf">Person</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span><span class="p">);</span> <span class="c1">// 形参为int的构造函数</span>

    <span class="c1">// 默认拷贝构造函数（编译器自动生成）</span>
    <span class="n">Person</span><span class="p">(</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>

    <span class="c1">// 默认移动构造函数（编译器生成）</span>
    <span class="n">Person</span><span class="p">(</span><span class="n">Person</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">Person</span> <span class="nf">p</span><span class="p">(</span><span class="s">"Nancy"</span><span class="p">);</span>
<span class="c1">// 以下代码会编译失败</span>
<span class="c1">// 原因是这里试图通过拷贝构造函数创建cloneOfP，但由于p不是const类型，</span>
<span class="c1">// 完美转发构造函数会参与竞争，且它的匹配优先级在非const对象时较高，</span>
<span class="c1">// 从而导致与拷贝构造函数的匹配不是最优解，最终编译失败</span>
<span class="n">Person</span> <span class="nf">cloneOfP</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</code></pre></div></div> <p>在上述代码中，当尝试通过拷贝构造函数创建<code class="language-plaintext highlighter-rouge">cloneOfP</code>对象时，由于<code class="language-plaintext highlighter-rouge">p</code>不是<code class="language-plaintext highlighter-rouge">const</code>类型，完美转发构造函数<code class="language-plaintext highlighter-rouge">Person(T&amp;&amp; n)</code>会参与竞争。在这种竞争环境下，完美转发构造函数的匹配优先级相对较高，使得拷贝构造函数的匹配不再是最优解，进而导致编译失败。实际应用中，这种竞争情况可能因具体代码场景的不同而更加复杂，可能涉及到不同类型的参数、继承关系等多种因素，开发者很难准确预测和控制编译器的选择，从而增加了代码出错的风险。因此，为了提高代码的可读性、可维护性以及稳定性，应尽量避免重载通用引用。</p> <h4 id="9-理解引用折叠">9. 理解引用折叠</h4> <p>在C++中，当实参传递给函数模板时，模板形参的推导结果会包含实参是左值还是右值的信息。以下通过具体示例进行说明：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>

<span class="n">Widget</span> <span class="nf">WidgetFactory</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 返回右值</span>
    <span class="k">return</span> <span class="n">Widget</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
<span class="n">func</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>               <span class="c1">// T的推导结果是左值引用类型，即T被推导为Widget&amp;</span>
<span class="n">func</span><span class="p">(</span><span class="n">WidgetFactory</span><span class="p">());</span> <span class="c1">// T的推导结果是非引用类型（注意，这里不是右值），即T被推导为Widget</span>
</code></pre></div></div> <p>在C++语言规则中，“引用的引用”这种形式是不允许直接书写的。然而，如上述例子中，当<code class="language-plaintext highlighter-rouge">T</code>被推导为<code class="language-plaintext highlighter-rouge">Widget&amp;</code>时，函数声明就变成了<code class="language-plaintext highlighter-rouge">void func(Widget&amp; &amp;&amp; param);</code>，出现了左值引用与右值引用叠加的情况。这表明在实际的编译过程中，编译器确实会遇到类似“引用的引用”的情况（尽管开发者不能在代码中直接使用这种形式）。</p> <p>针对这种情况，C++有特定的引用折叠规则：</p> <ul> <li>如果两个引用中至少有一个是左值引用，那么折叠后的结果就是左值引用；只有当两个引用都是右值引用时，折叠结果才是右值引用。例如，<code class="language-plaintext highlighter-rouge">int&amp; &amp;</code>折叠后为<code class="language-plaintext highlighter-rouge">int&amp;</code>，<code class="language-plaintext highlighter-rouge">int&amp; &amp;&amp;</code>折叠后同样为<code class="language-plaintext highlighter-rouge">int&amp;</code>，而<code class="language-plaintext highlighter-rouge">int&amp;&amp; &amp;&amp;</code>折叠后为<code class="language-plaintext highlighter-rouge">int&amp;&amp;</code>。</li> </ul> <p>引用折叠通常会在以下四种语境中发生：</p> <ul> <li><strong>模板实例化</strong>：如上述函数模板<code class="language-plaintext highlighter-rouge">func</code>的例子，在实例化过程中根据实参类型推导<code class="language-plaintext highlighter-rouge">T</code>的类型时，可能出现引用折叠。当传递左值时，<code class="language-plaintext highlighter-rouge">T</code>被推导为左值引用类型，与模板参数<code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>结合就可能触发引用折叠。</li> <li><strong>auto类型生成</strong>：当使用<code class="language-plaintext highlighter-rouge">auto</code>关键字根据表达式推断类型时，如果涉及到引用，可能发生引用折叠。例如，<code class="language-plaintext highlighter-rouge">auto&amp;&amp; var1 = w;</code>（<code class="language-plaintext highlighter-rouge">w</code>为左值），这里<code class="language-plaintext highlighter-rouge">var1</code>的类型推导就可能涉及引用折叠，最终<code class="language-plaintext highlighter-rouge">var1</code>为左值引用。</li> <li><strong>创建和运用typedef和别名声明</strong>：在使用<code class="language-plaintext highlighter-rouge">typedef</code>或别名声明时，如果涉及多层引用，也可能引发引用折叠。例如，<code class="language-plaintext highlighter-rouge">typedef int&amp; IntRef; IntRef&amp;&amp; var2;</code>这里<code class="language-plaintext highlighter-rouge">var2</code>的类型推导就遵循引用折叠规则。</li> <li><strong>decltype</strong>：<code class="language-plaintext highlighter-rouge">decltype</code>表达式在某些情况下也会导致引用折叠。比如，<code class="language-plaintext highlighter-rouge">int i; decltype((i))&amp;&amp; var3 = i;</code>，由于<code class="language-plaintext highlighter-rouge">decltype((i))</code>的结果是<code class="language-plaintext highlighter-rouge">int&amp;</code>，与<code class="language-plaintext highlighter-rouge">&amp;&amp;</code>结合就会发生引用折叠，<code class="language-plaintext highlighter-rouge">var3</code>最终为左值引用。</li> </ul> <p>通过理解引用折叠的概念、规则以及其发生的语境，开发者能更好地把握C++中类型推导和引用相关的机制，编写出更健壮的代码。</p>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><summary type="html"><![CDATA[引用那些事儿]]></summary></entry><entry><title type="html">（二）模板那些事儿：模板元</title><link href="https://marco-hmc.github.io/blog/2025/1_template_mtp/" rel="alternate" type="text/html" title="（二）模板那些事儿：模板元"/><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/1_template_mtp</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/1_template_mtp/"><![CDATA[<h2 id="二模板那些事儿模板元">（二）模板那些事儿：模板元</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>模板进阶
├── 1. 模板元编程基础
│   ├── 1.1 模板的内存能力体现
│   ├── 1.2 模板的循环的递归能力
│   ├── 1.3 模板的条件控制能力
├── 2. 模板与继承（施工中）
│   ├── 2.1 模板的继承
│   ├── 2.2 CRTP
│   └── 2.3 模板与多态
│   └── 2.4 `std::variant` 和 `std::visit` 实现多态模板与多态
├── 3. 不定长参数
│   ├── 3.1
├── 4. 类型擦除（施工中）
│   ├── 4.1
├── 5. 表达式模板（施工中）
│   ├── 5.1
</code></pre></div></div> <h3 id="1-模板元编程">1. 模板元编程</h3> <p>模板元编程（Template Metaprogramming, TMP）是一种利用模板技术在编译阶段执行计算的编程方式。它通过在编译期提前进行类型推导、计算以及选择，能有效地提升程序在运行时的性能，同时增强程序的灵活性。在 C++编程领域，模板元编程展现出强大的能力，能够应对各种复杂任务，如精准的类型推导、递归计算以及条件编译等。</p> <p>从本质上讲，模板元编程主要围绕类型和常量展开操作。虽然其功能十分强大，能够处理众多与类型和常量相关的操作，但不能绝对地说任何针对类型和常量的操作都可通过模板元编程实现。在实际应用中，会受到一些限制，例如模板实例化的深度限制等。</p> <p>元编程技术，简而言之，就是自动生成代码的技术。在早期的 C/C++编程中，常常借助宏来实现这一目的。以<code class="language-plaintext highlighter-rouge">Qt</code>库的<code class="language-plaintext highlighter-rouge">moc</code>（Meta - Object Compiler）技术为例，它同样可被视作元编程技术的一种体现。而模板元编程具有独特的优势：它在编译阶段执行，不会产生运行时开销；专注于针对类型和常量进行操作；并且具备图灵完备性，这意味着理论上它可以实现任何可计算的算法。</p> <ul> <li><strong>模板元编程图灵完备的体现</strong>： C++的模板元编程在理论上是图灵完备的，即能完成任何可计算的任务，而一个图灵完备的计算系统具备以下几个关键特征： <ul> <li><strong>值对象操作能力</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">定义</code>：能够读取和修改变量的值（或进行类似的操作）。</li> <li><code class="language-plaintext highlighter-rouge">关键</code>：编译期常量/ 类型/ traits</li> </ul> </li> <li><strong>条件控制能力</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">定义</code>： 能够执行条件语句（如 if-else 或 switch-case）。</li> <li><code class="language-plaintext highlighter-rouge">关键</code>： SFINAE / 重载决议/ concept</li> </ul> </li> <li><strong>循环或递归能力</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">定义</code>：能够执行循环或递归操作（递归和循环在计算理论中是等价的，是可相互转换的）。</li> <li><code class="language-plaintext highlighter-rouge">关键</code>：模板递归（终止条件）/ 不定长参数</li> </ul> </li> </ul> </li> </ul> <p>下面展开模板是如何体现值对象操作能力、条件控制能力，以及循环活递归能力的。</p> <h4 id="11-模板的值对象操作能力">1.1 模板的值对象操作能力</h4> <h5 id="111-基本例子">1.1.1 基本例子</h5> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Fib</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">Fib</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">+</span> <span class="n">Fib</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Fib</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Fib</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// static_assert可表明零运行时</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">Fib</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">==</span> <span class="mi">55</span><span class="p">);</span>
</code></pre></div></div> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">RemoveConst</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">RemoveConst</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">TestType1</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
<span class="k">using</span> <span class="n">TestType2</span> <span class="o">=</span> <span class="k">const</span> <span class="kt">int</span><span class="p">;</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">RemoveConst</span><span class="o">&lt;</span><span class="n">TestType1</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">,</span> <span class="n">TestType1</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">RemoveConst</span><span class="o">&lt;</span><span class="n">TestType2</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>
</code></pre></div></div> <h4 id="12-模板的循环和递归能力">1.2 模板的循环和递归能力</h4> <p>模板的递归是指在模板定义中递归调用模板自身。这种技术通常用于编写模板元编程代码，例如计算编译时常量、生成编译时数据结构等。模板的递归可以分为两种：函数模板递归和类模板递归。</p> <p>常见应用场景：</p> <ul> <li><strong>计算编译期常量</strong>：如阶乘、斐波那契数列等。</li> <li><strong>类型列表的递归处理</strong>：对类型序列进行递归操作，如类型列表的生成和拆解。</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="c1">// 类模板递归</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Factorial</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Factorial</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Factorial&lt;5&gt;::value = "</span> <span class="o">&lt;&lt;</span> <span class="n">Factorial</span><span class="o">&lt;</span><span class="mi">5</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出 120</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="13-模板的条件控制能力">1.3 模板的条件控制能力</h4> <h5 id="131-模板特化-switch-case">1.3.1 模板特化 switch-case</h5> <p>在C++中，模板特化提供了一种针对特定类型定制模板行为的机制。如下代码展示了模板特化的基本形式：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">TypeHandler</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">process</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Generic type</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">TypeHandler</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">process</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Integer type</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">TypeHandler</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">process</span><span class="p">();</span>  <span class="c1">// 输出 "Generic type"</span>
<span class="n">TypeHandler</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">process</span><span class="p">();</span>      <span class="c1">// 输出 "Integer type"</span>
</code></pre></div></div> <p>这里，<code class="language-plaintext highlighter-rouge">TypeHandler</code>模板类针对通用类型有一个默认实现，而针对<code class="language-plaintext highlighter-rouge">int</code>类型进行了特化。当调用<code class="language-plaintext highlighter-rouge">TypeHandler&lt;int&gt;::process()</code>时，会执行特化版本的函数；调用<code class="language-plaintext highlighter-rouge">TypeHandler&lt;double&gt;::process()</code>时，执行通用版本。这种根据不同类型执行不同代码的行为，在功能上类似于<code class="language-plaintext highlighter-rouge">switch - case</code>语句。</p> <p>在模板特化中，不同的模板参数类型就如同<code class="language-plaintext highlighter-rouge">switch - case</code>中不同的<code class="language-plaintext highlighter-rouge">case</code>值，模板的通用实现类似于<code class="language-plaintext highlighter-rouge">switch - case</code>中的<code class="language-plaintext highlighter-rouge">default</code>分支。它们都提供了一种根据不同条件选择执行不同代码块的方式。</p> <h5 id="132-sfinae-if-else">1.3.2 SFINAE if-else</h5> <p>SFINAE（Substitution Failure Is Not An Error）是C++模板编程里一个极为重要的概念。在模板实例化期间，如果某些模板参数的替换操作失败，并不会导致编译错误，编译器会尝试寻找其他可行的模板实例化方式。这一特性在条件性模板特化和模板元编程中有着广泛应用。</p> <p>SFINAE主要有以下用途：</p> <ul> <li><strong>根据类型选择不同模板</strong>：允许根据传入模板的类型，选择最合适的模板函数或模板特化，以实现不同类型下的特定行为。</li> <li><strong>类型特定行为实现</strong>：能够根据类型判断是否支持某些操作，比如判断一个类型是否支持加法运算，或者是否属于容器类型等，从而实现类型相关的定制化逻辑。</li> </ul> <p><strong>enable_if的应用</strong></p> <p><code class="language-plaintext highlighter-rouge">enable_if</code>是基于SFINAE实现的一个工具，用于有条件地启用或禁用模板实例化。以下是使用标准库<code class="language-plaintext highlighter-rouge">std::enable_if</code>的示例：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;::</span><span class="n">type</span> <span class="nf">process</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Integral: "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">void</span><span class="o">&gt;::</span><span class="n">type</span> <span class="nf">process</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Non - integral: "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">process</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>    <span class="c1">// Integral</span>
    <span class="n">process</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span>  <span class="c1">// Non - integral</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上述代码中，<code class="language-plaintext highlighter-rouge">std::enable_if</code>根据<code class="language-plaintext highlighter-rouge">std::is_integral_v&lt;T&gt;</code>的结果来决定是否启用对应的<code class="language-plaintext highlighter-rouge">process</code>模板函数。如果<code class="language-plaintext highlighter-rouge">T</code>是整数类型，<code class="language-plaintext highlighter-rouge">std::is_integral_v&lt;T&gt;</code>为<code class="language-plaintext highlighter-rouge">true</code>，第一个<code class="language-plaintext highlighter-rouge">process</code>模板函数被启用；否则，第二个<code class="language-plaintext highlighter-rouge">process</code>模板函数被启用。</p> <p>下面来看<code class="language-plaintext highlighter-rouge">enable_if</code>的一种简单自定义实现：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">B</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">T</span> <span class="o">=</span> <span class="kt">void</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">enable_if</span> <span class="p">{};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">enable_if</span><span class="o">&lt;</span><span class="nb">true</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>这个自定义的<code class="language-plaintext highlighter-rouge">enable_if</code>模板结构体，当第一个模板参数<code class="language-plaintext highlighter-rouge">B</code>为<code class="language-plaintext highlighter-rouge">true</code>时，定义了一个<code class="language-plaintext highlighter-rouge">type</code>别名，其类型为第二个模板参数<code class="language-plaintext highlighter-rouge">T</code>。在实际使用中，类似于标准库中的<code class="language-plaintext highlighter-rouge">std::enable_if</code>，通过这种方式可以在模板实例化时根据条件选择性地启用或禁用模板。</p> <h5 id="133-if-constexpr">1.3.3 if-constexpr</h5> <p>在C++编程中，<code class="language-plaintext highlighter-rouge">if - constexpr</code> 是一种强大的特性，用于在编译期进行条件判断，这与传统的 <code class="language-plaintext highlighter-rouge">if</code> 语句在运行期进行条件判断有所不同。以下通过具体代码示例来深入理解这一特性。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 编译时条件判断的版本</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">process_compile_time</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Integral: "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nf">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Floating: "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Other type</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 运行时条件判断的版本</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">process_runtime</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Integral: "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Floating: "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Other type</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上述代码中，<code class="language-plaintext highlighter-rouge">process_compile_time</code> 函数模板使用了 <code class="language-plaintext highlighter-rouge">if - constexpr</code>。这意味着编译器在编译阶段就会根据模板参数 <code class="language-plaintext highlighter-rouge">T</code> 的类型来决定执行哪个分支。如果 <code class="language-plaintext highlighter-rouge">T</code> 是整数类型（<code class="language-plaintext highlighter-rouge">std::is_integral_v&lt;T&gt;</code> 为 <code class="language-plaintext highlighter-rouge">true</code>），则执行第一个分支，将 <code class="language-plaintext highlighter-rouge">val</code> 乘以 2 后输出；如果 <code class="language-plaintext highlighter-rouge">T</code> 是浮点类型（<code class="language-plaintext highlighter-rouge">std::is_floating_point_v&lt;T&gt;</code> 为 <code class="language-plaintext highlighter-rouge">true</code>），则执行第二个分支，将 <code class="language-plaintext highlighter-rouge">val</code> 加上 1.0 后输出；否则执行 <code class="language-plaintext highlighter-rouge">else</code> 分支。</p> <p>而 <code class="language-plaintext highlighter-rouge">process_runtime</code> 函数模板使用的是普通的 <code class="language-plaintext highlighter-rouge">if</code> 语句，它在运行时根据 <code class="language-plaintext highlighter-rouge">T</code> 的类型来判断执行哪个分支。</p> <p><code class="language-plaintext highlighter-rouge">if - constexpr</code> 的优势主要体现在以下几个方面：</p> <ul> <li><strong>编译期优化</strong>：由于条件判断在编译期完成，对于不满足条件的分支，编译器不会生成对应的代码。这有助于减少生成的可执行文件大小，提高运行效率。例如，如果模板实例化时 <code class="language-plaintext highlighter-rouge">T</code> 是整数类型，那么 <code class="language-plaintext highlighter-rouge">process_compile_time</code> 函数中浮点类型和其他类型的分支代码不会被生成，而 <code class="language-plaintext highlighter-rouge">process_runtime</code> 函数无论 <code class="language-plaintext highlighter-rouge">T</code> 是什么类型，所有分支的代码都会被生成。</li> <li><strong>模板元编程</strong>：在模板元编程中，<code class="language-plaintext highlighter-rouge">if - constexpr</code> 能够实现基于类型的条件逻辑，使得模板代码更加灵活和强大。它可以根据不同的类型特性进行不同的操作，而不需要为每种类型都编写单独的模板特化。</li> </ul> <p>通过对比这两个函数模板，我们可以清晰地看到 <code class="language-plaintext highlighter-rouge">if - constexpr</code> 在编译时条件判断方面的独特作用，以及它与传统运行时条件判断的区别。在实际编程中，合理运用 <code class="language-plaintext highlighter-rouge">if - constexpr</code> 可以提升代码的性能和可维护性，尤其在处理模板相关的复杂逻辑时，能发挥出显著的优势。</p> <h5 id="134-concept">1.3.4 concept</h5> <p>在C++中，概念（<code class="language-plaintext highlighter-rouge">concept</code>）是一种用于约束模板参数的工具，它为模板参数指定了一组必须满足的条件。通过使用概念，我们可以使模板代码更加易读、易维护，并且在编译期就能发现更多潜在的错误。</p> <p>例如，下面的代码展示了如何定义和使用一个简单的概念：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 定义一个名为Iterable的概念，用于判断类型T是否可迭代</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">concept</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="k">requires</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">Iterable</span> <span class="n">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">item</span> <span class="o">:</span> <span class="n">container</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="n">print</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>     <span class="c1">// 调用版本1，输出 "1 2 3"</span>
    <span class="n">print</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>      <span class="c1">// 调用版本2，输出 "42"</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在上述代码中，首先定义了<code class="language-plaintext highlighter-rouge">Iterable</code>概念。这个概念要求类型<code class="language-plaintext highlighter-rouge">T</code>必须具备<code class="language-plaintext highlighter-rouge">begin()</code>和<code class="language-plaintext highlighter-rouge">end()</code>成员函数，满足这个条件的类型才被认为是可迭代的。</p> <p>然后，基于<code class="language-plaintext highlighter-rouge">Iterable</code>概念重载了<code class="language-plaintext highlighter-rouge">print</code>函数。当调用<code class="language-plaintext highlighter-rouge">print</code>函数时，编译器会根据传入参数的类型是否满足<code class="language-plaintext highlighter-rouge">Iterable</code>概念来选择合适的函数版本。如果传入的是可迭代类型（如<code class="language-plaintext highlighter-rouge">std::vector&lt;int&gt;</code>），则会调用第一个<code class="language-plaintext highlighter-rouge">print</code>函数，它会遍历容器并打印每个元素；如果传入的是普通类型（如<code class="language-plaintext highlighter-rouge">int</code>），则会调用第二个<code class="language-plaintext highlighter-rouge">print</code>函数，直接打印该值。</p> <p>使用概念有诸多优势。一方面，它增强了代码的可读性，通过明确模板参数的要求，使代码的意图更加清晰。另一方面，在编译期就能对模板参数进行更严格的检查，如果模板参数不满足概念所定义的条件，编译器会报错，从而避免在运行时出现难以调试的错误。这有助于提高代码的健壮性和稳定性，尤其在大型模板库和复杂的模板编程中，概念的使用能大大提升开发效率和代码质量。</p> <p>通过这种方式，C++中的概念为模板编程提供了一种强大的类型约束机制，使模板代码的编写和理解变得更加容易。</p> <h3 id="2-模板与继承">2. 模板与继承</h3> <p>模板与继承是 C++ 模板编程中的一个重要概念。通过将模板与继承结合使用，可以实现更加灵活和强大的代码结构。以下是模板与继承的几个主要方面：</p> <h4 id="21-模板类的继承">2.1 模板类的继承</h4> <p>模板类的继承是指一个模板类继承自另一个模板类或普通类。通过模板类的继承，可以实现代码的重用和扩展。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="c1">// 基类模板</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">baseFunction</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base function"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 派生类模板，继承自基类模板</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">derivedFunction</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Derived function"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Derived</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">baseFunction</span><span class="p">();</span>    <span class="c1">// 调用基类模板的函数</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">derivedFunction</span><span class="p">();</span> <span class="c1">// 调用派生类模板的函数</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="22-crtpcuriously-recurring-template-pattern">2.2 CRTP（Curiously Recurring Template Pattern）</h4> <p>CRTP（Curiously Recurring Template Pattern）是一种特殊的模板设计模式，其中派生类将自身作为模板参数传递给基类。CRTP 常用于实现静态多态、编译时多态和类型安全的接口。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Derived</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">interface</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">implementation</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">implementation</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base implementation"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">implementation</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Derived implementation"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Derived</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">interface</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="23-模板与多态">2.3 模板与多态</h4> <p>模板与多态是指将模板与多态结合使用，以实现更加灵活和强大的代码结构。通过将模板与多态结合使用，可以实现编译时多态和运行时多态的结合。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="c1">// 基类</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">function</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 派生类模板</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">function</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Derived function with type "</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;&gt;</span> <span class="n">objects</span><span class="p">;</span>
    <span class="n">objects</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">());</span>
    <span class="n">objects</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">());</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">obj</span> <span class="o">:</span> <span class="n">objects</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">obj</span><span class="o">-&gt;</span><span class="n">function</span><span class="p">();</span> <span class="c1">// 调用派生类模板的实现</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>模板与继承是 C++ 模板编程中的一个重要概念。通过将模板与继承结合使用，可以实现代码的重用和扩展。CRTP 是一种特殊的模板设计模式，常用于实现静态多态和类型安全的接口。模板与多态结合使用，可以实现编译时多态和运行时多态的结合，从而实现更加灵活和强大的代码结构。通过理解和使用模板与继承，可以编写出更加灵活和高效的代码。</p> <h3 id="3-不定长参数">3. 不定长参数</h3> <h4 id="31-c11-变参模板variadic-templates">3.1 C++11 变参模板（Variadic Templates）</h4> <p>变参模板允许模板接受任意数量的模板参数。这使得编写泛型代码更加灵活，特别是在处理不定数量的参数时。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"End of recursion"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">T</span> <span class="n">first</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">print</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="s">"Hello"</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="32-c17-折叠表达式fold-expressions">3.2 C++17 折叠表达式（Fold Expressions）</h4> <p>折叠表达式是 C++17 引入的一种语法，用于简化变参模板中的递归操作。折叠表达式可以对参数包进行折叠，生成一个单一的表达式。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">sum</span><span class="p">(</span><span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">args</span> <span class="o">+</span> <span class="p">...);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="4-表达式模板">4. 表达式模板</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstddef&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">jc</span> <span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SArray</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">SArray</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">sz</span><span class="p">)</span> <span class="o">:</span> <span class="n">data_</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">sz</span><span class="p">]),</span> <span class="n">sz_</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="p">{</span> <span class="n">init</span><span class="p">();</span> <span class="p">}</span>

  <span class="n">SArray</span><span class="p">(</span><span class="k">const</span> <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">:</span> <span class="n">data_</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">rhs</span><span class="p">.</span><span class="n">sz_</span><span class="p">]),</span> <span class="n">sz_</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">sz_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">copy</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span> <span class="o">!=</span> <span class="k">this</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">copy</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">SArray</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">data_</span><span class="p">;</span> <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sz_</span><span class="p">;</span> <span class="p">}</span>

  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>

  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">data_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>

  <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">sz_</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">sz_</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="k">const</span> <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">sz_</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">sz_</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">rhs</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">protected</span><span class="o">:</span>
  <span class="kt">void</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">{};</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">copy</span><span class="p">(</span><span class="k">const</span> <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">sz_</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">sz_</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">data_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">T</span><span class="o">*</span> <span class="n">data_</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">sz_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">{</span><span class="n">lhs</span><span class="p">.</span><span class="n">size</span><span class="p">()};</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lhs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">{</span><span class="n">lhs</span><span class="p">.</span><span class="n">size</span><span class="p">()};</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lhs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lhs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="k">const</span> <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">{</span><span class="n">rhs</span><span class="p">.</span><span class="n">size</span><span class="p">()};</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lhs</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">A_Scalar</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">constexpr</span> <span class="n">A_Scalar</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">constexpr</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value_</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">A_Traits</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">A_Traits</span><span class="o">&lt;</span><span class="n">A_Scalar</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">A_Scalar</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">OP1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">OP2</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">A_Add</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">A_Add</span><span class="p">(</span><span class="k">const</span> <span class="n">OP1</span><span class="o">&amp;</span> <span class="n">op1</span><span class="p">,</span> <span class="k">const</span> <span class="n">OP2</span><span class="o">&amp;</span> <span class="n">op2</span><span class="p">)</span> <span class="o">:</span> <span class="n">op1_</span><span class="p">(</span><span class="n">op1</span><span class="p">),</span> <span class="n">op2_</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">T</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">op1_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">op2_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">op1_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">op2_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">op1_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">op2_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">op1_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">op1_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">:</span> <span class="n">op2_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="k">typename</span> <span class="n">A_Traits</span><span class="o">&lt;</span><span class="n">OP1</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">op1_</span><span class="p">;</span>
  <span class="k">typename</span> <span class="n">A_Traits</span><span class="o">&lt;</span><span class="n">OP2</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">op2_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">OP1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">OP2</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">A_Mult</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">A_Mult</span><span class="p">(</span><span class="k">const</span> <span class="n">OP1</span><span class="o">&amp;</span> <span class="n">op1</span><span class="p">,</span> <span class="k">const</span> <span class="n">OP2</span><span class="o">&amp;</span> <span class="n">op2</span><span class="p">)</span> <span class="o">:</span> <span class="n">op1_</span><span class="p">(</span><span class="n">op1</span><span class="p">),</span> <span class="n">op2_</span><span class="p">(</span><span class="n">op2</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">T</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">op1_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">op2_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">op1_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">op2_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">op1_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">op2_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">op1_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">op1_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">:</span> <span class="n">op2_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="k">typename</span> <span class="n">A_Traits</span><span class="o">&lt;</span><span class="n">OP1</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">op1_</span><span class="p">;</span>
  <span class="k">typename</span> <span class="n">A_Traits</span><span class="o">&lt;</span><span class="n">OP2</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">op2_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">A1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">A2</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">A_Subscript</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">A_Subscript</span><span class="p">(</span><span class="k">const</span> <span class="n">A1</span><span class="o">&amp;</span> <span class="n">a1</span><span class="p">,</span> <span class="k">const</span> <span class="n">A2</span><span class="o">&amp;</span> <span class="n">a2</span><span class="p">)</span> <span class="o">:</span> <span class="n">a1_</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">a2_</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">a1_</span><span class="p">[</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a2_</span><span class="p">[</span><span class="n">i</span><span class="p">])]);</span>
  <span class="p">}</span>

  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a1_</span><span class="p">[</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a2_</span><span class="p">[</span><span class="n">i</span><span class="p">])];</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a2_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="k">const</span> <span class="n">A1</span><span class="o">&amp;</span> <span class="n">a1_</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">A2</span><span class="o">&amp;</span> <span class="n">a2_</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span>  <span class="c1">// namespace jc</span>

<span class="k">namespace</span> <span class="n">jc</span><span class="o">::</span><span class="n">test</span> <span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Rep</span> <span class="o">=</span> <span class="n">SArray</span><span class="o">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Array</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">Array</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">r_</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">Array</span><span class="p">(</span><span class="k">const</span> <span class="n">Rep</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="o">:</span> <span class="n">r_</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">Array</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Array</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">r_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Rep2</span><span class="p">&gt;</span>
  <span class="n">Array</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T2</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">r_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">r_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>

  <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">r_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">r_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Rep2</span><span class="p">&gt;</span>
  <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A_Subscript</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Rep</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;&gt;</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T2</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A_Subscript</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Rep</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;&gt;</span><span class="p">{</span>
        <span class="n">A_Subscript</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Rep</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;</span><span class="p">{</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">rep</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">rep</span><span class="p">()}};</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Rep2</span><span class="p">&gt;</span>
  <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="p">[](</span><span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T2</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A_Subscript</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Rep</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;&gt;</span><span class="p">{</span>
        <span class="n">A_Subscript</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Rep</span><span class="p">,</span> <span class="n">Rep2</span><span class="o">&gt;</span><span class="p">{</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">rep</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">rep</span><span class="p">()}};</span>
  <span class="p">}</span>

  <span class="n">Rep</span><span class="o">&amp;</span> <span class="n">rep</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">r_</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">const</span> <span class="n">Rep</span><span class="o">&amp;</span> <span class="n">rep</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">r_</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">Rep</span> <span class="n">r_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">R1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">R2</span><span class="p">&gt;</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A_Add</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;&gt;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R1</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A_Add</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;&gt;</span><span class="p">{</span><span class="n">A_Add</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;</span><span class="p">{</span><span class="n">lhs</span><span class="p">.</span><span class="n">rep</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">rep</span><span class="p">()}};</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">R1</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">R2</span><span class="p">&gt;</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A_Mult</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R1</span><span class="o">&gt;&amp;</span> <span class="n">lhs</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A_Mult</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;&gt;</span><span class="p">{</span><span class="n">A_Mult</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;</span><span class="p">{</span><span class="n">lhs</span><span class="p">.</span><span class="n">rep</span><span class="p">(),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">rep</span><span class="p">()}};</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">R2</span><span class="p">&gt;</span>
<span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A_Mult</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A_Scalar</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;&gt;</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span>
                                               <span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A_Mult</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A_Scalar</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;&gt;</span><span class="p">{</span>
      <span class="n">A_Mult</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">A_Scalar</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">R2</span><span class="o">&gt;</span><span class="p">{</span><span class="n">A_Scalar</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="n">rhs</span><span class="p">.</span><span class="n">rep</span><span class="p">()}};</span>
<span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace jc::test</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
  <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">jc</span><span class="o">::</span><span class="n">test</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">{</span><span class="n">sz</span><span class="p">};</span>
  <span class="n">jc</span><span class="o">::</span><span class="n">test</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">y</span><span class="p">{</span><span class="n">sz</span><span class="p">};</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">sz</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">sz</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span>
                <span class="k">decltype</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">x</span><span class="p">),</span>
                <span class="n">jc</span><span class="o">::</span><span class="n">test</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">jc</span><span class="o">::</span><span class="n">A_Mult</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">jc</span><span class="o">::</span><span class="n">A_Scalar</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span>
                                                   <span class="n">jc</span><span class="o">::</span><span class="n">SArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">);</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span>
                <span class="k">decltype</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">),</span>
                <span class="n">jc</span><span class="o">::</span><span class="n">test</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">jc</span><span class="o">::</span><span class="n">A_Mult</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">jc</span><span class="o">::</span><span class="n">SArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span>
                                                   <span class="n">jc</span><span class="o">::</span><span class="n">SArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;&gt;</span><span class="p">);</span>

  <span class="k">static_assert</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span>
          <span class="k">decltype</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">),</span>
          <span class="n">jc</span><span class="o">::</span><span class="n">test</span><span class="o">::</span><span class="n">Array</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span>
                          <span class="n">jc</span><span class="o">::</span><span class="n">A_Add</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span>
                                    <span class="n">jc</span><span class="o">::</span><span class="n">A_Mult</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">jc</span><span class="o">::</span><span class="n">A_Scalar</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span>
                                               <span class="n">jc</span><span class="o">::</span><span class="n">SArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span><span class="p">,</span>
                                    <span class="n">jc</span><span class="o">::</span><span class="n">A_Mult</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">jc</span><span class="o">::</span><span class="n">SArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">,</span>
                                               <span class="n">jc</span><span class="o">::</span><span class="n">SArray</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;&gt;&gt;&gt;</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/*
   * x[y] = 2.0 * x[y] equals to:
   * for (std::size_t i = 0; i &lt; y.size(); ++i) {
   *   x[y[i]] = 2 * x[y[i]];
   * }
   */</span>
  <span class="n">x</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">y</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>表达式模板支持对数组像内置类型一样进行数值运算，并且不会产生临时对象</p> <h3 id="5-类型擦除">5. 类型擦除</h3> <h4 id="51-什么是类型擦除可以用来做什么">5.1 什么是类型擦除？可以用来做什么？</h4> <ul> <li> <p><strong>什么是类型擦除</strong> 在 C++中，类型擦除（Type Erasure）是一种编程技术，它允许你在运行时隐藏或“擦除”对象的具体类型信息，只保留对象的行为，从而实现多态性和泛型编程的一种灵活方式。类型擦除是一个类似 wrapper 的行为。</p> <p>C++ 中模板提供了编译时的泛型编程能力，使用模板时编译器会根据具体的类型实例化代码。然而，有时我们希望在运行时处理不同类型的对象，而不需要知道它们的具体类型，只关心它们具有某些共同的行为。类型擦除通过创建一个抽象接口，将具体类型的对象包装起来，对外只暴露统一的接口，从而隐藏了具体的类型信息。</p> <p>例如，假设有多个不同类型的类 <code class="language-plaintext highlighter-rouge">Dog</code>、<code class="language-plaintext highlighter-rouge">Cat</code>、<code class="language-plaintext highlighter-rouge">Bird</code>，它们都有一个 <code class="language-plaintext highlighter-rouge">speak</code> 方法。可以通过类型擦除技术，将这些不同类型的对象统一包装在一个类（比如 <code class="language-plaintext highlighter-rouge">AnimalWrapper</code>）中，使得外部代码可以以相同的方式调用它们的 <code class="language-plaintext highlighter-rouge">speak</code> 方法，而无需关心具体是哪种动物。</p> </li> <li> <p><strong>类型擦除的用途</strong></p> <ul> <li><strong>实现多态行为</strong>：除了传统的虚函数多态，类型擦除提供了另一种实现多态的方式。通过类型擦除，不同类型的对象可以被视为具有相同的抽象类型，从而实现更灵活的多态行为。例如，在一个图形绘制系统中，<code class="language-plaintext highlighter-rouge">Circle</code>、<code class="language-plaintext highlighter-rouge">Rectangle</code>、<code class="language-plaintext highlighter-rouge">Triangle</code> 等不同形状的类可以通过类型擦除被统一处理，对外提供统一的 <code class="language-plaintext highlighter-rouge">draw</code> 接口。</li> <li><strong>泛型容器</strong>：在自定义容器中，使用类型擦除可以使容器能够存储不同类型的对象，而不需要为每种类型都单独实现一个容器。比如，实现一个 <code class="language-plaintext highlighter-rouge">Any</code> 类型的容器，它可以存储任意类型的对象，内部通过类型擦除技术来管理这些对象。</li> <li><strong>简化接口设计</strong>：类型擦除可以使接口更加简洁和通用。客户端代码只需要与抽象的接口交互，而不需要了解具体的实现类型。这有助于提高代码的可维护性和可扩展性。例如，在一个日志记录系统中，不同的日志记录器（如文件日志记录器、控制台日志记录器等）可以通过类型擦除被统一的日志记录接口调用。</li> </ul> </li> </ul> <h4 id="52-类型擦除实现的基本原理是什么">5.2 类型擦除实现的基本原理是什么？</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>假设我们希望实现一个容器，该容器能够同时存储任何类型的数据。换句话，就是弱化类型信息，或者说擦除类型信息，从而使得如何数据都可以同一种类型表示。
为了实现这一目标，容器内部存储的对象必然是`void* ptr`，以及`std::type_info *type`。一个表示地址，一个表示类型。

一种方法是将所有存储的类型都派生自一个公共父类，并通过该父类提供的方法获取类型信息。例如，我们可以定义 intType 和 doubleType 类，它们都继承自一个公共父类 type。这样，容器可以存储指向 type 类型的指针，通过多态机制获取具体类型并进行解码。

然而，这种方法需要对存储的类型进行改造，增加了复杂性。有没有一种更好的方法呢？

答案是肯定的。我们可以通过提供包装器的方式，将公共父类的概念隐藏到一个自定义类型中。这种方式就是类型擦除。类型擦除通过创建一个抽象接口，将具体类型的对象包装起来，对外只暴露统一的接口，从而隐藏了具体的类型信息，实现了更加灵活和简洁的多态性和泛型编程。
</code></pre></div></div> <h3 id="99-quiz">99. quiz</h3> <h4 id="2-模板参数-parameter-和模板实参-argument-概念的区分">2. 模板参数 parameter 和模板实参 argument 概念的区分</h4> <p>使用了 decltype(a)，各种莫名其妙报错，is_same_v 判断无效（因为 decltype(a) 会返回 A const &amp; 而不是 A，用 std::decay_t&lt;decltype(a)&gt; 即可） T::value_type 无法编译通过（由于缺乏 typename 前缀，用 typename T::value_type 即可）</p> <h4 id="3-将与参数无关的代码抽离模板factor-parameter-independent-code-out-of-templates">3. 将与参数无关的代码抽离模板（Factor Parameter-Independent Code Out of Templates）</h4> <p>在 C++ 模板编程中，模板参数的多样化可能导致生成冗余的二进制代码。为避免这种情况，可以将与模板参数无关的代码提取到模板外部。</p> <ul> <li><strong>原始代码</strong></li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SquareMatrix</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">invert</span><span class="p">();</span> <span class="c1">// 求逆矩阵</span>
<span class="p">};</span>

<span class="n">SquareMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">sm1</span><span class="p">;</span>
<span class="n">SquareMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">sm2</span><span class="p">;</span>
<span class="n">sm1</span><span class="p">.</span><span class="n">invert</span><span class="p">();</span>  <span class="c1">// 编译器会为这两个调用生成两个完全不同的 invert 实现</span>
<span class="n">sm2</span><span class="p">.</span><span class="n">invert</span><span class="p">();</span>
</code></pre></div></div> <ul> <li><strong>改进后的代码</strong></li> </ul> <p>将与模板参数 <code class="language-plaintext highlighter-rouge">n</code> 无关的代码提取到基类 <code class="language-plaintext highlighter-rouge">SquareMatrixBase</code> 中：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SquareMatrixBase</span> <span class="p">{</span>
<span class="nl">protected:</span>
    <span class="kt">void</span> <span class="n">invert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">matrixSize</span><span class="p">);</span>  <span class="c1">// 在基类中实现实际的求逆算法</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SquareMatrix</span> <span class="o">:</span> <span class="k">private</span> <span class="n">SquareMatrixBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="k">using</span> <span class="n">SquareMatrixBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">invert</span><span class="p">;</span>  <span class="c1">// 避免遮蔽基类的 invert 函数</span>

<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">invert</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">invert</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>  <span class="c1">// 使用一个 inline 调用来调用基类的 invert</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <ul> <li><strong>增加矩阵数据存储</strong></li> </ul> <p>使用指针存储矩阵数据，并在构造函数中传递给基类：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SquareMatrix</span> <span class="o">:</span> <span class="k">private</span> <span class="n">SquareMatrixBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">SquareMatrix</span><span class="p">()</span> <span class="o">:</span> <span class="n">SquareMatrixBase</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">pData</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">setDataPtr</span><span class="p">(</span><span class="n">pData</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>  <span class="c1">// 设置矩阵数据指针</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">pData</span><span class="p">;</span>  <span class="c1">// 存储在堆上的矩阵数据</span>
<span class="p">};</span>
</code></pre></div></div> <ul> <li><strong>总结</strong> <ol> <li><strong>避免模板参数依赖：</strong> 将与模板参数无关的代码抽离到基类中，减少冗余代码。</li> <li><strong>使用基类共享实现：</strong> 通过基类共享实现，避免因模板实例化导致的代码膨胀。</li> <li><strong>通过成员变量替代模板参数：</strong> 将非类型模板参数作为类成员变量传递，减少二进制膨胀。</li> <li><strong>使用指针和动态内存：</strong> 动态分配存储数据，进一步减少代码膨胀。</li> </ol> </li> </ul> <p>通过这些技巧，可以有效减少模板参数导致的代码膨胀，优化编译时间和生成的二进制文件。</p> <h4 id="4-宏的元编程和模板的元编程对比">4. 宏的元编程和模板的元编程对比</h4>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><category term="template"/><summary type="html"><![CDATA[（二）模板那些事儿：模板元]]></summary></entry><entry><title type="html">（一）多线程那些事儿：怎么用</title><link href="https://marco-hmc.github.io/blog/2025/1_threads/" rel="alternate" type="text/html" title="（一）多线程那些事儿：怎么用"/><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/1_threads</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/1_threads/"><![CDATA[<h2 id="一多线程那些事儿怎么用">（一）多线程那些事儿：怎么用</h2> <p>cpu 的单核性能提升接近瓶颈，多核是未来 cpu 的趋势。而多线程就能充分利用多核技术。但使用多线程不一定只是为了追求性能，使用多线程的意义也在于提升处理任务数量（请求个数）的能力，比如说即时通讯系统中，发起多个会话就是如此。不开线程就没办法，发起新的一个会话。当然多进程也能做这些事情，至于多线程和多进程的比较使用，则是另一个话题，也不在此展开。</p> <p>可以说多线程是比较重要，且属于程序开发中比较基础的能力。而多线程的使用可以从两个角度出发去理解：</p> <ul> <li>多线程的创建和相关管理手段</li> <li>多线程的通信和同步方式</li> </ul> <h3 id="0-concepts">0. concepts</h3> <h4 id="01-introduction">0.1 introduction</h4> <ul> <li><code class="language-plaintext highlighter-rouge">std::thread</code>, <code class="language-plaintext highlighter-rouge">std::async</code>, <code class="language-plaintext highlighter-rouge">std::packaged_task</code>的区别是什么？</li> <li>为什么多线程如何传引用？如何传类成员函数？</li> <li>什么是虚假唤醒？</li> <li><code class="language-plaintext highlighter-rouge">std::lock_guard</code>和<code class="language-plaintext highlighter-rouge">std::unique_lock</code>有什么不同？</li> <li><code class="language-plaintext highlighter-rouge">std::condition_variable</code>和<code class="language-plaintext highlighter-rouge">std::future</code>怎么同步？</li> <li>什么是 CAS？</li> <li>什么是内存序？什么是先行发生，什么是并行发生？</li> </ul> <h4 id="02-怎么理解线程和任务">0.2 怎么理解线程和任务？</h4> <p>在软件开发中，开发者的目标是<strong>并发/并行处理多个任务</strong>。而线程是作为实现并发处理的常见手段，其核心作用是承载和执行任务。</p> <p>随着线程池和并行库等高级工具的广泛应用，线程的管理逻辑被封装在内核中，外部调用者无需感知线程的具体创建、调度和销毁过程。这种抽象设计带来了便利，但也容易导致概念混淆。例如，在使用并行库执行任务时，开发者可能默认是通过多线程实现并行，但实际上底层实现可能采用协程、异步 I/O 或其他非线程技术。以<code class="language-plaintext highlighter-rouge">OpenMP</code>的嵌套并行为例，其内层并行任务在默认配置下并不会创建新的线程，而是复用外层线程资源，这进一步凸显了线程与任务的本质差异。</p> <p>因此，明确区分<strong>线程</strong>与<strong>任务</strong>的概念至关重要：</p> <ul> <li><strong>任务</strong>：指需要完成的具体工作单元，是开发者定义的逻辑操作，如数据处理、函数调用等；</li> <li><strong>线程</strong>：作为操作系统分配的执行资源，是任务的实际载体，具备独立的执行上下文和系统调度能力。</li> </ul> <p>准确理解这两个概念，不仅有助于更清晰地描述并发模型，也能在技术沟通和性能优化中避免歧义，提升协作效率。</p> <h4 id="03-多线程相关的性能开销有多少">0.3 多线程相关的性能开销有多少？</h4> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| 操作类型                                   | CPU时钟周期范围 | 时间范围（纳秒）  |
| L1 缓存读取                                  | 3-4          | 9-12ns          |
| L2 缓存读取                                  | 10-12        | 30-36ns         |
| L3 缓存读取                                  | 30-70        | 90-210ns        |
| 主内存读取                                   | 100-150      | 300-450ns       |
| NUMA（不同插槽的原子操作/CAS，估计值）         | 100-300      | 300-900ns       |
| NUMA（不同插槽的 L3 缓存读取）                | 100-300      | 300-900ns       |
| 分配+释放配对（小对象，内存池方式）            | 5-15         | 10-50ns         |
| 分配+释放配对（小对象，new和delete方式）       | 200-500      | 600-1500ns      |
| -------------------------                   | --------     | ----------      |
| 内核调用                                     | 1000-1500    | 3-4.5μs         |
| 线程上下文切换（直接成本）                    | 2k            | 6μs             |
| 线程上下文切换（总成本，包括缓存失效）         | 10k- 1m       | 30μs - 3ms      |
| -------------------------                   | --------     | ----------      |
| 磁盘访问（SSD）                              | 100k- 1m     | 30μs - 300μs    |
| 磁盘访问（HDD）                              | 1m- 10m      | 300μs - 3ms     |
| 线程创建                                     | 1m- 10m      | 300μs - 3ms     |
| 线程销毁                                     | 1m- 10m      | 300μs - 3ms     |
</code></pre></div></div> <p>在多线程性能分析中，虽然具体操作开销因硬件架构、系统负载等因素存在差异，但不同操作的开销量级关系具有普遍参考价值。深入理解这些量级差异及其影响因素，是实现系统性能优化的核心。</p> <p>从开销量级来看，线程创建与销毁的开销通常在 300 微秒至 3 毫秒之间。当单个任务执行时间达到 50 毫秒以上时，此类开销对任务整体耗时的影响相对较小；但对于本身是 5ms 左右的任务来说，在特定场景下却可能引发显著的性能瓶颈。</p> <p>以 IO 密集型任务为例，缓存机制对性能的影响尤为关键。当 L1/L2 缓存频繁失效，数据读取被迫降级至 L3 缓存甚至主内存时，访问延迟可能激增百倍。假设某任务中 IO 操作占比 80%，计算操作占比 20%，且 IO 操作高度依赖缓存命中，缓存失效将严重拖慢任务执行效率。</p> <p>此外，锁与同步机制产生的开销本质上也与 IO 存在关联。锁操作通过总线指令锁定数据资源，当其他线程尝试访问被锁定的数据时，会因资源不可用而进入阻塞状态，这种阻塞表现为数据输入输出的延迟，因此可将其纳入广义的 IO 开销范畴。</p> <p>因此，在分析多线程应用性能时，既可以采用传统的 IO 密集型/CPU 密集型分类，也可以从缓存读写、CPU 计算、同步开销三个维度展开分析。无论采用何种视角，通过优化缓存管理、减少不必要的上下文切换与同步操作，都是提升多线程系统性能的关键路径。</p> <h3 id="04-线程状态切换图">0.4 线程状态切换图</h3> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        +-------+       +-------+
        | New   |  -&gt;   | Ready |
        +-------+       +-------+
                          ^  |
                          |  v
        +-----------------------+
        |       Running         |
        +-----------------------+
            |  ^             |
            v  |             v
        +-------+        +-------+
| waiting/Blocked|       | Terminated|
        +-------+        +-------+
</code></pre></div></div> <p>如果把上述看成一个状态机，<code class="language-plaintext highlighter-rouge">New</code>和<code class="language-plaintext highlighter-rouge">Terminated</code>其实就是起点和终点，相对重要的是其余三个状态。首先是只有处于<code class="language-plaintext highlighter-rouge">Running</code>状态的才会消耗CPU资源。</p> <ul> <li>什么时候会进入<code class="language-plaintext highlighter-rouge">waiting/Blocked</code>状态？ <ul> <li>拿不到锁。<code class="language-plaintext highlighter-rouge">mtx.lock();</code>如果拿不到锁，当前锁就进入<code class="language-plaintext highlighter-rouge">waiting/Blocked</code>了</li> <li>调用<code class="language-plaintext highlighter-rouge">wait()</code>的时候，拿不到锁</li> <li>调用<code class="language-plaintext highlighter-rouge">sleep()</code></li> <li>发起内存/硬盘/网络等<code class="language-plaintext highlighter-rouge">io</code>操作</li> </ul> </li> <li>只有<code class="language-plaintext highlighter-rouge">Running</code>状态的才在真实消耗CPU计算资源</li> </ul> <h3 id="1-多线程的创建和管理手段">1. 多线程的创建和管理手段</h3> <p>c++多线程创建和管理的手段就三种：<code class="language-plaintext highlighter-rouge">std::thread</code>、<code class="language-plaintext highlighter-rouge">std:async</code>和<code class="language-plaintext highlighter-rouge">std::packaged_task</code>。</p> <p>如果用一句话总结区别的话就是，不需要线程返回结果就是用<code class="language-plaintext highlighter-rouge">std::thread</code>，需要线程返回结果就是用<code class="language-plaintext highlighter-rouge">std::async</code>和<code class="language-plaintext highlighter-rouge">std::packaged_task</code>；不想管理线程的，就是用<code class="language-plaintext highlighter-rouge">std::async</code>，想提升性能去管理线程的话，就是<code class="language-plaintext highlighter-rouge">std::packaged_task</code>和<code class="language-plaintext highlighter-rouge">std::thread</code>。</p> <h4 id="11-thread">1.1 thread</h4> <ul> <li> <p><strong>适用场景</strong>：</p> <ul> <li><strong>需要直接控制线程的生命周期</strong>：当你需要精细控制线程的创建、启动、暂停、恢复和终止时，使用 <code class="language-plaintext highlighter-rouge">std::thread</code> 是合适的选择。</li> <li><strong>需要共享资源的复杂同步</strong>：当多个线程需要访问共享资源，并且需要复杂的同步机制（如互斥锁、条件变量）时，<code class="language-plaintext highlighter-rouge">std::thread</code> 提供了更大的灵活性。</li> <li><strong>需要高性能</strong>：在某些高性能计算场景中，直接使用 <code class="language-plaintext highlighter-rouge">std::thread</code> 可以避免一些抽象层带来的开销。</li> </ul> </li> <li> <p><strong>特点</strong></p> <ul> <li><strong>直接控制</strong>：<code class="language-plaintext highlighter-rouge">std::thread</code> 提供了对线程的直接控制，可以精细地管理线程的创建、执行和销毁。</li> <li><strong>手动管理</strong>：需要手动管理线程的生命周期，包括创建、等待（<code class="language-plaintext highlighter-rouge">join</code>）和分离（<code class="language-plaintext highlighter-rouge">detach</code>）线程。</li> <li><strong>无返回值</strong>：<code class="language-plaintext highlighter-rouge">std::thread</code> 无法直接返回任务的结果，需要使用其他同步机制（如 <code class="language-plaintext highlighter-rouge">std::promise</code> 和 <code class="language-plaintext highlighter-rouge">std::future</code>）来获取结果。</li> </ul> </li> </ul> <h4 id="12-async">1.2 async</h4> <p><code class="language-plaintext highlighter-rouge">std::async</code> 是一个强大的工具，是 C++11 中引入的一个用于启动异步任务的函数。通过合理使用 <code class="language-plaintext highlighter-rouge">std::async</code> 和选择适当的启动策略，可以提高程序的并发性能和响应速度。它自动处理线程的创建和销毁，使得异步编程变得更简单。如果你只需要在后台运行一个任务并获取其结果，那么<code class="language-plaintext highlighter-rouge">std::async</code>通常是最好的选择。</p> <ul> <li> <p><strong>适用场景</strong>：</p> <ul> <li><strong>简单的异步任务</strong>：当你需要启动一个简单的异步任务，并且不需要显式管理线程时，使用 <code class="language-plaintext highlighter-rouge">std::async</code> 是最方便的选择。</li> <li><strong>任务的启动策略</strong>：当你希望任务可以根据需要立即执行或延迟执行时，<code class="language-plaintext highlighter-rouge">std::async</code> 提供了灵活的启动策略（如 <code class="language-plaintext highlighter-rouge">std::launch::async</code> 和 <code class="language-plaintext highlighter-rouge">std::launch::deferred</code>）。</li> <li><strong>需要返回值的异步任务</strong>：当你需要启动一个异步任务并获取其返回值时，<code class="language-plaintext highlighter-rouge">std::async</code> 会返回一个 <code class="language-plaintext highlighter-rouge">std::future</code> 对象，方便获取结果。</li> </ul> </li> <li> <p><strong>应用场景</strong></p> <ul> <li><strong>简单异步任务</strong>：适用于简单的异步任务，不需要复杂的线程管理。</li> <li><strong>自动管理需求</strong>：适用于希望自动管理线程生命周期的场景，减少手动管理的复杂性。多为同步计算和异步计算同时存在的场景。或者更进一步，用来处理 io 耗时而非 cpu 密集任务的。比如说要播放一个特效动画，然后计算伤害，特效动画开一个 async 去做，后面继续计算等等。</li> </ul> </li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Fn</span><span class="err">，</span> <span class="k">class</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">Fn</span><span class="p">(</span><span class="n">Args</span><span class="p">...)</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
      <span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span> <span class="n">policy</span><span class="err">，</span> <span class="n">Fn</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="err">，</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">);</span>
</code></pre></div></div> <h4 id="13-packaged_task">1.3 packaged_task</h4> <p><code class="language-plaintext highlighter-rouge">std::packaged_task</code> 是 C++11 中引入的一个类模板，用于将一个可调用对象（<code class="language-plaintext highlighter-rouge">task</code>，如函数、lambda 表达式或函数对象）包装成任务，并将其结果存储在一个 <code class="language-plaintext highlighter-rouge">std::future</code> 对象中，以便稍后获取。</p> <ul> <li><strong>适用场景</strong>： <ul> <li><strong>需要更高的灵活性</strong>：当你需要将任务与线程分离，并在不同的时间和上下文中启动任务时，使用 <code class="language-plaintext highlighter-rouge">std::packaged_task</code> 是合适的选择。</li> <li><strong>复杂的任务管理</strong>：当你需要显式管理任务的生命周期，并且可能需要将任务传递给其他线程或存储在容器中时，<code class="language-plaintext highlighter-rouge">std::packaged_task</code> 提供了更高的灵活性。</li> <li><strong>需要返回值的任务</strong>：与 <code class="language-plaintext highlighter-rouge">std::async</code> 类似，<code class="language-plaintext highlighter-rouge">std::packaged_task</code> 也会返回一个 <code class="language-plaintext highlighter-rouge">std::future</code> 对象，用于获取任务的结果。</li> </ul> </li> </ul> <h3 id="2-多线程间的通信同步手段">2. 多线程间的通信、同步手段</h3> <p>相较于进程，线程是共享同一进程的地址空间的，线程间的通信将会很容易，直接就可以通过全局变量来交换数据。但这种访问的便利性也带来了一些风险，通常当有多个线程访问相同的共享数据时，做出的操作往往是不安全的。这就需要线程同步。所谓的线程同步，就是指多线程通过特定的设置（如互斥量、事件对象、临界区）来控制线程之间的执行顺序。</p> <p>同步的目的是协同、协助、互相配合线程的运行，而不是同时进行。例如，一个线程完成任务后，另一个线程才开始执行。线程同步通过建立线程之间的执行顺序关系，确保线程按预定的顺序运行。如果没有同步机制，线程将各自独立运行，可能导致资源竞争和数据不一致的问题。</p> <p>下面介绍 c++标准库中支持的常见同步手段。</p> <ul> <li>互斥锁：<code class="language-plaintext highlighter-rouge">mutex</code>/ <code class="language-plaintext highlighter-rouge">shared_mutex</code>/ <code class="language-plaintext highlighter-rouge">recursive_mutex</code></li> <li>条件变量：<code class="language-plaintext highlighter-rouge">condition_variable</code></li> <li>承诺和期值：<code class="language-plaintext highlighter-rouge">promise</code>/ <code class="language-plaintext highlighter-rouge">future</code></li> <li>原子对象：<code class="language-plaintext highlighter-rouge">atomic</code></li> </ul> <p>还有一些 posix 标准支持的信号量，但标准库出来之后，现在用得很少了，但 C++20 又引入了，我了解不深，就不介绍了。</p> <h4 id="21-互斥锁">2.1 互斥锁</h4> <ul> <li><strong>适用场景</strong>： <ul> <li><strong>互斥锁</strong>：当你需要确保只有一个线程可以访问共享资源时，使用 <code class="language-plaintext highlighter-rouge">std::mutex</code> 是合适的选择。</li> </ul> </li> <li><strong>解释</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">std::mutex</code> 提供了互斥锁，确保只有一个线程可以访问共享资源。</li> <li>使用 <code class="language-plaintext highlighter-rouge">std::lock_guard</code> 自动管理锁的生命周期，避免死锁。</li> </ul> </li> </ul> <h5 id="211-c标准库直接支持的锁类型">2.1.1 c++标准库直接支持的锁类型</h5> <ul> <li><strong><code class="language-plaintext highlighter-rouge">std::mutex</code></strong>：基本的互斥锁。</li> <li><strong><code class="language-plaintext highlighter-rouge">std::recursive_mutex</code></strong>：递归互斥锁，允许同一线程多次获取锁。</li> <li><strong><code class="language-plaintext highlighter-rouge">std::shared_mutex</code></strong>：读写锁，允许多个线程同时读取，但写入时需要独占锁。</li> <li><strong><code class="language-plaintext highlighter-rouge">std::timed_mutex</code></strong>：带有超时功能的互斥锁。</li> <li><strong><code class="language-plaintext highlighter-rouge">std::shared_timed_mutex</code></strong>：带有超时功能的共享互斥锁。</li> </ul> <h5 id="212-锁策略锁管理上锁方式">2.1.2 锁策略/锁管理/上锁方式</h5> <ul> <li> <p><strong><code class="language-plaintext highlighter-rouge">std::lock</code></strong></p> <ul> <li><strong>功能</strong>：一个函数模板，用于使用死锁避免算法锁定多个可锁对象。</li> <li><strong>特点</strong>：确保多个锁按顺序锁定，避免死锁。</li> <li><strong>使用场景</strong>：适用于需要同时锁定多个互斥锁的场景，确保线程安全。</li> <li><strong>如何使用</strong>：</li> <li>调用 <code class="language-plaintext highlighter-rouge">std::lock</code> 函数时传入多个互斥锁，使用死锁避免算法锁定所有互斥锁。</li> <li>在锁定成功后，可以使用 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 或 <code class="language-plaintext highlighter-rouge">std::lock_guard</code> 管理这些锁。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">std::try_lock</code></strong></p> <ul> <li><strong>功能</strong>：一个函数模板，尝试获取多个互斥锁的所有权，如果无法获取则返回。</li> <li><strong>特点</strong>：用于尝试锁定多个互斥锁，而不会阻塞线程。</li> <li><strong>使用场景</strong>：适用于需要尝试锁定多个互斥锁的场景，避免线程阻塞。</li> <li><strong>如何使用</strong>：</li> <li>调用 <code class="language-plaintext highlighter-rouge">std::try_lock</code> 函数时传入多个互斥锁，尝试获取所有互斥锁的所有权。</li> <li>如果成功获取所有互斥锁，返回 -1；如果无法获取某个互斥锁，返回该互斥锁的索引。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">std::unique_lock</code></strong></p> <ul> <li><strong>功能</strong>：提供更多灵活性和控制的锁管理类，可以延迟锁定、手动锁定和解锁、传递锁的所有权。</li> <li><strong>特点</strong>：适用于复杂的锁定需求，支持延迟锁定和手动解锁。</li> <li><strong>使用场景</strong>：适用于需要灵活控制锁定和解锁的场景，如需要在不同函数间传递锁的所有权。</li> <li><strong>如何使用</strong>：</li> <li>创建 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 对象时可以选择立即锁定或延迟锁定互斥锁。</li> <li>可以手动调用 <code class="language-plaintext highlighter-rouge">lock</code> 和 <code class="language-plaintext highlighter-rouge">unlock</code> 方法来控制锁定和解锁。</li> <li>可以将 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 对象传递给其他函数，传递锁的所有权。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">std::lock_guard</code></strong></p> <ul> <li><strong>功能</strong>：简单的 RAII 风格的锁管理类，在构造时自动锁定互斥锁，在析构时自动解锁互斥锁。</li> <li><strong>特点</strong>：适用于基本的锁定需求，确保在作用域结束时自动释放锁。</li> <li><strong>使用场景</strong>：适用于简单的临界区保护，确保在函数退出时自动释放锁。</li> <li><strong>如何使用</strong>：</li> <li>创建 <code class="language-plaintext highlighter-rouge">std::lock_guard</code> 对象时传入互斥锁，自动锁定互斥锁。</li> <li>在作用域结束时，<code class="language-plaintext highlighter-rouge">std::lock_guard</code> 会自动解锁互斥锁。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">std::scoped_lock</code></strong></p> <ul> <li><strong>功能</strong>：同时锁定多个互斥锁，并在作用域结束时自动解锁。</li> <li><strong>特点</strong>：RAII 风格的锁管理器，确保在作用域结束时自动释放锁，避免死锁和资源泄漏。</li> <li><strong>使用场景</strong>：适用于需要同时锁定多个互斥锁的场景，确保线程安全。</li> <li><strong>如何使用</strong>：</li> <li>创建 <code class="language-plaintext highlighter-rouge">std::scoped_lock</code> 对象时传入多个互斥锁。</li> <li>在作用域结束时，<code class="language-plaintext highlighter-rouge">std::scoped_lock</code> 会自动解锁所有互斥锁。</li> </ul> </li> </ul> <h5 id="213-未支持的锁类型其他锁概念">2.1.3 未支持的锁类型/其他锁概念</h5> <ul> <li> <p><strong>自旋锁（Spin Lock）</strong></p> <ul> <li><strong>功能</strong>：自旋锁在等待锁时会不断循环检查锁的状态，而不是阻塞线程。</li> <li><strong>特点</strong>：适用于高频率锁定和解锁的场景，避免线程上下文切换的开销。</li> <li><strong>使用场景</strong>：适用于锁持有时间短、频繁加锁解锁的场景，如短时间的临界区保护。</li> <li><strong>如何实现</strong>：通常使用原子操作（如 <code class="language-plaintext highlighter-rouge">std::atomic_flag</code>）实现，通过不断尝试获取锁来实现自旋。</li> </ul> </li> <li> <p><strong>分段锁（Segmented Locks）</strong></p> <ul> <li><strong>功能</strong>：将资源分割成多个部分，并对每个部分使用单独锁的机制，以减少锁竞争。</li> <li><strong>特点</strong>：通过分段锁减少锁竞争，提高并发性能。</li> <li><strong>使用场景</strong>：适用于需要对大块资源进行并发访问的场景，如哈希表、缓存等。</li> <li><strong>如何实现</strong>：将资源分割成多个部分，每个部分使用单独的锁，线程只锁定需要访问的部分。</li> </ul> </li> <li> <p><strong>乐观锁（Optimistic Lock）</strong></p> <ul> <li><strong>功能</strong>：假设并发冲突不会频繁发生，在访问资源时不加锁，而是在提交修改时检查冲突，如果发生冲突则重试。</li> <li><strong>特点</strong>：通过减少锁的使用提高并发性能，适用于低冲突的场景。</li> <li><strong>使用场景</strong>：适用于低冲突的场景，如数据库读操作、缓存等。</li> <li><strong>如何实现</strong>：CAS+版本号，在提交修改时检查版本号或时间戳是否变化，如果发生冲突则重试。</li> </ul> </li> </ul> <h4 id="22-condition_variable">2.2 condition_variable</h4> <p>条件变量是一种“事件通知机制”，它本身不提供、也不能够实现“互斥”的功能。因此，条件变量通常（也必须）配合互斥量来一起使用，其中互斥量实现对“共享数据”的互斥（即同步），而条件变量则去执行 “通知共享数据状态信息的变化”的任务。比如通知队列为空、非空，或任何其他需要由线程处理的共享数据的状态变化。可以说，条件变量是程序用来等待某个状态为真的机制。而这个状态必须得是线程安全的，因此需要搭配互斥量使用。</p> <p>在 c++中，条件变量的关键词是<code class="language-plaintext highlighter-rouge">std::condition_variable</code>。它可以用来在多线程环境中实现复杂的同步模式。以下是一些常见的用法:</p> <ol> <li><strong>等待通知</strong>:一个线程可以使用<code class="language-plaintext highlighter-rouge">std::condition_variable::wait</code>或<code class="language-plaintext highlighter-rouge">wait_for</code>/<code class="language-plaintext highlighter-rouge">wait_until</code>方法来等待另一个线程的通知。当<code class="language-plaintext highlighter-rouge">wait</code>被调用时，当前线程将被阻塞，直到另一个线程调用<code class="language-plaintext highlighter-rouge">std::condition_variable::notify_one</code>或<code class="language-plaintext highlighter-rouge">notify_all</code>方法。</li> <li><strong>条件等待</strong>:<code class="language-plaintext highlighter-rouge">std::condition_variable::wait</code>方法还可以接受一个谓词(返回<code class="language-plaintext highlighter-rouge">bool</code>的函数或函数对象).只有当这个谓词返回<code class="language-plaintext highlighter-rouge">true</code>时，<code class="language-plaintext highlighter-rouge">wait</code>才会返回。这可以用来实现条件等待:线程等待某个条件成立。</li> <li><strong>唤醒一个或多个线程</strong>:可以使用<code class="language-plaintext highlighter-rouge">std::condition_variable::notify_one</code>方法唤醒一个等待的线程，或者使用<code class="language-plaintext highlighter-rouge">std::condition_variable::notify_all</code>方法唤醒所有等待的线程。</li> </ol> <ul> <li><strong>适用场景</strong>： <ul> <li><strong>条件变量</strong>：当你需要线程间的同步和通信时，使用 <code class="language-plaintext highlighter-rouge">std::condition_variable</code> 是合适的选择。</li> </ul> </li> <li><strong>解释</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">std::condition_variable</code> 提供了条件变量，用于线程间的同步和通信。</li> <li>一个线程等待条件变量，另一个线程设置条件并通知等待的线程。</li> </ul> </li> </ul> <h4 id="23-promise-future">2.3 promise/ future</h4> <p><code class="language-plaintext highlighter-rouge">future</code>和<code class="language-plaintext highlighter-rouge">promise</code>一般都是成对使用的。<code class="language-plaintext highlighter-rouge">future</code>用于多线程获得返回值，<code class="language-plaintext highlighter-rouge">promise</code>用于多线程设置值。</p> <ul> <li><strong>适用场景</strong>： <ul> <li><strong>线程之间的值传递</strong>：当你需要在线程之间传递值时，使用 <code class="language-plaintext highlighter-rouge">std::promise</code> 和 <code class="language-plaintext highlighter-rouge">std::future</code> 是合适的选择。</li> </ul> </li> <li><strong>解释</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">std::promise</code> 用于设置值，<code class="language-plaintext highlighter-rouge">std::future</code> 用于获取值。</li> <li>在一个线程中设置值，在另一个线程中获取值，实现线程间的值传递</li> </ul> </li> </ul> <h5 id="231-shared_future">2.3.1 shared_future</h5> <p><code class="language-plaintext highlighter-rouge">std::future</code>对象的设计是唯一所有权的，也就是说，一旦你从一个<code class="language-plaintext highlighter-rouge">std::future</code>对象中获取了值，这个<code class="language-plaintext highlighter-rouge">std::future</code>对象就不能再被用来获取值。这是因为<code class="language-plaintext highlighter-rouge">std::future::get</code>方法会移动(而不是复制)值或异常，这样可以避免不必要的复制，但也意味着你只能从一个<code class="language-plaintext highlighter-rouge">std::future</code>对象中获取值一次。</p> <p>因此，如果你需要在多个线程中共享同一个值，你不能直接使用<code class="language-plaintext highlighter-rouge">std::future</code>，而应该使用<code class="language-plaintext highlighter-rouge">std::shared_future</code>.<code class="language-plaintext highlighter-rouge">std::shared_future</code>对象可以被多次拷贝和读取，这意味着你可以在多个线程中共享同一个值。</p> <ul> <li>shared_future 可以直接对一个 promise 变量使用 get_future 方法吗</li> </ul> <p>不可以。<code class="language-plaintext highlighter-rouge">std::promise</code>的<code class="language-plaintext highlighter-rouge">get_future</code>方法只能返回一个<code class="language-plaintext highlighter-rouge">std::future</code>对象，而不是<code class="language-plaintext highlighter-rouge">std::shared_future</code>对象。如果你想要一个<code class="language-plaintext highlighter-rouge">std::shared_future</code>对象，你需要首先从<code class="language-plaintext highlighter-rouge">std::promise</code>获取一个<code class="language-plaintext highlighter-rouge">std::future</code>对象，然后调用<code class="language-plaintext highlighter-rouge">std::future</code>的<code class="language-plaintext highlighter-rouge">share</code>方法来获取一个<code class="language-plaintext highlighter-rouge">std::shared_future</code>对象。例如:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sf</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">share</span><span class="p">();</span>
</code></pre></div></div> <h4 id="24-atomic">2.4 atomic</h4> <p>std::call_once 和 std::once_flag：这些用于确保某个函数或操作只被调用一次，即使在多线程环境中也不会被重复执行。</p> <ul> <li>解决多线程下共享变量的问题(i++，指令重排问题)：对于共享变量的访问进行加锁，加锁可以保证对临界区的互斥访问，</li> <li>C++11 提供了一些原子变量与原子操作解决用户加锁操作麻烦或者容易出错的问题</li> <li>C++11 标准在标准库 atomic 头文件提供了模版 std::atomic&lt;&gt;来定义原子量，而对于大部分内建类型，C++11 提供了一些特化，如，std::atomic_int (std::atomic<int>)等</int></li> <li>自定义类型变成原子变量的条件是该类型必须为<strong>Trivially Copyable 类型</strong>(简单的判断标准就是这个类型可以用 std::memcpy 按位复制)</li> <li> <p>atomic 有一个成员函数 is_lock_free，这个成员函数可以告诉我们到底这个类型的原子量是使用了原子 CPU 指令实现了无锁化，还是依然使用的加锁的方式来实现原子操作</p> </li> <li><strong>适用场景</strong>： <ul> <li><strong>原子操作</strong>：当你需要进行原子操作以确保线程安全时，使用 <code class="language-plaintext highlighter-rouge">std::atomic</code> 是合适的选择。</li> </ul> </li> <li><strong>解释</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">std::atomic</code> 提供了原子操作，确保多个线程对共享变量的操作是线程安全的。</li> <li>在多个线程中对 <code class="language-plaintext highlighter-rouge">std::atomic</code> 变量进行操作，避免数据竞争。</li> </ul> </li> </ul> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-线程不使用-join-也不使用-detach会发生什么">1. 线程不使用 <code class="language-plaintext highlighter-rouge">join</code> 也不使用 <code class="language-plaintext highlighter-rouge">detach</code>，会发生什么？</h4> <p>在主线程退出时，可能会导致一些未定义行为，因为线程对象将被销毁，但线程本身可能仍在运行。</p> <ul> <li><strong>可能发生的情况</strong>： <ol> <li><strong>程序可能终止，但线程可能仍在运行</strong>： <ul> <li>如果主线程退出，而被创建的线程仍在运行，可能导致程序终止，但线程继续执行。这可能导致线程无法正确完成其任务，因为主线程已经退出。</li> </ul> </li> <li><strong>程序可能会崩溃</strong>： <ul> <li>这是由于线程对象的销毁可能涉及到一些资源的释放，而线程本身仍在访问这些资源，导致未定义行为。</li> </ul> </li> <li><strong>资源泄漏</strong>： <ul> <li>如果线程分配了一些资源（例如内存），但在线程执行完毕前这些资源没有被释放，可能会导致资源泄漏。</li> </ul> </li> </ol> </li> </ul> <h4 id="2-为什么多线程传引用要用stdref">2. 为什么多线程传引用要用<code class="language-plaintext highlighter-rouge">std::ref</code></h4> <p>问题出在 <code class="language-plaintext highlighter-rouge">std::thread</code> 不能直接传递引用类型参数。<code class="language-plaintext highlighter-rouge">std::thread</code> 在创建线程时会复制传入的参数。因为主线程和子线程是两个声明周期，如果直接传递引用，当主线程中的对象销毁后，线程函数中的引用就会成为悬空引用，访问悬空引用会导致未定义行为。</p> <p>如果能够直接传递引用类型参数，很容易使得开发人员因一时疏忽导致产生了悬空引用。为了保证安全性，如果要使用<code class="language-plaintext highlighter-rouge">T&amp;</code>则需要开发人员主动使用<code class="language-plaintext highlighter-rouge">std::ref</code>，否则会报错。因此来避免不小心而导致的悬空引用。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">modifyValue</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Value inside thread: "</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="c1">// std::thread t(modifyValue， value); // error</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">modifyValue</span><span class="err">，</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Value outside thread: "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="3-stdlock_guard和stdunique_lock有什么不同">3. <code class="language-plaintext highlighter-rouge">std::lock_guard</code>和<code class="language-plaintext highlighter-rouge">std::unique_lock</code>有什么不同？</h4> <p><code class="language-plaintext highlighter-rouge">std::lock_guard</code> 和 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 都是 RAII（Resource Acquisition Is Initialization）风格的互斥锁包装器，它们在构造时自动锁定互斥锁，在析构时自动解锁互斥锁。这种设计可以确保在函数退出（无论是正常退出还是异常退出）时自动释放锁，从而避免因忘记解锁而导致的死锁。<code class="language-plaintext highlighter-rouge">std::lock_guard</code>和<code class="language-plaintext highlighter-rouge">std::unique_lock</code>的主要区别在于:</p> <ol> <li> <p><strong>延迟锁定</strong>：</p> <ul> <li><code class="language-plaintext highlighter-rouge">std::lock_guard</code> 则在创建时必须立即上锁，然后只能在结束时解锁。</li> <li><code class="language-plaintext highlighter-rouge">std::unique_lock</code> 可以在任意时候上锁和解锁。</li> </ul> </li> <li> <p><strong>所有权传递</strong>：</p> <ul> <li><code class="language-plaintext highlighter-rouge">std::lock_guard</code> 则不可移动。</li> <li><code class="language-plaintext highlighter-rouge">std::unique_lock</code> 是可移动的，这意味着你可以将锁的所有权从一个 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 对象转移到另一个。例如：</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock1</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lock1</span><span class="p">);</span>
<span class="c1">// 此时 lock1 不再拥有锁的所有权，lock2 拥有</span>
</code></pre></div> </div> </li> </ol> <p>在使用<code class="language-plaintext highlighter-rouge">std::wait</code>的时候一定不能用<code class="language-plaintext highlighter-rouge">std::lock_guard</code>。因为调用 <code class="language-plaintext highlighter-rouge">wait()</code> 时，是先获取锁，然后检查条件。如果条件不满足需要再释放锁，从而允许其他线程访问共享资源。而<code class="language-plaintext highlighter-rouge">std::lock_guard</code>不可以手动解锁，所以无法在 <code class="language-plaintext highlighter-rouge">wait()</code> 期间临时释放锁。<code class="language-plaintext highlighter-rouge">std::unique_lock</code> 则可以在 <code class="language-plaintext highlighter-rouge">wait()</code> 期间自动解锁和重新加锁，这样就可以避免死锁或竞态条件。</p> <p>在一些简单的作用域加锁场景中，<code class="language-plaintext highlighter-rouge">std::lock_guard</code>因其简单轻量可能是更好的选择；而在需要更灵活控制锁的生命周期和所有权的复杂场景下，<code class="language-plaintext highlighter-rouge">std::unique_lock</code>则更为适用。</p> <h4 id="4-stdunique_lock提供的锁策略参数是什么">4. <code class="language-plaintext highlighter-rouge">std::unique_lock</code>提供的锁策略参数是什么？</h4> <p><code class="language-plaintext highlighter-rouge">std::adopt_lock</code>/<code class="language-plaintext highlighter-rouge">std::defer_lock</code> 和 <code class="language-plaintext highlighter-rouge">std::try_to_lock</code> 都是 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 的构造函数可以接受的锁策略参数，它们的含义和使用场景如下:</p> <ol> <li><strong>std::adopt_lock</strong>:这个策略表示互斥锁在构造锁对象时已经被锁定。当你已经手动锁定了一个互斥锁，然后想要将它的管理权交给 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 时，可以使用 <code class="language-plaintext highlighter-rouge">std::adopt_lock</code>.这样，<code class="language-plaintext highlighter-rouge">std::unique_lock</code> 在构造时就不会再次尝试锁定互斥锁，而是直接接管已经被锁定的互斥锁。</li> <li><strong>std::defer_lock</strong>:这个策略表示在构造 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 时不锁定互斥锁。你可以稍后手动调用 <code class="language-plaintext highlighter-rouge">std::unique_lock::lock</code> 方法来锁定互斥锁。这个策略在你需要延迟锁定互斥锁的情况下很有用。</li> <li><strong>std::try_to_lock</strong>:这个策略表示在构造 <code class="language-plaintext highlighter-rouge">std::unique_lock</code> 时尝试锁定互斥锁，如果互斥锁已经被锁定，则立即返回，不会阻塞。你可以检查 <code class="language-plaintext highlighter-rouge">std::unique_lock::owns_lock</code> 方法的返回值，来判断是否成功锁定了互斥锁。</li> </ol> <h4 id="5-什么是虚假唤醒为什么会有虚假唤醒可以避免虚假唤醒吗">5. 什么是虚假唤醒？为什么会有虚假唤醒？可以避免虚假唤醒吗？</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cond</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">queue</span><span class="p">;</span>

<span class="c1">// error</span>
<span class="kt">int</span> <span class="nf">dequeue</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>  <span class="c1">// 使用 if 判断，可能会出现虚假唤醒</span>
        <span class="n">cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">top</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ok_case1</span>
<span class="kt">int</span> <span class="nf">dequeue2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>  <span class="c1">// 不能用 if，必须用 while，避免虚假唤醒</span>
        <span class="n">cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">top</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ok_case2</span>
<span class="kt">int</span> <span class="nf">dequeue3</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
    <span class="n">cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="err">，</span> <span class="p">[]</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>  <span class="c1">// 使用 lambda 表达式检查条件</span>
    <span class="kt">int</span> <span class="n">top</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">top</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在多线程编程中，使用条件变量（Condition Variable）进行线程同步时，可能会遇到虚假唤醒的问题。以下是对虚假唤醒及其处理方法的详细解释：</p> <ul> <li> <p><strong>什么是虚假唤醒？</strong> 虚假唤醒（Spurious Wakeup）是指线程在等待条件变量时，即使没有任何线程调用 <code class="language-plaintext highlighter-rouge">notify_one</code> 或 <code class="language-plaintext highlighter-rouge">notify_all</code>，也会被唤醒的情况，即<code class="language-plaintext highlighter-rouge">wait</code>的时候被唤醒了。这种现象在某些操作系统和硬件平台上可能会发生。</p> </li> <li> <p><strong>为什么会有虚假唤醒？</strong> 虚假唤醒的原因可能包括：</p> <ol> <li><code class="language-plaintext highlighter-rouge">操作系统的调度策略</code>：操作系统可能会出于各种原因唤醒等待的线程，例如资源重新分配或优先级调整。</li> <li><code class="language-plaintext highlighter-rouge">硬件中断</code>：硬件中断可能会导致等待的线程被唤醒。</li> <li><code class="language-plaintext highlighter-rouge">其他系统级别的事件</code>：系统级别的事件（如信号处理）也可能导致线程被唤醒。</li> </ol> </li> <li> <p><strong>总结</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">虚假唤醒</code>：虚假唤醒是指线程在等待条件变量时，即使没有任何线程调用 <code class="language-plaintext highlighter-rouge">notify_one</code> 或 <code class="language-plaintext highlighter-rouge">notify_all</code>，也会被唤醒的情况。</li> <li><code class="language-plaintext highlighter-rouge">原因</code>：虚假唤醒可能由操作系统的调度策略、硬件中断或其他系统级别的事件引起。</li> <li><code class="language-plaintext highlighter-rouge">处理方法</code>：为了正确处理虚假唤醒，通常在一个 <code class="language-plaintext highlighter-rouge">while</code> 循环中调用 <code class="language-plaintext highlighter-rouge">.wait()</code> 方法，确保每次被唤醒时都重新检查条件是否满足。</li> </ul> </li> </ul> <h4 id="6-如果对stdfuture不调用-get会发生什么">6. 如果对<code class="language-plaintext highlighter-rouge">std::future</code>不调用 get()，会发生什么？</h4> <p><code class="language-plaintext highlighter-rouge">std::future</code>通常由<code class="language-plaintext highlighter-rouge">std::async</code>、<code class="language-plaintext highlighter-rouge">std::packaged_task</code>等创建。当创建了<code class="language-plaintext highlighter-rouge">std::future</code>对象，但未调用<code class="language-plaintext highlighter-rouge">get()</code>方法时，在<code class="language-plaintext highlighter-rouge">std::future</code>对象被销毁的过程中，如果其关联的异步操作（例如通过<code class="language-plaintext highlighter-rouge">std::async</code>启动的任务）尚未完成，程序会发生阻塞，一直到异步操作完成为止。</p> <p>这是由于<code class="language-plaintext highlighter-rouge">std::future</code>的析构函数会主动检查关联的异步操作状态。若操作未完成，析构函数便会进入阻塞等待状态，目的是确保异步操作能够安全结束，防止在未完成的情况下被强制终止。</p> <p>若不想在<code class="language-plaintext highlighter-rouge">std::future</code>对象被销毁时出现阻塞情况，可以调用<code class="language-plaintext highlighter-rouge">std::future::detach()</code>方法。该方法会使<code class="language-plaintext highlighter-rouge">std::future</code>对象与它所关联的异步操作相互分离，如此一来，即便<code class="language-plaintext highlighter-rouge">std::future</code>对象后续被销毁，异步操作依旧会继续执行。不过需要注意的是，调用<code class="language-plaintext highlighter-rouge">detach()</code>后，将无法再通过该<code class="language-plaintext highlighter-rouge">std::future</code>对象获取异步操作的结果。例如：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">([]{</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="p">});</span>
<span class="n">fut</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
<span class="c1">// 这里 fut 与异步操作分离，fut 销毁时不会阻塞，同时也无法获取异步操作结果</span>
</code></pre></div></div> <h4 id="7-什么是析构竞争">7. 什么是析构竞争？</h4> <p>简单来说，当线程 A 正在销毁对象，而线程 B 同时调用该对象的方法时，就会出现问题。具体而言，若多个线程持有该对象的裸指针或引用，当某个线程对其进行析构，其他线程再访问这个对象，就可能出现崩溃或者未定义行为。</p> <p>解决此问题，一般借助智能指针来管理这个对象。如果对象的生命周期需要在多处进行管理，可使用<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>；若只有一处能管理对象生命周期，通常搭配<code class="language-plaintext highlighter-rouge">std::weak_ptr</code>和锁来处理。<code class="language-plaintext highlighter-rouge">std::weak_ptr</code>能够判断对象的生命周期是否依然有效，若有效，则获取锁。同样，在析构对象时，也需要获取这个锁才能进行析构操作。</p>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><category term="threads"/><summary type="html"><![CDATA[（一）多线程那些事儿：怎么用]]></summary></entry><entry><title type="html">（二）多线程那些事儿：原子类型数据和内存序</title><link href="https://marco-hmc.github.io/blog/2025/2_atomic/" rel="alternate" type="text/html" title="（二）多线程那些事儿：原子类型数据和内存序"/><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>https://marco-hmc.github.io/blog/2025/2_atomic</id><content type="html" xml:base="https://marco-hmc.github.io/blog/2025/2_atomic/"><![CDATA[<h2 id="二多线程那些事儿原子类型数据和内存序">（二）多线程那些事儿：原子类型数据和内存序</h2> <h3 id="1-concepts">1. concepts</h3> <h4 id="11-怎么理解原子性">1.1 怎么理解原子性</h4> <p>在编程领域，原子性指操作不可再分割，类似原子在日常理解中不可分割（虽从科学角度原子可细分）。以常见的 <code class="language-plaintext highlighter-rouge">i++</code> 为例，它并非原子操作，实际包含三个步骤：读 <code class="language-plaintext highlighter-rouge">i</code> 值、<code class="language-plaintext highlighter-rouge">i</code> 值加 1、写回 <code class="language-plaintext highlighter-rouge">i</code> 值 。这是因为数据存储在内存等设备，而计算在 CPU 中进行，即使简单计算也需数据在内存与 CPU 间传输。</p> <p>不仅 <code class="language-plaintext highlighter-rouge">i++</code> 整体不是原子操作，“读 <code class="language-plaintext highlighter-rouge">i</code> 值” 本身也可能并非原子。比如当 <code class="language-plaintext highlighter-rouge">i</code> 值跨越多个缓存行时，CPU 读取操作可能分步进行，如从某地址读取长度为 3 行的数据，内存逐行返回。在此期间，若数据跨多行，读取第一行时第二行可能被其他操作改动。如果不好理解，不妨以一个复杂结构体为例子。如 <code class="language-plaintext highlighter-rouge">struct Foo { int a1;... int a1000; }</code>，当一个线程读取该结构体，还未读完所有成员（如 <code class="language-plaintext highlighter-rouge">a1000</code>）时，<code class="language-plaintext highlighter-rouge">a1000</code> 可能已被其他线程改动，导致读取到理论上不应存在的 “新旧混合” 数据。不过，多数计算机架构能保证像 <code class="language-plaintext highlighter-rouge">int</code> 这类简单数据的读取具有原子性，但这并非理所当然，不能想当然认为读操作一定就是原子的。</p> <p>总之，代码中的一行指令，在计算机内部可能对应若干机器指令及众多晶体管操作。若这些指令、这些操作不可被打断、分割，不会受其他操作干扰破坏，就是原子性的。</p> <h4 id="12-如何保证atomic的原子性是否有锁">1.2 如何保证<code class="language-plaintext highlighter-rouge">atomic</code>的原子性？是否有锁？</h4> <p>如今的处理器大多支持原子指令，像在 x86 架构中，会使用 <code class="language-plaintext highlighter-rouge">LOCK</code> 前缀，其他平台也有各自特定的原子操作指令。这些指令通过锁住总线或缓存行，确保在当前线程的相关指令执行完毕前，其他线程无法对被锁定的数据进行操作，从而实现阻塞。</p> <p>若硬件不支持原子指令，就需借助更为复杂的软件层面方法来实现原子操作，这里暂不深入探讨。</p> <p><code class="language-plaintext highlighter-rouge">std::atomic</code> 内部存在优化机制。对于简单数据类型，它能够借助原子指令，以非 <code class="language-plaintext highlighter-rouge">mutex</code>（互斥锁）的方式达成原子性；但对于复杂数据类型，可能就需要用到锁。</p> <p>部分数据类型的读操作，在 C++ 代码中看似一行，对应到指令操作其实也是一行，这种情况下无需锁住总线就能实现原子性；然而，部分数据类型的读操作，C++ 代码虽为一行，对应指令操作却可能多达几十行。为保证原子性，首条指令或许就是请求锁住总线，最后一条指令则是解除总线锁定。</p> <p>通常，原子指令大多较为简单，本身就是单一的不可打断操作；而有锁操作往往需要通过锁住总线来实现。</p> <h4 id="13-为何atomic禁止拷贝与复制">1.3 为何<code class="language-plaintext highlighter-rouge">atomic</code>禁止拷贝与复制</h4> <p>由于<code class="language-plaintext highlighter-rouge">std</code>库具有跨平台特性，并非每个平台都具备完善的原子操作指令。例如，对于“读取某一地址起始、长度为 3 行的数据”这一操作，部分平台可提供原子操作支持，而有些则无法做到。在缺乏良好原子操作指令的平台上，<code class="language-plaintext highlighter-rouge">std::atomic</code>的原子性需借助锁来保障。这意味着<code class="language-plaintext highlighter-rouge">std::atomic&lt;T&gt;</code>内部可能存在一个<code class="language-plaintext highlighter-rouge">mutex</code>（互斥锁）变量，而<code class="language-plaintext highlighter-rouge">mutex</code>本身是不可拷贝的，所以<code class="language-plaintext highlighter-rouge">std::atomic&lt;T&gt;</code>也不可拷贝。</p> <p>那么，为什么<code class="language-plaintext highlighter-rouge">mutex</code>不可拷贝呢？从语义层面看，锁支持拷贝这一说法本身就略显怪异，但仅以此作为不支持拷贝的理由并不充分。我们不妨通过反证法来深入思考：假设锁是可拷贝的，那么应采用浅拷贝还是深拷贝呢？深浅拷贝的概念通常针对对象内部存在指针或引用类型的数据，而原子对象并非此类，所以这里只考虑普通拷贝。若进行拷贝，其目的是什么呢？难道是创建一把新锁去锁定同一个对象？需注意，“锁定对象”只是一种抽象理解，实际上锁的作用是确保某段代码区间同一时间仅有一个线程能够执行。那是否就重复保护了？保护谁了？无论怎样设想，若<code class="language-plaintext highlighter-rouge">mutex</code>拷贝出一把新锁，其保护内容都会变得难以界定，逻辑混乱。那能否让新拷贝的锁不保护任何内容，仅作为一把新创建的锁呢？如此一来，这实际上就是构造一把新锁，而非拷贝的概念了。</p> <p>事实上，当希望对一个<code class="language-plaintext highlighter-rouge">atomic</code>对象拷贝的时候，其实也只是取其值，而非整个原子对象。如果拷贝出来的值，仍希望是原子的，则再通过这个值构造一个新的原子对象就好了，而非拷贝。</p> <h4 id="14-atomic-类型能有什么成员函数怎么用">1.4 atomic 类型能有什么成员函数？怎么用？</h4> <table> <thead> <tr> <th>操作</th> <th>对应函数（接口）</th> <th>对应操作符</th> </tr> </thead> <tbody> <tr> <td><strong>读取</strong></td> <td><code class="language-plaintext highlighter-rouge">T load(memory_order order = memory_order_seq_cst) const noexcept;</code></td> <td>转换操作符：<code class="language-plaintext highlighter-rouge">operator T() noexcept;</code></td> </tr> <tr> <td><strong>存储</strong></td> <td><code class="language-plaintext highlighter-rouge">void store(T desired, memory_order order = memory_order_seq_cst) noexcept;</code></td> <td>赋值操作符：<code class="language-plaintext highlighter-rouge">operator=(T desired) noexcept;</code></td> </tr> <tr> <td><strong>加法/自增</strong></td> <td><code class="language-plaintext highlighter-rouge">T fetch_add(T arg, memory_order order = memory_order_seq_cst) noexcept;</code></td> <td><code class="language-plaintext highlighter-rouge">operator+=(T arg) noexcept;</code><br/>后置自增 <code class="language-plaintext highlighter-rouge">operator++(int)</code></td> </tr> <tr> <td><strong>减法/自减</strong></td> <td><code class="language-plaintext highlighter-rouge">T fetch_sub(T arg, memory_order order = memory_order_seq_cst) noexcept;</code></td> <td><code class="language-plaintext highlighter-rouge">operator-=(T arg) noexcept;</code><br/>后置自减 <code class="language-plaintext highlighter-rouge">operator--(int)</code></td> </tr> <tr> <td><strong>按位与</strong></td> <td><code class="language-plaintext highlighter-rouge">T fetch_and(T arg, memory_order order = memory_order_seq_cst) noexcept;</code></td> <td><code class="language-plaintext highlighter-rouge">operator&amp;=(T arg) noexcept;</code></td> </tr> <tr> <td><strong>按位或</strong></td> <td><code class="language-plaintext highlighter-rouge">T fetch_or(T arg, memory_order order = memory_order_seq_cst) noexcept;</code></td> <td><code class="language-plaintext highlighter-rouge">operator\|=(T arg) noexcept;</code></td> </tr> <tr> <td><strong>按位异或</strong></td> <td><code class="language-plaintext highlighter-rouge">T fetch_xor(T arg, memory_order order = memory_order_seq_cst) noexcept;</code></td> <td><code class="language-plaintext highlighter-rouge">operator^=(T arg) noexcept;</code></td> </tr> <tr> <td><strong>交换</strong></td> <td><code class="language-plaintext highlighter-rouge">T exchange(T desired, memory_order order = memory_order_seq_cst) noexcept;</code></td> <td>——（无对应操作符）</td> </tr> <tr> <td><strong>比较交换（弱）</strong></td> <td><code class="language-plaintext highlighter-rouge">bool compare_exchange_weak(T&amp; expected, T desired, memory_order success, memory_order failure) noexcept;</code></td> <td>——（无对应操作符）</td> </tr> <tr> <td><strong>比较交换（强）</strong></td> <td><code class="language-plaintext highlighter-rouge">bool compare_exchange_strong(T&amp; expected, T desired, memory_order success, memory_order failure) noexcept;</code></td> <td>——（无对应操作符）</td> </tr> </tbody> </table> <ul> <li><strong>为什么同时提供函数接口，和操作符接口？</strong> 操作符（如赋值和类型转换）默认使用严格的内存序<code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code>），而函数版本允许开发者根据具体场景指定其他内存序（例如 relaxed、acquire/release），以便进行更细粒度的性能调优。</li> </ul> <h4 id="15-自定义的-atomic-有什么限制">1.5 自定义的 atomic 有什么限制？</h4> <ul> <li> <p><strong>基础要求</strong> 要让自定义类型<code class="language-plaintext highlighter-rouge">T</code>能使用<code class="language-plaintext highlighter-rouge">std::atomic&lt;T&gt;</code>，该类型必须满足<strong>Trivially Copyable</strong>条件，具体包含以下几点： 1. <strong>拷贝语义方面</strong>：得有平凡的拷贝构造函数与赋值运算符。这意味着不能有用户自定义的拷贝或移动操作。 2. <strong>析构函数方面</strong>：析构函数必须是平凡的，不能包含任何自定义操作。 3. <strong>基类与成员方面</strong>：所有基类和非静态数据成员也都要是 Trivially Copyable 类型。</p> </li> <li> <p><strong>尺寸与对齐限制</strong></p> <ul> <li><strong>尺寸方面</strong>：通常情况下，类型<code class="language-plaintext highlighter-rouge">T</code>的大小得小于或等于<code class="language-plaintext highlighter-rouge">std::atomic&lt;T&gt;::is_always_lock_free</code>所规定的最大尺寸（一般是 8 字节）。</li> <li><strong>对齐方面</strong>：类型<code class="language-plaintext highlighter-rouge">T</code>的对齐要求要和<code class="language-plaintext highlighter-rouge">alignof(std::atomic&lt;T&gt;)</code>保持一致，不然就需要使用<code class="language-plaintext highlighter-rouge">alignas</code>来进行显式对齐。</li> </ul> </li> </ul> <h3 id="2-内存序">2. 内存序</h3> <h4 id="21-什么是指令乱序">2.1 什么是指令乱序？</h4> <p>内存序本质上用于限制编译器以及 CPU 对指令执行顺序的重排程度。对指令执行顺序进行重排，本质上是为了提升单核性能。现代 CPU 采用诸如冒险预测以及超标量流水线等技术，导致指令乱序执行，使得代码操作不一定按照编写顺序依次发生。至于 CPU 指令乱序如何提升性能的具体原因，将在 “计算机组成 - CPU 章节” 中进一步探讨，此处暂不展开。</p> <p>在单线程场景下，C++作为编译型语言，能够充分利用程序上下文信息生成正确代码。例如<code class="language-plaintext highlighter-rouge">int a = 0; a = a + 1;</code>，编译器基于完整代码，必定能保证先定义后操作的顺序。而对于<code class="language-plaintext highlighter-rouge">a = a + 1; b = true;</code>这类情况，编译器无法确定<code class="language-plaintext highlighter-rouge">a</code>与<code class="language-plaintext highlighter-rouge">b</code>的计算先后顺序，但在单线程环境中，这种不确定性并无影响。</p> <p>然而，在多线程场景下，指令顺序变得至关重要。例如，一个线程执行<code class="language-plaintext highlighter-rouge">a = a + 1; b = true;</code>，另一个线程执行<code class="language-plaintext highlighter-rouge">while(!b){}; print(a);</code>，即等待<code class="language-plaintext highlighter-rouge">b</code>为真时输出<code class="language-plaintext highlighter-rouge">a</code>的值。此时，<code class="language-plaintext highlighter-rouge">a</code>和<code class="language-plaintext highlighter-rouge">b</code>的计算顺序将直接影响第二个线程的执行结果。为解决多线程环境下的指令乱序问题，主要有以下两种思路：</p> <ul> <li><strong>上锁机制</strong>：对执行<code class="language-plaintext highlighter-rouge">a = a + 1; b = true;</code>的代码块以及<code class="language-plaintext highlighter-rouge">while(!b){}; print(a);</code>的代码块分别上锁，确保这两个操作不能同时进行，然后通过<code class="language-plaintext highlighter-rouge">std::condition_variable</code>来协调执行先后顺序，从而避免问题。</li> <li><strong>限制乱序行为</strong>：允许两个操作同时进行，但保证特定的执行顺序，如确保先执行<code class="language-plaintext highlighter-rouge">a = a + 1;</code>，再执行<code class="language-plaintext highlighter-rouge">b = true</code>，以此保证程序正确性。</li> </ul> <p>对于第一种思路，此处不再赘述。而限制乱序行为主要通过两种方式实现：</p> <ul> <li><strong>内存屏障</strong>：以<code class="language-plaintext highlighter-rouge">AB|CD</code>为例，内存屏障可保证<code class="language-plaintext highlighter-rouge">AB</code>操作在<code class="language-plaintext highlighter-rouge">CD</code>之前执行，但不保证<code class="language-plaintext highlighter-rouge">AB</code>内部以及<code class="language-plaintext highlighter-rouge">CD</code>内部的执行顺序。</li> <li><strong>内存序</strong>：通过指定某个指令必须在特定操作之前或之后执行来保证顺序。例如在上述例子中，通过指定内存序，使得<code class="language-plaintext highlighter-rouge">b = true</code>这一写操作，在<code class="language-plaintext highlighter-rouge">a = a + 1</code>之后执行，具体来说是保证<code class="language-plaintext highlighter-rouge">b</code>的赋值操作是作用域内（<code class="language-plaintext highlighter-rouge">{}</code>或者函数内）最后一条写操作，这样就能保证多线程环境下的执行顺序正确。</li> </ul> <p>需要注意的是，内存序主要用于指定操作的顺序，改变指令的乱序行为，且这一操作与原子性并无直接关联。在单线程环境下，由于不存在数据共享问题，无需指定内存序，编译器会在保证安全的前提下尽力进行指令乱序优化。而在多线程环境中，对于共享的非原子类型的数据，一般通过锁机制来保证数据安全。只有对于共享数据的原子类型数据，才需要借助内存序来确保数据访问顺序的正确性。</p> <p>因此也就原子类型数据提供指定内存序的行为。</p> <h4 id="22-谁会对指令重排">2.2 谁会对指令重排？</h4> <ol> <li><strong>编译器重排</strong>：</li> </ol> <p>编译器为优化程序性能，在生成机器代码时可能调整指令顺序。例如，对于如下 C++代码：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</code></pre></div></div> <p>如果编译器分析发现<code class="language-plaintext highlighter-rouge">a = 5</code>和<code class="language-plaintext highlighter-rouge">b = 3</code>这两条指令不存在数据依赖关系，为提高执行效率，可能会交换它们的顺序。或者，对于条件语句中的指令，若符合优化条件，编译器可能将某条指令移至条件分支外部。编译器重排通常是安全的，因为它会保证在单线程环境中，重排后的程序行为与原程序一致。这是编译器基于对代码整体逻辑和性能优化的考量，在不改变单线程语义的前提下，对指令顺序进行的调整，以期望提升程序在目标机器上的执行效率。</p> <ol> <li><strong>CPU 重排</strong>：</li> </ol> <p>现代 CPU 为进一步提高执行效率，在执行指令时也可能改变指令顺序。例如，假设存在一条指令需要从内存中读取数据，但由于内存访问延迟，该指令暂时无法执行。此时，CPU 可能会先执行后续不依赖该数据的指令。从汇编层面看，若有指令序列<code class="language-plaintext highlighter-rouge">LOAD A, [mem]</code>（从内存地址<code class="language-plaintext highlighter-rouge">mem</code>加载数据到寄存器<code class="language-plaintext highlighter-rouge">A</code>）、<code class="language-plaintext highlighter-rouge">ADD B, A</code>（将寄存器<code class="language-plaintext highlighter-rouge">A</code>与<code class="language-plaintext highlighter-rouge">B</code>相加）、<code class="language-plaintext highlighter-rouge">SUB C, D</code>（寄存器<code class="language-plaintext highlighter-rouge">C</code>减去<code class="language-plaintext highlighter-rouge">D</code>），当<code class="language-plaintext highlighter-rouge">LOAD A, [mem]</code>因内存延迟等待时，CPU 可能会先执行<code class="language-plaintext highlighter-rouge">SUB C, D</code>。CPU 还可能通过并行执行多个指令来提升整体处理速度。与编译器重排类似，这种在 CPU 层面的重排一般也是安全的，因为 CPU 会确保在单核环境下，重排后的程序执行结果与原程序保持一致。CPU 重排是利用硬件特性，在不影响单核执行逻辑正确性的基础上，对指令执行顺序进行动态调整，从而充分发挥硬件资源的效能。</p> <p>需要注意的是，在多线程环境下，无论是编译器重排还是 CPU 重排，都可能引发数据竞争和同步问题，导致程序出现非预期的行为。这是因为不同线程对共享数据的访问顺序可能因重排而改变，从而破坏程序的正确性。</p> <h4 id="23-使用stdmutex时可能的乱序行为">2.3 使用<code class="language-plaintext highlighter-rouge">std::mutex</code>时可能的乱序行为</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">ready</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
        <span class="n">data</span><span class="o">++</span><span class="p">;</span>
        <span class="n">ready</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">[]{</span> <span class="k">return</span> <span class="n">ready</span><span class="p">;</span> <span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Data: "</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">producer</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">consumer</span><span class="p">);</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上面这个是使用<code class="language-plaintext highlighter-rouge">std::mutex</code>的例子，我会从这个例子出发，进而对比使用原子变量控制内存序时，两者的区别是什么。</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lock(): 如果互斥锁可用，则锁定；否则，让出 CPU。
wait(ready): 如果 ready 条件满足，则继续执行；否则，让出 CPU。
unlock(): 解锁互斥锁。
notify(cv): 通知。
wait(cv, ready): 如果条件变量 cv 满足，则执行。
reg: 寄存器

| mutex_producer |
| -------------- |
| lock()         |
| move reg data  |
| add reg 1      |
| move data reg  |
| move ready true|
| unlock()       |
| notify(cv)     |
| ...            |

| mutex_consumer |
| -------------- |
| wait(cv, ready)|
| print data     |
| unlock()       |
| ...            |
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">mutex_producer</code>在调用<code class="language-plaintext highlighter-rouge">lock()</code>后，在这之内的所有数据，如<code class="language-plaintext highlighter-rouge">data</code>和<code class="language-plaintext highlighter-rouge">ready</code>的数据总线都被锁住了，其他地方无法访问这些数据，如果其他核同时持有这些数据，则会通过<code class="language-plaintext highlighter-rouge">MESI</code>协议将数据状态置为失效，然后需要重新从其他缓存或者内存同步。因此，内存上的这个数据被锁住了，其他核心上的这个数据失效了，这个时候这个数据就是被独占的。</p> <p>而我们总能相信单线程的指令乱序不会导致单线程内部逻辑出错，也就是说<code class="language-plaintext highlighter-rouge">mutex_producer</code>和<code class="language-plaintext highlighter-rouge">mutex_consumer</code>内部的乱序是无所谓的，内部的依赖关系都能被正确处理。而锁又保证了<code class="language-plaintext highlighter-rouge">mutex_consumer</code>总能在<code class="language-plaintext highlighter-rouge">mutex_producer</code>之后执行，因此是没问题的。</p> <ul> <li><strong>小问题：如果<code class="language-plaintext highlighter-rouge">unlock()</code>排在了<code class="language-plaintext highlighter-rouge">notify(cv)</code>之前会怎么样？</strong> <code class="language-plaintext highlighter-rouge">unlock()</code>和<code class="language-plaintext highlighter-rouge">notify(cv)</code>这种多线程才存在的依赖关系，在单个核心的乱序行为会被控制吗？一句话回答，不会，这两个哪个在前，哪个在后都可以。因此原问题等价于下面两种实现，哪个才是正确的。</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
        <span class="n">data</span><span class="o">++</span><span class="p">;</span>
        <span class="n">ready</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">producer2</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
        <span class="n">data</span><span class="o">++</span><span class="p">;</span>
        <span class="n">ready</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>一句话回答，表现都正确，即都是线程安全。但是前者效率更好一些。我这里也首先表明一下，这里面潜藏的隐患是什么：如果生产者<code class="language-plaintext highlighter-rouge">notify</code>了，但是还没有让出锁；消费者被唤醒，但是却拿不到锁，这会不会有问题？会不会随后让出<code class="language-plaintext highlighter-rouge">cpu</code>，然后这个数据就一直没消费了？</p> <p>不会。在 C++ 的条件变量机制中，线程被唤醒后（无论是虚假唤醒，还是调用<code class="language-plaintext highlighter-rouge">notify</code>）必须先获取锁，才能检查条件。这一顺序由 <code class="language-plaintext highlighter-rouge">std::wait()</code> 的底层实现强制保证，确保线程安全。如果被唤醒，锁被占用了，则进入 <code class="language-plaintext highlighter-rouge">Ready</code> 队列等待锁，持续竞争 CPU，不主动让出资源；拿到锁之后，如果条件不满足，就会让出锁和 cpu 资源，重新回到<code class="language-plaintext highlighter-rouge">Block</code>状态。即这次 notify 不会被消费。</p> <h4 id="24-使用原子变量下时可能的乱序行为">2.4 使用原子变量下时可能的乱序行为</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">ready</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">producer</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">data</span><span class="o">++</span><span class="p">;</span>
    <span class="c1">// 此操作逻辑上等同于 ready = true，为写操作</span>
    <span class="n">ready</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">consumer</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 此操作逻辑上等同于检查 ready，为读操作</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ready</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// 等待 ready 变为 true</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Data: "</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">producer</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">consumer</span><span class="p">);</span>
    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>上述代码对应的伪汇编代码：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wait(): 如果 ready 条件满足，则继续执行；否则，让出 CPU。

| atomic:producer | atomic:producer |
| --------------- | --------------- |
| move reg data   | ready           |
| add reg 1       | ...             |
| move data reg   | move reg data   |
| ...             | add reg 1       |
| ready           | move data reg   |
| ...             | ...             |
| ...             | ...             |

| atomic:consumer |
| --------------- |
| wait(ready)     |
| print data      |
| ...             |
| ...             |
</code></pre></div></div> <p>从理论上来说，如果生产者完成生产任务并将标志位 <code class="language-plaintext highlighter-rouge">ready</code> 设置为 <code class="language-plaintext highlighter-rouge">true</code>，消费者便会开始消费，此时期望获取到的产品 <code class="language-plaintext highlighter-rouge">data</code> 值为 <code class="language-plaintext highlighter-rouge">1</code>。如果选择了严格的内存序，那<code class="language-plaintext highlighter-rouge">std::memory_order_sql_cst</code>就都没有问题，但上面代码是<code class="language-plaintext highlighter-rouge">std::memory_order_relaxed</code>，这个内存序并不能保证<code class="language-plaintext highlighter-rouge">ready</code>是最后一个内存写操作。因此由于指令执行顺序的不确定性，<code class="language-plaintext highlighter-rouge">data</code> 的输出值既可能是我们期望的 <code class="language-plaintext highlighter-rouge">1</code>，也有可能是初始值 <code class="language-plaintext highlighter-rouge">0</code>。</p> <p>使用 <code class="language-plaintext highlighter-rouge">atomic</code>（原子操作）作为同步手段时，情况则有所不同。消费者虽然要等到 <code class="language-plaintext highlighter-rouge">ready</code> 为 <code class="language-plaintext highlighter-rouge">true</code> 才会输出 <code class="language-plaintext highlighter-rouge">data</code>，但由于指令重排的存在，<code class="language-plaintext highlighter-rouge">ready</code> 的设置操作有可能在 <code class="language-plaintext highlighter-rouge">data</code> 修改数值之前执行，也有可能在之后执行。这就导致在 <code class="language-plaintext highlighter-rouge">atomic</code> 模式下，消费者获取到的 <code class="language-plaintext highlighter-rouge">data</code> 值无法得到有效保证。究其本质，当我们使用 <code class="language-plaintext highlighter-rouge">atomic</code> 进行同步时，以 <code class="language-plaintext highlighter-rouge">atomic</code> 相关的原子操作为核心，其前后的代码操作并不一定具备原子性，这就可能引发非预期的行为。</p> <h4 id="25-内存序有哪些">2.5 内存序有哪些？</h4> <ol> <li> <p><strong><code class="language-plaintext highlighter-rouge">memory_order_relaxed</code>（宽松内存序）</strong>：</p> <ul> <li>此内存序仅确保原子操作自身具备原子性，不提供任何关于同步或顺序方面的保证。这意味着在多线程环境下，该原子操作与其他线程中的操作之间不存在特定的顺序关系。</li> <li>这种内存序适用于类似计数器这样的场景，在这些场景中，并不需要进行跨线程的同步操作，仅关注对计数器值的原子更新。例如，在单线程环境下对某个计数器进行频繁自增操作，使用 <code class="language-plaintext highlighter-rouge">memory_order_relaxed</code> 既能保证自增操作的原子性，又能获得较好的性能，因为无需额外的同步开销。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">memory_order_consume</code>（消费内存序）</strong>：</p> <ul> <li>该内存序保证当前线程中，依赖于该原子变量的后续操作不会被重排到该原子操作之前。与 <code class="language-plaintext highlighter-rouge">memory_order_acquire</code> 相比，<code class="language-plaintext highlighter-rouge">memory_order_consume</code> 的限制更窄，它仅对那些实际依赖于该原子变量值的操作起作用，而 <code class="language-plaintext highlighter-rouge">memory_order_acquire</code> 则保证所有后续操作不会被重排到该原子操作之前。</li> <li>例如，当一个线程读取一个原子变量，并且后续操作是基于这个读取的值进行的（如根据读取的标志位决定是否执行某个函数），使用 <code class="language-plaintext highlighter-rouge">memory_order_consume</code> 可以确保这些依赖操作不会被提前到读取操作之前执行。不过，使用 <code class="language-plaintext highlighter-rouge">memory_order_consume</code> 需要更谨慎，因为它要求对依赖关系有清晰的界定，否则可能导致难以察觉的错误。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">memory_order_acquire</code>（获取内存序）与 <code class="language-plaintext highlighter-rouge">memory_order_release</code>（释放内存序）</strong>：</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">memory_order_acquire</code></strong>：在当前线程中，此内存序保证所有后续的内存操作不会被重排到该获取操作之前。也就是说，一旦执行了带有 <code class="language-plaintext highlighter-rouge">memory_order_acquire</code> 的原子操作，后续对内存的访问（读或写）在执行顺序上会遵循该原子操作之后的顺序，不会提前到该原子操作之前执行。</li> <li><strong><code class="language-plaintext highlighter-rouge">memory_order_release</code></strong>：与之相对，在当前线程内，<code class="language-plaintext highlighter-rouge">memory_order_release</code> 确保所有之前的内存操作不会被重排到该释放操作之后。即一旦执行了带有 <code class="language-plaintext highlighter-rouge">memory_order_release</code> 的原子操作，之前对内存的访问（读或写）在执行顺序上会保持在该原子操作之前，不会推迟到该原子操作之后执行。</li> <li>这两种内存序常用于锁的获取与释放场景。例如，当一个线程获取锁（类似 <code class="language-plaintext highlighter-rouge">memory_order_acquire</code> 的语义）后，能确保后续对共享资源的访问是在获取锁之后进行的；而当一个线程释放锁（类似 <code class="language-plaintext highlighter-rouge">memory_order_release</code> 的语义）前，能保证对共享资源的修改都已完成，不会被重排到释放锁之后，从而确保其他获取锁的线程能看到正确的共享资源状态。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">memory_order_acq_rel</code>（获取 - 释放内存序）</strong>：</p> <ul> <li>这种内存序同时具备 <code class="language-plaintext highlighter-rouge">memory_order_acquire</code> 和 <code class="language-plaintext highlighter-rouge">memory_order_release</code> 的语义。也就是说，对于执行此内存序的原子操作，在当前线程中，既保证后续的内存操作不会被重排到此操作之前，又保证之前的内存操作不会被重排到此操作之后。</li> <li>它适用于读 - 修改 - 写这类操作场景。例如，在多线程环境下对共享变量进行先读取值，然后根据读取的值进行修改，最后再写回的操作，使用 <code class="language-plaintext highlighter-rouge">memory_order_acq_rel</code> 能确保该操作在内存访问顺序上的正确性，同时兼顾获取和释放内存序的语义要求。</li> </ul> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code>（顺序一致性内存序）</strong>：</p> <ul> <li>该内存序提供了全局的顺序一致性保证，即所有线程看到的内存操作顺序都是一致的。这是一种非常严格的内存序，它确保了所有线程对内存的访问都按照一个全局统一的顺序进行，就好像所有线程的操作都是顺序执行的一样。</li> <li>然而，由于这种严格的顺序保证需要额外的同步开销，所以 <code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code> 通常是最强的内存序，但也可能对程序性能产生一定影响。在对性能要求极高且对操作顺序一致性要求不那么严格的场景下，可能需要权衡是否使用该内存序。</li> </ul> </li> </ol> <ul> <li> <p><strong>不同操作支持什么内存序？</strong></p> <ol> <li> <p><strong>Store 操作（存储操作，即写操作）</strong>：</p> <ul> <li><code class="language-plaintext highlighter-rouge">memory_order_relaxed</code></li> <li><code class="language-plaintext highlighter-rouge">memory_order_release</code></li> <li><code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code></li> </ul> </li> <li> <p><strong>Load 操作（加载操作，即读操作）</strong>：</p> <ul> <li><code class="language-plaintext highlighter-rouge">memory_order_relaxed</code></li> <li><code class="language-plaintext highlighter-rouge">memory_order_consume</code></li> <li><code class="language-plaintext highlighter-rouge">memory_order_acquire</code></li> <li><code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code></li> </ul> </li> <li> <p><strong>Read - modify - write（读 - 改 - 写）操作</strong>：</p> <ul> <li><code class="language-plaintext highlighter-rouge">memory_order_relaxed</code></li> <li><code class="language-plaintext highlighter-rouge">memory_order_consume</code></li> <li><code class="language-plaintext highlighter-rouge">memory_order_acquire</code></li> <li><code class="language-plaintext highlighter-rouge">memory_order_release</code></li> <li><code class="language-plaintext highlighter-rouge">memory_order_acq_rel</code></li> <li><code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code></li> </ul> </li> </ol> <p>所有操作的默认内存序为 <code class="language-plaintext highlighter-rouge">memory_order_seq_cst</code>。这意味着在未显式指定内存序时，编译器会按照最严格的顺序一致性内存序来处理原子操作，以确保程序在多线程环境下的正确性，但可能会牺牲一定的性能。在实际编程中，开发者可根据具体需求，在保证程序正确性的前提下，选择更合适的内存序来优化性能。</p> </li> </ul> <h4 id="26-内存序如何实现的">2.6 内存序如何实现的？</h4> <ol> <li><strong>编译器层面</strong> <ul> <li>编译器在实现内存序时，会借助插入特定的内存屏障指令来对指令重排进行限制。例如常见的 <code class="language-plaintext highlighter-rouge">mfence</code>（全内存屏障指令），它能确保在该指令之前的所有内存访问操作都已完成，才会执行后续的内存访问操作，有效地防止了指令跨越该屏障进行重排；<code class="language-plaintext highlighter-rouge">sfence</code>（存储内存屏障指令）则主要针对存储（写）操作，保证在它之前的所有存储操作都对内存可见后，才允许后续的存储操作执行，从而在编译器生成代码阶段，保障了内存操作顺序符合内存序的要求。通过这些内存屏障指令的合理插入，编译器能够在优化代码性能的同时，满足不同内存序所规定的操作顺序限制。<strong>总结：编译器通过插入如 <code class="language-plaintext highlighter-rouge">mfence</code> 和 <code class="language-plaintext highlighter-rouge">sfence</code> 等内存屏障指令，实现对指令重排的限制，保障内存操作顺序。</strong></li> </ul> </li> <li><strong>CPU 层面</strong> <ul> <li>CPU 利用缓存一致性协议来保障跨核心的内存操作顺序。以 MESI 协议为例，MESI 是一种广泛应用于多核 CPU 缓存系统的协议，它定义了缓存行（Cache Line）的四种状态：Modified（已修改）、Exclusive（独占）、Shared（共享）和 Invalid（无效）。当一个 CPU 核心对内存中的数据进行读写操作时，MESI 协议会协调各个核心之间缓存的状态变化。比如，当一个核心修改了共享数据，该数据所在的缓存行状态会变为 Modified，同时其他核心中对应的缓存行状态变为 Invalid，这样就保证了其他核心在下次访问该数据时，能从主存或者拥有最新数据的核心缓存中获取到正确的值，从而确保了跨核心的内存操作顺序和数据一致性。<strong>总结：CPU 通过缓存一致性协议（如 MESI 协议），协调各核心缓存状态变化，确保跨核心内存操作顺序与数据一致性。</strong></li> </ul> </li> <li><strong>硬件层面</strong> <ul> <li>不同的硬件架构，像 x86 和 ARM，在对内存序的支持上存在差异。x86 架构通常对内存序有较强的默认保证，很多情况下无需额外的内存屏障指令就能满足较严格的内存序要求；而 ARM 架构则相对灵活，开发者可能需要更精细地控制内存序。为了让开发者能在不同硬件平台上以统一的方式编写代码，C++ 标准库通过抽象机制将这些硬件层面的差异进行了屏蔽。开发者在使用 C++ 的原子操作和内存序相关功能时，无需关心底层具体的硬件架构细节，只需要依据 C++ 标准库提供的接口和规则来确保程序的内存操作顺序符合需求，提高了代码的可移植性和通用性。<strong>总结：不同硬件架构对内存序支持有别，C++ 标准库通过抽象屏蔽差异，提升代码可移植性与通用性。</strong></li> </ul> </li> </ol> <h4 id="27-六种内存序怎么用">2.7 六种内存序怎么用？</h4> <p>todo: 我前面展开内存序的时候更多是从理解和原理出发，并没有太结合实际说明什么场景下使用什么内存序。这一小段会补充说明。</p> <h4 id="28-什么是先行发生什么是并行发生">2.8 什么是先行发生，什么是并行发生？</h4> <p>todo：这个概念也是配合具体设置内存序的。之后补充。</p> <h3 id="3-原子幻觉">3. 原子幻觉</h3> <h4 id="31-什么是原子幻觉">3.1 什么是原子幻觉？</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;climits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MinMaxTracker</span> <span class="p">{</span>
  <span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">min_</span><span class="p">{</span><span class="n">INT_MAX</span><span class="p">};</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">min_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">min_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">get_min</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">min_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">worker</span><span class="p">(</span><span class="n">MinMaxTracker</span><span class="o">&amp;</span> <span class="n">tracker</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tracker</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">id</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MinMaxTracker</span> <span class="n">tracker</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">tracker</span><span class="p">),</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">t</span> <span class="o">:</span> <span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Min value: "</span> <span class="o">&lt;&lt;</span> <span class="n">tracker</span><span class="p">.</span><span class="n">get_min</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>这段代码旨在找出最小值，然而，它存在问题。那么，问题出在哪里呢？其实，这属于典型的原子幻觉问题。</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">min_</span><span class="p">.</span><span class="n">load</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">min_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div> <p>在多线程环境下，当<code class="language-plaintext highlighter-rouge">value &lt; min_.load()</code>这个条件为真时，由于其他线程也可能同时在执行<code class="language-plaintext highlighter-rouge">update</code>函数，竞争对<code class="language-plaintext highlighter-rouge">min_</code>的操作，在执行到下一行<code class="language-plaintext highlighter-rouge">min_.store(value)</code>之前，<code class="language-plaintext highlighter-rouge">min_</code>的值极有可能已被其他线程改变。此时，再用<code class="language-plaintext highlighter-rouge">value</code>去覆盖<code class="language-plaintext highlighter-rouge">min_</code>的值就可能导致错误结果。原子操作保证的是单个操作不可被打断，但多个原子操作组合起来的时候，就不再具有原子性。这种因疏忽而误以为组合的原子操作仍具备原子特性的错觉，就被称为原子幻觉。</p> <p>为避免这种原子幻觉带来的问题，可以使用互斥锁来保证<code class="language-plaintext highlighter-rouge">update</code>函数中操作的原子性。例如，在<code class="language-plaintext highlighter-rouge">MinMaxTracker</code>类中添加一个<code class="language-plaintext highlighter-rouge">std::mutex</code>成员变量，在<code class="language-plaintext highlighter-rouge">update</code>函数中先锁定互斥锁，完成比较和存储操作后再解锁。或者，也可以使用<code class="language-plaintext highlighter-rouge">std::atomic</code>提供的<code class="language-plaintext highlighter-rouge">compare_exchange_weak</code>或<code class="language-plaintext highlighter-rouge">compare_exchange_strong</code>方法，通过比较并交换操作，以原子方式完成整个更新过程，确保结果的正确性。</p> <h4 id="32-cas-技术">3.2 CAS 技术</h4> <p>针对上述的原子幻觉问题，可以用 CAS 解决（注意，CAS 是无锁编程的一种重要技巧，不一定和原子幻觉直接挂钩，这里只是通过原子幻觉问题，引入 CAS 技术。CAS 技术还可以用在其他无锁编程地方，比如说无锁的线程安全队列。）</p> <h5 id="321-什么是-cas">3.2.1 什么是 CAS？</h5> <p>通过前面的示例，我们已了解到具备原子性的变量可用于同步，发挥类似 <code class="language-plaintext highlighter-rouge">lock()/unlock()</code> 对的功能。而在实现无锁编程时，一种常见的借助原子变量达成此目的的技巧便是 CAS。</p> <p>CAS，即 Compare-And-Swap（比较并交换），是一项广泛应用的原子操作，常用于实现无锁编程。它依赖硬件支持的原子指令，以此保障多线程环境下的操作安全性。</p> <p>以下为一个简单的 CAS 操作示例代码：</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">CAS</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">expected</span><span class="p">,</span> <span class="kt">int</span> <span class="n">desired</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">addr</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">desired</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>在标准库中，上述 CAS 操作被封装成了以下两种形式：</p> <table> <thead> <tr> <th>操作</th> <th>对应函数（接口）</th> <th>对应操作符</th> </tr> </thead> <tbody> <tr> <td><strong>比较交换（弱）</strong></td> <td><code class="language-plaintext highlighter-rouge">bool compare_exchange_weak(T&amp; expected, T desired, memory_order success, memory_order failure) noexcept;</code></td> <td>——（无对应操作符）</td> </tr> <tr> <td><strong>比较交换（强）</strong></td> <td><code class="language-plaintext highlighter-rouge">bool compare_exchange_strong(T&amp; expected, T desired, memory_order success, memory_order failure) noexcept;</code></td> <td>——（无对应操作符）</td> </tr> </tbody> </table> <p><strong>参数类型分析</strong>： 在 <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code> 函数中，第一个参数 <code class="language-plaintext highlighter-rouge">expected</code> 采用引用类型，它实际上等价于前面自定义 <code class="language-plaintext highlighter-rouge">CAS(int* addr, int expect, int desired)</code> 函数中的 <code class="language-plaintext highlighter-rouge">expected</code> 参数，用于表示我们期望目标地址处的值。而 <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code> 函数中的 <code class="language-plaintext highlighter-rouge">desired</code> 参数同样对应自定义 <code class="language-plaintext highlighter-rouge">CAS</code> 函数中的 <code class="language-plaintext highlighter-rouge">desired</code> 参数，即我们想要替换成的新值。此外，<code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code> 函数后面的 <code class="language-plaintext highlighter-rouge">success</code> 和 <code class="language-plaintext highlighter-rouge">failure</code> 参数均为内存序相关参数，分别用于指定当比较交换操作成功和失败时所采用的内存序。</p> <p><strong>compare_exchange_weak()（弱版本）</strong>：</p> <ul> <li><strong>允许伪失败</strong>：此版本的一个重要特点是即使当前值与预期值相等，操作也有可能失败。这种失败并非由于数据本身的问题，而是源于硬件实现的一些限制。例如，在某些特定平台上，底层的 CAS 指令可能会偶尔出现失败情况。</li> <li><strong>适合循环使用</strong>：鉴于可能出现伪失败，在实际应用中，<code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code> 通常需要放在循环结构中反复尝试，直至操作成功。这样可以确保在遇到伪失败时，程序仍能继续尝试达成预期的比较交换操作。</li> <li><strong>性能更高</strong>：在某些硬件环境下，<code class="language-plaintext highlighter-rouge">compare_exchange_weak</code> 的实现相比 <code class="language-plaintext highlighter-rouge">compare_exchange_strong</code> 更为高效。这是因为其实现可能利用了硬件的特定特性，以牺牲一定的操作确定性来换取更好的性能表现。</li> <li>例如，对于 <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code> 函数，当目标变量的原始值与预期值一致时，存储操作仍有可能不成功。在这种情况下，变量的值不会发生改变，并且 <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code> 函数的返回值为 <code class="language-plaintext highlighter-rouge">false</code>。这种情况可能出现在缺少单条 CAS 操作（“比较 - 交换”指令）的机器上。当处理器无法保证该操作能够自动完成时，比如线程操作导致指令队列从中间关闭，且另一个线程安排的指令被操作系统替换（尤其在线程数多于处理器数量的情况下），就会出现这种所谓的“伪失败”（<em>spurious failure</em>）。其根本原因在于时间上的竞争条件，而非变量值本身的问题。</li> </ul> <p><strong>compare_exchange_strong()（强版本）</strong>： 与弱版本不同，<code class="language-plaintext highlighter-rouge">compare_exchange_strong()</code> 函数具有更强的确定性。只要实际值与期望值不相符，该函数就能保证返回 <code class="language-plaintext highlighter-rouge">false</code>，即不会出现伪失败的情况。这意味着在当前值等于预期值时，操作一定会成功完成比较交换。</p> <p><strong>使用建议</strong>： 综合来看，由于 <code class="language-plaintext highlighter-rouge">compare_exchange_weak()</code> 虽然可能出现伪失败，但在循环使用时能保证最终达成目标，且在某些硬件上具有性能优势，所以在很多场景下，使用 <code class="language-plaintext highlighter-rouge">compare_exchange_weak</code> 搭配循环是一种较为通用的做法。然而，具体的选择还需根据实际应用场景的需求和硬件环境等因素来综合考量。例如，在对操作确定性要求极高，性能要求相对较低的场景中，<code class="language-plaintext highlighter-rouge">compare_exchange_strong</code> 可能更为合适。</p> <h4 id="33-cas-解决原子幻觉">3.3 CAS 解决原子幻觉</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;atomic&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;climits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MinMaxTracker</span> <span class="p">{</span>
  <span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">min_</span><span class="p">{</span><span class="n">INT_MAX</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">max_</span><span class="p">{</span><span class="n">INT_MIN</span><span class="p">};</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">old_min</span> <span class="o">=</span> <span class="n">min_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">old_min</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">min_</span><span class="p">.</span><span class="n">compare_exchange_weak</span><span class="p">(</span><span class="n">old_min</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span> <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">get_min</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">min_</span><span class="p">.</span><span class="n">load</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">worker</span><span class="p">(</span><span class="n">MinMaxTracker</span><span class="o">&amp;</span> <span class="n">tracker</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tracker</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">id</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MinMaxTracker</span> <span class="n">tracker</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">threads</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">tracker</span><span class="p">),</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">t</span> <span class="o">:</span> <span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Min value: "</span> <span class="o">&lt;&lt;</span> <span class="n">tracker</span><span class="p">.</span><span class="n">get_min</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>原代码中的问题是将读取和写入操作分开，导致竞态条件。改进后的代码使用 CAS 循环，相当于将”读取-比较-写入”封装为原子操作：</p> <p>CAS 操作是原子性的，它执行以下逻辑：</p> <ol> <li><strong>比较</strong>：检查<code class="language-plaintext highlighter-rouge">min_</code>的当前值是否等于<code class="language-plaintext highlighter-rouge">old_min</code></li> <li><strong>交换</strong>： <ul> <li>如果相等，则将<code class="language-plaintext highlighter-rouge">min_</code>设置为<code class="language-plaintext highlighter-rouge">value</code>，返回<code class="language-plaintext highlighter-rouge">true</code></li> <li>如果不相等（说明其他线程已修改），则将<code class="language-plaintext highlighter-rouge">old_min</code>更新为当前值，返回<code class="language-plaintext highlighter-rouge">false</code></li> </ul> </li> <li><strong>循环重试</strong>：如果 CAS 失败（返回<code class="language-plaintext highlighter-rouge">false</code>），则重新读取最新值并重试，直到成功</li> </ol> <h4 id="34-cas-的-aba-问题">3.4 CAS 的 ABA 问题</h4> <p>todo: ABA 问题之后看情况再补充。</p> <p>在这个场景中，即使出现 ABA 问题（值从 A 变为 B 再变回 A）也不会影响正确性，因为我们只关心值本身，而不关心它的变化过程。但部分场景会在意这个问题。</p> <ul> <li><strong>CAS 的 ABA 问题</strong> <ul> <li>因为 CAS 需要在操作值的时候检查值有没有发生变化，如果没有发生变化则更新。但是一个值原来是 A，变成了 B，又变成了 A，那么使用 CAS 进行检查时会发现它的值没有发生变化，但实际上却变化了。</li> <li>CAS 只关注了比较前后的值是否改变，而无法清楚在此过程中变量的变更明细，这就是所谓的 ABA 问题。</li> <li><strong>解决思路</strong>： <ul> <li>使用版本号（如 MySQL 的 MVCC）。在变量前面追加版本号，每次变量更新的时候把版本号加一，那么 A-B-A 就变成了 1A-2B-3A，从而解决 ABA 问题。</li> </ul> </li> <li><strong>ABA 问题</strong> <ul> <li>CAS 需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是 A，变成了 B，又变成了 A，那么使用 CAS 进行检查时会发现它的值没有发生变化，但是实际上却变化了。这就是 CAS 的 ABA 问题</li> <li>常见的解决思路是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么<code class="language-plaintext highlighter-rouge">A-B-A</code> 就会变成<code class="language-plaintext highlighter-rouge">1A-2B-3A</code>，由于每个过程值都会有对应的版本，所以我们在修改过程中需要传入期望版本和当前的值，数据库的多版本并发控制也类似</li> <li>添加时间戳：添加世时间戳也可以解决。查询的时候把时间戳一起查出来，对的上才修改并且更新值的时候一起修改更新时间，这样也能保证，方法很多但是跟版本号都是异曲同工之妙</li> </ul> </li> <li>无限循环问题（自旋） <ul> <li>如果 CAS 不成功，则会原地自旋，如果长时间自旋会<strong>给 CPU 带来非常大且没必要的开销</strong></li> <li>可以使用 java8 中的 LongAdder，分段 CAS 和自动分段迁移</li> <li>自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率</li> </ul> </li> <li><strong>只能保证一个共享变量的原子操作</strong> <ul> <li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是<strong>把多个共享变量合并成一个共享变量来操作</strong>。比如有两个共享变量 i=2，j=a，合并一下 ij=2a，然后用 CAS 来操作</li> <li>可以用 AtomicReference (java)，这个是封装自定义对象的，多个变量可以放一个自定义对象里，然后他会检查这个对象的引用是不是同一个。如果多个线程同时对一个对象变量的引用进行赋值，用 AtomicReference 的 CAS 操作可以解决并发冲突问题</li> </ul> </li> </ul> </li> </ul> <h3 id="4-内存屏障">4. 内存屏障</h3> <p>todo: 内存屏障之后看情况再补充。</p> <p>内存屏障（也称为内存栅栏）是一种 CPU 指令，它确保屏障之前的所有操作完成后才执行屏障之后的操作。内存屏障可以防止编译器和处理器对指令重排序。</p> <ul> <li><strong>Load Barrier</strong>：加载屏障，确保所有在屏障前的读操作完成后，才执行屏障后的读操作。</li> <li><strong>Store Barrier</strong>：存储屏障，确保所有在屏障前的写操作完成后，才执行屏障后的写操作。</li> <li><strong>Full Barrier</strong>：全屏障，同时具有加载屏障和存储屏障的功能。</li> </ul> <p>内存屏障(Memory Barrier),也被称为内存栅栏,是一种同步原语,用于防止指令重排,确保特定的内存操作顺序.</p> <p>在多核处理器系统中,为了提高性能,处理器和编译器可能会对指令进行重排.这种重排可能会导致在多线程环境中出现问题,因为一个线程看到的内存操作顺序可能与另一个线程看到的顺序不一致.</p> <p>内存屏障可以防止这种情况的发生.它可以强制特定的内存操作顺序,例如:</p> <ul> <li>Load Barrier(加载屏障):保证在屏障之前的所有加载操作,都在屏障之后的加载操作之前完成.</li> <li>Store Barrier(存储屏障):保证在屏障之前的所有存储操作,都在屏障之后的存储操作之前完成.</li> <li>Full Barrier(全屏障):同时包含加载屏障和存储屏障,保证在屏障之前的所有内存操作,都在屏障之后的内存操作之前完成.</li> </ul> <p>在 C++中,你可以使用<code class="language-plaintext highlighter-rouge">std::atomic_thread_fence</code>函数来创建一个内存屏障.例如,<code class="language-plaintext highlighter-rouge">std::atomic_thread_fence(std::memory_order_acquire)</code>会创建一个加载屏障,<code class="language-plaintext highlighter-rouge">std::atomic_thread_fence(std::memory_order_release)</code>会创建一个存储屏障,<code class="language-plaintext highlighter-rouge">std::atomic_thread_fence(std::memory_order_seq_cst)</code>会创建一个全屏障.</p> <h3 id="5-总结">5. 总结</h3> <p>坦率地说，我觉得在国内技术团队里，真正透彻理解并能娴熟运用内存序的人并不多。毕竟，实际开发中需要如此精细优化性能的场景相对少见。当任务耗时较长时，采用锁机制和无锁机制保障线程安全，二者在任务耗时上的差异或许仅有百分之一。</p> <p>所以，我反对在未进行性能测试的情况下，就贸然使用<code class="language-plaintext highlighter-rouge">std::atomic</code>开展无锁编程。要是在使用<code class="language-plaintext highlighter-rouge">mutex</code>（互斥锁）时出了错，多调试几次往往就能找出问题所在。然而无锁编程一旦出错，很可能是内存序设置不当所致，这类错误通常具有偶发性。而且，CPU 对内存序的排序行为影响显著，不同厂家生产的 CPU，其乱序行为很可能各不相同。就拿本文中的代码来说，我尝试采用宽松内存序，本希望能跑出失败结果，却根本无法复现。这种错误的偶发性，以及受机器和操作系统影响的特性，会给代码的可维护性带来极大挑战。我在查阅资料的过程中，经常能看到不少因使用内存序进行无锁编程而“翻车”的案例。</p> <h3 id="99-quiz">99. quiz</h3> <h4 id="1-无锁编程的时候无脑使用严格内存序可以吗">1. 无锁编程的时候，无脑使用严格内存序可以吗？</h4> <p>todo: 补充实测数据。</p> <p>我一开始认为无锁编程的时候，是可以无脑使用严格内存序。但是进一步了解后，感觉严格内存序的开销也许不比上锁的开销小。既然如此，如果用了无锁编程，就得正确使用正确内存序。不然就老实用上锁编程。</p> <p>性能对比，等我实测。</p> <h4 id="2-多核-cpu-的缓存及缓存一致性维护">2. 多核 CPU 的缓存及缓存一致性维护</h4> <p>在多核 CPU 环境下，每个核心都配备高速缓存以加速数据访问。但多个核心同时操作同一份数据时，易引发数据不一致问题。例如，CPU 核心 A 和 B 都缓存了变量<code class="language-plaintext highlighter-rouge">x</code>，若 A 修改<code class="language-plaintext highlighter-rouge">x</code>值，B 仍使用旧缓存值，就会出现数据不一致情况。为此，多核 CPU 采用特定机制来保障缓存一致性。而保障缓存一致性常见的协议就是<code class="language-plaintext highlighter-rouge">MESI</code>协议。</p> <ol> <li><strong>MESI 协议概述</strong>：MESI 协议是常用的缓存一致性协议，其名称源于四个状态：Modified（已修改）、Exclusive（独占）、Shared（共享）和 Invalid（无效），每个缓存行都具备其中一种状态来表明当前状况。其核心原理就一句话，<strong>写入时，持有修改权的核心通知其他核心对应缓存行无效，确保各核心缓存与主内存数据一致。</strong></li> <li><strong>MESI 协议原理</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">Modified（已修改）</code>：此状态下缓存行数据已被修改，与主内存数据不一致，且仅有一个 CPU 核心可持有。</li> <li><code class="language-plaintext highlighter-rouge">Exclusive（独占）</code>：缓存行数据与主内存一致，且仅一个核心持有。</li> <li><code class="language-plaintext highlighter-rouge">Shared（共享）</code>：缓存行数据与主内存一致，多个核心可同时持有。</li> <li><code class="language-plaintext highlighter-rouge">Invalid（无效）</code>：该缓存行数据无效，不可使用。</li> </ul> </li> <li><strong>缓存一致性操作</strong>： <ul> <li><code class="language-plaintext highlighter-rouge">读取操作</code>：若 CPU 核心读取的缓存行状态为 Invalid，需从主内存或其他核心缓存获取最新数据。</li> <li><code class="language-plaintext highlighter-rouge">写入操作</code>：CPU 核心写入缓存行时，要通知其他核心将该缓存行状态设为 Invalid。</li> </ul> </li> </ol>]]></content><author><name></name></author><category term="cpp"/><category term="cpp"/><category term="threads"/><summary type="html"><![CDATA[（二）多线程那些事儿：原子类型数据和内存序]]></summary></entry></feed>