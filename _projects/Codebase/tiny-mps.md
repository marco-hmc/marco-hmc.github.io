---
layout: page
title: rtti-libs
description: A tiny memory pool system implementation
img: assets/img/5.jpg
importance: 1
category: Codebase
---

# 内存池系统

[Github Repo Link](https://github.com/marco-hmc/cpp_memory_pool_system)

## 1. 概念 (Concepts)

### 1.1 内存池的意义是什么？

#### 内存分配的原理

传统的动态内存分配操作（如 `new`、`malloc`）每次都需要进行复杂的内存查找、分配等操作，涉及系统调用和内存管理器的复杂算法。

#### 内存池的权衡 (Trade-offs)

内存池主要针对堆空间的内存管理。自定义内存池能够优于系统实现，并非通过更优的算法，而是通过特定的权衡策略：

**1. 大块预分配内存**

- **实现方式**：程序初始化时，预先分配大块连续内存
- **代价**：
  - 程序启动时间增加
  - 峰值内存需求增大
  - 非按需分配，可能造成内存浪费
- **收益**：
  - 避免频繁系统调用开销
  - 提升 CPU 缓存命中率（连续内存访问）
  - 减少内存分配器的竞争

**2. 固定大小块分配**

- **实现方式**：预定义固定大小的内存块，不支持任意大小分配
- **代价**：固定块大小可能导致内部碎片（对象大小与块大小不匹配）
- **收益**：
  - 简化内存管理逻辑
  - 分配/释放速度极快（O(1) 操作）
  - 便于预先规划和管理

**3. 线程本地内存池**

- **实现方式**：每个线程维护私有内存池
- **代价**：增加实现复杂度，需要手动管理
- **收益**：无锁设计，避免线程竞争

**4. 批量内存申请**

- **实现方式**：内存池扩展时一次申请大块内存
- **代价**：增加峰值内存开销
- **收益**：减少外部碎片，降低系统调用频率

### 1.2 内存池的实现方式

内存池的基本实现步骤：

1. **初始化阶段**：预先分配大块连续内存区域
2. **内存划分**：将大块内存划分为多个固定大小的小块
3. **空闲管理**：使用数据结构（链表/位图/栈）管理空闲内存块
4. **分配操作**：从空闲块中快速分配，更新管理结构
5. **释放操作**：将内存块归还到空闲管理结构

### 1.3 多尺寸对象的处理策略

针对不同大小的内存对象，内存池采用以下策略：

**1. 多级内存池 (Multi-level Pools)**

- 为不同大小创建独立的内存池
- 例如：8 字节池、16 字节池、32 字节池等
- 适用于大小分布相对固定的场景

**2. 分层内存池 (Tiered Pools)**

- 按大小范围分层管理
- 每层管理特定范围的内存块大小
- 平衡内存利用率和管理复杂度

## 2. 常见问题解答 (FAQ)

### 2.1 什么时候需要考虑 new 失败？

- **无虚拟内存环境**：嵌入式系统或实时系统
- **大数据处理**：数据导入阶段，内存需求难以预估
- **内存受限环境**：严格的内存限制场景

### 2.2 哪些场景不支持虚拟内存？

- 嵌入式环境，硬件资源不够，且操作系统有阉割，不一定支持虚拟内存；
- 高实时设备，不能够接受虚拟内存造成的不可预期卡顿，如遥控系统（远程手术机器人、辅助驾驶远程接管）。虚拟内存是被关闭的；

大部分情况下，家用电脑在现代操作系统下，因为有虚拟内存的存在，其实已经不太会出现内存不足的情况了。也就是说除非预期这个操作就是很吃内存的，比如说加载大数据的时候，这个操作可能把内存空间吃满了，虚拟内存也不够，不然不太需要考虑内存不足。

### 2.3 内存池如何处理碎片问题？

**外部碎片处理**：

- 通过固定块大小避免外部碎片
- 批量申请大块内存减少碎片
- 预分配策略避免运行时碎片化

**内部碎片权衡**：

- 固定大小分配可能产生内部碎片
- 通过合理的大小类设计最小化浪费
- 权衡内存利用率与分配速度

### 2.4 内存池的核心优化原理

内存池的性能提升主要来源于：

- **减少系统调用**：批量预分配避免频繁的 malloc/free 调用
- **简化分配算法**：使用简单数据结构（链表/栈）管理内存
- **提升缓存局部性**：连续内存分配提高 CPU 缓存命中率
- **消除锁竞争**：线程本地池避免多线程竞争
- **确定性性能**：固定时间复杂度的分配/释放操作
- **外部碎片**：通过内存池管理的时候，如果内存池满了，还需要申请内存的时候，就是一次开辟一大片内存，一个 Block。如果还是一般地按需申请的话，就只申请了一点，其他程序也这么做的话，整个内存段就会充斥着外部碎片了。

### 2.5 内存池的适用场景

**高频小对象分配**：

- **游戏开发**：粒子系统、子弹对象、临时数据结构
- **网络编程**：消息报文、连接对象、缓冲区管理
- **容器实现**：std::vector、std::deque 等容器的内部实现

**性能关键场景**：

- **实时系统**：需要确定性分配性能的嵌入式设备
- **高性能计算**：科学计算、图像处理等 CPU 密集型应用
- **服务器开发**：数据库服务器、Web 服务器的高并发处理

**特殊环境**：

- **内存受限环境**：需要精确控制内存使用的场景
- **无锁编程**：多线程环境下需要避免锁竞争的场景
